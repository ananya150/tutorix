import { DurableObject, WorkerEntrypoint } from "cloudflare:workers";
function _mergeNamespaces(n2, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n2)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n2, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
const t$1 = ({ base: e = "", routes: t2 = [], ...r2 } = {}) => ({ __proto__: new Proxy({}, { get: (r3, o2, a2, s2) => (r4, ...c2) => t2.push([o2.toUpperCase?.(), RegExp(`^${(s2 = (e + r4).replace(/\/+(\/|$)/g, "$1")).replace(/(\/?\.?):(\w+)\+/g, "($1(?<$2>*))").replace(/(\/?\.?):(\w+)/g, "($1(?<$2>[^$1/]+?))").replace(/\./g, "\\.").replace(/(\/?)\*/g, "($1.*)?")}/*$`), c2, s2]) && a2 }), routes: t2, ...r2, async fetch(e2, ...o2) {
  let a2, s2, c2 = new URL(e2.url), n2 = e2.query = { __proto__: null };
  for (let [e3, t3] of c2.searchParams) n2[e3] = n2[e3] ? [].concat(n2[e3], t3) : t3;
  e: try {
    for (let t3 of r2.before || []) if (null != (a2 = await t3(e2.proxy ?? e2, ...o2))) break e;
    t: for (let [r3, n3, l, i] of t2) if ((r3 == e2.method || "ALL" == r3) && (s2 = c2.pathname.match(n3))) {
      e2.params = s2.groups || {}, e2.route = i;
      for (let t3 of l) if (null != (a2 = await t3(e2.proxy ?? e2, ...o2))) break t;
    }
  } catch (t3) {
    if (!r2.catch) throw t3;
    a2 = await r2.catch(t3, e2.proxy ?? e2, ...o2);
  }
  try {
    for (let t3 of r2.finally || []) a2 = await t3(a2, e2.proxy ?? e2, ...o2) ?? a2;
  } catch (t3) {
    if (!r2.catch) throw t3;
    a2 = await r2.catch(t3, e2.proxy ?? e2, ...o2);
  }
  return a2;
} }), r = (e = "text/plain; charset=utf-8", t2) => (r2, o2 = {}) => {
  if (void 0 === r2 || r2 instanceof Response) return r2;
  const a2 = new Response(t2?.(r2) ?? r2, o2.url ? void 0 : o2);
  return a2.headers.set("content-type", e), a2;
}, o = r("application/json; charset=utf-8", JSON.stringify), a = (e) => ({ 400: "Bad Request", 401: "Unauthorized", 403: "Forbidden", 404: "Not Found", 500: "Internal Server Error" })[e] || "Unknown Error", s = (e = 500, t2) => {
  if (e instanceof Error) {
    const { message: r2, ...o2 } = e;
    e = e.status || 500, t2 = { error: r2 || a(e), ...o2 };
  }
  return t2 = { status: e, ..."object" == typeof t2 ? t2 : { error: t2 || a(e) } }, o(t2, { status: e });
}, c = (e) => {
  e.proxy = new Proxy(e.proxy ?? e, { get: (t2, r2) => t2[r2]?.bind?.(e) ?? t2[r2] ?? t2?.params?.[r2] });
}, n = ({ format: e = o, missing: r2 = () => s(404), finally: a2 = [], before: n2 = [], ...l } = {}) => t$1({ before: [c, ...n2], catch: s, finally: [(e2, ...t2) => e2 ?? r2(...t2), e, ...a2], ...l });
const y = (e = {}) => {
  const { origin: t2 = "*", credentials: r2 = false, allowMethods: o2 = "*", allowHeaders: a2, exposeHeaders: s2, maxAge: c2 } = e, n2 = (e2) => {
    const o3 = e2?.headers.get("origin");
    return true === t2 ? o3 : t2 instanceof RegExp ? t2.test(o3) ? o3 : void 0 : Array.isArray(t2) ? t2.includes(o3) ? o3 : void 0 : t2 instanceof Function ? t2(o3) : "*" == t2 && r2 ? o3 : t2;
  }, l = (e2, t3) => {
    for (const [r3, o3] of Object.entries(t3)) o3 && e2.headers.append(r3, o3);
    return e2;
  };
  return { corsify: (e2, t3) => e2?.headers?.get("access-control-allow-origin") || 101 == e2.status ? e2 : l(e2.clone(), { "access-control-allow-origin": n2(t3), "access-control-allow-credentials": r2 }), preflight: (e2) => {
    if ("OPTIONS" == e2.method) {
      const t3 = new Response(null, { status: 204 });
      return l(t3, { "access-control-allow-origin": n2(e2), "access-control-allow-methods": o2?.join?.(",") ?? o2, "access-control-expose-headers": s2?.join?.(",") ?? s2, "access-control-allow-headers": a2?.join?.(",") ?? a2 ?? e2.headers.get("access-control-request-headers"), "access-control-max-age": c2, "access-control-allow-credentials": r2 });
    }
  } };
};
async function generate(request, env) {
  const id = env.TLDRAW_AI_DURABLE_OBJECT.idFromName("anonymous");
  const DO = env.TLDRAW_AI_DURABLE_OBJECT.get(id);
  const response = await DO.fetch(request.url, {
    method: "POST",
    body: request.body
  });
  return new Response(response.body, {
    headers: { "Content-Type": "application/json" }
  });
}
async function stream(request, env) {
  const id = env.TLDRAW_AI_DURABLE_OBJECT.idFromName("anonymous");
  const DO = env.TLDRAW_AI_DURABLE_OBJECT.get(id);
  const response = await DO.fetch(request.url, {
    method: "POST",
    body: request.body
  });
  return new Response(response.body, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
      "X-Accel-Buffering": "no",
      "Transfer-Encoding": "chunked",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type"
    }
  });
}
const default_format = "RFC3986";
const formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: (v) => String(v)
};
const RFC1738 = "RFC1738";
const is_array$1 = Array.isArray;
const hex_table = (() => {
  const array2 = [];
  for (let i = 0; i < 256; ++i) {
    array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array2;
})();
const limit = 1024;
const encode = (str2, _defaultEncoder, charset, _kind, format2) => {
  if (str2.length === 0) {
    return str2;
  }
  let string2 = str2;
  if (typeof str2 === "symbol") {
    string2 = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string2 = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string2.length; j += limit) {
    const segment = string2.length >= limit ? string2.slice(j, j + limit) : string2;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c2 = segment.charCodeAt(i);
      if (c2 === 45 || // -
      c2 === 46 || // .
      c2 === 95 || // _
      c2 === 126 || // ~
      c2 >= 48 && c2 <= 57 || // 0-9
      c2 >= 65 && c2 <= 90 || // a-z
      c2 >= 97 && c2 <= 122 || // A-Z
      format2 === RFC1738 && (c2 === 40 || c2 === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c2 < 128) {
        arr[arr.length] = hex_table[c2];
        continue;
      }
      if (c2 < 2048) {
        arr[arr.length] = hex_table[192 | c2 >> 6] + hex_table[128 | c2 & 63];
        continue;
      }
      if (c2 < 55296 || c2 >= 57344) {
        arr[arr.length] = hex_table[224 | c2 >> 12] + hex_table[128 | c2 >> 6 & 63] + hex_table[128 | c2 & 63];
        continue;
      }
      i += 1;
      c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c2 >> 18] + hex_table[128 | c2 >> 12 & 63] + hex_table[128 | c2 >> 6 & 63] + hex_table[128 | c2 & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (is_array$1(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}
const has = Object.prototype.hasOwnProperty;
const array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
const is_array = Array.isArray;
const push = Array.prototype.push;
const push_to_array = function(arr, value_or_array) {
  push.apply(arr, is_array(value_or_array) ? value_or_array : [value_or_array]);
};
const to_ISO = Date.prototype.toISOString;
const defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: formatters[default_format],
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return to_ISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
const sentinel = {};
function inner_stringify(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object2;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object2);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter2 === "function") {
    obj = filter2(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && is_array(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults$1.encoder, charset, "key", format2)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format2);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder(obj, defaults$1.encoder, charset, "value", format2))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && is_array(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (is_array(filter2)) {
    obj_keys = filter2;
  } else {
    const keys2 = Object.keys(obj);
    obj_keys = sort ? keys2.sort(sort) : keys2;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && is_array(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && is_array(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = is_array(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object2, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && is_array(obj) ? null : encoder,
      filter2,
      sort,
      allowDots,
      serializeDate,
      format2,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults$1) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format2 = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has.call(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format2 = opts.format;
  }
  const formatter = formatters[format2];
  let filter2 = defaults$1.filter;
  if (typeof opts.filter === "function" || is_array(opts.filter)) {
    filter2 = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults$1.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: filter2,
    format: format2,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
}
function stringify(object2, opts = {}) {
  let obj = object2;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter2;
  if (typeof options.filter === "function") {
    filter2 = options.filter;
    obj = filter2("", obj);
  } else if (is_array(options.filter)) {
    filter2 = options.filter;
    obj_keys = filter2;
  }
  const keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys2, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys2.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
const VERSION = "4.104.0";
let auto = false;
let kind = void 0;
let fetch$2 = void 0;
let FormData$1 = void 0;
let File$1 = void 0;
let ReadableStream$1 = void 0;
let getMultipartRequestOptions = void 0;
let getDefaultAgent = void 0;
let fileFromPath = void 0;
let isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'openai/shims/${shims.kind}'\` before importing anything else from openai`);
  }
  if (kind) {
    throw new Error(`can't \`import 'openai/shims/${shims.kind}'\` after \`import 'openai/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch$2 = shims.fetch;
  FormData$1 = shims.FormData;
  File$1 = shims.File;
  ReadableStream$1 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}
class MultipartBody {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
}
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import … from 'openai'\`:
- \`import 'openai/shims/node'\` (if you're running on Node)
- \`import 'openai/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}
const init$3 = () => {
  if (!kind) setShims(getRuntime(), { auto: true });
};
init$3();
class OpenAIError extends Error {
}
class APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers?.["x-request-id"];
    this.error = error;
    const data = error;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const msg2 = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg2) {
      return `${status} ${msg2}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg2) {
      return msg2;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
}
class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
}
class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
}
class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}
class BadRequestError extends APIError {
}
class AuthenticationError extends APIError {
}
class PermissionDeniedError extends APIError {
}
class NotFoundError extends APIError {
}
class ConflictError extends APIError {
}
class UnprocessableEntityError extends APIError {
}
class RateLimitError extends APIError {
}
class InternalServerError extends APIError {
}
class LengthFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
}
class ContentFilterFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
}
var __classPrivateFieldSet$5 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$6 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LineDecoder_carriageReturnIndex;
class LineDecoder {
  constructor() {
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    this.buffer = new Uint8Array();
    __classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(this.buffer.length + binaryChunk.length);
    newData.set(this.buffer);
    newData.set(binaryChunk, this.buffer.length);
    this.buffer = newData;
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(this.buffer, __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(this.decodeText(this.buffer.slice(0, __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        this.buffer = this.buffer.slice(__classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f"));
        __classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet$6(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = this.decodeText(this.buffer.slice(0, endIndex));
      lines.push(line);
      this.buffer = this.buffer.slice(patternIndex.index);
      __classPrivateFieldSet$5(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new OpenAIError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new OpenAIError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length) {
      return [];
    }
    return this.decode("\n");
  }
}
_LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
function ReadableStreamToAsyncIterable(stream2) {
  if (stream2[Symbol.asyncIterator])
    return stream2;
  const reader = stream2.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
class Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || sse.event.startsWith("response.") || sse.event.startsWith("transcript.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, createResponseHeaders(response.headers));
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream$1({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
}
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
function partition(str2, delimiter) {
  const index2 = str2.indexOf(delimiter);
  if (index2 !== -1) {
    return [str2.substring(0, index2), delimiter, str2.substring(index2 + delimiter.length)];
  }
  return [str2, "", ""];
}
const isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
const isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
const isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
const isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options) {
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File$1(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = getName(value) ?? "unknown_file");
  if (!options?.type) {
    const type = bits[0]?.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File$1(bits, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${value?.constructor?.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  getStringFromMaybeBuffer(value.path)?.split(/[\\/]/).pop();
}
const getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
const isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
const isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
const multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
const createForm = async (body) => {
  const form = new FormData$1();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
const addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry2) => addFormValue(form, key + "[]", entry2)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};
var define_process_env_default$2 = {};
var __classPrivateFieldSet$4 = function(receiver, state, value, kind2, f) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet$5 = function(receiver, state, kind2, f) {
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
init$3();
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const mediaType = contentType?.split(";")[0]?.trim();
  const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}
class APIPromise extends Promise {
  constructor(responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * 👋 Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import … from 'openai'`:
   * - `import 'openai/shims/node'` (if you're running on Node)
   * - `import 'openai/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}
class APIClient {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch ?? fetch$2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = options.timeout + 1e3;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!inputOptions.idempotencyKey)
        inputOptions.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = inputOptions.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: options.signal ?? null
    };
    return { req, url, timeout: options.timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    if (getHeader(defaultHeaders, "x-stainless-timeout") === void 0 && getHeader(headers, "x-stainless-timeout") === void 0 && options.timeout) {
      reqHeaders["x-stainless-timeout"] = String(Math.trunc(options.timeout / 1e3));
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj$1(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init2, ms, controller) {
    const { signal, ...options } = init2 || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep$1(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
}
class AbstractPage {
  constructor(client2, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet$4(this, _AbstractPage_client, client2);
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet$5(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}
class PagePromise extends APIPromise {
  constructor(client2, request, Page2) {
    super(request, async (props) => new Page2(client2, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}
const createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
const requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __metadata: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
const isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj$1(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
const getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
const normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
const normalizePlatform = (platform2) => {
  platform2 = platform2.toLowerCase();
  if (platform2.includes("ios"))
    return "iOS";
  if (platform2 === "android")
    return "Android";
  if (platform2 === "darwin")
    return "MacOS";
  if (platform2 === "win32")
    return "Windows";
  if (platform2 === "freebsd")
    return "FreeBSD";
  if (platform2 === "openbsd")
    return "OpenBSD";
  if (platform2 === "linux")
    return "Linux";
  if (platform2)
    return `Other:${platform2}`;
  return "Unknown";
};
let _platformHeaders;
const getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
const safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
const startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
const isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
const sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const validatePositiveInteger = (name, n2) => {
  if (typeof n2 !== "number" || !Number.isInteger(n2)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n2 < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n2;
};
const castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
const readEnv$1 = (env) => {
  if (typeof process !== "undefined") {
    return define_process_env_default$2?.[env]?.trim() ?? void 0;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env)?.trim();
  }
  return void 0;
};
function isEmptyObj$1(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
const SENSITIVE_HEADERS = /* @__PURE__ */ new Set(["authorization", "api-key"]);
function debug(action, ...args) {
  if (typeof process !== "undefined" && define_process_env_default$2?.["DEBUG"] === "true") {
    const modifiedArgs = args.map((arg) => {
      if (!arg) {
        return arg;
      }
      if (arg["headers"]) {
        const modifiedArg2 = { ...arg, headers: { ...arg["headers"] } };
        for (const header in arg["headers"]) {
          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
            modifiedArg2["headers"][header] = "REDACTED";
          }
        }
        return modifiedArg2;
      }
      let modifiedArg = null;
      for (const header in arg) {
        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {
          modifiedArg ?? (modifiedArg = { ...arg });
          modifiedArg[header] = "REDACTED";
        }
      }
      return modifiedArg ?? arg;
    });
    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);
  }
}
const uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = Math.random() * 16 | 0;
    const v = c2 === "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
};
const isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
const isHeadersProtocol = (headers) => {
  return typeof headers?.get === "function";
};
const getHeader = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};
const toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
class Page extends AbstractPage {
  constructor(client2, response, body, options) {
    super(client2, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  /**
   * This page represents a response that isn't actually paginated at the API level
   * so there will never be any next page params.
   */
  nextPageParams() {
    return null;
  }
  nextPageInfo() {
    return null;
  }
}
class CursorPage extends AbstractPage {
  constructor(client2, response, body, options) {
    super(client2, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    const data = this.getPaginatedItems();
    if (!data.length) {
      return null;
    }
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return { params: { after: id } };
  }
}
class APIResource {
  constructor(client2) {
    this._client = client2;
  }
}
let Messages$1 = class Messages extends APIResource {
  list(completionId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(completionId, {}, query);
    }
    return this._client.getAPIList(`/chat/completions/${completionId}/messages`, ChatCompletionStoreMessagesPage, { query, ...options });
  }
};
let Completions$2 = class Completions extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages$1(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionId, options) {
    return this._client.get(`/chat/completions/${completionId}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionId, body, options) {
    return this._client.post(`/chat/completions/${completionId}`, { body, ...options });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/chat/completions", ChatCompletionsPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.del('completion_id');
   * ```
   */
  del(completionId, options) {
    return this._client.delete(`/chat/completions/${completionId}`, options);
  }
};
class ChatCompletionsPage extends CursorPage {
}
class ChatCompletionStoreMessagesPage extends CursorPage {
}
Completions$2.ChatCompletionsPage = ChatCompletionsPage;
Completions$2.Messages = Messages$1;
let Chat$1 = class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions$2(this._client);
  }
};
Chat$1.Completions = Completions$2;
Chat$1.ChatCompletionsPage = ChatCompletionsPage;
class Speech extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: { Accept: "application/octet-stream", ...options?.headers },
      __binaryResponse: true
    });
  }
}
class Transcriptions extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }));
  }
}
class Translations extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }));
  }
}
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
}
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;
class Batches extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchId, options) {
    return this._client.get(`/batches/${batchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/batches", BatchesPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchId, options) {
    return this._client.post(`/batches/${batchId}/cancel`, options);
  }
}
class BatchesPage extends CursorPage {
}
Batches.BatchesPage = BatchesPage;
var __classPrivateFieldSet$3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$4 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventStream_instances, _EventStream_connectedPromise, _EventStream_resolveConnectedPromise, _EventStream_rejectConnectedPromise, _EventStream_endPromise, _EventStream_resolveEndPromise, _EventStream_rejectEndPromise, _EventStream_listeners, _EventStream_ended, _EventStream_errored, _EventStream_aborted, _EventStream_catchingPromiseCreated, _EventStream_handleError;
class EventStream {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet$3(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet$3(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet$3(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet$3(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet$3(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet$3(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet$4(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet$4(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet$4(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet$4(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet$4(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet$4(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet$4(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index2 = listeners.findIndex((l) => l.listener === listener);
    if (index2 >= 0)
      listeners.splice(index2, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet$3(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet$3(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet$4(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet$4(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet$3(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet$4(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet$4(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet$4(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet$4(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet$4(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet$4(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error);
      }
      __classPrivateFieldGet$4(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet$4(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
}
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet$3(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet$3(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};
var __classPrivateFieldGet$3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AssistantStream_instances, _AssistantStream_events, _AssistantStream_runStepSnapshots, _AssistantStream_messageSnapshots, _AssistantStream_messageSnapshot, _AssistantStream_finalRun, _AssistantStream_currentContentIndex, _AssistantStream_currentContent, _AssistantStream_currentToolCallIndex, _AssistantStream_currentToolCall, _AssistantStream_currentEvent, _AssistantStream_currentRunSnapshot, _AssistantStream_currentRunStepSnapshot, _AssistantStream_addEvent, _AssistantStream_endRequest, _AssistantStream_handleMessage, _AssistantStream_handleRunStep, _AssistantStream_handleEvent, _AssistantStream_accumulateRunStep, _AssistantStream_accumulateMessage, _AssistantStream_accumulateContent, _AssistantStream_handleRun;
class AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream2) {
    const runner = new AssistantStream();
    runner._run(() => runner._fromReadableStream(stream2));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream2 = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream2) {
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream2 = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream2.toReadableStream();
  }
  static createToolAssistantStream(threadId, runId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runToolAssistantStream(threadId, runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run2, threadId, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream2 = await run2.submitToolOutputs(threadId, runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new AssistantStream();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet$3(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet$3(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet$3(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet$3(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet$3(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet$3(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream2 = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run2, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream2 = await run2.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index2 = deltaEntry["index"];
          if (index2 == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index2 !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index2}`);
          }
          const accEntry = accValue[index2];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index2] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run2) {
    return run2;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(threadId, runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, threadId, runId, params, options);
  }
}
_AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet$2(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet$3(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet$3(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet$2(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet$3(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet$3(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet$3(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet$3(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet$3(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet$2(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet$2(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet$3(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet$3(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet$3(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet$2(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet$2(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet$3(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet$2(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet$2(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet$2(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet$2(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet$3(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = AssistantStream.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet$3(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet$3(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return AssistantStream.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet$2(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
      __classPrivateFieldSet$2(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet$3(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet$2(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
  }
};
class Assistants extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantId, options) {
    return this._client.get(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantId, body, options) {
    return this._client.post(`/assistants/${assistantId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/assistants", AssistantsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted = await client.beta.assistants.del(
   *   'assistant_id',
   * );
   * ```
   */
  del(assistantId, options) {
    return this._client.delete(`/assistants/${assistantId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
}
class AssistantsPage extends CursorPage {
}
Assistants.AssistantsPage = AssistantsPage;
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}
const isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
const isFunctionMessage = (message) => {
  return message?.role === "function";
};
const isToolMessage = (message) => {
  return message?.role === "tool";
};
function makeParseableResponseFormat(response_format, parser) {
  const obj = { ...response_format };
  Object.defineProperties(obj, {
    $brand: {
      value: "auto-parseable-response-format",
      enumerable: false
    },
    $parseRaw: {
      value: parser,
      enumerable: false
    }
  });
  return obj;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool$1(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput$1(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => ({
        ...choice,
        message: {
          ...choice.message,
          parsed: null,
          ...choice.message.tool_calls ? {
            tool_calls: choice.message.tool_calls
          } : void 0
        }
      }))
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall$1(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall$1(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => inputTool2.function?.name === toolCall.function.name);
  return isAutoParsableTool$1(inputTool) || inputTool?.function.strict || false;
}
function hasAutoParseableInput$1(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t2) => isAutoParsableTool$1(t2) || t2.type === "function" && t2.function.strict === true) ?? false;
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}
var __classPrivateFieldGet$2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances, _AbstractChatCompletionRunner_getFinalContent, _AbstractChatCompletionRunner_getFinalMessage, _AbstractChatCompletionRunner_getFinalFunctionCall, _AbstractChatCompletionRunner_getFinalFunctionCallResult, _AbstractChatCompletionRunner_calculateTotalUsage, _AbstractChatCompletionRunner_validateParams, _AbstractChatCompletionRunner_stringifyFunctionCallResult;
const DEFAULT_MAX_CHAT_COMPLETIONS = 10;
class AbstractChatCompletionRunner extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if ((isFunctionMessage(message) || isToolMessage(message)) && message.content) {
        this._emit("functionCallResult", message.content);
      } else if (isAssistantMessage(message) && message.function_call) {
        this._emit("functionCall", message.function_call);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c2) => c2.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client2, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client2.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client2, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client2, params, options);
  }
  async _runFunctions(client2, params, options) {
    const role = "function";
    const { function_call = "auto", stream: stream2, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && function_call?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client2, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.function_call)
        return;
      const { name, arguments: args } = message.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error) {
        this._addMessage({
          role,
          name,
          content: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(client2, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream: stream2, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool$1(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t2) => t2.type === "function" ? {
      type: "function",
      function: {
        name: t2.function.name || t2.function.function.name,
        parameters: t2.function.parameters,
        description: t2.function.description,
        strict: t2.function.strict
      }
    } : t2) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client2, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet$2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const { function_call, ...rest } = message;
      const ret = {
        ...rest,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      if (function_call) {
        ret.function_call = function_call;
      }
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.function_call) {
      return message.function_call;
    }
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isFunctionMessage(message) && message.content != null) {
      return message.content;
    }
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y2) => y2.type === "function" && y2.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};
class ChatCompletionRunner extends AbstractChatCompletionRunner {
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client2, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client2, params, opts));
    return runner;
  }
  static runTools(client2, params, options) {
    const runner = new ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
}
const STR = 1;
const NUM$1 = 2;
const ARR = 4;
const OBJ = 8;
const NULL = 16;
const BOOL = 32;
const NAN = 64;
const INFINITY = 128;
const MINUS_INFINITY = 256;
const INF = INFINITY | MINUS_INFINITY;
const SPECIAL = NULL | BOOL | INF | NAN;
const ATOM = STR | NUM$1 | SPECIAL;
const COLLECTION = ARR | OBJ;
const ALL = ATOM | COLLECTION;
const Allow = {
  STR,
  NUM: NUM$1,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
class PartialJSON extends Error {
}
class MalformedJSON extends Error {
}
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
const _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index2 = 0;
  const markPartialJSON = (msg2) => {
    throw new PartialJSON(`${msg2} at position ${index2}`);
  };
  const throwMalformedError = (msg2) => {
    throw new MalformedJSON(`${msg2} at position ${index2}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index2 >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index2] === '"')
      return parseStr();
    if (jsonString[index2] === "{")
      return parseObj();
    if (jsonString[index2] === "[")
      return parseArr();
    if (jsonString.substring(index2, index2 + 4) === "null" || Allow.NULL & allow && length - index2 < 4 && "null".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return null;
    }
    if (jsonString.substring(index2, index2 + 4) === "true" || Allow.BOOL & allow && length - index2 < 4 && "true".startsWith(jsonString.substring(index2))) {
      index2 += 4;
      return true;
    }
    if (jsonString.substring(index2, index2 + 5) === "false" || Allow.BOOL & allow && length - index2 < 5 && "false".startsWith(jsonString.substring(index2))) {
      index2 += 5;
      return false;
    }
    if (jsonString.substring(index2, index2 + 8) === "Infinity" || Allow.INFINITY & allow && length - index2 < 8 && "Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 8;
      return Infinity;
    }
    if (jsonString.substring(index2, index2 + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index2 && length - index2 < 9 && "-Infinity".startsWith(jsonString.substring(index2))) {
      index2 += 9;
      return -Infinity;
    }
    if (jsonString.substring(index2, index2 + 3) === "NaN" || Allow.NAN & allow && length - index2 < 3 && "NaN".startsWith(jsonString.substring(index2))) {
      index2 += 3;
      return NaN;
    }
    return parseNum2();
  };
  const parseStr = () => {
    const start = index2;
    let escape2 = false;
    index2++;
    while (index2 < length && (jsonString[index2] !== '"' || escape2 && jsonString[index2 - 1] === "\\")) {
      escape2 = jsonString[index2] === "\\" ? !escape2 : false;
      index2++;
    }
    if (jsonString.charAt(index2) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index2 - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index2 - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index2++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index2] !== "}") {
        skipBlank();
        if (index2 >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index2++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index2] === ",")
          index2++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index2++;
    return obj;
  };
  const parseArr = () => {
    index2++;
    const arr = [];
    try {
      while (jsonString[index2] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index2] === ",") {
          index2++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index2++;
    return arr;
  };
  const parseNum2 = () => {
    if (index2 === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index2;
    if (jsonString[index2] === "-")
      index2++;
    while (jsonString[index2] && !",]}".includes(jsonString[index2]))
      index2++;
    if (index2 == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index2));
    } catch (e) {
      if (jsonString.substring(start, index2) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index2 < length && " \n\r	".includes(jsonString[index2])) {
      index2++;
    }
  };
  return parseAny();
};
const partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
var __classPrivateFieldSet$1 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet$1 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ChatCompletionStream_instances, _ChatCompletionStream_params, _ChatCompletionStream_choiceEventStates, _ChatCompletionStream_currentChatCompletionSnapshot, _ChatCompletionStream_beginRequest, _ChatCompletionStream_getChoiceEventState, _ChatCompletionStream_addChunk, _ChatCompletionStream_emitToolCallDoneEvent, _ChatCompletionStream_emitContentDoneEvents, _ChatCompletionStream_endRequest, _ChatCompletionStream_getAutoParseableResponseFormat, _ChatCompletionStream_accumulateChatCompletion;
class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet$1(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream2) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream2));
    return runner;
  }
  static createChatCompletion(client2, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client2, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client2, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream2 = await client2.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream2) {
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream2 = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream2) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet$1(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => tool.type === "function" && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool$1(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    const state = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet$1(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    const responseFormat = __classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a2, _b, _c, _d;
    let snapshot = __classPrivateFieldGet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet$1(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index: index2, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index2];
      if (!choice) {
        choice = snapshot.choices[index2] = { finish_reason, index: index2, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a2 = choice.logprobs).content ?? (_a2.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput$1(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet$1(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index3, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index3] ?? (_d[index3] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet$1(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream2 = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream2.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model: model2, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index: index2, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index2}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index2}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index2}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index2}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index: index2,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index: index2,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index2}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index: index2,
        logprobs
      };
    }),
    created,
    model: model2,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertNever(_x) {
}
class ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream2) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream2));
    return runner;
  }
  /** @deprecated - please use `runTools` instead. */
  static runFunctions(client2, params, options) {
    const runner = new ChatCompletionStreamingRunner(null);
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runFunctions" }
    };
    runner._run(() => runner._runFunctions(client2, params, opts));
    return runner;
  }
  static runTools(client2, params, options) {
    const runner = new ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client2, params, opts));
    return runner;
  }
}
let Completions$1 = class Completions2 extends APIResource {
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "beta.chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runFunctions(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runFunctions(this._client, body, options);
    }
    return ChatCompletionRunner.runFunctions(this._client, body, options);
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};
class Chat2 extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions$1(this._client);
  }
}
(function(Chat3) {
  Chat3.Completions = Completions$1;
})(Chat2 || (Chat2 = {}));
class Sessions extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
}
class TranscriptionSessions extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
}
class Realtime extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
}
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;
class Messages2 extends APIResource {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadId, body, options) {
    return this._client.post(`/threads/${threadId}/messages`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadId, messageId, options) {
    return this._client.get(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadId, messageId, body, options) {
    return this._client.post(`/threads/${threadId}/messages/${messageId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/messages`, MessagesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  del(threadId, messageId, options) {
    return this._client.delete(`/threads/${threadId}/messages/${messageId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
}
class MessagesPage extends CursorPage {
}
Messages2.MessagesPage = MessagesPage;
class Steps extends APIResource {
  retrieve(threadId, runId, stepId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(threadId, runId, stepId, {}, query);
    }
    return this._client.get(`/threads/${threadId}/runs/${runId}/steps/${stepId}`, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, runId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs/${runId}/steps`, RunStepsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
}
class RunStepsPage extends CursorPage {
}
Steps.RunStepsPage = RunStepsPage;
let Runs$1 = class Runs extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadId, params, options) {
    const { include, ...body } = params;
    return this._client.post(`/threads/${threadId}/runs`, {
      query: { include },
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadId, runId, options) {
    return this._client.get(`/threads/${threadId}/runs/${runId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(threadId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(threadId, {}, query);
    }
    return this._client.getAPIList(`/threads/${threadId}/runs`, RunsPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(threadId, runId, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run2 = await this.create(threadId, body, options);
    return await this.poll(threadId, run2.id, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(threadId, runId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: run2, response } = await this.retrieve(threadId, runId, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run2.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep$1(sleepInterval);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run2;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(threadId, runId, body, options) {
    return this._client.post(`/threads/${threadId}/runs/${runId}/submit_tool_outputs`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(threadId, runId, body, options) {
    const run2 = await this.submitToolOutputs(threadId, runId, body, options);
    return await this.poll(threadId, run2.id, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(threadId, runId, body, options) {
    return AssistantStream.createToolAssistantStream(threadId, runId, this._client.beta.threads.runs, body, options);
  }
};
class RunsPage extends CursorPage {
}
Runs$1.RunsPage = RunsPage;
Runs$1.Steps = Steps;
Runs$1.RunStepsPage = RunStepsPage;
class Threads extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs$1(this._client);
    this.messages = new Messages2(this._client);
  }
  create(body = {}, options) {
    if (isRequestOptions(body)) {
      return this.create({}, body);
    }
    return this._client.post("/threads", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadId, options) {
    return this._client.get(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadId, body, options) {
    return this._client.post(`/threads/${threadId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  del(threadId, options) {
    return this._client.delete(`/threads/${threadId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers },
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run2 = await this.createAndRun(body, options);
    return await this.runs.poll(run2.thread_id, run2.id, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
}
Threads.Runs = Runs$1;
Threads.RunsPage = RunsPage;
Threads.Messages = Messages2;
Threads.MessagesPage = MessagesPage;
class Beta extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chat = new Chat2(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads(this._client);
  }
}
Beta.Realtime = Realtime;
Beta.Assistants = Assistants;
Beta.AssistantsPage = AssistantsPage;
Beta.Threads = Threads;
class Completions3 extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
}
let Content$2 = class Content extends APIResource {
  /**
   * Retrieve Container File Content
   */
  retrieve(containerId, fileId, options) {
    return this._client.get(`/containers/${containerId}/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options?.headers },
      __binaryResponse: true
    });
  }
};
let Files$2 = class Files extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content$2(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerId, body, options) {
    return this._client.post(`/containers/${containerId}/files`, multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Retrieve Container File
   */
  retrieve(containerId, fileId, options) {
    return this._client.get(`/containers/${containerId}/files/${fileId}`, options);
  }
  list(containerId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(containerId, {}, query);
    }
    return this._client.getAPIList(`/containers/${containerId}/files`, FileListResponsesPage, {
      query,
      ...options
    });
  }
  /**
   * Delete Container File
   */
  del(containerId, fileId, options) {
    return this._client.delete(`/containers/${containerId}/files/${fileId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
};
class FileListResponsesPage extends CursorPage {
}
Files$2.FileListResponsesPage = FileListResponsesPage;
Files$2.Content = Content$2;
class Containers extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files$2(this._client);
  }
  /**
   * Create Container
   */
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerId, options) {
    return this._client.get(`/containers/${containerId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/containers", ContainerListResponsesPage, { query, ...options });
  }
  /**
   * Delete Container
   */
  del(containerId, options) {
    return this._client.delete(`/containers/${containerId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
}
class ContainerListResponsesPage extends CursorPage {
}
Containers.ContainerListResponsesPage = ContainerListResponsesPage;
Containers.Files = Files$2;
Containers.FileListResponsesPage = FileListResponsesPage;
class Embeddings extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      debug("Request", "User defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    debug("response", "Decoding base64 embeddings to float32 array");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
}
class OutputItems extends APIResource {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(evalId, runId, outputItemId, options) {
    return this._client.get(`/evals/${evalId}/runs/${runId}/output_items/${outputItemId}`, options);
  }
  list(evalId, runId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(evalId, runId, {}, query);
    }
    return this._client.getAPIList(`/evals/${evalId}/runs/${runId}/output_items`, OutputItemListResponsesPage, { query, ...options });
  }
}
class OutputItemListResponsesPage extends CursorPage {
}
OutputItems.OutputItemListResponsesPage = OutputItemListResponsesPage;
class Runs2 extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalId, body, options) {
    return this._client.post(`/evals/${evalId}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(evalId, runId, options) {
    return this._client.get(`/evals/${evalId}/runs/${runId}`, options);
  }
  list(evalId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(evalId, {}, query);
    }
    return this._client.getAPIList(`/evals/${evalId}/runs`, RunListResponsesPage, { query, ...options });
  }
  /**
   * Delete an eval run.
   */
  del(evalId, runId, options) {
    return this._client.delete(`/evals/${evalId}/runs/${runId}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(evalId, runId, options) {
    return this._client.post(`/evals/${evalId}/runs/${runId}`, options);
  }
}
class RunListResponsesPage extends CursorPage {
}
Runs2.RunListResponsesPage = RunListResponsesPage;
Runs2.OutputItems = OutputItems;
Runs2.OutputItemListResponsesPage = OutputItemListResponsesPage;
class Evals extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalId, options) {
    return this._client.get(`/evals/${evalId}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalId, body, options) {
    return this._client.post(`/evals/${evalId}`, { body, ...options });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/evals", EvalListResponsesPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  del(evalId, options) {
    return this._client.delete(`/evals/${evalId}`, options);
  }
}
class EvalListResponsesPage extends CursorPage {
}
Evals.EvalListResponsesPage = EvalListResponsesPage;
Evals.Runs = Runs2;
Evals.RunListResponsesPage = RunListResponsesPage;
let Files$1 = class Files2 extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 100 GB.
   *
   * The Assistants API supports files up to 2 million tokens and of specific file
   * types. See the
   * [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools) for
   * details.
   *
   * The Fine-tuning API only supports `.jsonl` files. The input also has certain
   * required formats for fine-tuning
   * [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input) or
   * [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   * models.
   *
   * The Batch API only supports `.jsonl` files up to 200 MB in size. The input also
   * has a specific required
   * [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileId, options) {
    return this._client.get(`/files/${fileId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/files", FileObjectsPage, { query, ...options });
  }
  /**
   * Delete a file.
   */
  del(fileId, options) {
    return this._client.delete(`/files/${fileId}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, {
      ...options,
      headers: { Accept: "application/binary", ...options?.headers },
      __binaryResponse: true
    });
  }
  /**
   * Returns the contents of the specified file.
   *
   * @deprecated The `.content()` method should be used instead
   */
  retrieveContent(fileId, options) {
    return this._client.get(`/files/${fileId}/content`, options);
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep$1(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};
class FileObjectsPage extends CursorPage {
}
Files$1.FileObjectsPage = FileObjectsPage;
class Methods extends APIResource {
}
let Graders$1 = class Graders extends APIResource {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   *   reference_answer: 'string',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};
class Alpha extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders$1(this._client);
  }
}
Alpha.Graders = Graders$1;
class Permissions extends APIResource {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, PermissionCreateResponsesPage, { body, method: "post", ...options });
  }
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.retrieve(fineTunedModelCheckpoint, {}, query);
    }
    return this._client.get(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.del(
   *     'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *   );
   * ```
   */
  del(fineTunedModelCheckpoint, permissionId, options) {
    return this._client.delete(`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions/${permissionId}`, options);
  }
}
class PermissionCreateResponsesPage extends Page {
}
Permissions.PermissionCreateResponsesPage = PermissionCreateResponsesPage;
let Checkpoints$1 = class Checkpoints extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints$1.Permissions = Permissions;
Checkpoints$1.PermissionCreateResponsesPage = PermissionCreateResponsesPage;
class Checkpoints2 extends APIResource {
  list(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/checkpoints`, FineTuningJobCheckpointsPage, { query, ...options });
  }
}
class FineTuningJobCheckpointsPage extends CursorPage {
}
Checkpoints2.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
class Jobs extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/fine-tuning)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobId, options) {
    return this._client.get(`/fine_tuning/jobs/${fineTuningJobId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/fine_tuning/jobs", FineTuningJobsPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/cancel`, options);
  }
  listEvents(fineTuningJobId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listEvents(fineTuningJobId, {}, query);
    }
    return this._client.getAPIList(`/fine_tuning/jobs/${fineTuningJobId}/events`, FineTuningJobEventsPage, {
      query,
      ...options
    });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobId, options) {
    return this._client.post(`/fine_tuning/jobs/${fineTuningJobId}/resume`, options);
  }
}
class FineTuningJobsPage extends CursorPage {
}
class FineTuningJobEventsPage extends CursorPage {
}
Jobs.FineTuningJobsPage = FineTuningJobsPage;
Jobs.FineTuningJobEventsPage = FineTuningJobEventsPage;
Jobs.Checkpoints = Checkpoints2;
Jobs.FineTuningJobCheckpointsPage = FineTuningJobCheckpointsPage;
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints$1(this._client);
    this.alpha = new Alpha(this._client);
  }
}
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.FineTuningJobsPage = FineTuningJobsPage;
FineTuning.FineTuningJobEventsPage = FineTuningJobEventsPage;
FineTuning.Checkpoints = Checkpoints$1;
FineTuning.Alpha = Alpha;
class GraderModels extends APIResource {
}
class Graders2 extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
}
Graders2.GraderModels = GraderModels;
class Images extends APIResource {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an edited or extended image given one or more source images and a
   * prompt. This endpoint only supports `gpt-image-1` and `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.edit({
   *   image: fs.createReadStream('path/to/file'),
   *   prompt: 'A cute baby sea otter wearing a beret',
   * });
   * ```
   */
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options }));
  }
  /**
   * Creates an image given a prompt.
   * [Learn more](https://platform.openai.com/docs/guides/images).
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.generate({
   *   prompt: 'A cute baby sea otter',
   * });
   * ```
   */
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
}
class Models extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model2, options) {
    return this._client.get(`/models/${model2}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", ModelsPage, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  del(model2, options) {
    return this._client.delete(`/models/${model2}`, options);
  }
}
class ModelsPage extends Page {
}
Models.ModelsPage = ModelsPage;
class Moderations extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
}
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}
class InputItems extends APIResource {
  list(responseId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(responseId, {}, query);
    }
    return this._client.getAPIList(`/responses/${responseId}/input_items`, ResponseItemsPage, {
      query,
      ...options
    });
  }
}
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m") throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;
class ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client2, params, options) {
    const runner = new ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client2, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client2, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream2;
    let starting_after = null;
    if ("response_id" in params) {
      stream2 = await client2.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream2 = await client2.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream2) {
      __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream2.controller.signal?.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          output.content.push(event.part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
}
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}
class Responses extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseId, query = {}, options) {
    return this._client.get(`/responses/${responseId}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.del(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  del(responseId, options) {
    return this._client.delete(`/responses/${responseId}`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseId, options) {
    return this._client.post(`/responses/${responseId}/cancel`, {
      ...options,
      headers: { Accept: "*/*", ...options?.headers }
    });
  }
}
class ResponseItemsPage extends CursorPage {
}
Responses.InputItems = InputItems;
class Parts extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/parts`, multipartFormRequestOptions({ body, ...options }));
  }
}
class Uploads extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadId, options) {
    return this._client.post(`/uploads/${uploadId}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadId, body, options) {
    return this._client.post(`/uploads/${uploadId}/complete`, { body, ...options });
  }
}
Uploads.Parts = Parts;
const allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};
class Files3 extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(vectorStoreId, fileId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(vectorStoreId, fileId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(vectorStoreId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list(vectorStoreId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files`, VectorStoreFilesPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  del(vectorStoreId, fileId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}/files/${fileId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreId, fileId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const fileResponse = await this.retrieve(vectorStoreId, fileId, {
        ...options,
        headers
      }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep$1(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(vectorStoreId, fileId, options) {
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/files/${fileId}/content`, FileContentResponsesPage, { ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers } });
  }
}
class VectorStoreFilesPage extends CursorPage {
}
class FileContentResponsesPage extends Page {
}
Files3.VectorStoreFilesPage = VectorStoreFilesPage;
Files3.FileContentResponsesPage = FileContentResponsesPage;
class FileBatches extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(vectorStoreId, batchId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}/file_batches/${batchId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(vectorStoreId, batchId, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/cancel`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(vectorStoreId, batchId, query = {}, options) {
    if (isRequestOptions(query)) {
      return this.listFiles(vectorStoreId, batchId, {}, query);
    }
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/file_batches/${batchId}/files`, VectorStoreFilesPage, { query, ...options, headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers } });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreId, batchId, options) {
    const headers = { ...options?.headers, "X-Stainless-Poll-Helper": "true" };
    if (options?.pollIntervalMs) {
      headers["X-Stainless-Custom-Poll-Interval"] = options.pollIntervalMs.toString();
    }
    while (true) {
      const { data: batch, response } = await this.retrieve(vectorStoreId, batchId, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep$1(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client2 = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client2.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
}
class VectorStores extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreId, options) {
    return this._client.get(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreId, body, options) {
    return this._client.post(`/vector_stores/${vectorStoreId}`, {
      body,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/vector_stores", VectorStoresPage, {
      query,
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Delete a vector store.
   */
  del(vectorStoreId, options) {
    return this._client.delete(`/vector_stores/${vectorStoreId}`, {
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreId, body, options) {
    return this._client.getAPIList(`/vector_stores/${vectorStoreId}/search`, VectorStoreSearchResponsesPage, {
      body,
      method: "post",
      ...options,
      headers: { "OpenAI-Beta": "assistants=v2", ...options?.headers }
    });
  }
}
class VectorStoresPage extends CursorPage {
}
class VectorStoreSearchResponsesPage extends Page {
}
VectorStores.VectorStoresPage = VectorStoresPage;
VectorStores.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
VectorStores.Files = Files3;
VectorStores.VectorStoreFilesPage = VectorStoreFilesPage;
VectorStores.FileContentResponsesPage = FileContentResponsesPage;
VectorStores.FileBatches = FileBatches;
var _a$2;
class OpenAI extends APIClient {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv$1("OPENAI_BASE_URL"), apiKey = readEnv$1("OPENAI_API_KEY"), organization = readEnv$1("OPENAI_ORG_ID") ?? null, project = readEnv$1("OPENAI_PROJECT_ID") ?? null, ...opts } = {}) {
    if (apiKey === void 0) {
      throw new OpenAIError("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      organization,
      project,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions3(this);
    this.chat = new Chat$1(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files$1(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this._options = options;
    this.apiKey = apiKey;
    this.organization = organization;
    this.project = project;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      "OpenAI-Organization": this.organization,
      "OpenAI-Project": this.project,
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
}
_a$2 = OpenAI;
OpenAI.OpenAI = _a$2;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.toFile = toFile;
OpenAI.fileFromPath = fileFromPath;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat$1;
OpenAI.ChatCompletionsPage = ChatCompletionsPage;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files$1;
OpenAI.FileObjectsPage = FileObjectsPage;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.ModelsPage = ModelsPage;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.VectorStoresPage = VectorStoresPage;
OpenAI.VectorStoreSearchResponsesPage = VectorStoreSearchResponsesPage;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.BatchesPage = BatchesPage;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Evals = Evals;
OpenAI.EvalListResponsesPage = EvalListResponsesPage;
OpenAI.Containers = Containers;
OpenAI.ContainerListResponsesPage = ContainerListResponsesPage;
class TldrawAiBaseService {
  constructor(env) {
    this.env = env;
  }
}
const TLDRAW_LIBRARY_VERSION_KEY = "__TLDRAW_LIBRARY_VERSIONS__";
function getLibraryVersions() {
  if (globalThis[TLDRAW_LIBRARY_VERSION_KEY]) {
    return globalThis[TLDRAW_LIBRARY_VERSION_KEY];
  }
  const info = {
    versions: [],
    didWarn: false,
    scheduledNotice: null
  };
  Object.defineProperty(globalThis, TLDRAW_LIBRARY_VERSION_KEY, {
    value: info,
    writable: false,
    configurable: false,
    enumerable: false
  });
  return info;
}
function registerTldrawLibraryVersion(name, version2, modules) {
  if (!name || !version2 || !modules) {
    {
      throw new Error("Missing name/version/module system in built version of tldraw library");
    }
  }
  const info = getLibraryVersions();
  info.versions.push({ name, version: version2, modules });
  if (!info.scheduledNotice) {
    try {
      info.scheduledNotice = setTimeout(() => {
        info.scheduledNotice = null;
        checkLibraryVersions(info);
      }, 100);
    } catch {
      checkLibraryVersions(info);
    }
  }
}
function checkLibraryVersions(info) {
  if (!info.versions.length) return;
  if (info.didWarn) return;
  const sorted = info.versions.sort((a2, b) => compareVersions(a2.version, b.version));
  const latestVersion = sorted[sorted.length - 1].version;
  const matchingVersions = /* @__PURE__ */ new Set();
  const nonMatchingVersions = /* @__PURE__ */ new Map();
  for (const lib of sorted) {
    if (nonMatchingVersions.has(lib.name)) {
      matchingVersions.delete(lib.name);
      entry(nonMatchingVersions, lib.name, /* @__PURE__ */ new Set()).add(lib.version);
      continue;
    }
    if (lib.version === latestVersion) {
      matchingVersions.add(lib.name);
    } else {
      matchingVersions.delete(lib.name);
      entry(nonMatchingVersions, lib.name, /* @__PURE__ */ new Set()).add(lib.version);
    }
  }
  if (nonMatchingVersions.size > 0) {
    const message = [
      `${format("[tldraw]", ["bold", "bgRed", "textWhite"])} ${format("You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.", ["textRed", "bold"])}`,
      "",
      `The latest version you have installed is ${format(`v${latestVersion}`, ["bold", "textBlue"])}. The following libraries are on the latest version:`,
      ...Array.from(matchingVersions, (name) => `  • ✅ ${format(name, ["bold"])}`),
      "",
      `The following libraries are not on the latest version, or have multiple versions installed:`,
      ...Array.from(nonMatchingVersions, ([name, versions]) => {
        const sortedVersions = Array.from(versions).sort(compareVersions).map((v) => format(`v${v}`, v === latestVersion ? ["textGreen"] : ["textRed"]));
        return `  • ❌ ${format(name, ["bold"])} (${sortedVersions.join(", ")})`;
      })
    ];
    console.log(message.join("\n"));
    info.didWarn = true;
    return;
  }
  const potentialDuplicates = /* @__PURE__ */ new Map();
  for (const lib of sorted) {
    entry(potentialDuplicates, lib.name, { version: lib.version, modules: [] }).modules.push(
      lib.modules
    );
  }
  const duplicates = /* @__PURE__ */ new Map();
  for (const [name, lib] of potentialDuplicates) {
    if (lib.modules.length > 1) duplicates.set(name, lib);
  }
  if (duplicates.size > 0) {
    const message = [
      `${format("[tldraw]", ["bold", "bgRed", "textWhite"])} ${format("You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ", ["textRed", "bold"])}`,
      "",
      "This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.",
      "",
      "The following libraries have been imported multiple times:",
      ...Array.from(duplicates, ([name, lib]) => {
        const modules = lib.modules.map((m, i) => m === "esm" ? `      ${i + 1}. ES Modules` : `      ${i + 1}. CommonJS`).join("\n");
        return `  • ❌ ${format(name, ["bold"])} v${lib.version}: 
${modules}`;
      }),
      "",
      "You should configure your bundler to only import one version of each library."
    ];
    console.log(message.join("\n"));
    info.didWarn = true;
    return;
  }
}
function compareVersions(a2, b) {
  const aMatch = a2.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  const bMatch = b.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  if (!aMatch || !bMatch) return a2.localeCompare(b);
  if (aMatch[1] !== bMatch[1]) return Number(aMatch[1]) - Number(bMatch[1]);
  if (aMatch[2] !== bMatch[2]) return Number(aMatch[2]) - Number(bMatch[2]);
  if (aMatch[3] !== bMatch[3]) return Number(aMatch[3]) - Number(bMatch[3]);
  if (aMatch[4] && bMatch[4]) return aMatch[4].localeCompare(bMatch[4]);
  if (aMatch[4]) return 1;
  if (bMatch[4]) return -1;
  return 0;
}
const formats = {
  bold: "1",
  textBlue: "94",
  textRed: "31",
  textGreen: "32",
  bgRed: "41",
  textWhite: "97"
};
function format(value, formatters2 = []) {
  return `\x1B[${formatters2.map((f) => formats[f]).join(";")}m${value}\x1B[m`;
}
function entry(map2, key, defaultValue) {
  if (map2.has(key)) {
    return map2.get(key);
  }
  map2.set(key, defaultValue);
  return defaultValue;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var lodash_throttle;
var hasRequiredLodash_throttle;
function requireLodash_throttle() {
  if (hasRequiredLodash_throttle) return lodash_throttle;
  hasRequiredLodash_throttle = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN2 = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max, nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce2(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time2) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time2;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time2) {
      lastInvokeTime = time2;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time2) : result;
    }
    function remainingWait(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time2) {
      var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time2 = now();
      if (shouldInvoke(time2)) {
        return trailingEdge(time2);
      }
      timerId = setTimeout(timerExpired, remainingWait(time2));
    }
    function trailingEdge(time2) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time2);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush2() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time2 = now(), isInvoking = shouldInvoke(time2);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time2;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush2;
    return debounced;
  }
  function throttle2(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject2(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce2(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol2(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol2(value)) {
      return NAN2;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
  }
  lodash_throttle = throttle2;
  return lodash_throttle;
}
var lodash_throttleExports = requireLodash_throttle();
const throttle = /* @__PURE__ */ getDefaultExportFromCjs(lodash_throttleExports);
var lodash_uniq;
var hasRequiredLodash_uniq;
function requireLodash_uniq() {
  if (hasRequiredLodash_uniq) return lodash_uniq;
  hasRequiredLodash_uniq = 1;
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY2 = 1 / 0;
  var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayIncludes2(array2, value) {
    var length = array2 ? array2.length : 0;
    return !!length && baseIndexOf(array2, value, 0) > -1;
  }
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length = array2.length, index2 = fromIndex + -1;
    while (++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array2, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    var index2 = fromIndex - 1, length = array2.length;
    while (++index2 < length) {
      if (array2[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var splice = arrayProto.splice;
  var Map2 = getNative(root, "Map"), Set2 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry2 = entries[index2];
      this.set(entry2[0], entry2[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry2 = entries[index2];
      this.set(entry2[0], entry2[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry2 = entries[index2];
      this.set(entry2[0], entry2[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseUniq(array2, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes2, length = array2.length, isCommon = true, result = [], seen = result;
    if (length >= LARGE_ARRAY_SIZE) {
      var set = createSet(array2);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = result;
    }
    outer:
      while (++index2 < length) {
        var value = array2[index2], computed2 = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed2 === computed2) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed2) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(seen, computed2, comparator)) {
          if (seen !== result) {
            seen.push(computed2);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY2) ? noop3 : function(values) {
    return new Set2(values);
  };
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function uniq2(array2) {
    return array2 && array2.length ? baseUniq(array2) : [];
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function noop3() {
  }
  lodash_uniq = uniq2;
  return lodash_uniq;
}
var lodash_uniqExports = requireLodash_uniq();
const _uniq = /* @__PURE__ */ getDefaultExportFromCjs(lodash_uniqExports);
function omitFromStackTrace(fn) {
  const wrappedFn = (...args) => {
    try {
      return fn(...args);
    } catch (error) {
      if (error instanceof Error && Error.captureStackTrace) {
        Error.captureStackTrace(error, wrappedFn);
      }
      throw error;
    }
  };
  return wrappedFn;
}
const noop$3 = () => {
};
const Result = {
  ok(value) {
    return { ok: true, value };
  },
  err(error) {
    return { ok: false, error };
  }
};
function exhaustiveSwitchError$1(value, property) {
  const debugValue = property && value && typeof value === "object" && property in value ? value[property] : value;
  throw new Error(`Unknown switch case ${debugValue}`);
}
const assert = omitFromStackTrace(
  (value, message) => {
    if (!value) {
      throw new Error(message || "Assertion Error");
    }
  }
);
const assertExists = omitFromStackTrace((value, message) => {
  if (value == null) {
    throw new Error(message ?? "value must be defined");
  }
  return value;
});
function promiseWithResolve() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return Object.assign(promise, {
    resolve,
    reject
  });
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const PERFORMANCE_COLORS = {
  Good: "#40C057",
  Mid: "#FFC078",
  Poor: "#E03131"
};
const PERFORMANCE_PREFIX_COLOR = PERFORMANCE_COLORS.Good;
class PerformanceTracker {
  startTime = 0;
  name = "";
  frames = 0;
  started = false;
  frame = null;
  // eslint-disable-next-line local/prefer-class-methods
  recordFrame = () => {
    this.frames++;
    if (!this.started) return;
    this.frame = requestAnimationFrame(this.recordFrame);
  };
  start(name) {
    this.name = name;
    this.frames = 0;
    this.started = true;
    if (this.frame !== null) cancelAnimationFrame(this.frame);
    this.frame = requestAnimationFrame(this.recordFrame);
    this.startTime = performance.now();
  }
  stop() {
    this.started = false;
    if (this.frame !== null) cancelAnimationFrame(this.frame);
    const duration = (performance.now() - this.startTime) / 1e3;
    const fps = duration === 0 ? 0 : Math.floor(this.frames / duration);
    const background = fps > 55 ? PERFORMANCE_COLORS.Good : fps > 30 ? PERFORMANCE_COLORS.Mid : PERFORMANCE_COLORS.Poor;
    const color = background === PERFORMANCE_COLORS.Mid ? "black" : "white";
    const capitalized = this.name[0].toUpperCase() + this.name.slice(1);
    console.debug(
      `%cPerf%c ${capitalized} %c${fps}%c fps`,
      `color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,
      "font-weight: normal",
      `font-weight: bold; padding: 2px; background: ${background};color: ${color};`,
      "font-weight: normal"
    );
  }
  isStarted() {
    return this.started;
  }
}
function dedupe(input, equals2) {
  const result = [];
  mainLoop: for (const item of input) {
    for (const existing of result) {
      if (equals2 ? equals2(item, existing) : item === existing) {
        continue mainLoop;
      }
    }
    result.push(item);
  }
  return result;
}
function compact$1(arr) {
  return arr.filter((i) => i !== void 0 && i !== null);
}
function last$1(arr) {
  return arr[arr.length - 1];
}
function minBy(arr, fn) {
  let min2;
  let minVal = Infinity;
  for (const item of arr) {
    const val = fn(item);
    if (val < minVal) {
      min2 = item;
      minVal = val;
    }
  }
  return min2;
}
function maxBy(arr, fn) {
  let max2;
  let maxVal = -Infinity;
  for (const item of arr) {
    const val = fn(item);
    if (val > maxVal) {
      max2 = item;
      maxVal = val;
    }
  }
  return max2;
}
function areArraysShallowEqual(arr1, arr2) {
  if (arr1 === arr2) return true;
  if (arr1.length !== arr2.length) return false;
  for (let i = 0; i < arr1.length; i++) {
    if (!Object.is(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
function mergeArraysAndReplaceDefaults(key, customEntries, defaults2) {
  const overrideTypes = new Set(customEntries.map((entry2) => entry2[key]));
  const result = [];
  for (const defaultEntry of defaults2) {
    if (overrideTypes.has(defaultEntry[key])) continue;
    result.push(defaultEntry);
  }
  for (const customEntry of customEntries) {
    result.push(customEntry);
  }
  return result;
}
/*!
 * MIT License: https://github.com/NoHomey/bind-decorator/blob/master/License
 * Copyright (c) 2016 Ivo Stratev
 */
function bind$1(...args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    context.addInitializer(function initializeMethod() {
      assert(Reflect.isExtensible(this), "Cannot bind to a non-extensible class.");
      const value = originalMethod.bind(this);
      const ok = Reflect.defineProperty(this, context.name, {
        value,
        writable: true,
        configurable: true
      });
      assert(ok, "Cannot bind a non-configurable class method.");
    });
  } else {
    const [_target, propertyKey, descriptor] = args;
    if (!descriptor || typeof descriptor.value !== "function") {
      throw new TypeError(
        `Only methods can be decorated with @bind. <${propertyKey}> is not a method!`
      );
    }
    return {
      configurable: true,
      get() {
        const bound = descriptor.value.bind(this);
        Object.defineProperty(this, propertyKey, {
          value: bound,
          configurable: true,
          writable: true
        });
        return bound;
      }
    };
  }
}
class WeakCache {
  /** The map of items to their cached values. */
  items = /* @__PURE__ */ new WeakMap();
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(item, cb) {
    if (!this.items.has(item)) {
      this.items.set(item, cb(item));
    }
    return this.items.get(item);
  }
}
function debounce(callback, wait) {
  let state = void 0;
  const fn = (...args) => {
    if (!state) {
      state = {};
      state.promise = new Promise((resolve, reject) => {
        state.resolve = resolve;
        state.reject = reject;
      });
    }
    clearTimeout(state.timeout);
    state.latestArgs = args;
    state.timeout = setTimeout(() => {
      const s2 = state;
      state = void 0;
      try {
        s2.resolve(callback(...s2.latestArgs));
      } catch (e) {
        s2.reject(e);
      }
    }, wait);
    return state.promise;
  };
  fn.cancel = () => {
    if (!state) return;
    clearTimeout(state.timeout);
  };
  return fn;
}
const annotationsByError = /* @__PURE__ */ new WeakMap();
function annotateError(error, annotations) {
  if (typeof error !== "object" || error === null) return;
  let currentAnnotations = annotationsByError.get(error);
  if (!currentAnnotations) {
    currentAnnotations = { tags: {}, extras: {} };
    annotationsByError.set(error, currentAnnotations);
  }
  if (annotations.tags) {
    currentAnnotations.tags = {
      ...currentAnnotations.tags,
      ...annotations.tags
    };
  }
  if (annotations.extras) {
    currentAnnotations.extras = {
      ...currentAnnotations.extras,
      ...annotations.extras
    };
  }
}
async function fetch$1(input, init2) {
  return window.fetch(input, {
    // We want to make sure that the referrer is not sent to other domains.
    referrerPolicy: "strict-origin-when-cross-origin",
    ...init2
  });
}
const Image = (width, height) => {
  const img = new window.Image(width, height);
  img.referrerPolicy = "strict-origin-when-cross-origin";
  return img;
};
class FileHelpers {
  /**
   * @deprecated Use `urlToArrayBuffer` instead.
   */
  static async dataUrlToArrayBuffer(dataURL) {
    return fetch$1(dataURL).then(function(result) {
      return result.arrayBuffer();
    });
  }
  /**
   * @param url - The url of the file.
   */
  static async urlToArrayBuffer(url) {
    const response = await fetch$1(url);
    return await response.arrayBuffer();
  }
  static async urlToBlob(url) {
    const response = await fetch$1(url);
    return await response.blob();
  }
  static async urlToDataUrl(url) {
    if (url.startsWith("data:")) return url;
    const blob = await FileHelpers.urlToBlob(url);
    return await FileHelpers.blobToDataUrl(blob);
  }
  /**
   * Convert a file to a base64 encoded data url.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.toDataUrl(myImageFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToDataUrl(file) {
    return await new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
        reader.readAsDataURL(file);
      }
    });
  }
  /**
   * Convert a file to a unicode text string.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.fileToDataUrl(myTextFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToText(file) {
    return await new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
        reader.readAsText(file);
      }
    });
  }
  static rewriteMimeType(blob, newMimeType) {
    if (blob.type === newMimeType) return blob;
    if (blob instanceof File) {
      return new File([blob], blob.name, { type: newMimeType });
    }
    return new Blob([blob], { type: newMimeType });
  }
}
function getHashForString(string2) {
  let hash2 = 0;
  for (let i = 0; i < string2.length; i++) {
    hash2 = (hash2 << 5) - hash2 + string2.charCodeAt(i);
    hash2 |= 0;
  }
  return hash2 + "";
}
/*!
 * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE
 * Modified code originally from <https://github.com/ai/nanoid>
 * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>
 *
 * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't
 * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a
 * CommonJS module. By including nanoid here, we can make sure it works well in every environment
 * where tldraw is used. We can also remove some unused features like custom alphabets.
 */
const crypto$1 = globalThis.crypto;
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
const POOL_SIZE_MULTIPLIER = 128;
let pool, poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = new Uint8Array(bytes * POOL_SIZE_MULTIPLIER);
    crypto$1.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    crypto$1.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function nanoid(size2 = 21) {
  fillPool(size2 -= 0);
  let id = "";
  for (let i = poolOffset - size2; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}
let impl = nanoid;
function uniqueId(size2) {
  return impl(size2);
}
/*!
 * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license
 * Copyright (c) Philip van Heemstra
 */
function isApngAnimated(buffer) {
  const view = new Uint8Array(buffer);
  if (!view || !(typeof Buffer !== "undefined" && Buffer.isBuffer(view) || view instanceof Uint8Array) || view.length < 16) {
    return false;
  }
  const isPNG = view[0] === 137 && view[1] === 80 && view[2] === 78 && view[3] === 71 && view[4] === 13 && view[5] === 10 && view[6] === 26 && view[7] === 10;
  if (!isPNG) {
    return false;
  }
  function indexOfSubstring(haystack, needle, fromIndex, upToIndex, chunksize = 1024) {
    if (!needle) {
      return -1;
    }
    needle = new RegExp(needle, "g");
    const needle_length = needle.source.length;
    const decoder = new TextDecoder();
    const full_haystack_length = haystack.length;
    if (typeof upToIndex === "undefined") {
      upToIndex = full_haystack_length;
    }
    if (fromIndex >= full_haystack_length || upToIndex <= 0 || fromIndex >= upToIndex) {
      return -1;
    }
    haystack = haystack.subarray(fromIndex, upToIndex);
    let position = -1;
    let current_index = 0;
    let full_length = 0;
    let needle_buffer = "";
    outer: while (current_index < haystack.length) {
      const next_index = current_index + chunksize;
      const chunk = haystack.subarray(current_index, next_index);
      const decoded = decoder.decode(chunk, { stream: true });
      const text = needle_buffer + decoded;
      let match;
      let last_index = -1;
      while ((match = needle.exec(text)) !== null) {
        last_index = match.index - needle_buffer.length;
        position = full_length + last_index;
        break outer;
      }
      current_index = next_index;
      full_length += decoded.length;
      const needle_index = last_index > -1 ? last_index + needle_length : decoded.length - needle_length;
      needle_buffer = decoded.slice(needle_index);
    }
    if (position >= 0) {
      position += fromIndex >= 0 ? fromIndex : full_haystack_length + fromIndex;
    }
    return position;
  }
  const idatIdx = indexOfSubstring(view, "IDAT", 12);
  if (idatIdx >= 12) {
    const actlIdx = indexOfSubstring(view, "acTL", 8, idatIdx);
    return actlIdx >= 8;
  }
  return false;
}
const isAvifAnimated = (buffer) => {
  const view = new Uint8Array(buffer);
  return view[3] === 44;
};
/*!
 * MIT License
 * Modified code originally from <https://github.com/qzb/is-animated>
 * Copyright (c) 2016 Józef Sokołowski <j.k.sokolowski@gmail.com>
 */
function getDataBlocksLength(buffer, offset2) {
  let length = 0;
  while (buffer[offset2 + length]) {
    length += buffer[offset2 + length] + 1;
  }
  return length + 1;
}
function isGIF(buffer) {
  const enc = new TextDecoder("ascii");
  const header = enc.decode(buffer.slice(0, 3));
  return header === "GIF";
}
function isGifAnimated(buffer) {
  const view = new Uint8Array(buffer);
  let hasColorTable, colorTableSize;
  let offset2 = 0;
  let imagesCount = 0;
  if (!isGIF(buffer)) {
    return false;
  }
  hasColorTable = view[10] & 128;
  colorTableSize = view[10] & 7;
  offset2 += 6;
  offset2 += 7;
  offset2 += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
  while (imagesCount < 2 && offset2 < view.length) {
    switch (view[offset2]) {
      // Image descriptor block. According to specification there could be any
      // number of these blocks (even zero). When there is more than one image
      // descriptor browsers will display animation (they shouldn't when there
      // is no delays defined, but they do it anyway).
      case 44:
        imagesCount += 1;
        hasColorTable = view[offset2 + 9] & 128;
        colorTableSize = view[offset2 + 9] & 7;
        offset2 += 10;
        offset2 += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
        offset2 += getDataBlocksLength(view, offset2 + 1) + 1;
        break;
      // Skip all extension blocks. In theory this "plain text extension" blocks
      // could be frames of animation, but no browser renders them.
      case 33:
        offset2 += 2;
        offset2 += getDataBlocksLength(view, offset2);
        break;
      // Stop processing on trailer block,
      // all data after this point will is ignored by decoders
      case 59:
        offset2 = view.length;
        break;
      // Oops! This GIF seems to be invalid
      default:
        offset2 = view.length;
        break;
    }
  }
  return imagesCount > 1;
}
/*!
 * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE
 * Copyright: 2014 Alex Gorbatchev
 * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts
 */
let TABLE = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
if (typeof Int32Array !== "undefined") {
  TABLE = new Int32Array(TABLE);
}
const crc = (current, previous) => {
  let crc2 = 0 ^ -1;
  for (let index2 = 0; index2 < current.length; index2++) {
    crc2 = TABLE[(crc2 ^ current[index2]) & 255] ^ crc2 >>> 8;
  }
  return crc2 ^ -1;
};
const LEN_SIZE = 4;
const CRC_SIZE = 4;
class PngHelpers {
  static isPng(view, offset2) {
    if (view.getUint8(offset2 + 0) === 137 && view.getUint8(offset2 + 1) === 80 && view.getUint8(offset2 + 2) === 78 && view.getUint8(offset2 + 3) === 71 && view.getUint8(offset2 + 4) === 13 && view.getUint8(offset2 + 5) === 10 && view.getUint8(offset2 + 6) === 26 && view.getUint8(offset2 + 7) === 10) {
      return true;
    }
    return false;
  }
  static getChunkType(view, offset2) {
    return [
      String.fromCharCode(view.getUint8(offset2)),
      String.fromCharCode(view.getUint8(offset2 + 1)),
      String.fromCharCode(view.getUint8(offset2 + 2)),
      String.fromCharCode(view.getUint8(offset2 + 3))
    ].join("");
  }
  static readChunks(view, offset2 = 0) {
    const chunks = {};
    if (!PngHelpers.isPng(view, offset2)) {
      throw new Error("Not a PNG");
    }
    offset2 += 8;
    while (offset2 <= view.buffer.byteLength) {
      const start = offset2;
      const len = view.getInt32(offset2);
      offset2 += 4;
      const chunkType = PngHelpers.getChunkType(view, offset2);
      if (chunkType === "IDAT" && chunks[chunkType]) {
        offset2 += len + LEN_SIZE + CRC_SIZE;
        continue;
      }
      if (chunkType === "IEND") {
        break;
      }
      chunks[chunkType] = {
        start,
        dataOffset: offset2 + 4,
        size: len
      };
      offset2 += len + LEN_SIZE + CRC_SIZE;
    }
    return chunks;
  }
  static parsePhys(view, offset2) {
    return {
      ppux: view.getUint32(offset2),
      ppuy: view.getUint32(offset2 + 4),
      unit: view.getUint8(offset2 + 4)
    };
  }
  static findChunk(view, type) {
    const chunks = PngHelpers.readChunks(view);
    return chunks[type];
  }
  static setPhysChunk(view, dpr = 1, options) {
    let offset2 = 46;
    let size2 = 0;
    const res1 = PngHelpers.findChunk(view, "pHYs");
    if (res1) {
      offset2 = res1.start;
      size2 = res1.size;
    }
    const res2 = PngHelpers.findChunk(view, "IDAT");
    if (res2) {
      offset2 = res2.start;
      size2 = 0;
    }
    const pHYsData = new ArrayBuffer(21);
    const pHYsDataView = new DataView(pHYsData);
    pHYsDataView.setUint32(0, 9);
    pHYsDataView.setUint8(4, "p".charCodeAt(0));
    pHYsDataView.setUint8(5, "H".charCodeAt(0));
    pHYsDataView.setUint8(6, "Y".charCodeAt(0));
    pHYsDataView.setUint8(7, "s".charCodeAt(0));
    const DPI_96 = 2835.5;
    pHYsDataView.setInt32(8, DPI_96 * dpr);
    pHYsDataView.setInt32(12, DPI_96 * dpr);
    pHYsDataView.setInt8(16, 1);
    const crcBit = new Uint8Array(pHYsData.slice(4, 17));
    pHYsDataView.setInt32(17, crc(crcBit));
    const startBuf = view.buffer.slice(0, offset2);
    const endBuf = view.buffer.slice(offset2 + size2);
    return new Blob([startBuf, pHYsData, endBuf], options);
  }
}
/*!
 * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
 */
function isWebp(view) {
  if (!view || view.length < 12) {
    return false;
  }
  return view[8] === 87 && view[9] === 69 && view[10] === 66 && view[11] === 80;
}
function isWebpAnimated(buffer) {
  const view = new Uint8Array(buffer);
  if (!isWebp(view)) {
    return false;
  }
  if (!view || view.length < 21) {
    return false;
  }
  return (view[20] >> 1 & 1) === 1;
}
const DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES = Object.freeze(["image/svg+xml"]);
const DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES = Object.freeze([
  "image/jpeg",
  "image/png",
  "image/webp"
]);
const DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES = Object.freeze([
  "image/gif",
  "image/apng",
  "image/avif"
]);
const DEFAULT_SUPPORTED_IMAGE_TYPES = Object.freeze([
  ...DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES,
  ...DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES,
  ...DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES
]);
const DEFAULT_SUPPORT_VIDEO_TYPES = Object.freeze([
  "video/mp4",
  "video/webm",
  "video/quicktime"
]);
const DEFAULT_SUPPORTED_MEDIA_TYPES = Object.freeze([
  ...DEFAULT_SUPPORTED_IMAGE_TYPES,
  ...DEFAULT_SUPPORT_VIDEO_TYPES
]);
const DEFAULT_SUPPORTED_MEDIA_TYPE_LIST = DEFAULT_SUPPORTED_MEDIA_TYPES.join(",");
class MediaHelpers {
  /**
   * Load a video from a url.
   * @public
   */
  static loadVideo(src) {
    return new Promise((resolve, reject) => {
      const video = document.createElement("video");
      video.onloadeddata = () => resolve(video);
      video.onerror = (e) => {
        console.error(e);
        reject(new Error("Could not load video"));
      };
      video.crossOrigin = "anonymous";
      video.src = src;
    });
  }
  static async getVideoFrameAsDataUrl(video, time2 = 0) {
    const promise = promiseWithResolve();
    let didSetTime = false;
    const onReadyStateChanged = () => {
      if (!didSetTime) {
        if (video.readyState >= video.HAVE_METADATA) {
          didSetTime = true;
          video.currentTime = time2;
        } else {
          return;
        }
      }
      if (video.readyState >= video.HAVE_CURRENT_DATA) {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Could not get 2d context");
        }
        ctx.drawImage(video, 0, 0);
        promise.resolve(canvas.toDataURL());
      }
    };
    const onError = (e) => {
      console.error(e);
      promise.reject(new Error("Could not get video frame"));
    };
    video.addEventListener("loadedmetadata", onReadyStateChanged);
    video.addEventListener("loadeddata", onReadyStateChanged);
    video.addEventListener("canplay", onReadyStateChanged);
    video.addEventListener("seeked", onReadyStateChanged);
    video.addEventListener("error", onError);
    video.addEventListener("stalled", onError);
    onReadyStateChanged();
    try {
      return await promise;
    } finally {
      video.removeEventListener("loadedmetadata", onReadyStateChanged);
      video.removeEventListener("loadeddata", onReadyStateChanged);
      video.removeEventListener("canplay", onReadyStateChanged);
      video.removeEventListener("seeked", onReadyStateChanged);
      video.removeEventListener("error", onError);
      video.removeEventListener("stalled", onError);
    }
  }
  /**
   * Load an image from a url.
   * @public
   */
  static getImageAndDimensions(src) {
    return new Promise((resolve, reject) => {
      const img = Image();
      img.onload = () => {
        let dimensions;
        if (img.naturalWidth) {
          dimensions = {
            w: img.naturalWidth,
            h: img.naturalHeight
          };
        } else {
          document.body.appendChild(img);
          dimensions = {
            w: img.clientWidth,
            h: img.clientHeight
          };
          document.body.removeChild(img);
        }
        resolve({ ...dimensions, image: img });
      };
      img.onerror = (e) => {
        console.error(e);
        reject(new Error("Could not load image"));
      };
      img.crossOrigin = "anonymous";
      img.referrerPolicy = "strict-origin-when-cross-origin";
      img.style.visibility = "hidden";
      img.style.position = "absolute";
      img.style.opacity = "0";
      img.style.zIndex = "-9999";
      img.src = src;
    });
  }
  /**
   * Get the size of a video blob
   *
   * @param blob - A SharedBlob containing the video
   * @public
   */
  static async getVideoSize(blob) {
    return MediaHelpers.usingObjectURL(blob, async (url) => {
      const video = await MediaHelpers.loadVideo(url);
      return { w: video.videoWidth, h: video.videoHeight };
    });
  }
  /**
   * Get the size of an image blob
   *
   * @param blob - A Blob containing the image.
   * @public
   */
  static async getImageSize(blob) {
    const { w, h } = await MediaHelpers.usingObjectURL(blob, MediaHelpers.getImageAndDimensions);
    try {
      if (blob.type === "image/png") {
        const view = new DataView(await blob.arrayBuffer());
        if (PngHelpers.isPng(view, 0)) {
          const physChunk = PngHelpers.findChunk(view, "pHYs");
          if (physChunk) {
            const physData = PngHelpers.parsePhys(view, physChunk.dataOffset);
            if (physData.unit === 0 && physData.ppux === physData.ppuy) {
              const pixelsPerMeter = 72 / 0.0254;
              const pixelRatio = Math.max(physData.ppux / pixelsPerMeter, 1);
              return {
                w: Math.round(w / pixelRatio),
                h: Math.round(h / pixelRatio)
              };
            }
          }
        }
      }
    } catch (err) {
      console.error(err);
      return { w, h };
    }
    return { w, h };
  }
  static async isAnimated(file) {
    if (file.type === "image/gif") {
      return isGifAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/avif") {
      return isAvifAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/webp") {
      return isWebpAnimated(await file.arrayBuffer());
    }
    if (file.type === "image/apng") {
      return isApngAnimated(await file.arrayBuffer());
    }
    return false;
  }
  static isAnimatedImageType(mimeType) {
    return DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES.includes(mimeType || "");
  }
  static isStaticImageType(mimeType) {
    return DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES.includes(mimeType || "");
  }
  static isVectorImageType(mimeType) {
    return DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES.includes(mimeType || "");
  }
  static isImageType(mimeType) {
    return DEFAULT_SUPPORTED_IMAGE_TYPES.includes(mimeType || "");
  }
  static async usingObjectURL(blob, fn) {
    const url = URL.createObjectURL(blob);
    try {
      return await fn(url);
    } finally {
      URL.revokeObjectURL(url);
    }
  }
}
function lerp(a2, b, t2) {
  return a2 + (b - a2) * t2;
}
function invLerp(a2, b, t2) {
  return (t2 - a2) / (b - a2);
}
function rng(seed = "") {
  let x = 0;
  let y2 = 0;
  let z = 0;
  let w = 0;
  function next() {
    const t2 = x ^ x << 11;
    x = y2;
    y2 = z;
    z = w;
    w ^= (w >>> 19 ^ t2 ^ t2 >>> 8) >>> 0;
    return w / 4294967296 * 2;
  }
  for (let k = 0; k < seed.length + 64; k++) {
    x ^= seed.charCodeAt(k) | 0;
    next();
  }
  return next;
}
function modulate(value, rangeA, rangeB, clamp2 = false) {
  const [fromLow, fromHigh] = rangeA;
  const [v0, v1] = rangeB;
  const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
  return clamp2 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
}
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getOwnProperty(obj, key) {
  if (!hasOwnProperty(obj, key)) {
    return void 0;
  }
  return obj[key];
}
function objectMapKeys(object2) {
  return Object.keys(object2);
}
function objectMapValues(object2) {
  return Object.values(object2);
}
function objectMapEntries(object2) {
  return Object.entries(object2);
}
function objectMapFromEntries(entries) {
  return Object.fromEntries(entries);
}
function filterEntries(object2, predicate) {
  const result = {};
  let didChange = false;
  for (const [key, value] of objectMapEntries(object2)) {
    if (predicate(key, value)) {
      result[key] = value;
    } else {
      didChange = true;
    }
  }
  return didChange ? result : object2;
}
function mapObjectMapValues(object2, mapper) {
  const result = {};
  for (const [key, value] of objectMapEntries(object2)) {
    const newValue = mapper(key, value);
    result[key] = newValue;
  }
  return result;
}
function areObjectsShallowEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  const keys1 = new Set(Object.keys(obj1));
  const keys2 = new Set(Object.keys(obj2));
  if (keys1.size !== keys2.size) return false;
  for (const key of keys1) {
    if (!keys2.has(key)) return false;
    if (!Object.is(obj1[key], obj2[key])) return false;
  }
  return true;
}
function indexCharacterSet(options) {
  const dicts = createCharSetDicts(options.chars);
  const limits = integerLimits(
    dicts,
    options.firstPositive,
    options.mostPositive,
    options.mostNegative
  );
  const jitterRange = options.jitterRange ?? Math.floor(Math.pow(dicts.length, 3) / 5);
  const paddingRange = paddingDict(jitterRange, dicts.length);
  return {
    chars: options.chars,
    byChar: dicts.byChar,
    byCode: dicts.byCode,
    length: dicts.length,
    first: dicts.byCode[0],
    last: dicts.byCode[dicts.length - 1],
    firstPositive: limits.firstPositive,
    mostPositive: limits.mostPositive,
    firstNegative: limits.firstNegative,
    mostNegative: limits.mostNegative,
    jitterRange,
    paddingDict: paddingRange
  };
}
function createCharSetDicts(charSet) {
  const byCode = {};
  const byChar = {};
  const length = charSet.length;
  for (let i = 0; i < length; i++) {
    const char = charSet[i];
    byCode[i] = char;
    byChar[char] = i;
  }
  return {
    byCode,
    byChar,
    length
  };
}
function integerLimits(dicts, firstPositive, mostPositive, mostNegative) {
  const firstPositiveIndex = dicts.byChar[firstPositive];
  const mostPositiveIndex = dicts.byChar[mostPositive];
  const mostNegativeIndex = dicts.byChar[mostNegative];
  if (firstPositiveIndex === void 0 || mostPositiveIndex === void 0 || mostNegativeIndex === void 0) {
    throw new Error("invalid charSet");
  }
  if (mostPositiveIndex - firstPositiveIndex < 3) {
    throw new Error(
      "mostPositive must be at least 3 characters away from neutral"
    );
  }
  if (firstPositiveIndex - mostNegativeIndex < 3) {
    throw new Error(
      "mostNegative must be at least 3 characters away from neutral"
    );
  }
  return {
    firstPositive: dicts.byCode[firstPositiveIndex],
    mostPositive: dicts.byCode[mostPositiveIndex],
    firstNegative: dicts.byCode[firstPositiveIndex - 1],
    mostNegative: dicts.byCode[mostNegativeIndex]
  };
}
function paddingDict(jitterRange, charSetLength) {
  const paddingDict2 = {};
  for (let i = 0; i < 100; i++) {
    paddingDict2[i] = Math.pow(charSetLength, i);
    if (paddingDict2[i] > jitterRange) {
      break;
    }
  }
  return paddingDict2;
}
var _base62CharSet = null;
function base62CharSet() {
  if (_base62CharSet)
    return _base62CharSet;
  return _base62CharSet = indexCharacterSet({
    // Base62 are all the alphanumeric characters, database and user friendly
    // For shorter strings and more room you could opt for more characters
    chars: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    // This gives us nice human readable keys to start with a0 a1 etc
    firstPositive: "a",
    mostPositive: "z",
    mostNegative: "A"
  });
}
function distanceBetween(a2, b, charSet) {
  const indexA = charSet.byChar[a2];
  const indexB = charSet.byChar[b];
  return Math.abs(indexA - indexB);
}
function integerLength(head, charSet) {
  const firstChar = head[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive) {
    const firstLevel = distanceBetween(firstChar, charSet.firstPositive, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head.slice(1), "positive", charSet);
  }
  if (firstChar === charSet.mostNegative) {
    const firstLevel = distanceBetween(firstChar, charSet.firstNegative, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head.slice(1), "negative", charSet);
  }
  const isPositiveRange = firstChar >= charSet.firstPositive;
  if (isPositiveRange) {
    return distanceBetween(firstChar, charSet.firstPositive, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.firstNegative, charSet) + 2;
  }
}
function integerLengthFromSecondLevel(key, direction, charSet) {
  const firstChar = key[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive && direction === "positive") {
    const totalPositiveRoom = distanceBetween(firstChar, charSet.mostNegative, charSet) + 1;
    return totalPositiveRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (firstChar === charSet.mostNegative && direction === "negative") {
    const totalNegativeRoom = distanceBetween(firstChar, charSet.mostPositive, charSet) + 1;
    return totalNegativeRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (direction === "positive") {
    return distanceBetween(firstChar, charSet.mostNegative, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.mostPositive, charSet) + 2;
  }
}
function makeSameLength(a2, b, pad, fillChar, forceLength) {
  const max2 = Math.max(a2.length, b.length);
  if (pad === "start") {
    return [a2.padStart(max2, fillChar), b.padStart(max2, fillChar)];
  }
  return [a2.padEnd(max2, fillChar), b.padEnd(max2, fillChar)];
}
function midPoint(lower, upper, charSet) {
  let [paddedLower, paddedUpper] = makeSameLength(
    lower,
    upper,
    "end",
    charSet.first
  );
  let distance = lexicalDistance(paddedLower, paddedUpper, charSet);
  if (distance === 1) {
    paddedLower = paddedLower.padEnd(paddedLower.length + 1, charSet.first);
    distance = charSet.length;
  }
  const mid = encodeToCharSet(Math.floor(distance / 2), charSet);
  return addCharSetKeys(paddedLower, mid, charSet);
}
function lexicalDistance(a2, b, charSet) {
  const [lower, upper] = makeSameLength(a2, b, "end", charSet.first).sort();
  const distance = subtractCharSetKeys(upper, lower, charSet);
  return decodeCharSetToNumber(distance, charSet);
}
function addCharSetKeys(a2, b, charSet) {
  const base2 = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a2, b, "start", charSet.first);
  const result = [];
  let carry = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    const digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]];
    const sum = digitA + digitB + carry;
    carry = Math.floor(sum / base2);
    const remainder = sum % base2;
    result.unshift(charSet.byCode[remainder]);
  }
  if (carry > 0) {
    result.unshift(charSet.byCode[carry]);
  }
  return result.join("");
}
function subtractCharSetKeys(a2, b, charSet) {
  const base2 = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a2, b, "start", charSet.first);
  const result = [];
  let borrow = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    let digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]] + borrow;
    if (digitA < digitB) {
      borrow = 1;
      digitA += base2;
    } else {
      borrow = 0;
    }
    const difference = digitA - digitB;
    result.unshift(charSet.byCode[difference]);
  }
  if (borrow > 0) {
    throw new Error(
      "Subtraction result is negative. Ensure a is greater than or equal to b."
    );
  }
  while (result.length > 1 && result[0] === charSet.byCode[0]) {
    result.shift();
  }
  return result.join("");
}
function incrementKey(key, charSet) {
  return addCharSetKeys(key, charSet.byCode[1], charSet);
}
function decrementKey(key, charSet) {
  return subtractCharSetKeys(key, charSet.byCode[1], charSet);
}
function encodeToCharSet(int, charSet) {
  if (int === 0) {
    return charSet.byCode[0];
  }
  let res = "";
  const max2 = charSet.length;
  while (int > 0) {
    res = charSet.byCode[int % max2] + res;
    int = Math.floor(int / max2);
  }
  return res;
}
function decodeCharSetToNumber(key, charSet) {
  let res = 0;
  const length = key.length;
  const max2 = charSet.length;
  for (let i = 0; i < length; i++) {
    res += charSet.byChar[key[i]] * Math.pow(max2, length - i - 1);
  }
  return res;
}
function startKey(charSet) {
  return charSet.firstPositive + charSet.byCode[0];
}
function validInteger(integer2, charSet) {
  const length = integerLength(integer2, charSet);
  return length === integer2.length;
}
function validateOrderKey(orderKey, charSet) {
  getIntegerPart(orderKey, charSet);
}
function getIntegerPart(orderKey, charSet) {
  const head = integerHead(orderKey, charSet);
  const integerPartLength = integerLength(head, charSet);
  if (integerPartLength > orderKey.length) {
    throw new Error("invalid order key length: " + orderKey);
  }
  return orderKey.slice(0, integerPartLength);
}
function validateInteger(integer2, charSet) {
  if (!validInteger(integer2, charSet)) {
    throw new Error("invalid integer length: " + integer2);
  }
}
function incrementInteger(integer2, charSet) {
  validateInteger(integer2, charSet);
  const [head, digs] = splitInteger(integer2, charSet);
  const anyNonMaxedDigit = digs.split("").some((d) => d !== charSet.byCode[charSet.length - 1]);
  if (anyNonMaxedDigit) {
    const newDigits = incrementKey(digs, charSet);
    return head + newDigits;
  }
  const nextHead = incrementIntegerHead(head, charSet);
  return startOnNewHead(nextHead, "lower", charSet);
}
function decrementInteger(integer2, charSet) {
  validateInteger(integer2, charSet);
  const [head, digs] = splitInteger(integer2, charSet);
  const anyNonLimitDigit = digs.split("").some((d) => d !== charSet.byCode[0]);
  if (anyNonLimitDigit) {
    const newDigits = decrementKey(digs, charSet);
    return head + newDigits;
  }
  const nextHead = decrementIntegerHead(head, charSet);
  return startOnNewHead(nextHead, "upper", charSet);
}
function integerHead(integer2, charSet) {
  let i = 0;
  if (integer2[0] === charSet.mostPositive) {
    while (integer2[i] === charSet.mostPositive) {
      i = i + 1;
    }
  }
  if (integer2[0] === charSet.mostNegative) {
    while (integer2[i] === charSet.mostNegative) {
      i = i + 1;
    }
  }
  return integer2.slice(0, i + 1);
}
function splitInteger(integer2, charSet) {
  const head = integerHead(integer2, charSet);
  const tail = integer2.slice(head.length);
  return [head, tail];
}
function incrementIntegerHead(head, charSet) {
  const inPositiveRange = head >= charSet.firstPositive;
  const nextHead = incrementKey(head, charSet);
  const headIsLimitMax = head[head.length - 1] === charSet.mostPositive;
  const nextHeadIsLimitMax = nextHead[nextHead.length - 1] === charSet.mostPositive;
  if (inPositiveRange && nextHeadIsLimitMax) {
    return nextHead + charSet.mostNegative;
  }
  if (!inPositiveRange && headIsLimitMax) {
    return head.slice(0, head.length - 1);
  }
  return nextHead;
}
function decrementIntegerHead(head, charSet) {
  const inPositiveRange = head >= charSet.firstPositive;
  const headIsLimitMin = head[head.length - 1] === charSet.mostNegative;
  if (inPositiveRange && headIsLimitMin) {
    const nextLevel = head.slice(0, head.length - 1);
    return decrementKey(nextLevel, charSet);
  }
  if (!inPositiveRange && headIsLimitMin) {
    return head + charSet.mostPositive;
  }
  return decrementKey(head, charSet);
}
function startOnNewHead(head, limit2, charSet) {
  const newLength = integerLength(head, charSet);
  const fillChar = limit2 === "upper" ? charSet.byCode[charSet.length - 1] : charSet.byCode[0];
  return head + fillChar.repeat(newLength - head.length);
}
function jitterString(orderKey, charSet) {
  const shift2 = encodeToCharSet(
    Math.floor(Math.random() * charSet.jitterRange),
    charSet
  );
  return addCharSetKeys(orderKey, shift2, charSet);
}
function padAndJitterString(orderKey, numberOfChars, charSet) {
  const paddedKey = orderKey.padEnd(
    orderKey.length + numberOfChars,
    charSet.first
  );
  return jitterString(paddedKey, charSet);
}
function paddingNeededForJitter(orderKey, b, charSet) {
  const integer2 = getIntegerPart(orderKey, charSet);
  const nextInteger = incrementInteger(integer2, charSet);
  let needed = 0;
  if (b !== null) {
    const distanceToB = lexicalDistance(orderKey, b, charSet);
    if (distanceToB < charSet.jitterRange + 1) {
      needed = Math.max(needed, paddingNeededForDistance(distanceToB, charSet));
    }
  }
  const distanceToNextInteger = lexicalDistance(orderKey, nextInteger, charSet);
  if (distanceToNextInteger < charSet.jitterRange + 1) {
    needed = Math.max(
      needed,
      paddingNeededForDistance(distanceToNextInteger, charSet)
    );
  }
  return needed;
}
function paddingNeededForDistance(distance, charSet) {
  const gap = charSet.jitterRange - distance;
  const firstBigger = Object.entries(charSet.paddingDict).find(
    ([_key, value]) => {
      return value > gap;
    }
  );
  return firstBigger ? parseInt(firstBigger[0]) : 0;
}
function generateKeyBetween(lower, upper, charSet = base62CharSet()) {
  if (lower !== null) {
    validateOrderKey(lower, charSet);
  }
  if (upper !== null) {
    validateOrderKey(upper, charSet);
  }
  if (lower === null && upper === null) {
    return startKey(charSet);
  }
  if (lower === null) {
    const integer2 = getIntegerPart(upper, charSet);
    return decrementInteger(integer2, charSet);
  }
  if (upper === null) {
    const integer2 = getIntegerPart(lower, charSet);
    return incrementInteger(integer2, charSet);
  }
  if (lower >= upper) {
    throw new Error(lower + " >= " + upper);
  }
  return midPoint(lower, upper, charSet);
}
function generateJitteredKeyBetween(lower, upper, charSet = base62CharSet()) {
  const key = generateKeyBetween(lower, upper, charSet);
  const paddingNeeded = paddingNeededForJitter(key, upper, charSet);
  if (paddingNeeded) {
    return padAndJitterString(key, paddingNeeded, charSet);
  }
  return jitterString(key, charSet);
}
function generateNJitteredKeysBetween(lower, upper, n2, charSet = base62CharSet()) {
  return spreadGeneratorResults(
    lower,
    upper,
    n2,
    charSet,
    generateJitteredKeyBetween,
    generateNJitteredKeysBetween
  );
}
function spreadGeneratorResults(lower, upper, n2, charSet, generateKey, generateNKeys) {
  if (n2 === 0) {
    return [];
  }
  if (n2 === 1) {
    return [generateKey(lower, upper, charSet)];
  }
  if (upper == null) {
    let newUpper = generateKey(lower, upper, charSet);
    const result = [newUpper];
    for (let i = 0; i < n2 - 1; i++) {
      newUpper = generateKey(newUpper, upper, charSet);
      result.push(newUpper);
    }
    return result;
  }
  if (lower == null) {
    let newLower = generateKey(lower, upper, charSet);
    const result = [newLower];
    for (let i = 0; i < n2 - 1; i++) {
      newLower = generateKey(lower, newLower, charSet);
      result.push(newLower);
    }
    result.reverse();
    return result;
  }
  const mid = Math.floor(n2 / 2);
  const midOrderKey = generateKey(lower, upper, charSet);
  return [
    ...generateNKeys(lower, midOrderKey, mid, charSet),
    midOrderKey,
    ...generateNKeys(midOrderKey, upper, n2 - mid - 1, charSet)
  ];
}
const generateKeysFn = generateNJitteredKeysBetween;
const ZERO_INDEX_KEY = "a0";
function validateIndexKey(index2) {
  try {
    generateJitteredKeyBetween(index2, null);
  } catch {
    throw new Error("invalid index: " + index2);
  }
}
function getIndicesBetween(below, above, n2) {
  return generateKeysFn(below ?? null, above ?? null, n2);
}
function getIndicesAbove(below, n2) {
  return generateKeysFn(below ?? null, null, n2);
}
function getIndexBetween(below, above) {
  return generateKeysFn(below ?? null, above ?? null, 1)[0];
}
function getIndexAbove(below = null) {
  return generateKeysFn(below, null, 1)[0];
}
function getIndexBelow(above = null) {
  return generateKeysFn(null, above, 1)[0];
}
function getIndices(n2, start = "a1") {
  return [start, ...generateKeysFn(start, null, n2)];
}
function sortByIndex$1(a2, b) {
  if (a2.index < b.index) {
    return -1;
  } else if (a2.index > b.index) {
    return 1;
  }
  return 0;
}
function sortById(a2, b) {
  return a2.id > b.id ? 1 : -1;
}
function getFromLocalStorage(key) {
  try {
    return localStorage.getItem(key);
  } catch {
    return null;
  }
}
function setInLocalStorage(key, value) {
  try {
    localStorage.setItem(key, value);
  } catch {
  }
}
function clearLocalStorage() {
  try {
    localStorage.clear();
  } catch {
  }
}
function getFromSessionStorage(key) {
  try {
    return sessionStorage.getItem(key);
  } catch {
    return null;
  }
}
function setInSessionStorage(key, value) {
  try {
    sessionStorage.setItem(key, value);
  } catch {
  }
}
function deleteFromSessionStorage(key) {
  try {
    sessionStorage.removeItem(key);
  } catch {
  }
}
function clearSessionStorage() {
  try {
    sessionStorage.clear();
  } catch {
  }
}
const fpsQueue = [];
const targetFps = 60;
const targetTimePerFrame = Math.ceil(1e3 / targetFps);
let frame;
let time = 0;
let last = 0;
const flush = () => {
  const queue = fpsQueue.splice(0, fpsQueue.length);
  for (const fn of queue) {
    fn();
  }
};
function tick() {
  if (frame) {
    return;
  }
  const now = Date.now();
  const elapsed = now - last;
  if (time + elapsed < targetTimePerFrame) {
    frame = requestAnimationFrame(() => {
      frame = void 0;
      tick();
    });
    return;
  }
  frame = requestAnimationFrame(() => {
    frame = void 0;
    last = now;
    time = Math.min(time + elapsed - targetTimePerFrame, targetTimePerFrame * 10);
    flush();
  });
}
let started = false;
function throttleToNextFrame$1(fn) {
  if (!fpsQueue.includes(fn)) {
    fpsQueue.push(fn);
    if (!started) {
      started = true;
      last = Date.now() - targetTimePerFrame - 1;
    }
    tick();
  }
  return () => {
    const index2 = fpsQueue.indexOf(fn);
    if (index2 > -1) {
      fpsQueue.splice(index2, 1);
    }
  };
}
class Timers {
  timeouts = /* @__PURE__ */ new Map();
  intervals = /* @__PURE__ */ new Map();
  rafs = /* @__PURE__ */ new Map();
  constructor() {
    this.setTimeout = this.setTimeout.bind(this);
    this.setInterval = this.setInterval.bind(this);
    this.requestAnimationFrame = this.requestAnimationFrame.bind(this);
    this.dispose = this.dispose.bind(this);
  }
  /** @public */
  setTimeout(contextId, handler, timeout, ...args) {
    const id = window.setTimeout(handler, timeout, args);
    const current = this.timeouts.get(contextId) ?? [];
    this.timeouts.set(contextId, [...current, id]);
    return id;
  }
  /** @public */
  setInterval(contextId, handler, timeout, ...args) {
    const id = window.setInterval(handler, timeout, args);
    const current = this.intervals.get(contextId) ?? [];
    this.intervals.set(contextId, [...current, id]);
    return id;
  }
  /** @public */
  requestAnimationFrame(contextId, callback) {
    const id = window.requestAnimationFrame(callback);
    const current = this.rafs.get(contextId) ?? [];
    this.rafs.set(contextId, [...current, id]);
    return id;
  }
  /** @public */
  dispose(contextId) {
    this.timeouts.get(contextId)?.forEach((id) => clearTimeout(id));
    this.intervals.get(contextId)?.forEach((id) => clearInterval(id));
    this.rafs.get(contextId)?.forEach((id) => cancelAnimationFrame(id));
    this.timeouts.delete(contextId);
    this.intervals.delete(contextId);
    this.rafs.delete(contextId);
  }
  disposeAll() {
    for (const contextId of this.timeouts.keys()) {
      this.dispose(contextId);
    }
  }
  forContext(contextId) {
    return {
      setTimeout: (handler, timeout, ...args) => this.setTimeout(contextId, handler, timeout, args),
      setInterval: (handler, timeout, ...args) => this.setInterval(contextId, handler, timeout, args),
      requestAnimationFrame: (callback) => this.requestAnimationFrame(contextId, callback),
      dispose: () => this.dispose(contextId)
    };
  }
}
const safeParseUrl = (url, baseUrl) => {
  try {
    return new URL(url, baseUrl);
  } catch {
    return;
  }
};
function isDefined(value) {
  return value !== void 0;
}
function getStructuredClone() {
  if (typeof globalThis !== "undefined" && globalThis.structuredClone) {
    return [globalThis.structuredClone, true];
  }
  if (typeof global !== "undefined" && global.structuredClone) {
    return [global.structuredClone, true];
  }
  if (typeof window !== "undefined" && window.structuredClone) {
    return [window.structuredClone, true];
  }
  return [(i) => i ? JSON.parse(JSON.stringify(i)) : i, false];
}
const _structuredClone = getStructuredClone();
const structuredClone = _structuredClone[0];
_structuredClone[1];
const STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}));
registerTldrawLibraryVersion(
  "@tldraw/utils",
  "3.13.1",
  "esm"
);
var es_array_at = {};
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis) return globalThis_1;
  hasRequiredGlobalThis = 1;
  var check = function(it) {
    return it && it.Math === Math && it;
  };
  globalThis_1 = // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof globalThis_1 == "object" && globalThis_1) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")();
  return globalThis_1;
}
var objectGetOwnPropertyDescriptor = {};
var fails;
var hasRequiredFails;
function requireFails() {
  if (hasRequiredFails) return fails;
  hasRequiredFails = 1;
  fails = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
  return fails;
}
var descriptors;
var hasRequiredDescriptors;
function requireDescriptors() {
  if (hasRequiredDescriptors) return descriptors;
  hasRequiredDescriptors = 1;
  var fails2 = requireFails();
  descriptors = !fails2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
  return descriptors;
}
var functionBindNative;
var hasRequiredFunctionBindNative;
function requireFunctionBindNative() {
  if (hasRequiredFunctionBindNative) return functionBindNative;
  hasRequiredFunctionBindNative = 1;
  var fails2 = requireFails();
  functionBindNative = !fails2(function() {
    var test = function() {
    }.bind();
    return typeof test != "function" || test.hasOwnProperty("prototype");
  });
  return functionBindNative;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var call2 = Function.prototype.call;
  functionCall = NATIVE_BIND ? call2.bind(call2) : function() {
    return call2.apply(call2, arguments);
  };
  return functionCall;
}
var objectPropertyIsEnumerable = {};
var hasRequiredObjectPropertyIsEnumerable;
function requireObjectPropertyIsEnumerable() {
  if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
  hasRequiredObjectPropertyIsEnumerable = 1;
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
    var descriptor = getOwnPropertyDescriptor(this, V2);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
  return objectPropertyIsEnumerable;
}
var createPropertyDescriptor;
var hasRequiredCreatePropertyDescriptor;
function requireCreatePropertyDescriptor() {
  if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
  hasRequiredCreatePropertyDescriptor = 1;
  createPropertyDescriptor = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  return createPropertyDescriptor;
}
var functionUncurryThis;
var hasRequiredFunctionUncurryThis;
function requireFunctionUncurryThis() {
  if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
  hasRequiredFunctionUncurryThis = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var call2 = FunctionPrototype.call;
  var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call2, call2);
  functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
      return call2.apply(fn, arguments);
    };
  };
  return functionUncurryThis;
}
var classofRaw;
var hasRequiredClassofRaw;
function requireClassofRaw() {
  if (hasRequiredClassofRaw) return classofRaw;
  hasRequiredClassofRaw = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = uncurryThis({}.toString);
  var stringSlice = uncurryThis("".slice);
  classofRaw = function(it) {
    return stringSlice(toString2(it), 8, -1);
  };
  return classofRaw;
}
var indexedObject;
var hasRequiredIndexedObject;
function requireIndexedObject() {
  if (hasRequiredIndexedObject) return indexedObject;
  hasRequiredIndexedObject = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var classof2 = requireClassofRaw();
  var $Object = Object;
  var split2 = uncurryThis("".split);
  indexedObject = fails2(function() {
    return !$Object("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof2(it) === "String" ? split2(it, "") : $Object(it);
  } : $Object;
  return indexedObject;
}
var isNullOrUndefined;
var hasRequiredIsNullOrUndefined;
function requireIsNullOrUndefined() {
  if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
  hasRequiredIsNullOrUndefined = 1;
  isNullOrUndefined = function(it) {
    return it === null || it === void 0;
  };
  return isNullOrUndefined;
}
var requireObjectCoercible;
var hasRequiredRequireObjectCoercible;
function requireRequireObjectCoercible() {
  if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
  hasRequiredRequireObjectCoercible = 1;
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var $TypeError = TypeError;
  requireObjectCoercible = function(it) {
    if (isNullOrUndefined2(it)) throw new $TypeError("Can't call method on " + it);
    return it;
  };
  return requireObjectCoercible;
}
var toIndexedObject;
var hasRequiredToIndexedObject;
function requireToIndexedObject() {
  if (hasRequiredToIndexedObject) return toIndexedObject;
  hasRequiredToIndexedObject = 1;
  var IndexedObject = requireIndexedObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  toIndexedObject = function(it) {
    return IndexedObject(requireObjectCoercible2(it));
  };
  return toIndexedObject;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var documentAll = typeof document == "object" && document.all;
  isCallable = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
  return isCallable;
}
var isObject;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject;
  hasRequiredIsObject = 1;
  var isCallable2 = requireIsCallable();
  isObject = function(it) {
    return typeof it == "object" ? it !== null : isCallable2(it);
  };
  return isObject;
}
var getBuiltIn;
var hasRequiredGetBuiltIn;
function requireGetBuiltIn() {
  if (hasRequiredGetBuiltIn) return getBuiltIn;
  hasRequiredGetBuiltIn = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var aFunction = function(argument) {
    return isCallable2(argument) ? argument : void 0;
  };
  getBuiltIn = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
  };
  return getBuiltIn;
}
var objectIsPrototypeOf;
var hasRequiredObjectIsPrototypeOf;
function requireObjectIsPrototypeOf() {
  if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
  hasRequiredObjectIsPrototypeOf = 1;
  var uncurryThis = requireFunctionUncurryThis();
  objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
  return objectIsPrototypeOf;
}
var environmentUserAgent;
var hasRequiredEnvironmentUserAgent;
function requireEnvironmentUserAgent() {
  if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
  hasRequiredEnvironmentUserAgent = 1;
  var globalThis2 = requireGlobalThis();
  var navigator2 = globalThis2.navigator;
  var userAgent = navigator2 && navigator2.userAgent;
  environmentUserAgent = userAgent ? String(userAgent) : "";
  return environmentUserAgent;
}
var environmentV8Version;
var hasRequiredEnvironmentV8Version;
function requireEnvironmentV8Version() {
  if (hasRequiredEnvironmentV8Version) return environmentV8Version;
  hasRequiredEnvironmentV8Version = 1;
  var globalThis2 = requireGlobalThis();
  var userAgent = requireEnvironmentUserAgent();
  var process2 = globalThis2.process;
  var Deno2 = globalThis2.Deno;
  var versions = process2 && process2.versions || Deno2 && Deno2.version;
  var v8 = versions && versions.v8;
  var match, version2;
  if (v8) {
    match = v8.split(".");
    version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version2 && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version2 = +match[1];
    }
  }
  environmentV8Version = version2;
  return environmentV8Version;
}
var symbolConstructorDetection;
var hasRequiredSymbolConstructorDetection;
function requireSymbolConstructorDetection() {
  if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
  hasRequiredSymbolConstructorDetection = 1;
  var V8_VERSION = requireEnvironmentV8Version();
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $String = globalThis2.String;
  symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
    var symbol = Symbol("symbol detection");
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  return symbolConstructorDetection;
}
var useSymbolAsUid;
var hasRequiredUseSymbolAsUid;
function requireUseSymbolAsUid() {
  if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
  hasRequiredUseSymbolAsUid = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  return useSymbolAsUid;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol;
  hasRequiredIsSymbol = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var isCallable2 = requireIsCallable();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var $Object = Object;
  isSymbol = USE_SYMBOL_AS_UID ? function(it) {
    return typeof it == "symbol";
  } : function(it) {
    var $Symbol = getBuiltIn2("Symbol");
    return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
  };
  return isSymbol;
}
var tryToString;
var hasRequiredTryToString;
function requireTryToString() {
  if (hasRequiredTryToString) return tryToString;
  hasRequiredTryToString = 1;
  var $String = String;
  tryToString = function(argument) {
    try {
      return $String(argument);
    } catch (error) {
      return "Object";
    }
  };
  return tryToString;
}
var aCallable;
var hasRequiredACallable;
function requireACallable() {
  if (hasRequiredACallable) return aCallable;
  hasRequiredACallable = 1;
  var isCallable2 = requireIsCallable();
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  aCallable = function(argument) {
    if (isCallable2(argument)) return argument;
    throw new $TypeError(tryToString2(argument) + " is not a function");
  };
  return aCallable;
}
var getMethod$1;
var hasRequiredGetMethod;
function requireGetMethod() {
  if (hasRequiredGetMethod) return getMethod$1;
  hasRequiredGetMethod = 1;
  var aCallable2 = requireACallable();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  getMethod$1 = function(V2, P) {
    var func = V2[P];
    return isNullOrUndefined2(func) ? void 0 : aCallable2(func);
  };
  return getMethod$1;
}
var ordinaryToPrimitive;
var hasRequiredOrdinaryToPrimitive;
function requireOrdinaryToPrimitive() {
  if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
  hasRequiredOrdinaryToPrimitive = 1;
  var call2 = requireFunctionCall();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var $TypeError = TypeError;
  ordinaryToPrimitive = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable2(fn = input.toString) && !isObject2(val = call2(fn, input))) return val;
    if (isCallable2(fn = input.valueOf) && !isObject2(val = call2(fn, input))) return val;
    if (pref !== "string" && isCallable2(fn = input.toString) && !isObject2(val = call2(fn, input))) return val;
    throw new $TypeError("Can't convert object to primitive value");
  };
  return ordinaryToPrimitive;
}
var sharedStore = { exports: {} };
var isPure;
var hasRequiredIsPure;
function requireIsPure() {
  if (hasRequiredIsPure) return isPure;
  hasRequiredIsPure = 1;
  isPure = false;
  return isPure;
}
var defineGlobalProperty;
var hasRequiredDefineGlobalProperty;
function requireDefineGlobalProperty() {
  if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
  hasRequiredDefineGlobalProperty = 1;
  var globalThis2 = requireGlobalThis();
  var defineProperty = Object.defineProperty;
  defineGlobalProperty = function(key, value) {
    try {
      defineProperty(globalThis2, key, { value, configurable: true, writable: true });
    } catch (error) {
      globalThis2[key] = value;
    }
    return value;
  };
  return defineGlobalProperty;
}
var hasRequiredSharedStore;
function requireSharedStore() {
  if (hasRequiredSharedStore) return sharedStore.exports;
  hasRequiredSharedStore = 1;
  var IS_PURE = requireIsPure();
  var globalThis2 = requireGlobalThis();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var SHARED = "__core-js_shared__";
  var store = sharedStore.exports = globalThis2[SHARED] || defineGlobalProperty2(SHARED, {});
  (store.versions || (store.versions = [])).push({
    version: "3.43.0",
    mode: IS_PURE ? "pure" : "global",
    copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.43.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  return sharedStore.exports;
}
var shared;
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1;
  var store = requireSharedStore();
  shared = function(key, value) {
    return store[key] || (store[key] = value || {});
  };
  return shared;
}
var toObject;
var hasRequiredToObject;
function requireToObject() {
  if (hasRequiredToObject) return toObject;
  hasRequiredToObject = 1;
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var $Object = Object;
  toObject = function(argument) {
    return $Object(requireObjectCoercible2(argument));
  };
  return toObject;
}
var hasOwnProperty_1;
var hasRequiredHasOwnProperty;
function requireHasOwnProperty() {
  if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
  hasRequiredHasOwnProperty = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
  hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
    return hasOwnProperty2(toObject2(it), key);
  };
  return hasOwnProperty_1;
}
var uid;
var hasRequiredUid;
function requireUid() {
  if (hasRequiredUid) return uid;
  hasRequiredUid = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var id = 0;
  var postfix = Math.random();
  var toString2 = uncurryThis(1.1.toString);
  uid = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
  };
  return uid;
}
var wellKnownSymbol;
var hasRequiredWellKnownSymbol;
function requireWellKnownSymbol() {
  if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
  hasRequiredWellKnownSymbol = 1;
  var globalThis2 = requireGlobalThis();
  var shared2 = requireShared();
  var hasOwn2 = requireHasOwnProperty();
  var uid2 = requireUid();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var Symbol2 = globalThis2.Symbol;
  var WellKnownSymbolsStore = shared2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
  wellKnownSymbol = function(name) {
    if (!hasOwn2(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn2(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  return wellKnownSymbol;
}
var toPrimitive;
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive) return toPrimitive;
  hasRequiredToPrimitive = 1;
  var call2 = requireFunctionCall();
  var isObject2 = requireIsObject();
  var isSymbol2 = requireIsSymbol();
  var getMethod2 = requireGetMethod();
  var ordinaryToPrimitive2 = requireOrdinaryToPrimitive();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var $TypeError = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
  toPrimitive = function(input, pref) {
    if (!isObject2(input) || isSymbol2(input)) return input;
    var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0) pref = "default";
      result = call2(exoticToPrim, input, pref);
      if (!isObject2(result) || isSymbol2(result)) return result;
      throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === void 0) pref = "number";
    return ordinaryToPrimitive2(input, pref);
  };
  return toPrimitive;
}
var toPropertyKey;
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey) return toPropertyKey;
  hasRequiredToPropertyKey = 1;
  var toPrimitive2 = requireToPrimitive();
  var isSymbol2 = requireIsSymbol();
  toPropertyKey = function(argument) {
    var key = toPrimitive2(argument, "string");
    return isSymbol2(key) ? key : key + "";
  };
  return toPropertyKey;
}
var documentCreateElement;
var hasRequiredDocumentCreateElement;
function requireDocumentCreateElement() {
  if (hasRequiredDocumentCreateElement) return documentCreateElement;
  hasRequiredDocumentCreateElement = 1;
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var document2 = globalThis2.document;
  var EXISTS = isObject2(document2) && isObject2(document2.createElement);
  documentCreateElement = function(it) {
    return EXISTS ? document2.createElement(it) : {};
  };
  return documentCreateElement;
}
var ie8DomDefine;
var hasRequiredIe8DomDefine;
function requireIe8DomDefine() {
  if (hasRequiredIe8DomDefine) return ie8DomDefine;
  hasRequiredIe8DomDefine = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  var createElement = requireDocumentCreateElement();
  ie8DomDefine = !DESCRIPTORS && !fails2(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  return ie8DomDefine;
}
var hasRequiredObjectGetOwnPropertyDescriptor;
function requireObjectGetOwnPropertyDescriptor() {
  if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
  hasRequiredObjectGetOwnPropertyDescriptor = 1;
  var DESCRIPTORS = requireDescriptors();
  var call2 = requireFunctionCall();
  var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var toIndexedObject2 = requireToIndexedObject();
  var toPropertyKey2 = requireToPropertyKey();
  var hasOwn2 = requireHasOwnProperty();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject2(O);
    P = toPropertyKey2(P);
    if (IE8_DOM_DEFINE) try {
      return $getOwnPropertyDescriptor(O, P);
    } catch (error) {
    }
    if (hasOwn2(O, P)) return createPropertyDescriptor2(!call2(propertyIsEnumerableModule.f, O, P), O[P]);
  };
  return objectGetOwnPropertyDescriptor;
}
var objectDefineProperty = {};
var v8PrototypeDefineBug;
var hasRequiredV8PrototypeDefineBug;
function requireV8PrototypeDefineBug() {
  if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
  hasRequiredV8PrototypeDefineBug = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  v8PrototypeDefineBug = DESCRIPTORS && fails2(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  return v8PrototypeDefineBug;
}
var anObject;
var hasRequiredAnObject;
function requireAnObject() {
  if (hasRequiredAnObject) return anObject;
  hasRequiredAnObject = 1;
  var isObject2 = requireIsObject();
  var $String = String;
  var $TypeError = TypeError;
  anObject = function(argument) {
    if (isObject2(argument)) return argument;
    throw new $TypeError($String(argument) + " is not an object");
  };
  return anObject;
}
var hasRequiredObjectDefineProperty;
function requireObjectDefineProperty() {
  if (hasRequiredObjectDefineProperty) return objectDefineProperty;
  hasRequiredObjectDefineProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var anObject2 = requireAnObject();
  var toPropertyKey2 = requireToPropertyKey();
  var $TypeError = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
    anObject2(O);
    P = toPropertyKey2(P);
    anObject2(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject2(O);
    P = toPropertyKey2(P);
    anObject2(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
    if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
    if ("value" in Attributes) O[P] = Attributes.value;
    return O;
  };
  return objectDefineProperty;
}
var createNonEnumerableProperty;
var hasRequiredCreateNonEnumerableProperty;
function requireCreateNonEnumerableProperty() {
  if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
  hasRequiredCreateNonEnumerableProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var definePropertyModule = requireObjectDefineProperty();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  createNonEnumerableProperty = DESCRIPTORS ? function(object2, key, value) {
    return definePropertyModule.f(object2, key, createPropertyDescriptor2(1, value));
  } : function(object2, key, value) {
    object2[key] = value;
    return object2;
  };
  return createNonEnumerableProperty;
}
var makeBuiltIn = { exports: {} };
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
  if (hasRequiredFunctionName) return functionName;
  hasRequiredFunctionName = 1;
  var DESCRIPTORS = requireDescriptors();
  var hasOwn2 = requireHasOwnProperty();
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn2(FunctionPrototype, "name");
  var PROPER = EXISTS && function something() {
  }.name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
  functionName = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
  return functionName;
}
var inspectSource;
var hasRequiredInspectSource;
function requireInspectSource() {
  if (hasRequiredInspectSource) return inspectSource;
  hasRequiredInspectSource = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var isCallable2 = requireIsCallable();
  var store = requireSharedStore();
  var functionToString = uncurryThis(Function.toString);
  if (!isCallable2(store.inspectSource)) {
    store.inspectSource = function(it) {
      return functionToString(it);
    };
  }
  inspectSource = store.inspectSource;
  return inspectSource;
}
var weakMapBasicDetection;
var hasRequiredWeakMapBasicDetection;
function requireWeakMapBasicDetection() {
  if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
  hasRequiredWeakMapBasicDetection = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var WeakMap2 = globalThis2.WeakMap;
  weakMapBasicDetection = isCallable2(WeakMap2) && /native code/.test(String(WeakMap2));
  return weakMapBasicDetection;
}
var sharedKey;
var hasRequiredSharedKey;
function requireSharedKey() {
  if (hasRequiredSharedKey) return sharedKey;
  hasRequiredSharedKey = 1;
  var shared2 = requireShared();
  var uid2 = requireUid();
  var keys2 = shared2("keys");
  sharedKey = function(key) {
    return keys2[key] || (keys2[key] = uid2(key));
  };
  return sharedKey;
}
var hiddenKeys;
var hasRequiredHiddenKeys;
function requireHiddenKeys() {
  if (hasRequiredHiddenKeys) return hiddenKeys;
  hasRequiredHiddenKeys = 1;
  hiddenKeys = {};
  return hiddenKeys;
}
var internalState;
var hasRequiredInternalState;
function requireInternalState() {
  if (hasRequiredInternalState) return internalState;
  hasRequiredInternalState = 1;
  var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var hasOwn2 = requireHasOwnProperty();
  var shared2 = requireSharedStore();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError2 = globalThis2.TypeError;
  var WeakMap2 = globalThis2.WeakMap;
  var set, get2, has2;
  var enforce = function(it) {
    return has2(it) ? get2(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject2(it) || (state = get2(it)).type !== TYPE) {
        throw new TypeError2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared2.state) {
    var store = shared2.state || (shared2.state = new WeakMap2());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get2 = function(it) {
      return store.get(it) || {};
    };
    has2 = function(it) {
      return store.has(it);
    };
  } else {
    var STATE = sharedKey2("state");
    hiddenKeys2[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn2(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty2(it, STATE, metadata);
      return metadata;
    };
    get2 = function(it) {
      return hasOwn2(it, STATE) ? it[STATE] : {};
    };
    has2 = function(it) {
      return hasOwn2(it, STATE);
    };
  }
  internalState = {
    set,
    get: get2,
    has: has2,
    enforce,
    getterFor
  };
  return internalState;
}
var hasRequiredMakeBuiltIn;
function requireMakeBuiltIn() {
  if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
  hasRequiredMakeBuiltIn = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var hasOwn2 = requireHasOwnProperty();
  var DESCRIPTORS = requireDescriptors();
  var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
  var inspectSource2 = requireInspectSource();
  var InternalStateModule = requireInternalState();
  var enforceInternalState = InternalStateModule.enforce;
  var getInternalState = InternalStateModule.get;
  var $String = String;
  var defineProperty = Object.defineProperty;
  var stringSlice = uncurryThis("".slice);
  var replace2 = uncurryThis("".replace);
  var join2 = uncurryThis([].join);
  var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails2(function() {
    return defineProperty(function() {
    }, "length", { value: 8 }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn$1 = makeBuiltIn.exports = function(value, name, options) {
    if (stringSlice($String(name), 0, 7) === "Symbol(") {
      name = "[" + replace2($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    }
    if (options && options.getter) name = "get " + name;
    if (options && options.setter) name = "set " + name;
    if (!hasOwn2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
      if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
      else value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn2(options, "arity") && value.length !== options.arity) {
      defineProperty(value, "length", { value: options.arity });
    }
    try {
      if (options && hasOwn2(options, "constructor") && options.constructor) {
        if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
      } else if (value.prototype) value.prototype = void 0;
    } catch (error) {
    }
    var state = enforceInternalState(value);
    if (!hasOwn2(state, "source")) {
      state.source = join2(TEMPLATE, typeof name == "string" ? name : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn$1(function toString2() {
    return isCallable2(this) && getInternalState(this).source || inspectSource2(this);
  }, "toString");
  return makeBuiltIn.exports;
}
var defineBuiltIn;
var hasRequiredDefineBuiltIn;
function requireDefineBuiltIn() {
  if (hasRequiredDefineBuiltIn) return defineBuiltIn;
  hasRequiredDefineBuiltIn = 1;
  var isCallable2 = requireIsCallable();
  var definePropertyModule = requireObjectDefineProperty();
  var makeBuiltIn2 = requireMakeBuiltIn();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  defineBuiltIn = function(O, key, value, options) {
    if (!options) options = {};
    var simple = options.enumerable;
    var name = options.name !== void 0 ? options.name : key;
    if (isCallable2(value)) makeBuiltIn2(value, name, options);
    if (options.global) {
      if (simple) O[key] = value;
      else defineGlobalProperty2(key, value);
    } else {
      try {
        if (!options.unsafe) delete O[key];
        else if (O[key]) simple = true;
      } catch (error) {
      }
      if (simple) O[key] = value;
      else definePropertyModule.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
    }
    return O;
  };
  return defineBuiltIn;
}
var objectGetOwnPropertyNames = {};
var mathTrunc;
var hasRequiredMathTrunc;
function requireMathTrunc() {
  if (hasRequiredMathTrunc) return mathTrunc;
  hasRequiredMathTrunc = 1;
  var ceil = Math.ceil;
  var floor2 = Math.floor;
  mathTrunc = Math.trunc || function trunc(x) {
    var n2 = +x;
    return (n2 > 0 ? floor2 : ceil)(n2);
  };
  return mathTrunc;
}
var toIntegerOrInfinity;
var hasRequiredToIntegerOrInfinity;
function requireToIntegerOrInfinity() {
  if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
  hasRequiredToIntegerOrInfinity = 1;
  var trunc = requireMathTrunc();
  toIntegerOrInfinity = function(argument) {
    var number2 = +argument;
    return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
  };
  return toIntegerOrInfinity;
}
var toAbsoluteIndex;
var hasRequiredToAbsoluteIndex;
function requireToAbsoluteIndex() {
  if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
  hasRequiredToAbsoluteIndex = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var max2 = Math.max;
  var min2 = Math.min;
  toAbsoluteIndex = function(index2, length) {
    var integer2 = toIntegerOrInfinity2(index2);
    return integer2 < 0 ? max2(integer2 + length, 0) : min2(integer2, length);
  };
  return toAbsoluteIndex;
}
var toLength;
var hasRequiredToLength;
function requireToLength() {
  if (hasRequiredToLength) return toLength;
  hasRequiredToLength = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var min2 = Math.min;
  toLength = function(argument) {
    var len = toIntegerOrInfinity2(argument);
    return len > 0 ? min2(len, 9007199254740991) : 0;
  };
  return toLength;
}
var lengthOfArrayLike;
var hasRequiredLengthOfArrayLike;
function requireLengthOfArrayLike() {
  if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
  hasRequiredLengthOfArrayLike = 1;
  var toLength2 = requireToLength();
  lengthOfArrayLike = function(obj) {
    return toLength2(obj.length);
  };
  return lengthOfArrayLike;
}
var arrayIncludes;
var hasRequiredArrayIncludes;
function requireArrayIncludes() {
  if (hasRequiredArrayIncludes) return arrayIncludes;
  hasRequiredArrayIncludes = 1;
  var toIndexedObject2 = requireToIndexedObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject2($this);
      var length = lengthOfArrayLike2(O);
      if (length === 0) return !IS_INCLUDES && -1;
      var index2 = toAbsoluteIndex2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el) while (length > index2) {
        value = O[index2++];
        if (value !== value) return true;
      }
      else for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };
  return arrayIncludes;
}
var objectKeysInternal;
var hasRequiredObjectKeysInternal;
function requireObjectKeysInternal() {
  if (hasRequiredObjectKeysInternal) return objectKeysInternal;
  hasRequiredObjectKeysInternal = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var hasOwn2 = requireHasOwnProperty();
  var toIndexedObject2 = requireToIndexedObject();
  var indexOf = requireArrayIncludes().indexOf;
  var hiddenKeys2 = requireHiddenKeys();
  var push2 = uncurryThis([].push);
  objectKeysInternal = function(object2, names) {
    var O = toIndexedObject2(object2);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwn2(hiddenKeys2, key) && hasOwn2(O, key) && push2(result, key);
    while (names.length > i) if (hasOwn2(O, key = names[i++])) {
      ~indexOf(result, key) || push2(result, key);
    }
    return result;
  };
  return objectKeysInternal;
}
var enumBugKeys;
var hasRequiredEnumBugKeys;
function requireEnumBugKeys() {
  if (hasRequiredEnumBugKeys) return enumBugKeys;
  hasRequiredEnumBugKeys = 1;
  enumBugKeys = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  return enumBugKeys;
}
var hasRequiredObjectGetOwnPropertyNames;
function requireObjectGetOwnPropertyNames() {
  if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
  hasRequiredObjectGetOwnPropertyNames = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys2);
  };
  return objectGetOwnPropertyNames;
}
var objectGetOwnPropertySymbols = {};
var hasRequiredObjectGetOwnPropertySymbols;
function requireObjectGetOwnPropertySymbols() {
  if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
  hasRequiredObjectGetOwnPropertySymbols = 1;
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  return objectGetOwnPropertySymbols;
}
var ownKeys$1;
var hasRequiredOwnKeys;
function requireOwnKeys() {
  if (hasRequiredOwnKeys) return ownKeys$1;
  hasRequiredOwnKeys = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis = requireFunctionUncurryThis();
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var anObject2 = requireAnObject();
  var concat = uncurryThis([].concat);
  ownKeys$1 = getBuiltIn2("Reflect", "ownKeys") || function ownKeys2(it) {
    var keys2 = getOwnPropertyNamesModule.f(anObject2(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
  };
  return ownKeys$1;
}
var copyConstructorProperties;
var hasRequiredCopyConstructorProperties;
function requireCopyConstructorProperties() {
  if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
  hasRequiredCopyConstructorProperties = 1;
  var hasOwn2 = requireHasOwnProperty();
  var ownKeys2 = requireOwnKeys();
  var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
  var definePropertyModule = requireObjectDefineProperty();
  copyConstructorProperties = function(target, source, exceptions) {
    var keys2 = ownKeys2(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    }
  };
  return copyConstructorProperties;
}
var isForced_1;
var hasRequiredIsForced;
function requireIsForced() {
  if (hasRequiredIsForced) return isForced_1;
  hasRequiredIsForced = 1;
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var replacement = /#|\.prototype\./;
  var isForced = function(feature, detection) {
    var value = data[normalize2(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails2(detection) : !!detection;
  };
  var normalize2 = isForced.normalize = function(string2) {
    return String(string2).replace(replacement, ".").toLowerCase();
  };
  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = "N";
  var POLYFILL = isForced.POLYFILL = "P";
  isForced_1 = isForced;
  return isForced_1;
}
var _export;
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  var globalThis2 = requireGlobalThis();
  var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var copyConstructorProperties2 = requireCopyConstructorProperties();
  var isForced = requireIsForced();
  _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = globalThis2;
    } else if (STATIC) {
      target = globalThis2[TARGET] || defineGlobalProperty2(TARGET, {});
    } else {
      target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties2(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty2(sourceProperty, "sham", true);
      }
      defineBuiltIn2(target, key, sourceProperty, options);
    }
  };
  return _export;
}
var objectDefineProperties = {};
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  objectKeys = Object.keys || function keys2(O) {
    return internalObjectKeys(O, enumBugKeys2);
  };
  return objectKeys;
}
var hasRequiredObjectDefineProperties;
function requireObjectDefineProperties() {
  if (hasRequiredObjectDefineProperties) return objectDefineProperties;
  hasRequiredObjectDefineProperties = 1;
  var DESCRIPTORS = requireDescriptors();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var definePropertyModule = requireObjectDefineProperty();
  var anObject2 = requireAnObject();
  var toIndexedObject2 = requireToIndexedObject();
  var objectKeys2 = requireObjectKeys();
  objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject2(O);
    var props = toIndexedObject2(Properties);
    var keys2 = objectKeys2(Properties);
    var length = keys2.length;
    var index2 = 0;
    var key;
    while (length > index2) definePropertyModule.f(O, key = keys2[index2++], props[key]);
    return O;
  };
  return objectDefineProperties;
}
var html;
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html;
  hasRequiredHtml = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  html = getBuiltIn2("document", "documentElement");
  return html;
}
var objectCreate;
var hasRequiredObjectCreate;
function requireObjectCreate() {
  if (hasRequiredObjectCreate) return objectCreate;
  hasRequiredObjectCreate = 1;
  var anObject2 = requireAnObject();
  var definePropertiesModule = requireObjectDefineProperties();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = requireHiddenKeys();
  var html2 = requireHtml();
  var documentCreateElement2 = requireDocumentCreateElement();
  var sharedKey2 = requireSharedKey();
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey2("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement2("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html2.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys2.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys2[length]];
    return NullProtoObject();
  };
  hiddenKeys2[IE_PROTO] = true;
  objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject2(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
  };
  return objectCreate;
}
var addToUnscopables;
var hasRequiredAddToUnscopables;
function requireAddToUnscopables() {
  if (hasRequiredAddToUnscopables) return addToUnscopables;
  hasRequiredAddToUnscopables = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var create = requireObjectCreate();
  var defineProperty = requireObjectDefineProperty().f;
  var UNSCOPABLES = wellKnownSymbol2("unscopables");
  var ArrayPrototype = Array.prototype;
  if (ArrayPrototype[UNSCOPABLES] === void 0) {
    defineProperty(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create(null)
    });
  }
  addToUnscopables = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };
  return addToUnscopables;
}
var hasRequiredEs_array_at;
function requireEs_array_at() {
  if (hasRequiredEs_array_at) return es_array_at;
  hasRequiredEs_array_at = 1;
  var $ = require_export();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var addToUnscopables2 = requireAddToUnscopables();
  $({ target: "Array", proto: true }, {
    at: function at2(index2) {
      var O = toObject2(this);
      var len = lengthOfArrayLike2(O);
      var relativeIndex = toIntegerOrInfinity2(index2);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? void 0 : O[k];
    }
  });
  addToUnscopables2("at");
  return es_array_at;
}
var entryUnbind;
var hasRequiredEntryUnbind;
function requireEntryUnbind() {
  if (hasRequiredEntryUnbind) return entryUnbind;
  hasRequiredEntryUnbind = 1;
  var globalThis2 = requireGlobalThis();
  var uncurryThis = requireFunctionUncurryThis();
  entryUnbind = function(CONSTRUCTOR, METHOD) {
    return uncurryThis(globalThis2[CONSTRUCTOR].prototype[METHOD]);
  };
  return entryUnbind;
}
var at$3;
var hasRequiredAt$3;
function requireAt$3() {
  if (hasRequiredAt$3) return at$3;
  hasRequiredAt$3 = 1;
  requireEs_array_at();
  var entryUnbind2 = requireEntryUnbind();
  at$3 = entryUnbind2("Array", "at");
  return at$3;
}
var at$2;
var hasRequiredAt$2;
function requireAt$2() {
  if (hasRequiredAt$2) return at$2;
  hasRequiredAt$2 = 1;
  var parent = requireAt$3();
  at$2 = parent;
  return at$2;
}
requireAt$2();
var es_array_flatMap = {};
var isArray;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray;
  hasRequiredIsArray = 1;
  var classof2 = requireClassofRaw();
  isArray = Array.isArray || function isArray2(argument) {
    return classof2(argument) === "Array";
  };
  return isArray;
}
var doesNotExceedSafeInteger;
var hasRequiredDoesNotExceedSafeInteger;
function requireDoesNotExceedSafeInteger() {
  if (hasRequiredDoesNotExceedSafeInteger) return doesNotExceedSafeInteger;
  hasRequiredDoesNotExceedSafeInteger = 1;
  var $TypeError = TypeError;
  var MAX_SAFE_INTEGER = 9007199254740991;
  doesNotExceedSafeInteger = function(it) {
    if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
    return it;
  };
  return doesNotExceedSafeInteger;
}
var functionUncurryThisClause;
var hasRequiredFunctionUncurryThisClause;
function requireFunctionUncurryThisClause() {
  if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
  hasRequiredFunctionUncurryThisClause = 1;
  var classofRaw2 = requireClassofRaw();
  var uncurryThis = requireFunctionUncurryThis();
  functionUncurryThisClause = function(fn) {
    if (classofRaw2(fn) === "Function") return uncurryThis(fn);
  };
  return functionUncurryThisClause;
}
var functionBindContext;
var hasRequiredFunctionBindContext;
function requireFunctionBindContext() {
  if (hasRequiredFunctionBindContext) return functionBindContext;
  hasRequiredFunctionBindContext = 1;
  var uncurryThis = requireFunctionUncurryThisClause();
  var aCallable2 = requireACallable();
  var NATIVE_BIND = requireFunctionBindNative();
  var bind2 = uncurryThis(uncurryThis.bind);
  functionBindContext = function(fn, that) {
    aCallable2(fn);
    return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
  return functionBindContext;
}
var flattenIntoArray_1;
var hasRequiredFlattenIntoArray;
function requireFlattenIntoArray() {
  if (hasRequiredFlattenIntoArray) return flattenIntoArray_1;
  hasRequiredFlattenIntoArray = 1;
  var isArray2 = requireIsArray();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var doesNotExceedSafeInteger2 = requireDoesNotExceedSafeInteger();
  var bind2 = requireFunctionBindContext();
  var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? bind2(mapper, thisArg) : false;
    var element, elementLen;
    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
        if (depth > 0 && isArray2(element)) {
          elementLen = lengthOfArrayLike2(element);
          targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
        } else {
          doesNotExceedSafeInteger2(targetIndex + 1);
          target[targetIndex] = element;
        }
        targetIndex++;
      }
      sourceIndex++;
    }
    return targetIndex;
  };
  flattenIntoArray_1 = flattenIntoArray;
  return flattenIntoArray_1;
}
var toStringTagSupport;
var hasRequiredToStringTagSupport;
function requireToStringTagSupport() {
  if (hasRequiredToStringTagSupport) return toStringTagSupport;
  hasRequiredToStringTagSupport = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var test = {};
  test[TO_STRING_TAG] = "z";
  toStringTagSupport = String(test) === "[object z]";
  return toStringTagSupport;
}
var classof;
var hasRequiredClassof;
function requireClassof() {
  if (hasRequiredClassof) return classof;
  hasRequiredClassof = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var isCallable2 = requireIsCallable();
  var classofRaw2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var $Object = Object;
  var CORRECT_ARGUMENTS = classofRaw2(/* @__PURE__ */ function() {
    return arguments;
  }()) === "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error) {
    }
  };
  classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O) : (result = classofRaw2(O)) === "Object" && isCallable2(O.callee) ? "Arguments" : result;
  };
  return classof;
}
var isConstructor;
var hasRequiredIsConstructor;
function requireIsConstructor() {
  if (hasRequiredIsConstructor) return isConstructor;
  hasRequiredIsConstructor = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassof();
  var getBuiltIn2 = requireGetBuiltIn();
  var inspectSource2 = requireInspectSource();
  var noop3 = function() {
  };
  var construct = getBuiltIn2("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.test(noop3);
  var isConstructorModern = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    try {
      construct(noop3, [], argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    switch (classof2(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource2(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  isConstructor = !construct || fails2(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
  return isConstructor;
}
var arraySpeciesConstructor;
var hasRequiredArraySpeciesConstructor;
function requireArraySpeciesConstructor() {
  if (hasRequiredArraySpeciesConstructor) return arraySpeciesConstructor;
  hasRequiredArraySpeciesConstructor = 1;
  var isArray2 = requireIsArray();
  var isConstructor2 = requireIsConstructor();
  var isObject2 = requireIsObject();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var SPECIES = wellKnownSymbol2("species");
  var $Array = Array;
  arraySpeciesConstructor = function(originalArray) {
    var C;
    if (isArray2(originalArray)) {
      C = originalArray.constructor;
      if (isConstructor2(C) && (C === $Array || isArray2(C.prototype))) C = void 0;
      else if (isObject2(C)) {
        C = C[SPECIES];
        if (C === null) C = void 0;
      }
    }
    return C === void 0 ? $Array : C;
  };
  return arraySpeciesConstructor;
}
var arraySpeciesCreate;
var hasRequiredArraySpeciesCreate;
function requireArraySpeciesCreate() {
  if (hasRequiredArraySpeciesCreate) return arraySpeciesCreate;
  hasRequiredArraySpeciesCreate = 1;
  var arraySpeciesConstructor2 = requireArraySpeciesConstructor();
  arraySpeciesCreate = function(originalArray, length) {
    return new (arraySpeciesConstructor2(originalArray))(length === 0 ? 0 : length);
  };
  return arraySpeciesCreate;
}
var hasRequiredEs_array_flatMap;
function requireEs_array_flatMap() {
  if (hasRequiredEs_array_flatMap) return es_array_flatMap;
  hasRequiredEs_array_flatMap = 1;
  var $ = require_export();
  var flattenIntoArray = requireFlattenIntoArray();
  var aCallable2 = requireACallable();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  $({ target: "Array", proto: true }, {
    flatMap: function flatMap2(callbackfn) {
      var O = toObject2(this);
      var sourceLen = lengthOfArrayLike2(O);
      var A;
      aCallable2(callbackfn);
      A = arraySpeciesCreate2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      return A;
    }
  });
  return es_array_flatMap;
}
var es_array_unscopables_flatMap = {};
var hasRequiredEs_array_unscopables_flatMap;
function requireEs_array_unscopables_flatMap() {
  if (hasRequiredEs_array_unscopables_flatMap) return es_array_unscopables_flatMap;
  hasRequiredEs_array_unscopables_flatMap = 1;
  var addToUnscopables2 = requireAddToUnscopables();
  addToUnscopables2("flatMap");
  return es_array_unscopables_flatMap;
}
var flatMap$1;
var hasRequiredFlatMap$1;
function requireFlatMap$1() {
  if (hasRequiredFlatMap$1) return flatMap$1;
  hasRequiredFlatMap$1 = 1;
  requireEs_array_flatMap();
  requireEs_array_unscopables_flatMap();
  var entryUnbind2 = requireEntryUnbind();
  flatMap$1 = entryUnbind2("Array", "flatMap");
  return flatMap$1;
}
var flatMap;
var hasRequiredFlatMap;
function requireFlatMap() {
  if (hasRequiredFlatMap) return flatMap;
  hasRequiredFlatMap = 1;
  var parent = requireFlatMap$1();
  flatMap = parent;
  return flatMap;
}
requireFlatMap();
var es_array_flat = {};
var hasRequiredEs_array_flat;
function requireEs_array_flat() {
  if (hasRequiredEs_array_flat) return es_array_flat;
  hasRequiredEs_array_flat = 1;
  var $ = require_export();
  var flattenIntoArray = requireFlattenIntoArray();
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  $({ target: "Array", proto: true }, {
    flat: function flat2() {
      var depthArg = arguments.length ? arguments[0] : void 0;
      var O = toObject2(this);
      var sourceLen = lengthOfArrayLike2(O);
      var A = arraySpeciesCreate2(O, 0);
      A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity2(depthArg));
      return A;
    }
  });
  return es_array_flat;
}
var es_array_unscopables_flat = {};
var hasRequiredEs_array_unscopables_flat;
function requireEs_array_unscopables_flat() {
  if (hasRequiredEs_array_unscopables_flat) return es_array_unscopables_flat;
  hasRequiredEs_array_unscopables_flat = 1;
  var addToUnscopables2 = requireAddToUnscopables();
  addToUnscopables2("flat");
  return es_array_unscopables_flat;
}
var flat$1;
var hasRequiredFlat$1;
function requireFlat$1() {
  if (hasRequiredFlat$1) return flat$1;
  hasRequiredFlat$1 = 1;
  requireEs_array_flat();
  requireEs_array_unscopables_flat();
  var entryUnbind2 = requireEntryUnbind();
  flat$1 = entryUnbind2("Array", "flat");
  return flat$1;
}
var flat;
var hasRequiredFlat;
function requireFlat() {
  if (hasRequiredFlat) return flat;
  hasRequiredFlat = 1;
  var parent = requireFlat$1();
  flat = parent;
  return flat;
}
requireFlat();
var es_string_atAlternative = {};
var toString;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString;
  hasRequiredToString = 1;
  var classof2 = requireClassof();
  var $String = String;
  toString = function(argument) {
    if (classof2(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
  };
  return toString;
}
var hasRequiredEs_string_atAlternative;
function requireEs_string_atAlternative() {
  if (hasRequiredEs_string_atAlternative) return es_string_atAlternative;
  hasRequiredEs_string_atAlternative = 1;
  var $ = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var fails2 = requireFails();
  var charAt = uncurryThis("".charAt);
  var FORCED = fails2(function() {
    return "𠮷".at(-2) !== "\uD842";
  });
  $({ target: "String", proto: true, forced: FORCED }, {
    at: function at2(index2) {
      var S = toString2(requireObjectCoercible2(this));
      var len = S.length;
      var relativeIndex = toIntegerOrInfinity2(index2);
      var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
      return k < 0 || k >= len ? void 0 : charAt(S, k);
    }
  });
  return es_string_atAlternative;
}
var at$1;
var hasRequiredAt$1;
function requireAt$1() {
  if (hasRequiredAt$1) return at$1;
  hasRequiredAt$1 = 1;
  requireEs_string_atAlternative();
  var entryUnbind2 = requireEntryUnbind();
  at$1 = entryUnbind2("String", "at");
  return at$1;
}
var at;
var hasRequiredAt;
function requireAt() {
  if (hasRequiredAt) return at;
  hasRequiredAt = 1;
  var parent = requireAt$1();
  at = parent;
  return at;
}
requireAt();
var es_regexp_exec = {};
var regexpFlags;
var hasRequiredRegexpFlags;
function requireRegexpFlags() {
  if (hasRequiredRegexpFlags) return regexpFlags;
  hasRequiredRegexpFlags = 1;
  var anObject2 = requireAnObject();
  regexpFlags = function() {
    var that = anObject2(this);
    var result = "";
    if (that.hasIndices) result += "d";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.unicodeSets) result += "v";
    if (that.sticky) result += "y";
    return result;
  };
  return regexpFlags;
}
var regexpStickyHelpers;
var hasRequiredRegexpStickyHelpers;
function requireRegexpStickyHelpers() {
  if (hasRequiredRegexpStickyHelpers) return regexpStickyHelpers;
  hasRequiredRegexpStickyHelpers = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  var UNSUPPORTED_Y = fails2(function() {
    var re = $RegExp("a", "y");
    re.lastIndex = 2;
    return re.exec("abcd") !== null;
  });
  var MISSED_STICKY = UNSUPPORTED_Y || fails2(function() {
    return !$RegExp("a", "y").sticky;
  });
  var BROKEN_CARET = UNSUPPORTED_Y || fails2(function() {
    var re = $RegExp("^r", "gy");
    re.lastIndex = 2;
    return re.exec("str") !== null;
  });
  regexpStickyHelpers = {
    BROKEN_CARET,
    MISSED_STICKY,
    UNSUPPORTED_Y
  };
  return regexpStickyHelpers;
}
var regexpUnsupportedDotAll;
var hasRequiredRegexpUnsupportedDotAll;
function requireRegexpUnsupportedDotAll() {
  if (hasRequiredRegexpUnsupportedDotAll) return regexpUnsupportedDotAll;
  hasRequiredRegexpUnsupportedDotAll = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  regexpUnsupportedDotAll = fails2(function() {
    var re = $RegExp(".", "s");
    return !(re.dotAll && re.test("\n") && re.flags === "s");
  });
  return regexpUnsupportedDotAll;
}
var regexpUnsupportedNcg;
var hasRequiredRegexpUnsupportedNcg;
function requireRegexpUnsupportedNcg() {
  if (hasRequiredRegexpUnsupportedNcg) return regexpUnsupportedNcg;
  hasRequiredRegexpUnsupportedNcg = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  regexpUnsupportedNcg = fails2(function() {
    var re = $RegExp("(?<a>b)", "g");
    return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
  });
  return regexpUnsupportedNcg;
}
var regexpExec;
var hasRequiredRegexpExec;
function requireRegexpExec() {
  if (hasRequiredRegexpExec) return regexpExec;
  hasRequiredRegexpExec = 1;
  var call2 = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var toString2 = requireToString();
  var regexpFlags2 = requireRegexpFlags();
  var stickyHelpers = requireRegexpStickyHelpers();
  var shared2 = requireShared();
  var create = requireObjectCreate();
  var getInternalState = requireInternalState().get;
  var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
  var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();
  var nativeReplace = shared2("native-string-replace", String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt = uncurryThis("".charAt);
  var indexOf = uncurryThis("".indexOf);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var UPDATES_LAST_INDEX_WRONG = function() {
    var re1 = /a/;
    var re2 = /b*/g;
    call2(nativeExec, re1, "a");
    call2(nativeExec, re2, "a");
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  }();
  var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
  var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
  if (PATCH) {
    patchedExec = function exec(string2) {
      var re = this;
      var state = getInternalState(re);
      var str2 = toString2(string2);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i, object2, group;
      if (raw) {
        raw.lastIndex = re.lastIndex;
        result = call2(patchedExec, raw, str2);
        re.lastIndex = raw.lastIndex;
        return result;
      }
      var groups = state.groups;
      var sticky = UNSUPPORTED_Y && re.sticky;
      var flags = call2(regexpFlags2, re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str2;
      if (sticky) {
        flags = replace2(flags, "y", "");
        if (indexOf(flags, "g") === -1) {
          flags += "g";
        }
        strCopy = stringSlice(str2, re.lastIndex);
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str2, re.lastIndex - 1) !== "\n")) {
          source = "(?: " + source + ")";
          strCopy = " " + strCopy;
          charsAdded++;
        }
        reCopy = new RegExp("^(?:" + source + ")", flags);
      }
      if (NPCG_INCLUDED) {
        reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
      match = call2(nativeExec, sticky ? reCopy : re, strCopy);
      if (sticky) {
        if (match) {
          match.input = stringSlice(match.input, charsAdded);
          match[0] = stringSlice(match[0], charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        call2(nativeReplace, match[0], reCopy, function() {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === void 0) match[i] = void 0;
          }
        });
      }
      if (match && groups) {
        match.groups = object2 = create(null);
        for (i = 0; i < groups.length; i++) {
          group = groups[i];
          object2[group[0]] = match[group[1]];
        }
      }
      return match;
    };
  }
  regexpExec = patchedExec;
  return regexpExec;
}
var hasRequiredEs_regexp_exec;
function requireEs_regexp_exec() {
  if (hasRequiredEs_regexp_exec) return es_regexp_exec;
  hasRequiredEs_regexp_exec = 1;
  var $ = require_export();
  var exec = requireRegexpExec();
  $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
    exec
  });
  return es_regexp_exec;
}
var es_string_replace = {};
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var apply2 = FunctionPrototype.apply;
  var call2 = FunctionPrototype.call;
  functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call2.bind(apply2) : function() {
    return call2.apply(apply2, arguments);
  });
  return functionApply;
}
var fixRegexpWellKnownSymbolLogic;
var hasRequiredFixRegexpWellKnownSymbolLogic;
function requireFixRegexpWellKnownSymbolLogic() {
  if (hasRequiredFixRegexpWellKnownSymbolLogic) return fixRegexpWellKnownSymbolLogic;
  hasRequiredFixRegexpWellKnownSymbolLogic = 1;
  requireEs_regexp_exec();
  var call2 = requireFunctionCall();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var regexpExec2 = requireRegexpExec();
  var fails2 = requireFails();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var SPECIES = wellKnownSymbol2("species");
  var RegExpPrototype = RegExp.prototype;
  fixRegexpWellKnownSymbolLogic = function(KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol2(KEY);
    var DELEGATES_TO_SYMBOL = !fails2(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ""[KEY](O) !== 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails2(function() {
      var execCalled = false;
      var re = /a/;
      if (KEY === "split") {
        re = {};
        re.constructor = {};
        re.constructor[SPECIES] = function() {
          return re;
        };
        re.flags = "";
        re[SYMBOL] = /./[SYMBOL];
      }
      re.exec = function() {
        execCalled = true;
        return null;
      };
      re[SYMBOL]("");
      return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str2, arg2, forceStringMethod) {
        var $exec = regexp.exec;
        if ($exec === regexpExec2 || $exec === RegExpPrototype.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            return { done: true, value: call2(nativeRegExpMethod, regexp, str2, arg2) };
          }
          return { done: true, value: call2(nativeMethod, str2, regexp, arg2) };
        }
        return { done: false };
      });
      defineBuiltIn2(String.prototype, KEY, methods[0]);
      defineBuiltIn2(RegExpPrototype, SYMBOL, methods[1]);
    }
    if (SHAM) createNonEnumerableProperty2(RegExpPrototype[SYMBOL], "sham", true);
  };
  return fixRegexpWellKnownSymbolLogic;
}
var stringMultibyte;
var hasRequiredStringMultibyte;
function requireStringMultibyte() {
  if (hasRequiredStringMultibyte) return stringMultibyte;
  hasRequiredStringMultibyte = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var charAt = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var stringSlice = uncurryThis("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = toString2(requireObjectCoercible2($this));
      var position = toIntegerOrInfinity2(pos);
      var size2 = S.length;
      var first2, second;
      if (position < 0 || position >= size2) return CONVERT_TO_STRING ? "" : void 0;
      first2 = charCodeAt(S, position);
      return first2 < 55296 || first2 > 56319 || position + 1 === size2 || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first2 : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };
  return stringMultibyte;
}
var advanceStringIndex;
var hasRequiredAdvanceStringIndex;
function requireAdvanceStringIndex() {
  if (hasRequiredAdvanceStringIndex) return advanceStringIndex;
  hasRequiredAdvanceStringIndex = 1;
  var charAt = requireStringMultibyte().charAt;
  advanceStringIndex = function(S, index2, unicode) {
    return index2 + (unicode ? charAt(S, index2).length : 1);
  };
  return advanceStringIndex;
}
var getSubstitution;
var hasRequiredGetSubstitution;
function requireGetSubstitution() {
  if (hasRequiredGetSubstitution) return getSubstitution;
  hasRequiredGetSubstitution = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var floor2 = Math.floor;
  var charAt = uncurryThis("".charAt);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
  getSubstitution = function(matched, str2, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== void 0) {
      namedCaptures = toObject2(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace2(replacement, symbols, function(match, ch) {
      var capture;
      switch (charAt(ch, 0)) {
        case "$":
          return "$";
        case "&":
          return matched;
        case "`":
          return stringSlice(str2, 0, position);
        case "'":
          return stringSlice(str2, tailPos);
        case "<":
          capture = namedCaptures[stringSlice(ch, 1, -1)];
          break;
        default:
          var n2 = +ch;
          if (n2 === 0) return match;
          if (n2 > m) {
            var f = floor2(n2 / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
            return match;
          }
          capture = captures[n2 - 1];
      }
      return capture === void 0 ? "" : capture;
    });
  };
  return getSubstitution;
}
var regexpFlagsDetection;
var hasRequiredRegexpFlagsDetection;
function requireRegexpFlagsDetection() {
  if (hasRequiredRegexpFlagsDetection) return regexpFlagsDetection;
  hasRequiredRegexpFlagsDetection = 1;
  var globalThis2 = requireGlobalThis();
  var fails2 = requireFails();
  var RegExp2 = globalThis2.RegExp;
  var FLAGS_GETTER_IS_CORRECT = !fails2(function() {
    var INDICES_SUPPORT = true;
    try {
      RegExp2(".", "d");
    } catch (error) {
      INDICES_SUPPORT = false;
    }
    var O = {};
    var calls = "";
    var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
    var addGetter = function(key2, chr) {
      Object.defineProperty(O, key2, { get: function() {
        calls += chr;
        return true;
      } });
    };
    var pairs = {
      dotAll: "s",
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      sticky: "y"
    };
    if (INDICES_SUPPORT) pairs.hasIndices = "d";
    for (var key in pairs) addGetter(key, pairs[key]);
    var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O);
    return result !== expected || calls !== expected;
  });
  regexpFlagsDetection = { correct: FLAGS_GETTER_IS_CORRECT };
  return regexpFlagsDetection;
}
var regexpGetFlags;
var hasRequiredRegexpGetFlags;
function requireRegexpGetFlags() {
  if (hasRequiredRegexpGetFlags) return regexpGetFlags;
  hasRequiredRegexpGetFlags = 1;
  var call2 = requireFunctionCall();
  var hasOwn2 = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var regExpFlagsDetection = requireRegexpFlagsDetection();
  var regExpFlagsGetterImplementation = requireRegexpFlags();
  var RegExpPrototype = RegExp.prototype;
  regexpGetFlags = regExpFlagsDetection.correct ? function(it) {
    return it.flags;
  } : function(it) {
    return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn2(it, "flags") ? call2(regExpFlagsGetterImplementation, it) : it.flags;
  };
  return regexpGetFlags;
}
var regexpExecAbstract;
var hasRequiredRegexpExecAbstract;
function requireRegexpExecAbstract() {
  if (hasRequiredRegexpExecAbstract) return regexpExecAbstract;
  hasRequiredRegexpExecAbstract = 1;
  var call2 = requireFunctionCall();
  var anObject2 = requireAnObject();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassofRaw();
  var regexpExec2 = requireRegexpExec();
  var $TypeError = TypeError;
  regexpExecAbstract = function(R, S) {
    var exec = R.exec;
    if (isCallable2(exec)) {
      var result = call2(exec, R, S);
      if (result !== null) anObject2(result);
      return result;
    }
    if (classof2(R) === "RegExp") return call2(regexpExec2, R, S);
    throw new $TypeError("RegExp#exec called on incompatible receiver");
  };
  return regexpExecAbstract;
}
var hasRequiredEs_string_replace;
function requireEs_string_replace() {
  if (hasRequiredEs_string_replace) return es_string_replace;
  hasRequiredEs_string_replace = 1;
  var apply2 = requireFunctionApply();
  var call2 = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
  var fails2 = requireFails();
  var anObject2 = requireAnObject();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toLength2 = requireToLength();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var advanceStringIndex2 = requireAdvanceStringIndex();
  var getMethod2 = requireGetMethod();
  var getSubstitution2 = requireGetSubstitution();
  var getRegExpFlags = requireRegexpGetFlags();
  var regExpExec = requireRegexpExecAbstract();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var REPLACE = wellKnownSymbol2("replace");
  var max2 = Math.max;
  var min2 = Math.min;
  var concat = uncurryThis([].concat);
  var push2 = uncurryThis([].push);
  var stringIndexOf = uncurryThis("".indexOf);
  var stringSlice = uncurryThis("".slice);
  var maybeToString = function(it) {
    return it === void 0 ? it : String(it);
  };
  var REPLACE_KEEPS_$0 = function() {
    return "a".replace(/./, "$0") === "$0";
  }();
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
    if (/./[REPLACE]) {
      return /./[REPLACE]("a", "$0") === "";
    }
    return false;
  }();
  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails2(function() {
    var re = /./;
    re.exec = function() {
      var result = [];
      result.groups = { a: "7" };
      return result;
    };
    return "".replace(re, "$<a>") !== "7";
  });
  fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace2(searchValue, replaceValue) {
        var O = requireObjectCoercible2(this);
        var replacer = isObject2(searchValue) ? getMethod2(searchValue, REPLACE) : void 0;
        return replacer ? call2(replacer, searchValue, O, replaceValue) : call2(nativeReplace, toString2(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function(string2, replaceValue) {
        var rx = anObject2(this);
        var S = toString2(string2);
        if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }
        var functionalReplace = isCallable2(replaceValue);
        if (!functionalReplace) replaceValue = toString2(replaceValue);
        var flags = toString2(getRegExpFlags(rx));
        var global2 = stringIndexOf(flags, "g") !== -1;
        var fullUnicode;
        if (global2) {
          fullUnicode = stringIndexOf(flags, "u") !== -1;
          rx.lastIndex = 0;
        }
        var results = [];
        var result;
        while (true) {
          result = regExpExec(rx, S);
          if (result === null) break;
          push2(results, result);
          if (!global2) break;
          var matchStr = toString2(result[0]);
          if (matchStr === "") rx.lastIndex = advanceStringIndex2(S, toLength2(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = "";
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = toString2(result[0]);
          var position = max2(min2(toIntegerOrInfinity2(result.index), S.length), 0);
          var captures = [];
          var replacement;
          for (var j = 1; j < result.length; j++) push2(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position, S);
            if (namedCaptures !== void 0) push2(replacerArgs, namedCaptures);
            replacement = toString2(apply2(replaceValue, void 0, replacerArgs));
          } else {
            replacement = getSubstitution2(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice(S, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  return es_string_replace;
}
var es_string_replaceAll = {};
var isRegexp;
var hasRequiredIsRegexp;
function requireIsRegexp() {
  if (hasRequiredIsRegexp) return isRegexp;
  hasRequiredIsRegexp = 1;
  var isObject2 = requireIsObject();
  var classof2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH = wellKnownSymbol2("match");
  isRegexp = function(it) {
    var isRegExp2;
    return isObject2(it) && ((isRegExp2 = it[MATCH]) !== void 0 ? !!isRegExp2 : classof2(it) === "RegExp");
  };
  return isRegexp;
}
var hasRequiredEs_string_replaceAll;
function requireEs_string_replaceAll() {
  if (hasRequiredEs_string_replaceAll) return es_string_replaceAll;
  hasRequiredEs_string_replaceAll = 1;
  var $ = require_export();
  var call2 = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var isRegExp2 = requireIsRegexp();
  var toString2 = requireToString();
  var getMethod2 = requireGetMethod();
  var getRegExpFlags = requireRegexpGetFlags();
  var getSubstitution2 = requireGetSubstitution();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var IS_PURE = requireIsPure();
  var REPLACE = wellKnownSymbol2("replace");
  var $TypeError = TypeError;
  var indexOf = uncurryThis("".indexOf);
  var replace2 = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var max2 = Math.max;
  $({ target: "String", proto: true }, {
    replaceAll: function replaceAll2(searchValue, replaceValue) {
      var O = requireObjectCoercible2(this);
      var IS_REG_EXP, flags, replacer, string2, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
      var endOfLastMatch = 0;
      var result = "";
      if (isObject2(searchValue)) {
        IS_REG_EXP = isRegExp2(searchValue);
        if (IS_REG_EXP) {
          flags = toString2(requireObjectCoercible2(getRegExpFlags(searchValue)));
          if (!~indexOf(flags, "g")) throw new $TypeError("`.replaceAll` does not allow non-global regexes");
        }
        replacer = getMethod2(searchValue, REPLACE);
        if (replacer) return call2(replacer, searchValue, O, replaceValue);
        if (IS_PURE && IS_REG_EXP) return replace2(toString2(O), searchValue, replaceValue);
      }
      string2 = toString2(O);
      searchString = toString2(searchValue);
      functionalReplace = isCallable2(replaceValue);
      if (!functionalReplace) replaceValue = toString2(replaceValue);
      searchLength = searchString.length;
      advanceBy = max2(1, searchLength);
      position = indexOf(string2, searchString);
      while (position !== -1) {
        replacement = functionalReplace ? toString2(replaceValue(searchString, position, string2)) : getSubstitution2(searchString, string2, position, [], void 0, replaceValue);
        result += stringSlice(string2, endOfLastMatch, position) + replacement;
        endOfLastMatch = position + searchLength;
        position = position + advanceBy > string2.length ? -1 : indexOf(string2, searchString, position + advanceBy);
      }
      if (endOfLastMatch < string2.length) {
        result += stringSlice(string2, endOfLastMatch);
      }
      return result;
    }
  });
  return es_string_replaceAll;
}
var replaceAll$1;
var hasRequiredReplaceAll$1;
function requireReplaceAll$1() {
  if (hasRequiredReplaceAll$1) return replaceAll$1;
  hasRequiredReplaceAll$1 = 1;
  requireEs_regexp_exec();
  requireEs_string_replace();
  requireEs_string_replaceAll();
  var entryUnbind2 = requireEntryUnbind();
  replaceAll$1 = entryUnbind2("String", "replaceAll");
  return replaceAll$1;
}
var replaceAll;
var hasRequiredReplaceAll;
function requireReplaceAll() {
  if (hasRequiredReplaceAll) return replaceAll;
  hasRequiredReplaceAll = 1;
  var parent = requireReplaceAll$1();
  replaceAll = parent;
  return replaceAll;
}
requireReplaceAll();
function isChild(x) {
  return x && typeof x === "object" && "parents" in x;
}
function haveParentsChanged(child) {
  for (let i = 0, n2 = child.parents.length; i < n2; i++) {
    child.parents[i].__unsafe__getWithoutCapture(true);
    if (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {
      return true;
    }
  }
  return false;
}
function detach(parent, child) {
  if (!parent.children.remove(child)) {
    return;
  }
  if (parent.children.isEmpty && isChild(parent)) {
    for (let i = 0, n2 = parent.parents.length; i < n2; i++) {
      detach(parent.parents[i], parent);
    }
  }
}
function attach(parent, child) {
  if (!parent.children.add(child)) {
    return;
  }
  if (isChild(parent)) {
    for (let i = 0, n2 = parent.parents.length; i < n2; i++) {
      attach(parent.parents[i], parent);
    }
  }
}
function equals(a2, b) {
  const shallowEquals = a2 === b || Object.is(a2, b) || Boolean(a2 && b && typeof a2.equals === "function" && a2.equals(b));
  return shallowEquals;
}
function singleton(key, init2) {
  const symbol = Symbol.for(`com.tldraw.state/${key}`);
  const global2 = globalThis;
  global2[symbol] ??= init2();
  return global2[symbol];
}
const EMPTY_ARRAY = singleton("empty_array", () => Object.freeze([]));
const ARRAY_SIZE_THRESHOLD = 8;
class ArraySet {
  arraySize = 0;
  array = Array(ARRAY_SIZE_THRESHOLD);
  set = null;
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array) {
      return this.arraySize === 0;
    }
    if (this.set) {
      return this.set.size === 0;
    }
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx !== -1) {
        return false;
      }
      if (this.arraySize < ARRAY_SIZE_THRESHOLD) {
        this.array[this.arraySize] = elem;
        this.arraySize++;
        return true;
      } else {
        this.set = new Set(this.array);
        this.array = null;
        this.set.add(elem);
        return true;
      }
    }
    if (this.set) {
      if (this.set.has(elem)) {
        return false;
      }
      this.set.add(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(elem) {
    if (this.array) {
      const idx = this.array.indexOf(elem);
      if (idx === -1) {
        return false;
      }
      this.array[idx] = void 0;
      this.arraySize--;
      if (idx !== this.arraySize) {
        this.array[idx] = this.array[this.arraySize];
        this.array[this.arraySize] = void 0;
      }
      return true;
    }
    if (this.set) {
      if (!this.set.has(elem)) {
        return false;
      }
      this.set.delete(elem);
      return true;
    }
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor - The callback to run for each element.
   */
  visit(visitor) {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          visitor(elem);
        }
      }
      return;
    }
    if (this.set) {
      this.set.forEach(visitor);
      return;
    }
    throw new Error("no set or array");
  }
  *[Symbol.iterator]() {
    if (this.array) {
      for (let i = 0; i < this.arraySize; i++) {
        const elem = this.array[i];
        if (typeof elem !== "undefined") {
          yield elem;
        }
      }
    } else if (this.set) {
      yield* this.set;
    } else {
      throw new Error("no set or array");
    }
  }
  has(elem) {
    if (this.array) {
      return this.array.indexOf(elem) !== -1;
    } else {
      return this.set.has(elem);
    }
  }
  clear() {
    if (this.set) {
      this.set.clear();
    } else {
      this.arraySize = 0;
      this.array = [];
    }
  }
  size() {
    if (this.set) {
      return this.set.size;
    } else {
      return this.arraySize;
    }
  }
}
const RESET_VALUE = Symbol.for("com.tldraw.state/RESET_VALUE");
class HistoryBuffer {
  constructor(capacity) {
    this.capacity = capacity;
    this.buffer = new Array(capacity);
  }
  index = 0;
  // use a wrap around buffer to store the last N values
  buffer;
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch - The epoch when the diff was computed.
   * @param currentEpoch - The current epoch.
   * @param diff - The diff to add, or else a reset value.
   */
  pushEntry(lastComputedEpoch, currentEpoch, diff) {
    if (diff === void 0) {
      return;
    }
    if (diff === RESET_VALUE) {
      this.clear();
      return;
    }
    this.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff];
    this.index = (this.index + 1) % this.capacity;
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0;
    this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param sinceEpoch - The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(sinceEpoch) {
    const { index: index2, capacity, buffer } = this;
    for (let i = 0; i < capacity; i++) {
      const offset2 = (index2 - 1 + capacity - i) % capacity;
      const elem = buffer[offset2];
      if (!elem) {
        return RESET_VALUE;
      }
      const [fromEpoch, toEpoch] = elem;
      if (i === 0 && sinceEpoch >= toEpoch) {
        return [];
      }
      if (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {
        const len = i + 1;
        const result = new Array(len);
        for (let j = 0; j < len; j++) {
          result[j] = buffer[(offset2 + j) % capacity][2];
        }
        return result;
      }
    }
    return RESET_VALUE;
  }
}
const GLOBAL_START_EPOCH = -1;
class __EffectScheduler__ {
  constructor(name, runEffect, options) {
    this.name = name;
    this.runEffect = runEffect;
    this._scheduleEffect = options?.scheduleEffect;
  }
  _isActivelyListening = false;
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /** @internal */
  lastTraversedEpoch = GLOBAL_START_EPOCH;
  lastReactedEpoch = GLOBAL_START_EPOCH;
  _scheduleCount = 0;
  __debug_ancestor_epochs__ = null;
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  parentSet = new ArraySet();
  /** @internal */
  parentEpochs = [];
  /** @internal */
  parents = [];
  _scheduleEffect;
  /** @internal */
  maybeScheduleEffect() {
    if (!this._isActivelyListening) return;
    if (this.lastReactedEpoch === getGlobalEpoch()) return;
    if (this.parents.length && !haveParentsChanged(this)) {
      this.lastReactedEpoch = getGlobalEpoch();
      return;
    }
    this.scheduleEffect();
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++;
    if (this._scheduleEffect) {
      this._scheduleEffect(this.maybeExecute);
    } else {
      this.execute();
    }
  }
  /** @internal */
  // eslint-disable-next-line local/prefer-class-methods
  maybeExecute = () => {
    if (!this._isActivelyListening) return;
    this.execute();
  };
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.
   * @public
   */
  attach() {
    this._isActivelyListening = true;
    for (let i = 0, n2 = this.parents.length; i < n2; i++) {
      attach(this.parents[i], this);
    }
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.
   */
  detach() {
    this._isActivelyListening = false;
    for (let i = 0, n2 = this.parents.length; i < n2; i++) {
      detach(this.parents[i], this);
    }
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      startCapturingParents(this);
      const currentEpoch = getGlobalEpoch();
      const result = this.runEffect(this.lastReactedEpoch);
      this.lastReactedEpoch = currentEpoch;
      return result;
    } finally {
      stopCapturingParents();
    }
  }
}
const EffectScheduler = singleton(
  "EffectScheduler",
  () => __EffectScheduler__
);
function react$1(name, fn, options) {
  const scheduler2 = new EffectScheduler(name, fn, options);
  scheduler2.attach();
  scheduler2.scheduleEffect();
  return () => {
    scheduler2.detach();
  };
}
function reactor(name, fn, options) {
  const scheduler2 = new EffectScheduler(name, fn, options);
  return {
    scheduler: scheduler2,
    start: (options2) => {
      const force = options2?.force ?? false;
      scheduler2.attach();
      if (force) {
        scheduler2.scheduleEffect();
      } else {
        scheduler2.maybeScheduleEffect();
      }
    },
    stop: () => {
      scheduler2.detach();
    }
  };
}
let Transaction$1 = class Transaction {
  constructor(parent) {
    this.parent = parent;
  }
  initialAtomValues = /* @__PURE__ */ new Map();
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (inst$1.globalIsReacting) {
      for (const atom2 of this.initialAtomValues.keys()) {
        traverseAtomForCleanup(atom2);
      }
    } else if (this.isRoot) {
      flushChanges(this.initialAtomValues.keys());
    } else {
      this.initialAtomValues.forEach((value, atom2) => {
        if (!this.parent.initialAtomValues.has(atom2)) {
          this.parent.initialAtomValues.set(atom2, value);
        }
      });
    }
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    inst$1.globalEpoch++;
    this.initialAtomValues.forEach((value, atom2) => {
      atom2.set(value);
      atom2.historyBuffer?.clear();
    });
    this.commit();
  }
};
const inst$1 = singleton("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: GLOBAL_START_EPOCH + 1,
  // Whether any transaction is reacting.
  globalIsReacting: false,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: GLOBAL_START_EPOCH + 1
}));
function getReactionEpoch() {
  return inst$1.reactionEpoch;
}
function getGlobalEpoch() {
  return inst$1.globalEpoch;
}
function getIsReacting() {
  return inst$1.globalIsReacting;
}
function traverse(reactors, child) {
  if (child.lastTraversedEpoch === inst$1.globalEpoch) {
    return;
  }
  child.lastTraversedEpoch = inst$1.globalEpoch;
  if (child instanceof EffectScheduler) {
    reactors.add(child);
  } else {
    child.children.visit((c2) => traverse(reactors, c2));
  }
}
function flushChanges(atoms) {
  if (inst$1.globalIsReacting) {
    throw new Error("flushChanges cannot be called during a reaction");
  }
  const outerTxn = inst$1.currentTransaction;
  try {
    inst$1.currentTransaction = null;
    inst$1.globalIsReacting = true;
    inst$1.reactionEpoch = inst$1.globalEpoch;
    const reactors = /* @__PURE__ */ new Set();
    for (const atom2 of atoms) {
      atom2.children.visit((child) => traverse(reactors, child));
    }
    for (const r2 of reactors) {
      r2.maybeScheduleEffect();
    }
    let updateDepth = 0;
    while (inst$1.cleanupReactors?.size) {
      if (updateDepth++ > 1e3) {
        throw new Error("Reaction update depth limit exceeded");
      }
      const reactors2 = inst$1.cleanupReactors;
      inst$1.cleanupReactors = null;
      for (const r2 of reactors2) {
        r2.maybeScheduleEffect();
      }
    }
  } finally {
    inst$1.cleanupReactors = null;
    inst$1.globalIsReacting = false;
    inst$1.currentTransaction = outerTxn;
  }
}
function atomDidChange(atom2, previousValue) {
  if (inst$1.currentTransaction) {
    if (!inst$1.currentTransaction.initialAtomValues.has(atom2)) {
      inst$1.currentTransaction.initialAtomValues.set(atom2, previousValue);
    }
  } else if (inst$1.globalIsReacting) {
    traverseAtomForCleanup(atom2);
  } else {
    flushChanges([atom2]);
  }
}
function traverseAtomForCleanup(atom2) {
  const rs = inst$1.cleanupReactors ??= /* @__PURE__ */ new Set();
  atom2.children.visit((child) => traverse(rs, child));
}
function advanceGlobalEpoch() {
  inst$1.globalEpoch++;
}
function transaction(fn) {
  const txn = new Transaction$1(inst$1.currentTransaction);
  inst$1.currentTransaction = txn;
  try {
    let result = void 0;
    let rollback = false;
    try {
      result = fn(() => rollback = true);
    } catch (e) {
      txn.abort();
      throw e;
    }
    if (rollback) {
      txn.abort();
    } else {
      txn.commit();
    }
    return result;
  } finally {
    inst$1.currentTransaction = inst$1.currentTransaction.parent;
  }
}
function transact(fn) {
  if (inst$1.currentTransaction) {
    return fn();
  }
  return transaction(fn);
}
let didWarnComputedGetter = false;
function logComputedGetterWarning() {
  if (didWarnComputedGetter) return;
  didWarnComputedGetter = true;
  console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  );
}
const UNINITIALIZED = Symbol.for("com.tldraw.state/UNINITIALIZED");
function isUninitialized(value) {
  return value === UNINITIALIZED;
}
const WithDiff = singleton(
  "WithDiff",
  () => class WithDiff {
    constructor(value, diff) {
      this.value = value;
      this.diff = diff;
    }
  }
);
function withDiff(value, diff) {
  return new WithDiff(value, diff);
}
class __UNSAFE__Computed {
  constructor(name, derive, options) {
    this.name = name;
    this.derive = derive;
    if (options?.historyLength) {
      this.historyBuffer = new HistoryBuffer(options.historyLength);
    }
    this.computeDiff = options?.computeDiff;
    this.isEqual = options?.isEqual ?? equals;
  }
  lastChangedEpoch = GLOBAL_START_EPOCH;
  lastTraversedEpoch = GLOBAL_START_EPOCH;
  __debug_ancestor_epochs__ = null;
  /**
   * The epoch when the reactor was last checked.
   */
  lastCheckedEpoch = GLOBAL_START_EPOCH;
  parentSet = new ArraySet();
  parents = [];
  parentEpochs = [];
  children = new ArraySet();
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  historyBuffer;
  // The last-computed value of this signal.
  state = UNINITIALIZED;
  // If the signal throws an error we stash it so we can rethrow it on the next get()
  error = null;
  computeDiff;
  isEqual;
  __unsafe__getWithoutCapture(ignoreErrors) {
    const isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH;
    const globalEpoch = getGlobalEpoch();
    if (!isNew && (this.lastCheckedEpoch === globalEpoch || this.isActivelyListening && getIsReacting() && this.lastTraversedEpoch < getReactionEpoch() || !haveParentsChanged(this))) {
      this.lastCheckedEpoch = globalEpoch;
      if (this.error) {
        if (!ignoreErrors) {
          throw this.error.thrownValue;
        } else {
          return this.state;
        }
      } else {
        return this.state;
      }
    }
    try {
      startCapturingParents(this);
      const result = this.derive(this.state, this.lastCheckedEpoch);
      const newState = result instanceof WithDiff ? result.value : result;
      const isUninitialized2 = this.state === UNINITIALIZED;
      if (isUninitialized2 || !this.isEqual(newState, this.state)) {
        if (this.historyBuffer && !isUninitialized2) {
          const diff = result instanceof WithDiff ? result.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            getGlobalEpoch(),
            diff ?? this.computeDiff?.(this.state, newState, this.lastCheckedEpoch, getGlobalEpoch()) ?? RESET_VALUE
          );
        }
        this.lastChangedEpoch = getGlobalEpoch();
        this.state = newState;
      }
      this.error = null;
      this.lastCheckedEpoch = getGlobalEpoch();
      return this.state;
    } catch (e) {
      if (this.state !== UNINITIALIZED) {
        this.state = UNINITIALIZED;
        this.lastChangedEpoch = getGlobalEpoch();
      }
      this.lastCheckedEpoch = getGlobalEpoch();
      if (this.historyBuffer) {
        this.historyBuffer.clear();
      }
      this.error = { thrownValue: e };
      if (!ignoreErrors) throw e;
      return this.state;
    } finally {
      stopCapturingParents();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      maybeCaptureParent(this);
    }
  }
  getDiffSince(epoch) {
    this.__unsafe__getWithoutCapture(true);
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE;
  }
}
const _Computed = singleton("Computed", () => __UNSAFE__Computed);
function computedMethodLegacyDecorator(options = {}, _target, key, descriptor) {
  const originalMethod = descriptor.value;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.value = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  descriptor.value[isComputedMethodKey] = true;
  return descriptor;
}
function computedGetterLegacyDecorator(options = {}, _target, key, descriptor) {
  const originalMethod = descriptor.get;
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + key);
  descriptor.get = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(key, originalMethod.bind(this), options);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  return descriptor;
}
function computedMethodTc39Decorator(options, compute, context) {
  assert(context.kind === "method", "@computed can only be used on methods");
  const derivationKey = Symbol.for("__@tldraw/state__computed__" + String(context.name));
  const fn = function() {
    let d = this[derivationKey];
    if (!d) {
      d = new _Computed(String(context.name), compute.bind(this), options);
      Object.defineProperty(this, derivationKey, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: d
      });
    }
    return d.get();
  };
  fn[isComputedMethodKey] = true;
  return fn;
}
function computedDecorator(options = {}, args) {
  if (args.length === 2) {
    const [originalMethod, context] = args;
    return computedMethodTc39Decorator(options, originalMethod, context);
  } else {
    const [_target, key, descriptor] = args;
    if (descriptor.get) {
      logComputedGetterWarning();
      return computedGetterLegacyDecorator(options, _target, key, descriptor);
    } else {
      return computedMethodLegacyDecorator(options, _target, key, descriptor);
    }
  }
}
const isComputedMethodKey = "@@__isComputedMethod__@@";
function computed() {
  if (arguments.length === 1) {
    const options = arguments[0];
    return (...args) => computedDecorator(options, args);
  } else if (typeof arguments[0] === "string") {
    return new _Computed(arguments[0], arguments[1], arguments[2]);
  } else {
    return computedDecorator(void 0, arguments);
  }
}
function isComputed(value) {
  return value && value instanceof _Computed;
}
class CaptureStackFrame {
  constructor(below, child) {
    this.below = below;
    this.child = child;
  }
  offset = 0;
  maybeRemoved;
}
const inst = singleton("capture", () => ({ stack: null }));
function unsafe__withoutCapture(fn) {
  const oldStack = inst.stack;
  inst.stack = null;
  try {
    return fn();
  } finally {
    inst.stack = oldStack;
  }
}
function startCapturingParents(child) {
  inst.stack = new CaptureStackFrame(inst.stack, child);
  if (child.__debug_ancestor_epochs__) {
    const previousAncestorEpochs = child.__debug_ancestor_epochs__;
    child.__debug_ancestor_epochs__ = null;
    for (const p of child.parents) {
      p.__unsafe__getWithoutCapture(true);
    }
    logChangedAncestors(child, previousAncestorEpochs);
  }
  child.parentSet.clear();
}
function stopCapturingParents() {
  const frame2 = inst.stack;
  inst.stack = frame2.below;
  if (frame2.offset < frame2.child.parents.length) {
    for (let i = frame2.offset; i < frame2.child.parents.length; i++) {
      const maybeRemovedParent = frame2.child.parents[i];
      if (!frame2.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame2.child);
      }
    }
    frame2.child.parents.length = frame2.offset;
    frame2.child.parentEpochs.length = frame2.offset;
  }
  if (frame2.maybeRemoved) {
    for (let i = 0; i < frame2.maybeRemoved.length; i++) {
      const maybeRemovedParent = frame2.maybeRemoved[i];
      if (!frame2.child.parentSet.has(maybeRemovedParent)) {
        detach(maybeRemovedParent, frame2.child);
      }
    }
  }
  if (frame2.child.__debug_ancestor_epochs__) {
    captureAncestorEpochs(frame2.child, frame2.child.__debug_ancestor_epochs__);
  }
}
function maybeCaptureParent(p) {
  if (inst.stack) {
    const wasCapturedAlready = inst.stack.child.parentSet.has(p);
    if (wasCapturedAlready) {
      return;
    }
    inst.stack.child.parentSet.add(p);
    if (inst.stack.child.isActivelyListening) {
      attach(p, inst.stack.child);
    }
    if (inst.stack.offset < inst.stack.child.parents.length) {
      const maybeRemovedParent = inst.stack.child.parents[inst.stack.offset];
      if (maybeRemovedParent !== p) {
        if (!inst.stack.maybeRemoved) {
          inst.stack.maybeRemoved = [maybeRemovedParent];
        } else {
          inst.stack.maybeRemoved.push(maybeRemovedParent);
        }
      }
    }
    inst.stack.child.parents[inst.stack.offset] = p;
    inst.stack.child.parentEpochs[inst.stack.offset] = p.lastChangedEpoch;
    inst.stack.offset++;
  }
}
function captureAncestorEpochs(child, ancestorEpochs) {
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    const epoch = child.parentEpochs[i];
    ancestorEpochs.set(parent, epoch);
    if (isComputed(parent)) {
      captureAncestorEpochs(parent, ancestorEpochs);
    }
  }
  return ancestorEpochs;
}
function collectChangedAncestors(child, ancestorEpochs) {
  const changeTree = {};
  for (let i = 0; i < child.parents.length; i++) {
    const parent = child.parents[i];
    if (!ancestorEpochs.has(parent)) {
      continue;
    }
    const prevEpoch = ancestorEpochs.get(parent);
    const currentEpoch = parent.lastChangedEpoch;
    if (currentEpoch !== prevEpoch) {
      if (isComputed(parent)) {
        changeTree[parent.name] = collectChangedAncestors(parent, ancestorEpochs);
      } else {
        changeTree[parent.name] = null;
      }
    }
  }
  return changeTree;
}
function logChangedAncestors(child, ancestorEpochs) {
  const changeTree = collectChangedAncestors(child, ancestorEpochs);
  if (Object.keys(changeTree).length === 0) {
    console.log(`Effect(${child.name}) was executed manually.`);
    return;
  }
  let str2 = isComputed(child) ? `Computed(${child.name}) is recomputing because:` : `Effect(${child.name}) is executing because:`;
  function logParent(tree, indent) {
    const indentStr = "\n" + " ".repeat(indent) + "↳ ";
    for (const [name, val] of Object.entries(tree)) {
      if (val) {
        str2 += `${indentStr}Computed(${name}) changed`;
        logParent(val, indent + 2);
      } else {
        str2 += `${indentStr}Atom(${name}) changed`;
      }
    }
  }
  logParent(changeTree, 1);
  console.log(str2);
}
class __Atom__ {
  constructor(name, current, options) {
    this.name = name;
    this.current = current;
    this.isEqual = options?.isEqual ?? null;
    if (!options) return;
    if (options.historyLength) {
      this.historyBuffer = new HistoryBuffer(options.historyLength);
    }
    this.computeDiff = options.computeDiff;
  }
  isEqual;
  computeDiff;
  lastChangedEpoch = getGlobalEpoch();
  children = new ArraySet();
  historyBuffer;
  __unsafe__getWithoutCapture(_ignoreErrors) {
    return this.current;
  }
  get() {
    maybeCaptureParent(this);
    return this.current;
  }
  set(value, diff) {
    if (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {
      return this.current;
    }
    advanceGlobalEpoch();
    if (this.historyBuffer) {
      this.historyBuffer.pushEntry(
        this.lastChangedEpoch,
        getGlobalEpoch(),
        diff ?? this.computeDiff?.(this.current, value, this.lastChangedEpoch, getGlobalEpoch()) ?? RESET_VALUE
      );
    }
    this.lastChangedEpoch = getGlobalEpoch();
    const oldValue = this.current;
    this.current = value;
    atomDidChange(this, oldValue);
    return value;
  }
  update(updater) {
    return this.set(updater(this.current));
  }
  getDiffSince(epoch) {
    maybeCaptureParent(this);
    if (epoch >= this.lastChangedEpoch) {
      return EMPTY_ARRAY;
    }
    return this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE;
  }
}
const _Atom = singleton("Atom", () => __Atom__);
function atom(name, initialValue, options) {
  return new _Atom(name, initialValue, options);
}
const currentApiVersion = 1;
const actualApiVersion = singleton("apiVersion", () => currentApiVersion);
if (actualApiVersion !== currentApiVersion) {
  throw new Error(
    `You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`
  );
}
registerTldrawLibraryVersion(
  "@tldraw/state",
  "3.13.1",
  "esm"
);
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n2 = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y2 = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z && a2[z] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a2, b, e) {
    this.props = a2;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a2, b) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b, "setState");
  };
  E.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a2, b, e) {
    this.props = a2;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a2, b, e) {
    var d, c2 = {}, k = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c2[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c2.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c2.children = f;
    }
    if (a2 && a2.defaultProps) for (d in g = a2.defaultProps, g) void 0 === c2[d] && (c2[d] = g[d]);
    return { $$typeof: l, type: a2, key: k, ref: h, props: c2, _owner: K.current };
  }
  function N(a2, b) {
    return { $$typeof: l, type: a2.type, key: b, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l;
  }
  function escape2(a2) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b[a3];
    });
  }
  var P = /\/+/g;
  function Q(a2, b) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape2("" + a2.key) : b.toString(36);
  }
  function R(a2, b, e, d, c2) {
    var k = typeof a2;
    if ("undefined" === k || "boolean" === k) a2 = null;
    var h = false;
    if (null === a2) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l:
          case n2:
            h = true;
        }
    }
    if (h) return h = a2, c2 = c2(h), a2 = "" === d ? "." + Q(h, 0) : d, I(c2) ? (e = "", null != a2 && (e = a2.replace(P, "$&/") + "/"), R(c2, b, e, "", function(a3) {
      return a3;
    })) : null != c2 && (O(c2) && (c2 = N(c2, e + (!c2.key || h && h.key === c2.key ? "" : ("" + c2.key).replace(P, "$&/") + "/") + a2)), b.push(c2)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I(a2)) for (var g = 0; g < a2.length; g++) {
      k = a2[g];
      var f = d + Q(k, g);
      h += R(k, b, e, f, c2);
    }
    else if (f = A(a2), "function" === typeof f) for (a2 = f.call(a2), g = 0; !(k = a2.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c2);
    else if ("object" === k) throw b = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a2, b, e) {
    if (null == a2) return a2;
    var d = [], c2 = 0;
    R(a2, d, "", "", function(a3) {
      return b.call(e, a3, c2++);
    });
    return d;
  }
  function T(a2) {
    if (-1 === a2._status) {
      var b = a2._result;
      b = b();
      b.then(function(b2) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b2;
      }, function(b2) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b2;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U = { current: null }, V2 = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a2, b, e) {
    S(a2, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a2) {
    var b = 0;
    S(a2, function() {
      b++;
    });
    return b;
  }, toArray: function(a2) {
    return S(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!O(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a2, b, e) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d = C({}, a2.props), c2 = a2.key, k = a2.ref, h = a2._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c2 = "" + b.key);
      if (a2.type && a2.type.defaultProps) var g = a2.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d.children = g;
    }
    return { $$typeof: l, type: a2.type, key: c2, ref: k, props: d, _owner: h };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t2, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a2) {
    var b = M.bind(null, a2);
    b.type = a2;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v, render: a2 };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y2, _payload: { _status: -1, _result: a2 }, _init: T };
  };
  react_production_min.memo = function(a2, b) {
    return { $$typeof: x, type: a2, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a2) {
    var b = V2.transition;
    V2.transition = {};
    try {
      a2();
    } finally {
      V2.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a2, b) {
    return U.current.useCallback(a2, b);
  };
  react_production_min.useContext = function(a2) {
    return U.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b) {
    return U.current.useEffect(a2, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b, e) {
    return U.current.useImperativeHandle(a2, b, e);
  };
  react_production_min.useInsertionEffect = function(a2, b) {
    return U.current.useInsertionEffect(a2, b);
  };
  react_production_min.useLayoutEffect = function(a2, b) {
    return U.current.useLayoutEffect(a2, b);
  };
  react_production_min.useMemo = function(a2, b) {
    return U.current.useMemo(a2, b);
  };
  react_production_min.useReducer = function(a2, b, e) {
    return U.current.useReducer(a2, b, e);
  };
  react_production_min.useRef = function(a2) {
    return U.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b, e) {
    return U.current.useSyncExternalStore(a2, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
function useStateTracking(name, render, deps = []) {
  const renderRef = React.useRef(render);
  renderRef.current = render;
  const [scheduler2, subscribe, getSnapshot2] = React.useMemo(() => {
    let scheduleUpdate = null;
    const subscribe2 = (cb) => {
      scheduleUpdate = cb;
      return () => {
        scheduleUpdate = null;
      };
    };
    const scheduler22 = new EffectScheduler(
      `useStateTracking(${name})`,
      // this is what `scheduler.execute()` will call
      () => renderRef.current?.(),
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          scheduleUpdate?.();
        }
      }
    );
    const getSnapshot22 = () => scheduler22.scheduleCount;
    return [scheduler22, subscribe2, getSnapshot22];
  }, [name, ...deps]);
  React.useSyncExternalStore(subscribe, getSnapshot2, getSnapshot2);
  React.useEffect(() => {
    scheduler2.attach();
    scheduler2.maybeScheduleEffect();
    return () => {
      scheduler2.detach();
    };
  }, [scheduler2]);
  return scheduler2.execute();
}
const ProxyHandlers = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(Component, thisArg, argumentsList) {
    return useStateTracking(
      Component.displayName ?? Component.name ?? "tracked(???)",
      () => Component.apply(thisArg, argumentsList)
    );
  }
};
const ReactMemoSymbol = Symbol.for("react.memo");
const ReactForwardRefSymbol = Symbol.for("react.forward_ref");
function track(baseComponent) {
  let compare = null;
  const $$typeof = baseComponent["$$typeof"];
  if ($$typeof === ReactMemoSymbol) {
    baseComponent = baseComponent.type;
    compare = baseComponent.compare;
  }
  if ($$typeof === ReactForwardRefSymbol) {
    return reactExports.memo(reactExports.forwardRef(new Proxy(baseComponent.render, ProxyHandlers)));
  }
  return reactExports.memo(new Proxy(baseComponent, ProxyHandlers), compare);
}
function useAtom(name, valueOrInitialiser, options) {
  return reactExports.useState(() => {
    const initialValue = typeof valueOrInitialiser === "function" ? valueOrInitialiser() : valueOrInitialiser;
    return atom(`useAtom(${name})`, initialValue, options);
  })[0];
}
function useComputed() {
  const name = arguments[0];
  const compute = arguments[1];
  const opts = arguments.length === 3 ? void 0 : arguments[2];
  const deps = arguments.length === 3 ? arguments[2] : arguments[3];
  return reactExports.useMemo(() => computed(`useComputed(${name})`, compute, opts), deps);
}
function useQuickReactor(name, reactFn, deps = EMPTY_ARRAY) {
  reactExports.useEffect(() => {
    const scheduler2 = new EffectScheduler(name, reactFn);
    scheduler2.attach();
    scheduler2.execute();
    return () => {
      scheduler2.detach();
    };
  }, deps);
}
function useReactor(name, reactFn, deps = []) {
  const raf = reactExports.useRef(-1);
  const scheduler2 = reactExports.useMemo(
    () => new EffectScheduler(name, reactFn, {
      scheduleEffect: (cb) => {
        const rafId = requestAnimationFrame(cb);
        raf.current = rafId;
        return rafId;
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  reactExports.useEffect(() => {
    scheduler2.attach();
    scheduler2.execute();
    return () => {
      scheduler2.detach();
      cancelAnimationFrame(raf.current);
    };
  }, [scheduler2]);
}
function useValue() {
  const args = arguments;
  const deps = args.length === 3 ? args[2] : [args[0]];
  const name = args.length === 3 ? args[0] : `useValue(${args[0].name})`;
  const isInRender = reactExports.useRef(true);
  isInRender.current = true;
  const $val = reactExports.useMemo(() => {
    if (args.length === 1) {
      return args[0];
    }
    return computed(name, () => {
      if (isInRender.current) {
        return args[1]();
      } else {
        try {
          return args[1]();
        } catch {
          return {};
        }
      }
    });
  }, deps);
  try {
    const { subscribe, getSnapshot: getSnapshot2 } = reactExports.useMemo(() => {
      return {
        subscribe: (listen) => {
          return react$1(`useValue(${name})`, () => {
            $val.get();
            listen();
          });
        },
        getSnapshot: () => $val.get()
      };
    }, [$val]);
    return reactExports.useSyncExternalStore(subscribe, getSnapshot2, getSnapshot2);
  } finally {
    isInRender.current = false;
  }
}
registerTldrawLibraryVersion(
  "@tldraw/state-react",
  "3.13.1",
  "esm"
);
/*!
 * This file was lovingly and delicately extracted from Immutable.js
 * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE
 * Copyright (c) 2014-present, Lee Byron and other contributors.
 */
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
const defaultValueOf = Object.prototype.valueOf;
function hash(o2) {
  if (o2 == null) {
    return hashNullish(o2);
  }
  if (typeof o2.hashCode === "function") {
    return smi(o2.hashCode(o2));
  }
  const v = valueOf(o2);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n2) {
  if (n2 !== n2 || n2 === Infinity) {
    return 0;
  }
  let hash2 = n2 | 0;
  if (hash2 !== n2) {
    hash2 ^= n2 * 4294967295;
  }
  while (n2 > 4294967295) {
    n2 /= 4294967295;
    hash2 ^= n2;
  }
  return smi(hash2);
}
function cachedHashString(string2) {
  let hashed = stringHashCache[string2];
  if (hashed === void 0) {
    hashed = hashString(string2);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string2] = hashed;
  }
  return hashed;
}
function hashString(string2) {
  let hashed = 0;
  for (let ii = 0; ii < string2.length; ii++) {
    hashed = 31 * hashed + string2.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  let hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  let hashed = weakMap.get(obj);
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  weakMap.set(obj, hashed);
  return hashed;
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  const nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
const weakMap = /* @__PURE__ */ new WeakMap();
const symbolMap = /* @__PURE__ */ Object.create(null);
let _objHashUID = 0;
const STRING_HASH_CACHE_MIN_STRLEN = 16;
const STRING_HASH_CACHE_MAX_SIZE = 255;
let STRING_HASH_CACHE_SIZE = 0;
let stringHashCache = {};
const SHIFT = 5;
const SIZE = 1 << SHIFT;
const MASK = SIZE - 1;
const NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function arrCopy(arr, offset2) {
  offset2 = offset2 || 0;
  const len = Math.max(0, arr.length - offset2);
  const newArr = new Array(len);
  for (let ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset2];
  }
  return newArr;
}
const is = Object.is;
class OwnerID {
}
class ImmutableMap {
  // @pragma Construction
  // @ts-ignore
  _root;
  // @ts-ignore
  size;
  // @ts-ignore
  __ownerID;
  // @ts-ignore
  __hash;
  // @ts-ignore
  __altered;
  constructor(value) {
    return value === void 0 || value === null ? emptyMap() : value instanceof ImmutableMap ? value : emptyMap().withMutations((map2) => {
      for (const [k, v] of value) {
        map2.set(k, v);
      }
    });
  }
  get(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  }
  set(k, v) {
    return updateMap(this, k, v);
  }
  delete(k) {
    return updateMap(this, k, NOT_SET);
  }
  deleteAll(keys2) {
    return this.withMutations((map2) => {
      for (const key of keys2) {
        map2.delete(key);
      }
    });
  }
  __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  }
  withMutations(fn) {
    const mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  }
  wasAltered() {
    return this.__altered;
  }
  asMutable() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  }
  [Symbol.iterator]() {
    return this.entries()[Symbol.iterator]();
  }
  entries() {
    return new MapIterator(this, ITERATE_ENTRIES, false);
  }
  keys() {
    return new MapIterator(this, ITERATE_KEYS, false);
  }
  values() {
    return new MapIterator(this, ITERATE_VALUES, false);
  }
}
class ArrayMapNode {
  constructor(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  }
  get(_shift, _keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, _shift, _keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && entries.length === 1) {
      return;
    }
    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new ArrayMapNode(ownerID, newEntries);
  }
}
class BitmapIndexedNode {
  constructor(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  }
  get(shift2, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const bit = 1 << ((shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK);
    const bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift2 + SHIFT, keyHash, key, notSetValue);
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const keyHashFrag = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
    const bit = 1 << keyHashFrag;
    const bitmap = this.bitmap;
    const exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
      return this;
    }
    const idx = popCount(bitmap & bit - 1);
    const nodes = this.nodes;
    const node = exists ? nodes[idx] : void 0;
    const newNode = updateNode(
      node,
      ownerID,
      shift2 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }
    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    const newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }
    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  }
}
class HashArrayMapNode {
  constructor(ownerID, count2, nodes) {
    this.ownerID = ownerID;
    this.count = count2;
    this.nodes = nodes;
  }
  get(shift2, keyHash, key, notSetValue) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
    const node = this.nodes[idx];
    return node ? node.get(shift2 + SHIFT, keyHash, key, notSetValue) : notSetValue;
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const idx = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
    const removed = value === NOT_SET;
    const nodes = this.nodes;
    const node = nodes[idx];
    if (removed && !node) {
      return this;
    }
    const newNode = updateNode(
      node,
      ownerID,
      shift2 + SHIFT,
      keyHash,
      key,
      value,
      didChangeSize,
      didAlter
    );
    if (newNode === node) {
      return this;
    }
    let newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newNodes = setAt(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }
    return new HashArrayMapNode(ownerID, newCount, newNodes);
  }
}
class HashCollisionNode {
  constructor(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  }
  get(shift2, keyHash, key, notSetValue) {
    const entries = this.entries;
    for (let ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === void 0) {
      keyHash = hash(key);
    }
    const removed = value === NOT_SET;
    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift2, keyHash, [key, value]);
    }
    const entries = this.entries;
    let idx = 0;
    const len = entries.length;
    for (; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    const exists = idx < len;
    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);
    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }
    const isEditable = ownerID && ownerID === this.ownerID;
    const newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  }
}
class ValueNode {
  constructor(ownerID, keyHash, entry2) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry2;
  }
  get(shift2, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  }
  update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
    const removed = value === NOT_SET;
    const keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed) {
      SetRef(didChangeSize);
      return;
    }
    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new ValueNode(ownerID, this.keyHash, [key, value]);
    }
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift2, hash(key), [key, value]);
  }
}
class MapIterator {
  constructor(map2, _type, _reverse) {
    this._type = _type;
    this._reverse = _reverse;
    this._stack = map2._root && mapIteratorFrame(map2._root);
  }
  _stack;
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const type = this._type;
    let stack2 = this._stack;
    while (stack2) {
      const node = stack2.node;
      const index2 = stack2.index++;
      let maxIndex;
      if (node.entry) {
        if (index2 === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if ("entries" in node && node.entries) {
        maxIndex = node.entries.length - 1;
        if (index2 <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index2 : index2]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index2 <= maxIndex) {
          const subNode = node.nodes[this._reverse ? maxIndex - index2 : index2];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack2 = this._stack = mapIteratorFrame(subNode, stack2);
          }
          continue;
        }
      }
      stack2 = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }
}
function mapIteratorValue(type, entry2) {
  return iteratorValue(type, entry2[0], entry2[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
const ITERATE_KEYS = 0;
const ITERATE_VALUES = 1;
const ITERATE_ENTRIES = 2;
function iteratorValue(type, k, v, iteratorResult) {
  const value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function makeMap(size2, root, ownerID, hash2) {
  const map2 = Object.create(ImmutableMap.prototype);
  map2.size = size2;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
let EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  let newRoot;
  let newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    const didChangeSize = MakeRef();
    const didAlter = MakeRef();
    newRoot = updateNode(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift2, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(ownerID, shift2, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift2, keyHash, entry2) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry2]);
  }
  const idx1 = (shift2 === 0 ? node.keyHash : node.keyHash >>> shift2) & MASK;
  const idx2 = (shift2 === 0 ? keyHash : keyHash >>> shift2) & MASK;
  let newNode;
  const nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift2 + SHIFT, keyHash, entry2)] : (newNode = new ValueNode(ownerID, keyHash, entry2), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  let node = new ValueNode(ownerID, hash(key), [key, value]);
  for (let ii = 0; ii < entries.length; ii++) {
    const entry2 = entries[ii];
    node = node.update(ownerID, 0, void 0, entry2[0], entry2[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  let bitmap = 0;
  let packedII = 0;
  const packedNodes = new Array(count2);
  for (let ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    const node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  let count2 = 0;
  const expandedNodes = new Array(SIZE);
  for (let ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array2, idx, val, canEdit) {
  const newArray = canEdit ? array2 : arrCopy(array2);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array2, idx, val, canEdit) {
  const newLen = array2.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array2[idx] = val;
    return array2;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array2[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array2, idx, canEdit) {
  const newLen = array2.length - 1;
  if (canEdit && idx === newLen) {
    array2.pop();
    return array2;
  }
  const newArray = new Array(newLen);
  let after = 0;
  for (let ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array2[ii + after];
  }
  return newArray;
}
const MAX_ARRAY_MAP_SIZE = SIZE / 4;
const MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
const MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
class AtomMap {
  constructor(name, entries) {
    this.name = name;
    let atoms = emptyMap();
    if (entries) {
      atoms = atoms.withMutations((atoms2) => {
        for (const [k, v] of entries) {
          atoms2.set(k, atom(`${name}:${String(k)}`, v));
        }
      });
    }
    this.atoms = atom(`${name}:atoms`, atoms);
  }
  atoms;
  /** @internal */
  getAtom(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      this.atoms.get();
      return void 0;
    }
    return valueAtom;
  }
  get(key) {
    const value = this.getAtom(key)?.get();
    assert(value !== UNINITIALIZED);
    return value;
  }
  __unsafe__getWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return void 0;
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    return value;
  }
  has(key) {
    const valueAtom = this.getAtom(key);
    if (!valueAtom) {
      return false;
    }
    return valueAtom.get() !== UNINITIALIZED;
  }
  __unsafe__hasWithoutCapture(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) return false;
    assert(valueAtom.__unsafe__getWithoutCapture() !== UNINITIALIZED);
    return true;
  }
  set(key, value) {
    const existingAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (existingAtom) {
      existingAtom.set(value);
    } else {
      this.atoms.update((atoms) => {
        return atoms.set(key, atom(`${this.name}:${String(key)}`, value));
      });
    }
    return this;
  }
  update(key, updater) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      throw new Error(`AtomMap: key ${key} not found`);
    }
    const value = valueAtom.__unsafe__getWithoutCapture();
    assert(value !== UNINITIALIZED);
    valueAtom.set(updater(value));
  }
  delete(key) {
    const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
    if (!valueAtom) {
      return false;
    }
    transact(() => {
      valueAtom.set(UNINITIALIZED);
      this.atoms.update((atoms) => {
        return atoms.delete(key);
      });
    });
    return true;
  }
  deleteMany(keys2) {
    return transact(() => {
      const deleted = [];
      const newAtoms = this.atoms.get().withMutations((atoms) => {
        for (const key of keys2) {
          const valueAtom = atoms.get(key);
          if (!valueAtom) continue;
          const oldValue = valueAtom.get();
          assert(oldValue !== UNINITIALIZED);
          deleted.push([key, oldValue]);
          atoms.delete(key);
          valueAtom.set(UNINITIALIZED);
        }
      });
      if (deleted.length) {
        this.atoms.set(newAtoms);
      }
      return deleted;
    });
  }
  clear() {
    return transact(() => {
      for (const valueAtom of this.atoms.__unsafe__getWithoutCapture().values()) {
        valueAtom.set(UNINITIALIZED);
      }
      this.atoms.set(emptyMap());
    });
  }
  *entries() {
    for (const [key, valueAtom] of this.atoms.get()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield [key, value];
    }
  }
  *keys() {
    for (const key of this.atoms.get().keys()) {
      yield key;
    }
  }
  *values() {
    for (const valueAtom of this.atoms.get().values()) {
      const value = valueAtom.get();
      assert(value !== UNINITIALIZED);
      yield value;
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.atoms.get().size;
  }
  forEach(callbackfn, thisArg) {
    for (const [key, value] of this.entries()) {
      callbackfn.call(thisArg, value, key, this);
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "AtomMap";
}
class IncrementalSetConstructor {
  constructor(previousValue) {
    this.previousValue = previousValue;
  }
  /**
   * The next value of the set.
   *
   * @internal
   */
  nextValue;
  /**
   * The diff of the set.
   *
   * @internal
   */
  diff;
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    const numRemoved = this.diff?.removed?.size ?? 0;
    const numAdded = this.diff?.added?.size ?? 0;
    if (numRemoved === 0 && numAdded === 0) {
      return void 0;
    }
    return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(item, wasAlreadyPresent) {
    this.nextValue ??= new Set(this.previousValue);
    this.nextValue.add(item);
    this.diff ??= {};
    if (wasAlreadyPresent) {
      this.diff.removed?.delete(item);
    } else {
      this.diff.added ??= /* @__PURE__ */ new Set();
      this.diff.added.add(item);
    }
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @public
   */
  add(item) {
    const wasAlreadyPresent = this.previousValue.has(item);
    if (wasAlreadyPresent) {
      const wasRemoved = this.diff?.removed?.has(item);
      if (!wasRemoved) return;
      return this._add(item, wasAlreadyPresent);
    }
    const isCurrentlyPresent = this.nextValue?.has(item);
    if (isCurrentlyPresent) return;
    this._add(item, wasAlreadyPresent);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(item, wasAlreadyPresent) {
    this.nextValue ??= new Set(this.previousValue);
    this.nextValue.delete(item);
    this.diff ??= {};
    if (wasAlreadyPresent) {
      this.diff.removed ??= /* @__PURE__ */ new Set();
      this.diff.removed.add(item);
    } else {
      this.diff.added?.delete(item);
    }
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @public
   */
  remove(item) {
    const wasAlreadyPresent = this.previousValue.has(item);
    if (!wasAlreadyPresent) {
      const wasAdded = this.diff?.added?.has(item);
      if (!wasAdded) return;
      return this._remove(item, wasAlreadyPresent);
    }
    const hasAlreadyBeenRemoved = this.diff?.removed?.has(item);
    if (hasAlreadyBeenRemoved) return;
    this._remove(item, wasAlreadyPresent);
  }
}
class RecordType {
  constructor(typeName, config) {
    this.typeName = typeName;
    this.createDefaultProperties = config.createDefaultProperties;
    this.validator = config.validator ?? { validate: (r2) => r2 };
    this.scope = config.scope ?? "document";
    this.ephemeralKeys = config.ephemeralKeys;
    const ephemeralKeySet = /* @__PURE__ */ new Set();
    if (config.ephemeralKeys) {
      for (const [key, isEphemeral] of objectMapEntries(config.ephemeralKeys)) {
        if (isEphemeral) ephemeralKeySet.add(key);
      }
    }
    this.ephemeralKeySet = ephemeralKeySet;
  }
  createDefaultProperties;
  validator;
  ephemeralKeys;
  ephemeralKeySet;
  scope;
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   * @returns The new record.
   */
  create(properties) {
    const result = {
      ...this.createDefaultProperties(),
      id: "id" in properties ? properties.id : this.createId()
    };
    for (const [k, v] of Object.entries(properties)) {
      if (v !== void 0) {
        result[k] = v;
      }
    }
    result.typeName = this.typeName;
    return result;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @returns The cloned record.
   * @public
   */
  clone(record) {
    return { ...structuredClone(record), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(customUniquePart) {
    return this.typeName + ":" + (customUniquePart ?? uniqueId());
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createCustomId('myId')
   * ```
   *
   * @deprecated - Use `createId` instead.
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(id) {
    return this.typeName + ":" + id;
  }
  /**
   * Takes an id like `user:123` and returns the part after the colon `123`
   *
   * @param id - The id
   * @returns
   */
  parseId(id) {
    if (!this.isId(id)) {
      throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`);
    }
    return id.slice(this.typeName.length + 1);
  }
  /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */
  isInstance(record) {
    return record?.typeName === this.typeName;
  }
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isIn('someId')
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(id) {
    if (!id) return false;
    for (let i = 0; i < this.typeName.length; i++) {
      if (id[i] !== this.typeName[i]) return false;
    }
    return id[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(createDefaultProperties) {
    return new RecordType(this.typeName, {
      createDefaultProperties,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Check that the passed in record passes the validations for this type. Returns its input
   * correctly typed if it does, but throws an error otherwise.
   */
  validate(record, recordBefore) {
    if (recordBefore && this.validator.validateUsingKnownGoodVersion) {
      return this.validator.validateUsingKnownGoodVersion(recordBefore, record);
    }
    return this.validator.validate(record);
  }
}
function createRecordType(typeName, config) {
  return new RecordType(typeName, {
    createDefaultProperties: () => ({}),
    validator: config.validator,
    scope: config.scope,
    ephemeralKeys: config.ephemeralKeys
  });
}
function createEmptyRecordsDiff() {
  return { added: {}, updated: {}, removed: {} };
}
function reverseRecordsDiff(diff) {
  const result = { added: diff.removed, removed: diff.added, updated: {} };
  for (const [from2, to] of Object.values(diff.updated)) {
    result.updated[from2.id] = [to, from2];
  }
  return result;
}
function isRecordsDiffEmpty(diff) {
  return Object.keys(diff.added).length === 0 && Object.keys(diff.updated).length === 0 && Object.keys(diff.removed).length === 0;
}
function squashRecordDiffs(diffs) {
  const result = { added: {}, removed: {}, updated: {} };
  squashRecordDiffsMutable(result, diffs);
  return result;
}
function squashRecordDiffsMutable(target, diffs) {
  for (const diff of diffs) {
    for (const [id, value] of objectMapEntries(diff.added)) {
      if (target.removed[id]) {
        const original = target.removed[id];
        delete target.removed[id];
        if (original !== value) {
          target.updated[id] = [original, value];
        }
      } else {
        target.added[id] = value;
      }
    }
    for (const [id, [_from, to]] of objectMapEntries(diff.updated)) {
      if (target.added[id]) {
        target.added[id] = to;
        delete target.updated[id];
        delete target.removed[id];
        continue;
      }
      if (target.updated[id]) {
        target.updated[id] = [target.updated[id][0], to];
        delete target.removed[id];
        continue;
      }
      target.updated[id] = diff.updated[id];
      delete target.removed[id];
    }
    for (const [id, value] of objectMapEntries(diff.removed)) {
      if (target.added[id]) {
        delete target.added[id];
      } else if (target.updated[id]) {
        target.removed[id] = target.updated[id][0];
        delete target.updated[id];
      } else {
        target.removed[id] = value;
      }
    }
  }
}
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  if (hasRequiredLodash_isequal) return lodash_isequal.exports;
  hasRequiredLodash_isequal = 1;
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset2 = array2.length;
      while (++index2 < length) {
        array2[offset2 + index2] = values[index2];
      }
      return array2;
    }
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry2 = entries[index2];
        this.set(entry2[0], entry2[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (hasOwnProperty2.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack2.get(array2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack2.get(object2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual2(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual2;
  })(lodash_isequal, lodash_isequal.exports);
  return lodash_isequal.exports;
}
var lodash_isequalExports = requireLodash_isequal();
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(lodash_isequalExports);
function intersectSets(sets) {
  if (sets.length === 0) return /* @__PURE__ */ new Set();
  const first2 = sets[0];
  const rest = sets.slice(1);
  const result = /* @__PURE__ */ new Set();
  for (const val of first2) {
    if (rest.every((set) => set.has(val))) {
      result.add(val);
    }
  }
  return result;
}
function diffSets(prev, next) {
  const result = {};
  for (const val of next) {
    if (!prev.has(val)) {
      result.added ??= /* @__PURE__ */ new Set();
      result.added.add(val);
    }
  }
  for (const val of prev) {
    if (!next.has(val)) {
      result.removed ??= /* @__PURE__ */ new Set();
      result.removed.add(val);
    }
  }
  return result.added || result.removed ? result : void 0;
}
function objectMatchesQuery(query, object2) {
  for (const [key, _matcher] of Object.entries(query)) {
    const matcher = _matcher;
    const value = object2[key];
    if ("eq" in matcher && value !== matcher.eq) return false;
    if ("neq" in matcher && value === matcher.neq) return false;
    if ("gt" in matcher && (typeof value !== "number" || value <= matcher.gt)) return false;
  }
  return true;
}
function executeQuery(store, typeName, query) {
  const matchIds = Object.fromEntries(Object.keys(query).map((key) => [key, /* @__PURE__ */ new Set()]));
  for (const [k, matcher] of Object.entries(query)) {
    if ("eq" in matcher) {
      const index2 = store.index(typeName, k);
      const ids = index2.get().get(matcher.eq);
      if (ids) {
        for (const id of ids) {
          matchIds[k].add(id);
        }
      }
    } else if ("neq" in matcher) {
      const index2 = store.index(typeName, k);
      for (const [value, ids] of index2.get()) {
        if (value !== matcher.neq) {
          for (const id of ids) {
            matchIds[k].add(id);
          }
        }
      }
    } else if ("gt" in matcher) {
      const index2 = store.index(typeName, k);
      for (const [value, ids] of index2.get()) {
        if (value > matcher.gt) {
          for (const id of ids) {
            matchIds[k].add(id);
          }
        }
      }
    }
  }
  return intersectSets(Object.values(matchIds));
}
class StoreQueries {
  constructor(recordMap, history2) {
    this.recordMap = recordMap;
    this.history = history2;
  }
  /**
   * A cache of derivations (indexes).
   *
   * @internal
   */
  indexCache = /* @__PURE__ */ new Map();
  /**
   * A cache of derivations (filtered histories).
   *
   * @internal
   */
  historyCache = /* @__PURE__ */ new Map();
  /**
   * Create a derivation that contains the history for a given type
   *
   * @param typeName - The name of the type to filter by.
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(typeName) {
    if (this.historyCache.has(typeName)) {
      return this.historyCache.get(typeName);
    }
    const filtered = computed(
      "filterHistory:" + typeName,
      (lastValue, lastComputedEpoch) => {
        if (isUninitialized(lastValue)) {
          return this.history.get();
        }
        const diff = this.history.getDiffSince(lastComputedEpoch);
        if (diff === RESET_VALUE) return this.history.get();
        const res = { added: {}, removed: {}, updated: {} };
        let numAdded = 0;
        let numRemoved = 0;
        let numUpdated = 0;
        for (const changes of diff) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName) {
              if (res.removed[added.id]) {
                const original = res.removed[added.id];
                delete res.removed[added.id];
                numRemoved--;
                if (original !== added) {
                  res.updated[added.id] = [original, added];
                  numUpdated++;
                }
              } else {
                res.added[added.id] = added;
                numAdded++;
              }
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              if (res.added[to.id]) {
                res.added[to.id] = to;
              } else if (res.updated[to.id]) {
                res.updated[to.id] = [res.updated[to.id][0], to];
              } else {
                res.updated[to.id] = [from2, to];
                numUpdated++;
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              if (res.added[removed.id]) {
                delete res.added[removed.id];
                numAdded--;
              } else if (res.updated[removed.id]) {
                res.removed[removed.id] = res.updated[removed.id][0];
                delete res.updated[removed.id];
                numUpdated--;
                numRemoved++;
              } else {
                res.removed[removed.id] = removed;
                numRemoved++;
              }
            }
          }
        }
        if (numAdded || numRemoved || numUpdated) {
          return withDiff(this.history.get(), res);
        } else {
          return lastValue;
        }
      },
      { historyLength: 100 }
    );
    this.historyCache.set(typeName, filtered);
    return filtered;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   * @public
   */
  index(typeName, property) {
    const cacheKey = typeName + ":" + property;
    if (this.indexCache.has(cacheKey)) {
      return this.indexCache.get(cacheKey);
    }
    const index2 = this.__uncached_createIndex(typeName, property);
    this.indexCache.set(cacheKey, index2);
    return index2;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   * @internal
   */
  __uncached_createIndex(typeName, property) {
    const typeHistory = this.filterHistory(typeName);
    const fromScratch = () => {
      typeHistory.get();
      const res = /* @__PURE__ */ new Map();
      for (const record of this.recordMap.values()) {
        if (record.typeName === typeName) {
          const value = record[property];
          if (!res.has(value)) {
            res.set(value, /* @__PURE__ */ new Set());
          }
          res.get(value).add(record.id);
        }
      }
      return res;
    };
    return computed(
      "index:" + typeName + ":" + property,
      (prevValue, lastComputedEpoch) => {
        if (isUninitialized(prevValue)) return fromScratch();
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratch();
        }
        const setConstructors = /* @__PURE__ */ new Map();
        const add = (value, id) => {
          let setConstructor = setConstructors.get(value);
          if (!setConstructor)
            setConstructor = new IncrementalSetConstructor(
              prevValue.get(value) ?? /* @__PURE__ */ new Set()
            );
          setConstructor.add(id);
          setConstructors.set(value, setConstructor);
        };
        const remove2 = (value, id) => {
          let set = setConstructors.get(value);
          if (!set) set = new IncrementalSetConstructor(prevValue.get(value) ?? /* @__PURE__ */ new Set());
          set.remove(id);
          setConstructors.set(value, set);
        };
        for (const changes of history2) {
          for (const record of objectMapValues(changes.added)) {
            if (record.typeName === typeName) {
              const value = record[property];
              add(value, record.id);
            }
          }
          for (const [from2, to] of objectMapValues(changes.updated)) {
            if (to.typeName === typeName) {
              const prev = from2[property];
              const next = to[property];
              if (prev !== next) {
                remove2(prev, to.id);
                add(next, to.id);
              }
            }
          }
          for (const record of objectMapValues(changes.removed)) {
            if (record.typeName === typeName) {
              const value = record[property];
              remove2(value, record.id);
            }
          }
        }
        let nextValue = void 0;
        let nextDiff = void 0;
        for (const [value, setConstructor] of setConstructors) {
          const result = setConstructor.get();
          if (!result) continue;
          if (!nextValue) nextValue = new Map(prevValue);
          if (!nextDiff) nextDiff = /* @__PURE__ */ new Map();
          if (result.value.size === 0) {
            nextValue.delete(value);
          } else {
            nextValue.set(value, result.value);
          }
          nextDiff.set(value, result.diff);
        }
        if (nextValue && nextDiff) {
          return withDiff(nextValue, nextDiff);
        }
        return prevValue;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optional) The name of the query.
   */
  record(typeName, queryCreator = () => ({}), name = "record:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, name);
    return computed(name, () => {
      for (const id of ids.get()) {
        return this.recordMap.get(id);
      }
      return void 0;
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(typeName, queryCreator = () => ({}), name = "records:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const ids = this.ids(typeName, queryCreator, "ids:" + name);
    return computed(
      name,
      () => {
        return Array.from(ids.get(), (id) => this.recordMap.get(id));
      },
      {
        isEqual: areArraysShallowEqual
      }
    );
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(typeName, queryCreator = () => ({}), name = "ids:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
    const typeHistory = this.filterHistory(typeName);
    const fromScratch = () => {
      typeHistory.get();
      const query = queryCreator();
      if (Object.keys(query).length === 0) {
        const ids = /* @__PURE__ */ new Set();
        for (const record of this.recordMap.values()) {
          if (record.typeName === typeName) ids.add(record.id);
        }
        return ids;
      }
      return executeQuery(this, typeName, query);
    };
    const fromScratchWithDiff = (prevValue) => {
      const nextValue = fromScratch();
      const diff = diffSets(prevValue, nextValue);
      if (diff) {
        return withDiff(nextValue, diff);
      } else {
        return prevValue;
      }
    };
    const cachedQuery = computed("ids_query:" + name, queryCreator, {
      isEqual
    });
    return computed(
      "query:" + name,
      (prevValue, lastComputedEpoch) => {
        const query = cachedQuery.get();
        if (isUninitialized(prevValue)) {
          return fromScratch();
        }
        if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
          return fromScratchWithDiff(prevValue);
        }
        const history2 = typeHistory.getDiffSince(lastComputedEpoch);
        if (history2 === RESET_VALUE) {
          return fromScratchWithDiff(prevValue);
        }
        const setConstructor = new IncrementalSetConstructor(
          prevValue
        );
        for (const changes of history2) {
          for (const added of objectMapValues(changes.added)) {
            if (added.typeName === typeName && objectMatchesQuery(query, added)) {
              setConstructor.add(added.id);
            }
          }
          for (const [_, updated] of objectMapValues(changes.updated)) {
            if (updated.typeName === typeName) {
              if (objectMatchesQuery(query, updated)) {
                setConstructor.add(updated.id);
              } else {
                setConstructor.remove(updated.id);
              }
            }
          }
          for (const removed of objectMapValues(changes.removed)) {
            if (removed.typeName === typeName) {
              setConstructor.remove(removed.id);
            }
          }
        }
        const result = setConstructor.get();
        if (!result) {
          return prevValue;
        }
        return withDiff(result.value, result.diff);
      },
      { historyLength: 50 }
    );
  }
  exec(typeName, query) {
    const ids = executeQuery(this, typeName, query);
    if (ids.size === 0) {
      return EMPTY_ARRAY;
    }
    return Array.from(ids, (id) => this.recordMap.get(id));
  }
}
class StoreSideEffects {
  constructor(store) {
    this.store = store;
  }
  _beforeCreateHandlers = {};
  _afterCreateHandlers = {};
  _beforeChangeHandlers = {};
  _afterChangeHandlers = {};
  _beforeDeleteHandlers = {};
  _afterDeleteHandlers = {};
  _operationCompleteHandlers = [];
  _isEnabled = true;
  /** @internal */
  isEnabled() {
    return this._isEnabled;
  }
  /** @internal */
  setIsEnabled(enabled) {
    this._isEnabled = enabled;
  }
  /** @internal */
  handleBeforeCreate(record, source) {
    if (!this._isEnabled) return record;
    const handlers2 = this._beforeCreateHandlers[record.typeName];
    if (handlers2) {
      let r2 = record;
      for (const handler of handlers2) {
        r2 = handler(r2, source);
      }
      return r2;
    }
    return record;
  }
  /** @internal */
  handleAfterCreate(record, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterCreateHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /** @internal */
  handleBeforeChange(prev, next, source) {
    if (!this._isEnabled) return next;
    const handlers2 = this._beforeChangeHandlers[next.typeName];
    if (handlers2) {
      let r2 = next;
      for (const handler of handlers2) {
        r2 = handler(prev, r2, source);
      }
      return r2;
    }
    return next;
  }
  /** @internal */
  handleAfterChange(prev, next, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterChangeHandlers[next.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(prev, next, source);
      }
    }
  }
  /** @internal */
  handleBeforeDelete(record, source) {
    if (!this._isEnabled) return true;
    const handlers2 = this._beforeDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        if (handler(record, source) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /** @internal */
  handleAfterDelete(record, source) {
    if (!this._isEnabled) return;
    const handlers2 = this._afterDeleteHandlers[record.typeName];
    if (handlers2) {
      for (const handler of handlers2) {
        handler(record, source);
      }
    }
  }
  /** @internal */
  handleOperationComplete(source) {
    if (!this._isEnabled) return;
    for (const handler of this._operationCompleteHandlers) {
      handler(source);
    }
  }
  /**
   * Internal helper for registering a bunch of side effects at once and keeping them organized.
   * @internal
   */
  register(handlersByType) {
    const disposes = [];
    for (const [type, handlers2] of Object.entries(handlersByType)) {
      if (handlers2?.beforeCreate) {
        disposes.push(this.registerBeforeCreateHandler(type, handlers2.beforeCreate));
      }
      if (handlers2?.afterCreate) {
        disposes.push(this.registerAfterCreateHandler(type, handlers2.afterCreate));
      }
      if (handlers2?.beforeChange) {
        disposes.push(this.registerBeforeChangeHandler(type, handlers2.beforeChange));
      }
      if (handlers2?.afterChange) {
        disposes.push(this.registerAfterChangeHandler(type, handlers2.afterChange));
      }
      if (handlers2?.beforeDelete) {
        disposes.push(this.registerBeforeDeleteHandler(type, handlers2.beforeDelete));
      }
      if (handlers2?.afterDelete) {
        disposes.push(this.registerAfterDeleteHandler(type, handlers2.afterDelete));
      }
    }
    return () => {
      for (const dispose of disposes) dispose();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(typeName, handler) {
    const handlers2 = this._beforeCreateHandlers[typeName];
    if (!handlers2) this._beforeCreateHandlers[typeName] = [];
    this._beforeCreateHandlers[typeName].push(handler);
    return () => remove(this._beforeCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape<TLTextShape>({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { richText: toRichText(page.name) },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(typeName, handler) {
    const handlers2 = this._afterCreateHandlers[typeName];
    if (!handlers2) this._afterCreateHandlers[typeName] = [];
    this._afterCreateHandlers[typeName].push(handler);
    return () => remove(this._afterCreateHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(typeName, handler) {
    const handlers2 = this._beforeChangeHandlers[typeName];
    if (!handlers2) this._beforeChangeHandlers[typeName] = [];
    this._beforeChangeHandlers[typeName].push(handler);
    return () => remove(this._beforeChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(typeName, handler) {
    const handlers2 = this._afterChangeHandlers[typeName];
    if (!handlers2) this._afterChangeHandlers[typeName] = [];
    this._afterChangeHandlers[typeName].push(handler);
    return () => remove(this._afterChangeHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(typeName, handler) {
    const handlers2 = this._beforeDeleteHandlers[typeName];
    if (!handlers2) this._beforeDeleteHandlers[typeName] = [];
    this._beforeDeleteHandlers[typeName].push(handler);
    return () => remove(this._beforeDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(typeName, handler) {
    const handlers2 = this._afterDeleteHandlers[typeName];
    if (!handlers2) this._afterDeleteHandlers[typeName] = [];
    this._afterDeleteHandlers[typeName].push(handler);
    return () => remove(this._afterDeleteHandlers[typeName], handler);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(handler) {
    this._operationCompleteHandlers.push(handler);
    return () => remove(this._operationCompleteHandlers, handler);
  }
}
function remove(array2, item) {
  const index2 = array2.indexOf(item);
  if (index2 >= 0) {
    array2.splice(index2, 1);
  }
}
function devFreeze(object2) {
  {
    return object2;
  }
}
class Store {
  /**
   * The random id of the store.
   */
  id;
  /**
   * An AtomMap containing the stores records.
   *
   * @internal
   * @readonly
   */
  records;
  /**
   * An atom containing the store's history.
   *
   * @public
   * @readonly
   */
  history = atom("history", 0, {
    historyLength: 1e3
  });
  /**
   * A StoreQueries instance for this store.
   *
   * @public
   * @readonly
   */
  query;
  /**
   * A set containing listeners that have been added to this store.
   *
   * @internal
   */
  listeners = /* @__PURE__ */ new Set();
  /**
   * An array of history entries that have not yet been flushed.
   *
   * @internal
   */
  historyAccumulator = new HistoryAccumulator();
  /**
   * A reactor that responds to changes to the history by squashing the accumulated history and
   * notifying listeners of the changes.
   *
   * @internal
   */
  historyReactor;
  /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */
  cancelHistoryReactor() {
  }
  schema;
  props;
  scopedTypes;
  sideEffects = new StoreSideEffects(this);
  constructor(config) {
    const { initialData, schema, id } = config;
    this.id = id ?? uniqueId();
    this.schema = schema;
    this.props = config.props;
    if (initialData) {
      this.records = new AtomMap(
        "store",
        objectMapEntries(initialData).map(([id2, record]) => [
          id2,
          devFreeze(this.schema.validateRecord(this, record, "initialize", null))
        ])
      );
    } else {
      this.records = new AtomMap("store");
    }
    this.query = new StoreQueries(this.records, this.history);
    this.historyReactor = reactor(
      "Store.historyReactor",
      () => {
        this.history.get();
        this._flushHistory();
      },
      { scheduleEffect: (cb) => this.cancelHistoryReactor = throttleToNextFrame$1(cb) }
    );
    this.scopedTypes = {
      document: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
      ),
      session: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "session").map((t2) => t2.typeName)
      ),
      presence: new Set(
        objectMapValues(this.schema.types).filter((t2) => t2.scope === "presence").map((t2) => t2.typeName)
      )
    };
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const entries = this.historyAccumulator.flush();
      for (const { changes, source } of entries) {
        let instanceChanges = null;
        let documentChanges = null;
        let presenceChanges = null;
        for (const { onHistory, filters } of this.listeners) {
          if (filters.source !== "all" && filters.source !== source) {
            continue;
          }
          if (filters.scope !== "all") {
            if (filters.scope === "document") {
              documentChanges ??= this.filterChangesByScope(changes, "document");
              if (!documentChanges) continue;
              onHistory({ changes: documentChanges, source });
            } else if (filters.scope === "session") {
              instanceChanges ??= this.filterChangesByScope(changes, "session");
              if (!instanceChanges) continue;
              onHistory({ changes: instanceChanges, source });
            } else {
              presenceChanges ??= this.filterChangesByScope(changes, "presence");
              if (!presenceChanges) continue;
              onHistory({ changes: presenceChanges, source });
            }
          } else {
            onHistory({ changes, source });
          }
        }
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */
  filterChangesByScope(change, scope) {
    const result = {
      added: filterEntries(change.added, (_, r2) => this.scopedTypes[scope].has(r2.typeName)),
      updated: filterEntries(change.updated, (_, r2) => this.scopedTypes[scope].has(r2[1].typeName)),
      removed: filterEntries(change.removed, (_, r2) => this.scopedTypes[scope].has(r2.typeName))
    };
    if (Object.keys(result.added).length === 0 && Object.keys(result.updated).length === 0 && Object.keys(result.removed).length === 0) {
      return null;
    }
    return result;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(changes) {
    this.historyAccumulator.add({
      changes,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    });
    if (this.listeners.size === 0) {
      this.historyAccumulator.clear();
    }
    this.history.set(this.history.get() + 1, changes);
  }
  validate(phase) {
    this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null));
  }
  /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @param phaseOverride - The phase override.
   * @public
   */
  put(records, phaseOverride) {
    this.atomic(() => {
      const updates = {};
      const additions = {};
      let record;
      let didChange = false;
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      for (let i = 0, n2 = records.length; i < n2; i++) {
        record = records[i];
        const initialValue = this.records.__unsafe__getWithoutCapture(record.id);
        if (initialValue) {
          record = this.sideEffects.handleBeforeChange(initialValue, record, source);
          const validated = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "updateRecord",
            initialValue
          );
          if (validated === initialValue) continue;
          record = devFreeze(record);
          this.records.set(record.id, record);
          didChange = true;
          updates[record.id] = [initialValue, record];
          this.addDiffForAfterEvent(initialValue, record);
        } else {
          record = this.sideEffects.handleBeforeCreate(record, source);
          didChange = true;
          record = this.schema.validateRecord(
            this,
            record,
            phaseOverride ?? "createRecord",
            null
          );
          record = devFreeze(record);
          additions[record.id] = record;
          this.addDiffForAfterEvent(null, record);
          this.records.set(record.id, record);
        }
      }
      if (!didChange) return;
      this.updateHistory({
        added: additions,
        updated: updates,
        removed: {}
      });
    });
  }
  /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */
  remove(ids) {
    this.atomic(() => {
      const toDelete = new Set(ids);
      const source = this.isMergingRemoteChanges ? "remote" : "user";
      if (this.sideEffects.isEnabled()) {
        for (const id of ids) {
          const record = this.records.__unsafe__getWithoutCapture(id);
          if (!record) continue;
          if (this.sideEffects.handleBeforeDelete(record, source) === false) {
            toDelete.delete(id);
          }
        }
      }
      const actuallyDeleted = this.records.deleteMany(toDelete);
      if (actuallyDeleted.length === 0) return;
      const removed = {};
      for (const [id, record] of actuallyDeleted) {
        removed[id] = record;
        this.addDiffForAfterEvent(record, null);
      }
      this.updateHistory({ added: {}, updated: {}, removed });
    });
  }
  /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */
  get(id) {
    return this.records.get(id);
  }
  /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */
  unsafeGetWithoutCapture(id) {
    return this.records.__unsafe__getWithoutCapture(id);
  }
  /**
   * Creates a JSON payload from the record store.
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   * @returns The record store snapshot as a JSON payload.
   */
  serialize(scope = "document") {
    const result = {};
    for (const [id, record] of this.records) {
      if (scope === "all" || this.scopedTypes[scope].has(record.typeName)) {
        result[id] = record;
      }
    }
    return result;
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   *
   * @public
   */
  getStoreSnapshot(scope = "document") {
    return {
      store: this.serialize(scope),
      schema: this.schema.serialize()
    };
  }
  /**
   * @deprecated use `getSnapshot` from the 'tldraw' package instead.
   */
  getSnapshot(scope = "document") {
    console.warn(
      "[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead."
    );
    return this.getStoreSnapshot(scope);
  }
  /**
   * Migrate a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getSnapshot()
   * store.migrateSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  migrateSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    return {
      store: migrationResult.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  loadStoreSnapshot(snapshot) {
    const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
    if (migrationResult.type === "error") {
      throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
    }
    const prevSideEffectsEnabled = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(false);
      this.atomic(() => {
        this.clear();
        this.put(Object.values(migrationResult.value));
        this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
    }
  }
  /**
   * @public
   * @deprecated use `loadSnapshot` from the 'tldraw' package instead.
   */
  loadSnapshot(snapshot) {
    console.warn(
      "[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead."
    );
    this.loadStoreSnapshot(snapshot);
  }
  /**
   * Get an array of all values in the store.
   *
   * @returns An array of all values in the store.
   * @public
   */
  allRecords() {
    return Array.from(this.records.values());
  }
  /**
   * Removes all records from the store.
   *
   * @public
   */
  clear() {
    this.remove(Array.from(this.records.keys()));
  }
  /**
   * Update a record. To update multiple records at once, use the `update` method of the
   * `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */
  update(id, updater) {
    const existing = this.unsafeGetWithoutCapture(id);
    if (!existing) {
      console.error(`Record ${id} not found. This is probably an error`);
      return;
    }
    this.put([updater(existing)]);
  }
  /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */
  has(id) {
    return this.records.has(id);
  }
  /**
   * Add a new listener to the store.
   *
   * @param onHistory - The listener to call when the store updates.
   * @param filters - Filters to apply to the listener.
   * @returns A function to remove the listener.
   */
  listen(onHistory, filters) {
    this._flushHistory();
    const listener = {
      onHistory,
      filters: {
        source: filters?.source ?? "all",
        scope: filters?.scope ?? "all"
      }
    };
    if (!this.historyReactor.scheduler.isActivelyListening) {
      this.historyReactor.start();
      this.historyReactor.scheduler.execute();
    }
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
      if (this.listeners.size === 0) {
        this.historyReactor.stop();
      }
    };
  }
  isMergingRemoteChanges = false;
  /**
   * Merge changes from a remote source
   *
   * @param fn - A function that merges the external changes.
   * @public
   */
  mergeRemoteChanges(fn) {
    if (this.isMergingRemoteChanges) {
      return fn();
    }
    if (this._isInAtomicOp) {
      throw new Error("Cannot merge remote changes while in atomic operation");
    }
    try {
      this.atomic(fn, true, true);
    } finally {
      this.ensureStoreIsUsable();
    }
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(fn) {
    const changes = [];
    const dispose = this.historyAccumulator.addInterceptor((entry2) => changes.push(entry2.changes));
    try {
      transact(fn);
      return squashRecordDiffs(changes);
    } finally {
      dispose();
    }
  }
  applyDiff(diff, {
    runCallbacks = true,
    ignoreEphemeralKeys = false
  } = {}) {
    this.atomic(() => {
      const toPut = objectMapValues(diff.added);
      for (const [_from, to] of objectMapValues(diff.updated)) {
        const type = this.schema.getType(to.typeName);
        if (ignoreEphemeralKeys && type.ephemeralKeySet.size) {
          const existing = this.get(to.id);
          if (!existing) {
            toPut.push(to);
            continue;
          }
          let changed = null;
          for (const [key, value] of Object.entries(to)) {
            if (type.ephemeralKeySet.has(key) || Object.is(value, getOwnProperty(existing, key))) {
              continue;
            }
            if (!changed) changed = { ...existing };
            changed[key] = value;
          }
          if (changed) toPut.push(changed);
        } else {
          toPut.push(to);
        }
      }
      const toRemove = objectMapKeys(diff.removed);
      if (toPut.length) {
        this.put(toPut);
      }
      if (toRemove.length) {
        this.remove(toRemove);
      }
    }, runCallbacks);
  }
  /**
   * Create a cache based on values in the store. Pass in a function that takes and ID and a
   * signal for the underlying record. Return a signal (usually a computed) for the cached value.
   * For simple derivations, use {@link Store.createComputedCache}. This function is useful if you
   * need more precise control over intermediate values.
   */
  createCache(create) {
    const cache = new WeakCache();
    return {
      get: (id) => {
        const atom2 = this.records.getAtom(id);
        if (!atom2) return void 0;
        return cache.get(atom2, () => create(id, atom2)).get();
      }
    };
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param opts - Options for the computed cache.
   * @public
   */
  createComputedCache(name, derive, opts) {
    return this.createCache((id, record) => {
      const recordSignal = opts?.areRecordsEqual ? computed(`${name}:${id}:isEqual`, () => record.get(), { isEqual: opts.areRecordsEqual }) : record;
      return computed(
        name + ":" + id,
        () => {
          return derive(recordSignal.get());
        },
        {
          isEqual: opts?.areResultsEqual
        }
      );
    });
  }
  _integrityChecker;
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      this._integrityChecker ??= this.schema.createIntegrityChecker(this);
      this._integrityChecker?.();
    });
  }
  _isPossiblyCorrupted = false;
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = true;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  pendingAfterEvents = null;
  addDiffForAfterEvent(before, after) {
    assert(this.pendingAfterEvents, "must be in event operation");
    if (before === after) return;
    if (before && after) assert(before.id === after.id);
    if (!before && !after) return;
    const id = (before || after).id;
    const existing = this.pendingAfterEvents.get(id);
    if (existing) {
      existing.after = after;
    } else {
      this.pendingAfterEvents.set(id, { before, after });
    }
  }
  flushAtomicCallbacks(isMergingRemoteChanges) {
    let updateDepth = 0;
    let source = isMergingRemoteChanges ? "remote" : "user";
    while (this.pendingAfterEvents) {
      const events = this.pendingAfterEvents;
      this.pendingAfterEvents = null;
      if (!this.sideEffects.isEnabled()) continue;
      updateDepth++;
      if (updateDepth > 100) {
        throw new Error("Maximum store update depth exceeded, bailing out");
      }
      for (const { before, after } of events.values()) {
        if (before && after && before !== after && !isEqual(before, after)) {
          this.sideEffects.handleAfterChange(before, after, source);
        } else if (before && !after) {
          this.sideEffects.handleAfterDelete(before, source);
        } else if (!before && after) {
          this.sideEffects.handleAfterCreate(after, source);
        }
      }
      if (!this.pendingAfterEvents) {
        this.sideEffects.handleOperationComplete(source);
      } else {
        source = "user";
      }
    }
  }
  _isInAtomicOp = false;
  /** @internal */
  atomic(fn, runCallbacks = true, isMergingRemoteChanges = false) {
    return transact(() => {
      if (this._isInAtomicOp) {
        if (!this.pendingAfterEvents) this.pendingAfterEvents = /* @__PURE__ */ new Map();
        const prevSideEffectsEnabled2 = this.sideEffects.isEnabled();
        assert(!isMergingRemoteChanges, "cannot call mergeRemoteChanges while in atomic operation");
        try {
          if (prevSideEffectsEnabled2 && !runCallbacks) {
            this.sideEffects.setIsEnabled(false);
          }
          return fn();
        } finally {
          this.sideEffects.setIsEnabled(prevSideEffectsEnabled2);
        }
      }
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const prevSideEffectsEnabled = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled);
      this._isInAtomicOp = true;
      if (isMergingRemoteChanges) {
        this.isMergingRemoteChanges = true;
      }
      try {
        const result = fn();
        this.isMergingRemoteChanges = false;
        this.flushAtomicCallbacks(isMergingRemoteChanges);
        return result;
      } finally {
        this.pendingAfterEvents = null;
        this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
        this._isInAtomicOp = false;
        this.isMergingRemoteChanges = false;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(fn) {
    return this.historyAccumulator.addInterceptor(
      (entry2) => fn(entry2, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
}
function squashHistoryEntries(entries) {
  if (entries.length === 0) return [];
  const chunked = [];
  let chunk = [entries[0]];
  let entry2;
  for (let i = 1, n2 = entries.length; i < n2; i++) {
    entry2 = entries[i];
    if (chunk[0].source !== entry2.source) {
      chunked.push(chunk);
      chunk = [];
    }
    chunk.push(entry2);
  }
  chunked.push(chunk);
  return devFreeze(
    chunked.map((chunk2) => ({
      source: chunk2[0].source,
      changes: squashRecordDiffs(chunk2.map((e) => e.changes))
    }))
  );
}
class HistoryAccumulator {
  _history = [];
  _interceptors = /* @__PURE__ */ new Set();
  addInterceptor(fn) {
    this._interceptors.add(fn);
    return () => {
      this._interceptors.delete(fn);
    };
  }
  add(entry2) {
    this._history.push(entry2);
    for (const interceptor of this._interceptors) {
      interceptor(entry2);
    }
  }
  flush() {
    const history2 = squashHistoryEntries(this._history);
    this._history = [];
    return history2;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
}
function createComputedCache(name, derive, opts) {
  const cache = new WeakCache();
  return {
    get(context, id) {
      const computedCache = cache.get(context, () => {
        const store = context instanceof Store ? context : context.store;
        return store.createComputedCache(name, (record) => derive(context, record), opts);
      });
      return computedCache.get(id);
    }
  };
}
function squashDependsOn(sequence) {
  const result = [];
  for (let i = sequence.length - 1; i >= 0; i--) {
    const elem = sequence[i];
    if (!("id" in elem)) {
      const dependsOn = elem.dependsOn;
      const prev = result[0];
      if (prev) {
        result[0] = {
          ...prev,
          dependsOn: dependsOn.concat(prev.dependsOn ?? [])
        };
      }
    } else {
      result.unshift(elem);
    }
  }
  return result;
}
function createMigrationSequence({
  sequence,
  sequenceId,
  retroactive = true
}) {
  const migrations = {
    sequenceId,
    retroactive,
    sequence: squashDependsOn(sequence)
  };
  validateMigrations(migrations);
  return migrations;
}
function createMigrationIds(sequenceId, versions) {
  return Object.fromEntries(
    objectMapEntries(versions).map(([key, version2]) => [key, `${sequenceId}/${version2}`])
  );
}
function createRecordMigrationSequence(opts) {
  const sequenceId = opts.sequenceId;
  return createMigrationSequence({
    sequenceId,
    retroactive: opts.retroactive ?? true,
    sequence: opts.sequence.map(
      (m) => "id" in m ? {
        ...m,
        scope: "record",
        filter: (r2) => r2.typeName === opts.recordType && (m.filter?.(r2) ?? true) && (opts.filter?.(r2) ?? true)
      } : m
    )
  });
}
function sortMigrations(migrations) {
  const byId = new Map(migrations.map((m) => [m.id, m]));
  const isProcessing = /* @__PURE__ */ new Set();
  const result = [];
  function process2(m) {
    assert(!isProcessing.has(m.id), `Circular dependency in migrations: ${m.id}`);
    isProcessing.add(m.id);
    const { version: version2, sequenceId } = parseMigrationId(m.id);
    const parent = byId.get(`${sequenceId}/${version2 - 1}`);
    if (parent) {
      process2(parent);
    }
    if (m.dependsOn) {
      for (const dep of m.dependsOn) {
        const depMigration = byId.get(dep);
        if (depMigration) {
          process2(depMigration);
        }
      }
    }
    byId.delete(m.id);
    result.push(m);
  }
  for (const m of byId.values()) {
    process2(m);
  }
  return result;
}
function parseMigrationId(id) {
  const [sequenceId, version2] = id.split("/");
  return { sequenceId, version: parseInt(version2) };
}
function validateMigrationId(id, expectedSequenceId) {
  if (expectedSequenceId) {
    assert(
      id.startsWith(expectedSequenceId + "/"),
      `Every migration in sequence '${expectedSequenceId}' must have an id starting with '${expectedSequenceId}/'. Got invalid id: '${id}'`
    );
  }
  assert(id.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${id}'`);
}
function validateMigrations(migrations) {
  assert(
    !migrations.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${migrations.sequenceId}`
  );
  assert(migrations.sequenceId.length, "sequenceId must be a non-empty string");
  if (migrations.sequence.length === 0) {
    return;
  }
  validateMigrationId(migrations.sequence[0].id, migrations.sequenceId);
  let n2 = parseMigrationId(migrations.sequence[0].id).version;
  assert(
    n2 === 1,
    `Expected the first migrationId to be '${migrations.sequenceId}/1' but got '${migrations.sequence[0].id}'`
  );
  for (let i = 1; i < migrations.sequence.length; i++) {
    const id = migrations.sequence[i].id;
    validateMigrationId(id, migrations.sequenceId);
    const m = parseMigrationId(id).version;
    assert(
      m === n2 + 1,
      `Migration id numbers must increase in increments of 1, expected ${migrations.sequenceId}/${n2 + 1} but got '${migrations.sequence[i].id}'`
    );
    n2 = m;
  }
}
var MigrationFailureReason = /* @__PURE__ */ ((MigrationFailureReason2) => {
  MigrationFailureReason2["IncompatibleSubtype"] = "incompatible-subtype";
  MigrationFailureReason2["UnknownType"] = "unknown-type";
  MigrationFailureReason2["TargetVersionTooNew"] = "target-version-too-new";
  MigrationFailureReason2["TargetVersionTooOld"] = "target-version-too-old";
  MigrationFailureReason2["MigrationError"] = "migration-error";
  MigrationFailureReason2["UnrecognizedSubtype"] = "unrecognized-subtype";
  return MigrationFailureReason2;
})(MigrationFailureReason || {});
function upgradeSchema(schema) {
  if (schema.schemaVersion > 2 || schema.schemaVersion < 1) return Result.err("Bad schema version");
  if (schema.schemaVersion === 2) return Result.ok(schema);
  const result = {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": schema.storeVersion
    }
  };
  for (const [typeName, recordVersion] of Object.entries(schema.recordVersions)) {
    result.sequences[`com.tldraw.${typeName}`] = recordVersion.version;
    if ("subTypeKey" in recordVersion) {
      for (const [subType, version2] of Object.entries(recordVersion.subTypeVersions)) {
        result.sequences[`com.tldraw.${typeName}.${subType}`] = version2;
      }
    }
  }
  return Result.ok(result);
}
class StoreSchema {
  constructor(types, options) {
    this.types = types;
    this.options = options;
    for (const m of options.migrations ?? []) {
      assert(!this.migrations[m.sequenceId], `Duplicate migration sequenceId ${m.sequenceId}`);
      validateMigrations(m);
      this.migrations[m.sequenceId] = m;
    }
    const allMigrations = Object.values(this.migrations).flatMap((m) => m.sequence);
    this.sortedMigrations = sortMigrations(allMigrations);
    for (const migration of this.sortedMigrations) {
      if (!migration.dependsOn?.length) continue;
      for (const dep of migration.dependsOn) {
        const depMigration = allMigrations.find((m) => m.id === dep);
        assert(depMigration, `Migration '${migration.id}' depends on missing migration '${dep}'`);
      }
    }
  }
  static create(types, options) {
    return new StoreSchema(types, options ?? {});
  }
  migrations = {};
  sortedMigrations;
  validateRecord(store, record, phase, recordBefore) {
    try {
      const recordType = getOwnProperty(this.types, record.typeName);
      if (!recordType) {
        throw new Error(`Missing definition for record type ${record.typeName}`);
      }
      return recordType.validate(record, recordBefore ?? void 0);
    } catch (error) {
      if (this.options.onValidationFailure) {
        return this.options.onValidationFailure({
          store,
          record,
          phase,
          recordBefore,
          error
        });
      } else {
        throw error;
      }
    }
  }
  // TODO: use a weakmap to store the result of this function
  getMigrationsSince(persistedSchema) {
    const upgradeResult = upgradeSchema(persistedSchema);
    if (!upgradeResult.ok) {
      return upgradeResult;
    }
    const schema = upgradeResult.value;
    const sequenceIdsToInclude = new Set(
      // start with any shared sequences
      Object.keys(schema.sequences).filter((sequenceId) => this.migrations[sequenceId])
    );
    for (const sequenceId in this.migrations) {
      if (schema.sequences[sequenceId] === void 0 && this.migrations[sequenceId].retroactive) {
        sequenceIdsToInclude.add(sequenceId);
      }
    }
    if (sequenceIdsToInclude.size === 0) {
      return Result.ok([]);
    }
    const allMigrationsToInclude = /* @__PURE__ */ new Set();
    for (const sequenceId of sequenceIdsToInclude) {
      const theirVersion = schema.sequences[sequenceId];
      if (typeof theirVersion !== "number" && this.migrations[sequenceId].retroactive || theirVersion === 0) {
        for (const migration of this.migrations[sequenceId].sequence) {
          allMigrationsToInclude.add(migration.id);
        }
        continue;
      }
      const theirVersionId = `${sequenceId}/${theirVersion}`;
      const idx = this.migrations[sequenceId].sequence.findIndex((m) => m.id === theirVersionId);
      if (idx === -1) {
        return Result.err("Incompatible schema?");
      }
      for (const migration of this.migrations[sequenceId].sequence.slice(idx + 1)) {
        allMigrationsToInclude.add(migration.id);
      }
    }
    return Result.ok(this.sortedMigrations.filter(({ id }) => allMigrationsToInclude.has(id)));
  }
  migratePersistedRecord(record, persistedSchema, direction = "up") {
    const migrations = this.getMigrationsSince(persistedSchema);
    if (!migrations.ok) {
      console.error("Error migrating record", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    let migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: record };
    }
    if (migrationsToApply.some((m) => m.scope === "store")) {
      return {
        type: "error",
        reason: direction === "down" ? MigrationFailureReason.TargetVersionTooOld : MigrationFailureReason.TargetVersionTooNew
      };
    }
    if (direction === "down") {
      if (!migrationsToApply.every((m) => m.down)) {
        return {
          type: "error",
          reason: MigrationFailureReason.TargetVersionTooOld
        };
      }
      migrationsToApply = migrationsToApply.slice().reverse();
    }
    record = structuredClone(record);
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "store") throw new Error(
          /* won't happen, just for TS */
        );
        const shouldApply = migration.filter ? migration.filter(record) : true;
        if (!shouldApply) continue;
        const result = migration[direction](record);
        if (result) {
          record = structuredClone(result);
        }
      }
    } catch (e) {
      console.error("Error migrating record", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: record };
  }
  migrateStoreSnapshot(snapshot) {
    let { store } = snapshot;
    const migrations = this.getMigrationsSince(snapshot.schema);
    if (!migrations.ok) {
      console.error("Error migrating store", migrations.error);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    const migrationsToApply = migrations.value;
    if (migrationsToApply.length === 0) {
      return { type: "success", value: store };
    }
    store = structuredClone(store);
    try {
      for (const migration of migrationsToApply) {
        if (migration.scope === "record") {
          for (const [id, record] of Object.entries(store)) {
            const shouldApply = migration.filter ? migration.filter(record) : true;
            if (!shouldApply) continue;
            const result = migration.up(record);
            if (result) {
              store[id] = structuredClone(result);
            }
          }
        } else if (migration.scope === "store") {
          const result = migration.up(store);
          if (result) {
            store = structuredClone(result);
          }
        } else {
          exhaustiveSwitchError$1(migration);
        }
      }
    } catch (e) {
      console.error("Error migrating store", e);
      return { type: "error", reason: MigrationFailureReason.MigrationError };
    }
    return { type: "success", value: store };
  }
  /** @internal */
  createIntegrityChecker(store) {
    return this.options.createIntegrityChecker?.(store) ?? void 0;
  }
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId, sequence }) => [
          sequenceId,
          sequence.length ? parseMigrationId(sequence.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId }) => [sequenceId, 0])
      )
    };
  }
  /** @internal */
  getType(typeName) {
    const type = getOwnProperty(this.types, typeName);
    assert(type, "record type does not exists");
    return type;
  }
}
registerTldrawLibraryVersion(
  "@tldraw/store",
  "3.13.1",
  "esm"
);
function formatPath(path) {
  if (!path.length) {
    return null;
  }
  let formattedPath = "";
  for (const item of path) {
    if (typeof item === "number") {
      formattedPath += `.${item}`;
    } else if (item.startsWith("(")) {
      if (formattedPath.endsWith(")")) {
        formattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`;
      } else {
        formattedPath += item;
      }
    } else {
      formattedPath += `.${item}`;
    }
  }
  formattedPath = formattedPath.replace(/id = [^,]+, /, "").replace(/id = [^)]+/, "");
  if (formattedPath.startsWith(".")) {
    return formattedPath.slice(1);
  }
  return formattedPath;
}
class ValidationError extends Error {
  constructor(rawMessage, path = []) {
    const formattedPath = formatPath(path);
    const indentedMessage = rawMessage.split("\n").map((line, i) => i === 0 ? line : `  ${line}`).join("\n");
    super(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage);
    this.rawMessage = rawMessage;
    this.path = path;
  }
  name = "ValidationError";
}
function prefixError(path, fn) {
  try {
    return fn();
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ValidationError(err.rawMessage, [path, ...err.path]);
    }
    throw new ValidationError(err.toString(), [path]);
  }
}
function typeToString(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "an array";
  const type = typeof value;
  switch (type) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${type}`;
    case "object":
      return `an ${type}`;
    case "undefined":
      return "undefined";
    default:
      exhaustiveSwitchError$1(type);
  }
}
class Validator {
  constructor(validationFn, validateUsingKnownGoodVersionFn) {
    this.validationFn = validationFn;
    this.validateUsingKnownGoodVersionFn = validateUsingKnownGoodVersionFn;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The returned value is
   * guaranteed to be referentially equal to the passed value.
   */
  validate(value) {
    const validated = this.validationFn(value);
    return validated;
  }
  validateUsingKnownGoodVersion(knownGoodValue, newValue) {
    if (Object.is(knownGoodValue, newValue)) {
      return knownGoodValue;
    }
    if (this.validateUsingKnownGoodVersionFn) {
      return this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue);
    }
    return this.validate(newValue);
  }
  /** Checks that the passed value is of the correct type. */
  isValid(value) {
    try {
      this.validate(value);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  nullable() {
    return nullable(this);
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  optional() {
    return optional(this);
  }
  /**
   * Refine this validation to a new type. The passed-in validation function should throw an error
   * if the value can't be converted to the new type, or return the new type otherwise.
   */
  refine(otherValidationFn) {
    return new Validator(
      (value) => {
        return otherValidationFn(this.validate(value));
      },
      (knownGoodValue, newValue) => {
        const validated = this.validateUsingKnownGoodVersion(knownGoodValue, newValue);
        if (Object.is(knownGoodValue, validated)) {
          return knownGoodValue;
        }
        return otherValidationFn(validated);
      }
    );
  }
  check(nameOrCheckFn, checkFn) {
    if (typeof nameOrCheckFn === "string") {
      return this.refine((value) => {
        prefixError(`(check ${nameOrCheckFn})`, () => checkFn(value));
        return value;
      });
    } else {
      return this.refine((value) => {
        nameOrCheckFn(value);
        return value;
      });
    }
  }
}
class ArrayOfValidator extends Validator {
  constructor(itemValidator) {
    super(
      (value) => {
        const arr = array.validate(value);
        for (let i = 0; i < arr.length; i++) {
          prefixError(i, () => itemValidator.validate(arr[i]));
        }
        return arr;
      },
      (knownGoodValue, newValue) => {
        if (!itemValidator.validateUsingKnownGoodVersion) return this.validate(newValue);
        const arr = array.validate(newValue);
        let isDifferent = knownGoodValue.length !== arr.length;
        for (let i = 0; i < arr.length; i++) {
          const item = arr[i];
          if (i >= knownGoodValue.length) {
            isDifferent = true;
            prefixError(i, () => itemValidator.validate(item));
            continue;
          }
          if (Object.is(knownGoodValue[i], item)) {
            continue;
          }
          const checkedItem = prefixError(
            i,
            () => itemValidator.validateUsingKnownGoodVersion(knownGoodValue[i], item)
          );
          if (!Object.is(checkedItem, knownGoodValue[i])) {
            isDifferent = true;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.itemValidator = itemValidator;
  }
  nonEmpty() {
    return this.check((value) => {
      if (value.length === 0) {
        throw new ValidationError("Expected a non-empty array");
      }
    });
  }
  lengthGreaterThan1() {
    return this.check((value) => {
      if (value.length <= 1) {
        throw new ValidationError("Expected an array with length greater than 1");
      }
    });
  }
}
class ObjectValidator extends Validator {
  constructor(config, shouldAllowUnknownProperties = false) {
    super(
      (object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, validator] of Object.entries(config)) {
          prefixError(key, () => {
            ;
            validator.validate(getOwnProperty(object2, key));
          });
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(object2)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        return object2;
      },
      (knownGoodValue, newValue) => {
        if (typeof newValue !== "object" || newValue === null) {
          throw new ValidationError(`Expected object, got ${typeToString(newValue)}`);
        }
        let isDifferent = false;
        for (const [key, validator] of Object.entries(config)) {
          const prev = getOwnProperty(knownGoodValue, key);
          const next = getOwnProperty(newValue, key);
          if (Object.is(prev, next)) {
            continue;
          }
          const checked = prefixError(key, () => {
            const validatable = validator;
            if (validatable.validateUsingKnownGoodVersion) {
              return validatable.validateUsingKnownGoodVersion(prev, next);
            } else {
              return validatable.validate(next);
            }
          });
          if (!Object.is(checked, prev)) {
            isDifferent = true;
          }
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(newValue)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        for (const key of Object.keys(knownGoodValue)) {
          if (!hasOwnProperty(newValue, key)) {
            isDifferent = true;
            break;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.config = config;
    this.shouldAllowUnknownProperties = shouldAllowUnknownProperties;
  }
  allowUnknownProperties() {
    return new ObjectValidator(this.config, true);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   *
   * ```ts
   * const animalValidator = T.object({
   * 	name: T.string,
   * })
   * const catValidator = animalValidator.extend({
   * 	meowVolume: T.number,
   * })
   * ```
   */
  extend(extension) {
    return new ObjectValidator({ ...this.config, ...extension });
  }
}
class UnionValidator extends Validator {
  constructor(key, config, unknownValueValidation, useNumberKeys) {
    super(
      (input) => {
        this.expectObject(input);
        const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input);
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(input, variant);
        }
        return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input));
      },
      (prevValue, newValue) => {
        this.expectObject(newValue);
        this.expectObject(prevValue);
        const { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue);
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(newValue, variant);
        }
        if (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {
          return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue));
        }
        return prefixError(`(${key} = ${variant})`, () => {
          if (matchingSchema.validateUsingKnownGoodVersion) {
            return matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue);
          } else {
            return matchingSchema.validate(newValue);
          }
        });
      }
    );
    this.key = key;
    this.config = config;
    this.unknownValueValidation = unknownValueValidation;
    this.useNumberKeys = useNumberKeys;
  }
  expectObject(value) {
    if (typeof value !== "object" || value === null) {
      throw new ValidationError(`Expected an object, got ${typeToString(value)}`, []);
    }
  }
  getMatchingSchemaAndVariant(object2) {
    const variant = getOwnProperty(object2, this.key);
    if (!this.useNumberKeys && typeof variant !== "string") {
      throw new ValidationError(
        `Expected a string for key "${this.key}", got ${typeToString(variant)}`
      );
    } else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {
      throw new ValidationError(`Expected a number for key "${this.key}", got "${variant}"`);
    }
    const matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : void 0;
    return { matchingSchema, variant };
  }
  validateUnknownVariants(unknownValueValidation) {
    return new UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys);
  }
}
class DictValidator extends Validator {
  constructor(keyValidator, valueValidator) {
    super(
      (object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, value] of Object.entries(object2)) {
          prefixError(key, () => {
            keyValidator.validate(key);
            valueValidator.validate(value);
          });
        }
        return object2;
      },
      (knownGoodValue, newValue) => {
        if (typeof newValue !== "object" || newValue === null) {
          throw new ValidationError(`Expected object, got ${typeToString(newValue)}`);
        }
        let isDifferent = false;
        for (const [key, value] of Object.entries(newValue)) {
          if (!hasOwnProperty(knownGoodValue, key)) {
            isDifferent = true;
            prefixError(key, () => {
              keyValidator.validate(key);
              valueValidator.validate(value);
            });
            continue;
          }
          const prev = getOwnProperty(knownGoodValue, key);
          const next = value;
          if (Object.is(prev, next)) {
            continue;
          }
          const checked = prefixError(key, () => {
            if (valueValidator.validateUsingKnownGoodVersion) {
              return valueValidator.validateUsingKnownGoodVersion(prev, next);
            } else {
              return valueValidator.validate(next);
            }
          });
          if (!Object.is(checked, prev)) {
            isDifferent = true;
          }
        }
        for (const key of Object.keys(knownGoodValue)) {
          if (!hasOwnProperty(newValue, key)) {
            isDifferent = true;
            break;
          }
        }
        return isDifferent ? newValue : knownGoodValue;
      }
    );
    this.keyValidator = keyValidator;
    this.valueValidator = valueValidator;
  }
}
function typeofValidator(type) {
  return new Validator((value) => {
    if (typeof value !== type) {
      throw new ValidationError(`Expected ${type}, got ${typeToString(value)}`);
    }
    return value;
  });
}
const unknown = new Validator((value) => value);
const any = new Validator((value) => value);
const string = typeofValidator("string");
const number = typeofValidator("number").check((number2) => {
  if (Number.isNaN(number2)) {
    throw new ValidationError("Expected a number, got NaN");
  }
  if (!Number.isFinite(number2)) {
    throw new ValidationError(`Expected a finite number, got ${number2}`);
  }
});
const positiveNumber = number.check((value) => {
  if (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`);
});
const nonZeroNumber = number.check((value) => {
  if (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`);
});
const integer = number.check((value) => {
  if (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`);
});
const positiveInteger = integer.check((value) => {
  if (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`);
});
const nonZeroInteger = integer.check((value) => {
  if (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`);
});
const boolean = typeofValidator("boolean");
function literal(expectedValue) {
  return new Validator((actualValue) => {
    if (actualValue !== expectedValue) {
      throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`);
    }
    return expectedValue;
  });
}
const array = new Validator((value) => {
  if (!Array.isArray(value)) {
    throw new ValidationError(`Expected an array, got ${typeToString(value)}`);
  }
  return value;
});
function arrayOf(itemValidator) {
  return new ArrayOfValidator(itemValidator);
}
function object(config) {
  return new ObjectValidator(config);
}
function isPlainObject$1(value) {
  return typeof value === "object" && value !== null && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null || Object.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE);
}
function isValidJson(value) {
  if (value === null || typeof value === "number" || typeof value === "string" || typeof value === "boolean") {
    return true;
  }
  if (Array.isArray(value)) {
    return value.every(isValidJson);
  }
  if (isPlainObject$1(value)) {
    return Object.values(value).every(isValidJson);
  }
  return false;
}
const jsonValue = new Validator(
  (value) => {
    if (isValidJson(value)) {
      return value;
    }
    throw new ValidationError(`Expected json serializable value, got ${typeof value}`);
  },
  (knownGoodValue, newValue) => {
    if (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {
      let isDifferent = knownGoodValue.length !== newValue.length;
      for (let i = 0; i < newValue.length; i++) {
        if (i >= knownGoodValue.length) {
          isDifferent = true;
          jsonValue.validate(newValue[i]);
          continue;
        }
        const prev = knownGoodValue[i];
        const next = newValue[i];
        if (Object.is(prev, next)) {
          continue;
        }
        const checked = jsonValue.validateUsingKnownGoodVersion(prev, next);
        if (!Object.is(checked, prev)) {
          isDifferent = true;
        }
      }
      return isDifferent ? newValue : knownGoodValue;
    } else if (isPlainObject$1(knownGoodValue) && isPlainObject$1(newValue)) {
      let isDifferent = false;
      for (const key of Object.keys(newValue)) {
        if (!hasOwnProperty(knownGoodValue, key)) {
          isDifferent = true;
          jsonValue.validate(newValue[key]);
          continue;
        }
        const prev = knownGoodValue[key];
        const next = newValue[key];
        if (Object.is(prev, next)) {
          continue;
        }
        const checked = jsonValue.validateUsingKnownGoodVersion(prev, next);
        if (!Object.is(checked, prev)) {
          isDifferent = true;
        }
      }
      for (const key of Object.keys(knownGoodValue)) {
        if (!hasOwnProperty(newValue, key)) {
          isDifferent = true;
          break;
        }
      }
      return isDifferent ? newValue : knownGoodValue;
    } else {
      return jsonValue.validate(newValue);
    }
  }
);
function dict(keyValidator, valueValidator) {
  return new DictValidator(keyValidator, valueValidator);
}
function union(key, config) {
  return new UnionValidator(
    key,
    config,
    (_unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    },
    false
  );
}
function numberUnion(key, config) {
  return new UnionValidator(
    key,
    config,
    (unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    },
    true
  );
}
function model(name, validator) {
  return new Validator(
    (value) => {
      return prefixError(name, () => validator.validate(value));
    },
    (prevValue, newValue) => {
      return prefixError(name, () => {
        if (validator.validateUsingKnownGoodVersion) {
          return validator.validateUsingKnownGoodVersion(prevValue, newValue);
        } else {
          return validator.validate(newValue);
        }
      });
    }
  );
}
function setEnum(values) {
  return new Validator((value) => {
    if (!values.has(value)) {
      const valuesString = Array.from(values, (value2) => JSON.stringify(value2)).join(" or ");
      throw new ValidationError(`Expected ${valuesString}, got ${value}`);
    }
    return value;
  });
}
function optional(validator) {
  return new Validator(
    (value) => {
      if (value === void 0) return void 0;
      return validator.validate(value);
    },
    (knownGoodValue, newValue) => {
      if (knownGoodValue === void 0 && newValue === void 0) return void 0;
      if (newValue === void 0) return void 0;
      if (validator.validateUsingKnownGoodVersion && knownGoodValue !== void 0) {
        return validator.validateUsingKnownGoodVersion(knownGoodValue, newValue);
      }
      return validator.validate(newValue);
    }
  );
}
function nullable(validator) {
  return new Validator(
    (value) => {
      if (value === null) return null;
      return validator.validate(value);
    },
    (knownGoodValue, newValue) => {
      if (newValue === null) return null;
      if (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {
        return validator.validateUsingKnownGoodVersion(knownGoodValue, newValue);
      }
      return validator.validate(newValue);
    }
  );
}
function literalEnum(...values) {
  return setEnum(new Set(values));
}
function parseUrl(str2) {
  try {
    return new URL(str2);
  } catch {
    if (str2.startsWith("/") || str2.startsWith("./")) {
      try {
        return new URL(str2, "http://example.com");
      } catch {
        throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str2)}`);
      }
    }
    throw new ValidationError(`Expected a valid url, got ${JSON.stringify(str2)}`);
  }
}
const validLinkProtocols = /* @__PURE__ */ new Set(["http:", "https:", "mailto:"]);
const linkUrl = string.check((value) => {
  if (value === "") return;
  const url = parseUrl(value);
  if (!validLinkProtocols.has(url.protocol.toLowerCase())) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
const validSrcProtocols = /* @__PURE__ */ new Set(["http:", "https:", "data:", "asset:"]);
const srcUrl = string.check((value) => {
  if (value === "") return;
  const url = parseUrl(value);
  if (!validSrcProtocols.has(url.protocol.toLowerCase())) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
string.check((value) => {
  if (value === "") return;
  const url = parseUrl(value);
  if (!url.protocol.toLowerCase().match(/^https?:$/)) {
    throw new ValidationError(
      `Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`
    );
  }
});
const indexKey = string.refine((key) => {
  try {
    validateIndexKey(key);
    return key;
  } catch {
    throw new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`);
  }
});
registerTldrawLibraryVersion(
  "@tldraw/validate",
  "3.13.1",
  "esm"
);
function idValidator(prefix) {
  return string.refine((id) => {
    if (!id.startsWith(`${prefix}:`)) {
      throw new Error(`${prefix} ID must start with "${prefix}:"`);
    }
    return id;
  });
}
const assetIdValidator = idValidator("asset");
function createAssetValidator(type, props) {
  return object({
    id: assetIdValidator,
    typeName: literal("asset"),
    type: literal(type),
    props,
    meta: jsonValue
  });
}
const vecModelValidator = object({
  x: number,
  y: number,
  z: number.optional()
});
const boxModelValidator = object({
  x: number,
  y: number,
  w: number,
  h: number
});
const opacityValidator = number.check((n2) => {
  if (n2 < 0 || n2 > 1) {
    throw new ValidationError("Opacity must be between 0 and 1");
  }
});
const parentIdValidator = string.refine((id) => {
  if (!id.startsWith("page:") && !id.startsWith("shape:")) {
    throw new Error('Parent ID must start with "page:" or "shape:"');
  }
  return id;
});
const shapeIdValidator = idValidator("shape");
function createShapeValidator(type, props, meta) {
  return object({
    id: shapeIdValidator,
    typeName: literal("shape"),
    x: number,
    y: number,
    rotation: number,
    index: indexKey,
    parentId: parentIdValidator,
    type: literal(type),
    isLocked: boolean,
    opacity: opacityValidator,
    props: props ? object(props) : jsonValue,
    meta: meta ? object(meta) : jsonValue
  });
}
const bindingIdValidator = idValidator("binding");
function createBindingValidator(type, props, meta) {
  return object({
    id: bindingIdValidator,
    typeName: literal("binding"),
    type: literal(type),
    fromId: shapeIdValidator,
    toId: shapeIdValidator,
    props: props ? object(props) : jsonValue,
    meta: meta ? object(meta) : jsonValue
  });
}
createMigrationIds("com.tldraw.binding", {});
createRecordMigrationSequence({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function createBindingId(id) {
  return `binding:${uniqueId()}`;
}
function createBindingPropsMigrationSequence(migrations) {
  return migrations;
}
function createBindingPropsMigrationIds(bindingType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.binding.${bindingType}/${v}`);
}
function createBindingRecordType(bindings) {
  return createRecordType("binding", {
    scope: "document",
    validator: model(
      "binding",
      union(
        "type",
        mapObjectMapValues(
          bindings,
          (type, { props, meta }) => createBindingValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}
class StyleProp {
  /** @internal */
  constructor(id, defaultValue, type) {
    this.id = id;
    this.defaultValue = defaultValue;
    this.type = type;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(uniqueId2, options) {
    const { defaultValue, type = any } = options;
    return new StyleProp(uniqueId2, defaultValue, type);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(uniqueId2, options) {
    const { defaultValue, values } = options;
    return new EnumStyleProp(uniqueId2, defaultValue, values);
  }
  setDefaultValue(value) {
    this.defaultValue = value;
  }
  validate(value) {
    return this.type.validate(value);
  }
  validateUsingKnownGoodVersion(prevValue, newValue) {
    if (this.type.validateUsingKnownGoodVersion) {
      return this.type.validateUsingKnownGoodVersion(prevValue, newValue);
    } else {
      return this.validate(newValue);
    }
  }
}
class EnumStyleProp extends StyleProp {
  /** @internal */
  constructor(id, defaultValue, values) {
    super(id, defaultValue, literalEnum(...values));
    this.values = values;
  }
}
const rootShapeVersions = createMigrationIds("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
});
const rootShapeMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: rootShapeVersions.AddIsLocked,
      up: (record) => {
        record.isLocked = false;
      },
      down: (record) => {
        delete record.isLocked;
      }
    },
    {
      id: rootShapeVersions.HoistOpacity,
      up: (record) => {
        record.opacity = Number(record.props.opacity ?? "1");
        delete record.props.opacity;
      },
      down: (record) => {
        const opacity = record.opacity;
        delete record.opacity;
        record.props.opacity = opacity < 0.175 ? "0.1" : opacity < 0.375 ? "0.25" : opacity < 0.625 ? "0.5" : opacity < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: rootShapeVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: rootShapeVersions.AddWhite,
      up: (_record) => {
      },
      down: (record) => {
        if (record.props.color === "white") {
          record.props.color = "black";
        }
      }
    }
  ]
});
function isShape(record) {
  if (!record) return false;
  return record.typeName === "shape";
}
function isShapeId(id) {
  if (!id) return false;
  return id.startsWith("shape:");
}
function createShapeId(id) {
  return `shape:${id ?? uniqueId()}`;
}
function getShapePropKeysByStyle(props) {
  const propKeysByStyle = /* @__PURE__ */ new Map();
  for (const [key, prop] of Object.entries(props)) {
    if (prop instanceof StyleProp) {
      if (propKeysByStyle.has(prop)) {
        throw new Error(
          `Duplicate style prop ${prop.id}. Each style prop can only be used once within a shape.`
        );
      }
      propKeysByStyle.set(prop, key);
    }
  }
  return propKeysByStyle;
}
function createShapePropsMigrationSequence(migrations) {
  return migrations;
}
function createShapePropsMigrationIds(shapeType, ids) {
  return mapObjectMapValues(ids, (_k, v) => `com.tldraw.shape.${shapeType}/${v}`);
}
function createShapeRecordType(shapes) {
  return createRecordType("shape", {
    scope: "document",
    validator: model(
      "shape",
      union(
        "type",
        mapObjectMapValues(
          shapes,
          (type, { props, meta }) => createShapeValidator(type, props, meta)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: false,
    opacity: 1,
    meta: {}
  }));
}
function processPropsMigrations(typeName, records) {
  const result = [];
  for (const [subType, { migrations }] of Object.entries(records)) {
    const sequenceId = `com.tldraw.${typeName}.${subType}`;
    if (!migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: []
        })
      );
    } else if ("sequenceId" in migrations) {
      assert(
        sequenceId === migrations.sequenceId,
        `sequenceId mismatch for ${subType} ${RecordType} migrations. Expected '${sequenceId}', got '${migrations.sequenceId}'`
      );
      result.push(migrations);
    } else if ("sequence" in migrations) {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: migrations.sequence.map(
            (m) => "id" in m ? createPropsMigration(typeName, subType, m) : m
          )
        })
      );
    } else {
      result.push(
        createMigrationSequence({
          sequenceId,
          retroactive: true,
          sequence: Object.keys(migrations.migrators).map((k) => Number(k)).sort((a2, b) => a2 - b).map(
            (version2) => ({
              id: `${sequenceId}/${version2}`,
              scope: "record",
              filter: (r2) => r2.typeName === typeName && r2.type === subType,
              up: (record) => {
                const result2 = migrations.migrators[version2].up(record);
                if (result2) {
                  return result2;
                }
              },
              down: (record) => {
                const result2 = migrations.migrators[version2].down(record);
                if (result2) {
                  return result2;
                }
              }
            })
          )
        })
      );
    }
  }
  return result;
}
function createPropsMigration(typeName, subType, m) {
  return {
    id: m.id,
    dependsOn: m.dependsOn,
    scope: "record",
    filter: (r2) => r2.typeName === typeName && r2.type === subType,
    up: (record) => {
      const result = m.up(record.props);
      if (result) {
        record.props = result;
      }
    },
    down: typeof m.down === "function" ? (record) => {
      const result = m.down(record.props);
      if (result) {
        record.props = result;
      }
    } : void 0
  };
}
const defaultColorNames = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
];
const DefaultColorThemePalette = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "#f9fafb",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      frame: {
        headingStroke: "#717171",
        headingFill: "#ffffff",
        stroke: "#717171",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#FCE19C",
        text: "#000000"
      },
      semi: "#e8e8e8",
      pattern: "#494949",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8205 0.05)"
      }
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      frame: {
        headingStroke: "#6681ec",
        headingFill: "#f9fafe",
        stroke: "#6681ec",
        fill: "#f9fafe",
        text: "#000000"
      },
      note: {
        fill: "#8AA3FF",
        text: "#000000"
      },
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlight: {
        srgb: "#10acff",
        p3: "color(display-p3 0.308 0.6632 0.9996)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      frame: {
        headingStroke: "#37a684",
        headingFill: "#f8fcfa",
        stroke: "#37a684",
        fill: "#f8fcfa",
        text: "#000000"
      },
      note: {
        fill: "#6FC896",
        text: "#000000"
      },
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlight: {
        srgb: "#00ffc8",
        p3: "color(display-p3 0.2536 0.984 0.7981)"
      }
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      frame: {
        headingStroke: "#aaaaab",
        headingFill: "#fbfcfc",
        stroke: "#aaaaab",
        fill: "#fcfcfd",
        text: "#000000"
      },
      note: {
        fill: "#C0CAD3",
        text: "#000000"
      },
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlight: {
        srgb: "#cbe7f1",
        p3: "color(display-p3 0.8163 0.9023 0.9416)"
      }
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      frame: {
        headingStroke: "#6cb2f3",
        headingFill: "#f8fbfe",
        stroke: "#6cb2f3",
        fill: "#fafcff",
        text: "#000000"
      },
      note: {
        fill: "#9BC4FD",
        text: "#000000"
      },
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlight: {
        srgb: "#00f4ff",
        p3: "color(display-p3 0.1512 0.9414 0.9996)"
      }
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      frame: {
        headingStroke: "#6dbe7c",
        headingFill: "#f8fcf9",
        stroke: "#6dbe7c",
        fill: "#fafdfa",
        text: "#000000"
      },
      note: {
        fill: "#98D08A",
        text: "#000000"
      },
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlight: {
        srgb: "#65f641",
        p3: "color(display-p3 0.563 0.9495 0.3857)"
      }
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      frame: {
        headingStroke: "#f89090",
        headingFill: "#fffafa",
        stroke: "#f89090",
        fill: "#fffbfb",
        text: "#000000"
      },
      note: {
        fill: "#F7A5A1",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlight: {
        srgb: "#ff7fa3",
        p3: "color(display-p3 0.9988 0.5301 0.6397)"
      }
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      frame: {
        headingStroke: "#e59bf5",
        headingFill: "#fefaff",
        stroke: "#e59bf5",
        fill: "#fefbff",
        text: "#000000"
      },
      note: {
        fill: "#DFB0F9",
        text: "#000000"
      },
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlight: {
        srgb: "#ff88ff",
        p3: "color(display-p3 0.9676 0.5652 0.9999)"
      }
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      frame: {
        headingStroke: "#e68544",
        headingFill: "#fef9f6",
        stroke: "#e68544",
        fill: "#fef9f6",
        text: "#000000"
      },
      note: {
        fill: "#FAA475",
        text: "#000000"
      },
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlight: {
        srgb: "#ffa500",
        p3: "color(display-p3 0.9988 0.6905 0.266)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      frame: {
        headingStroke: "#e55757",
        headingFill: "#fef7f7",
        stroke: "#e55757",
        fill: "#fef9f9",
        text: "#000000"
      },
      note: {
        fill: "#FC8282",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#e55959",
      highlight: {
        srgb: "#ff636e",
        p3: "color(display-p3 0.9992 0.4376 0.45)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      frame: {
        headingStroke: "#bc62d3",
        headingFill: "#fcf7fd",
        stroke: "#bc62d3",
        fill: "#fdf9fd",
        text: "#000000"
      },
      note: {
        fill: "#DB91FD",
        text: "#000000"
      },
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlight: {
        srgb: "#c77cff",
        p3: "color(display-p3 0.7469 0.5089 0.9995)"
      }
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      frame: {
        headingStroke: "#f3bb6c",
        headingFill: "#fefcf8",
        stroke: "#f3bb6c",
        fill: "#fffdfa",
        text: "#000000"
      },
      note: {
        fill: "#FED49A",
        text: "#000000"
      },
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frame: {
        headingStroke: "#7d7d7d",
        headingFill: "#ffffff",
        stroke: "#7d7d7d",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#FFFFFF",
        text: "#000000"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      frame: {
        headingStroke: "#5c5c5c",
        headingFill: "#252525",
        stroke: "#5c5c5c",
        fill: "#0c0c0c",
        text: "#f2f2f2"
      },
      note: {
        fill: "#2c2c2c",
        text: "#f2f2f2"
      },
      semi: "#2c3036",
      pattern: "#989898",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.6225 0.0312)"
      }
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      frame: {
        headingStroke: "#384994",
        headingFill: "#1C2036",
        stroke: "#384994",
        fill: "#11141f",
        text: "#f2f2f2"
      },
      note: {
        fill: "#2A3F98",
        text: "#f2f2f2"
      },
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlight: {
        srgb: "#0079d2",
        p3: "color(display-p3 0.0032 0.4655 0.7991)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      frame: {
        headingStroke: "#10513C",
        headingFill: "#14241f",
        stroke: "#10513C",
        fill: "#0E1614",
        text: "#f2f2f2"
      },
      note: {
        fill: "#014429",
        text: "#f2f2f2"
      },
      semi: "#253231",
      pattern: "#366a53",
      highlight: {
        srgb: "#009774",
        p3: "color(display-p3 0.0085 0.582 0.4604)"
      }
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      frame: {
        headingStroke: "#42474D",
        headingFill: "#23262A",
        stroke: "#42474D",
        fill: "#151719",
        text: "#f2f2f2"
      },
      note: {
        fill: "#56595F",
        text: "#f2f2f2"
      },
      semi: "#33373c",
      pattern: "#7c8187",
      highlight: {
        srgb: "#9cb4cb",
        p3: "color(display-p3 0.6299 0.7012 0.7856)"
      }
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      frame: {
        headingStroke: "#075797",
        headingFill: "#142839",
        stroke: "#075797",
        fill: "#0B1823",
        text: "#f2f2f2"
      },
      note: {
        fill: "#1F5495",
        text: "#f2f2f2"
      },
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlight: {
        srgb: "#00bdc8",
        p3: "color(display-p3 0.0023 0.7259 0.7735)"
      }
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      frame: {
        headingStroke: "#1C5427",
        headingFill: "#18251A",
        stroke: "#1C5427",
        fill: "#0F1911",
        text: "#f2f2f2"
      },
      note: {
        fill: "#21581D",
        text: "#f2f2f2"
      },
      semi: "#2a3830",
      pattern: "#4e874e",
      highlight: {
        srgb: "#00a000",
        p3: "color(display-p3 0.2711 0.6172 0.0195)"
      }
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      frame: {
        headingStroke: "#6f3232",
        // Darker and desaturated variant of solid
        headingFill: "#341818",
        // Deep, muted dark red
        stroke: "#6f3232",
        // Matches headingStroke
        fill: "#181212",
        // Darker, muted background shade
        text: "#f2f2f2"
        // Consistent bright text color
      },
      note: {
        fill: "#7a3333",
        // Medium-dark, muted variant of solid
        text: "#f2f2f2"
      },
      semi: "#3c2b2b",
      // Subdued, darker neutral-red tone
      pattern: "#a56767",
      // Existing pattern shade retained
      highlight: {
        srgb: "#db005b",
        p3: "color(display-p3 0.7849 0.0585 0.3589)"
      }
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      frame: {
        headingStroke: "#6c367a",
        headingFill: "#2D2230",
        stroke: "#6c367a",
        fill: "#1C151E",
        text: "#f2f2f2"
      },
      note: {
        fill: "#762F8E",
        text: "#f2f2f2"
      },
      semi: "#383442",
      pattern: "#9770a9",
      highlight: {
        srgb: "#c400c7",
        p3: "color(display-p3 0.7024 0.0403 0.753)"
      }
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      frame: {
        headingStroke: "#773a0e",
        // Darker, muted version of solid
        headingFill: "#2f1d13",
        // Deep, warm, muted background
        stroke: "#773a0e",
        // Matches headingStroke
        fill: "#1c1512",
        // Darker, richer muted background
        text: "#f2f2f2"
        // Bright text for contrast
      },
      note: {
        fill: "#7c3905",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#3b2e27",
      // Muted neutral-orange tone
      pattern: "#9f552d",
      // Retained existing shade
      highlight: {
        srgb: "#d07a00",
        p3: "color(display-p3 0.7699 0.4937 0.0085)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      frame: {
        headingStroke: "#701e1e",
        // Darker, muted variation of solid
        headingFill: "#301616",
        // Deep, muted reddish backdrop
        stroke: "#701e1e",
        // Matches headingStroke
        fill: "#1b1313",
        // Rich, dark muted background
        text: "#f2f2f2"
        // Bright text for readability
      },
      note: {
        fill: "#7e201f",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#382726",
      // Dark neutral-red tone
      pattern: "#8f3734",
      // Existing pattern color retained
      highlight: {
        srgb: "#de002c",
        p3: "color(display-p3 0.7978 0.0509 0.2035)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      frame: {
        headingStroke: "#6d1583",
        // Darker, muted variation of solid
        headingFill: "#27152e",
        // Deep, rich muted violet backdrop
        stroke: "#6d1583",
        // Matches headingStroke
        fill: "#1b0f21",
        // Darker muted violet background
        text: "#f2f2f2"
        // Consistent bright text color
      },
      note: {
        fill: "#5f1c70",
        // Muted dark variant for note fill
        text: "#f2f2f2"
      },
      semi: "#342938",
      // Dark neutral-violet tone
      pattern: "#763a8b",
      // Retained existing pattern color
      highlight: {
        srgb: "#9e00ee",
        p3: "color(display-p3 0.5651 0.0079 0.8986)"
      }
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      frame: {
        headingStroke: "#684e12",
        // Darker, muted variant of solid
        headingFill: "#2a2113",
        // Rich, muted dark-yellow background
        stroke: "#684e12",
        // Matches headingStroke
        fill: "#1e1911",
        // Darker muted shade for background fill
        text: "#f2f2f2"
        // Bright text color for readability
      },
      note: {
        fill: "#8a5e1c",
        // Muted, dark complementary variant
        text: "#f2f2f2"
      },
      semi: "#3b352b",
      // Dark muted neutral-yellow tone
      pattern: "#fecb92",
      // Existing shade retained
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      frame: {
        headingStroke: "#ffffff",
        headingFill: "#ffffff",
        stroke: "#ffffff",
        fill: "#ffffff",
        text: "#000000"
      },
      note: {
        fill: "#eaeaea",
        text: "#1d1d1d"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  }
};
function getDefaultColorTheme(opts) {
  return opts.isDarkMode ? DefaultColorThemePalette.darkMode : DefaultColorThemePalette.lightMode;
}
const DefaultColorStyle = StyleProp.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: defaultColorNames
});
const DefaultLabelColorStyle = StyleProp.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: defaultColorNames
});
const DefaultDashStyle = StyleProp.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
});
const DefaultFillStyle = StyleProp.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill"]
});
const DefaultFontStyle = StyleProp.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
});
const DefaultFontFamilies = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
};
const DefaultSizeStyle = StyleProp.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
});
const arrowKinds = ["arc", "elbow"];
const ArrowShapeKindStyle = StyleProp.defineEnum("tldraw:arrowKind", {
  defaultValue: "arc",
  values: arrowKinds
});
const arrowheadTypes = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
];
const ArrowShapeArrowheadStartStyle = StyleProp.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: arrowheadTypes
});
const ArrowShapeArrowheadEndStyle = StyleProp.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: arrowheadTypes
});
const arrowShapeProps = {
  kind: ArrowShapeKindStyle,
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  arrowheadStart: ArrowShapeArrowheadStartStyle,
  arrowheadEnd: ArrowShapeArrowheadEndStyle,
  font: DefaultFontStyle,
  start: vecModelValidator,
  end: vecModelValidator,
  bend: number,
  text: string,
  labelPosition: number,
  scale: nonZeroNumber,
  elbowMidPoint: number
};
const arrowShapeVersions = createShapePropsMigrationIds("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5,
  AddElbow: 6
});
function propsMigration(migration) {
  return createPropsMigration("shape", "arrow", migration);
}
const arrowShapeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: false,
  sequence: [
    propsMigration({
      id: arrowShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    }),
    propsMigration({
      id: arrowShapeVersions.AddIsPrecise,
      up: ({ start, end }) => {
        if (start.type === "binding") {
          start.isPrecise = !(start.normalizedAnchor.x === 0.5 && start.normalizedAnchor.y === 0.5);
        }
        if (end.type === "binding") {
          end.isPrecise = !(end.normalizedAnchor.x === 0.5 && end.normalizedAnchor.y === 0.5);
        }
      },
      down: ({ start, end }) => {
        if (start.type === "binding") {
          if (!start.isPrecise) {
            start.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete start.isPrecise;
        }
        if (end.type === "binding") {
          if (!end.isPrecise) {
            end.normalizedAnchor = { x: 0.5, y: 0.5 };
          }
          delete end.isPrecise;
        }
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddLabelPosition,
      up: (props) => {
        props.labelPosition = 0.5;
      },
      down: (props) => {
        delete props.labelPosition;
      }
    }),
    {
      id: arrowShapeVersions.ExtractBindings,
      scope: "store",
      up: (oldStore) => {
        const arrows = Object.values(oldStore).filter(
          (r2) => r2.typeName === "shape" && r2.type === "arrow"
        );
        for (const arrow2 of arrows) {
          const { start, end } = arrow2.props;
          if (start.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow2.id,
              toId: start.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: start.normalizedAnchor,
                isExact: start.isExact,
                isPrecise: start.isPrecise
              }
            };
            oldStore[id] = binding;
            arrow2.props.start = { x: 0, y: 0 };
          } else {
            delete arrow2.props.start.type;
          }
          if (end.type === "binding") {
            const id = createBindingId();
            const binding = {
              typeName: "binding",
              id,
              type: "arrow",
              fromId: arrow2.id,
              toId: end.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: end.normalizedAnchor,
                isExact: end.isExact,
                isPrecise: end.isPrecise
              }
            };
            oldStore[id] = binding;
            arrow2.props.end = { x: 0, y: 0 };
          } else {
            delete arrow2.props.end.type;
          }
        }
      }
    },
    propsMigration({
      id: arrowShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }),
    propsMigration({
      id: arrowShapeVersions.AddElbow,
      up: (props) => {
        props.kind = "arc";
        props.elbowMidPoint = 0.5;
      },
      down: (props) => {
        delete props.kind;
        delete props.elbowMidPoint;
      }
    })
  ]
});
const ElbowArrowSnap = literalEnum("center", "edge-point", "edge", "none");
const arrowBindingProps = {
  terminal: literalEnum("start", "end"),
  normalizedAnchor: vecModelValidator,
  isExact: boolean,
  isPrecise: boolean,
  snap: ElbowArrowSnap
};
const arrowBindingVersions = createBindingPropsMigrationIds("arrow", {
  AddSnap: 1
});
const arrowBindingMigrations = createBindingPropsMigrationSequence({
  sequence: [
    { dependsOn: [arrowShapeVersions.ExtractBindings] },
    {
      id: arrowBindingVersions.AddSnap,
      up: (props) => {
        props.snap = "none";
      },
      down: (props) => {
        delete props.snap;
      }
    }
  ]
});
const cameraValidator = model(
  "camera",
  object({
    typeName: literal("camera"),
    id: idValidator("camera"),
    x: number,
    y: number,
    z: number,
    meta: jsonValue
  })
);
const cameraVersions = createMigrationIds("com.tldraw.camera", {
  AddMeta: 1
});
const cameraMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: cameraVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const CameraRecordType = createRecordType("camera", {
  validator: cameraValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
);
const TL_CURSOR_TYPES = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]);
const cursorTypeValidator = setEnum(TL_CURSOR_TYPES);
const cursorValidator = object({
  type: cursorTypeValidator,
  rotation: number
});
const TL_CANVAS_UI_COLOR_TYPES = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]);
const canvasUiColorTypeValidator = setEnum(TL_CANVAS_UI_COLOR_TYPES);
const TL_SCRIBBLE_STATES = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]);
const scribbleValidator = object({
  id: string,
  points: arrayOf(vecModelValidator),
  size: positiveNumber,
  color: canvasUiColorTypeValidator,
  opacity: number,
  state: setEnum(TL_SCRIBBLE_STATES),
  delay: number,
  shrink: number,
  taper: boolean
});
const pageIdValidator = idValidator("page");
const pageValidator = model(
  "page",
  object({
    typeName: literal("page"),
    id: pageIdValidator,
    name: string,
    index: indexKey,
    meta: jsonValue
  })
);
const pageVersions = createMigrationIds("com.tldraw.page", {
  AddMeta: 1
});
const pageMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: pageVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const PageRecordType = createRecordType("page", {
  validator: pageValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function isPageId(id) {
  return PageRecordType.isId(id);
}
const shouldKeyBePreservedBetweenSessions = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: false,
  // meta
  typeName: false,
  // meta
  currentPageId: false,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: false,
  // does not preserve because it's a temporary state
  stylesForNextShape: false,
  // does not preserve because it's a temporary state
  followingUserId: false,
  // does not preserve because it's a temporary state
  highlightedUserIds: false,
  // does not preserve because it's a temporary state
  brush: false,
  // does not preserve because it's a temporary state
  cursor: false,
  // does not preserve because it's a temporary state
  scribbles: false,
  // does not preserve because it's a temporary state
  isFocusMode: true,
  // preserves because it's a user preference
  isDebugMode: true,
  // preserves because it's a user preference
  isToolLocked: true,
  // preserves because it's a user preference
  exportBackground: true,
  // preserves because it's a user preference
  screenBounds: true,
  // preserves because it's capturing the user's screen state
  insets: true,
  // preserves because it's capturing the user's screen state
  zoomBrush: false,
  // does not preserve because it's a temporary state
  chatMessage: false,
  // does not preserve because it's a temporary state
  isChatting: false,
  // does not preserve because it's a temporary state
  isPenMode: false,
  // does not preserve because it's a temporary state
  isGridMode: true,
  // preserves because it's a user preference
  isFocused: true,
  // preserves because obviously
  devicePixelRatio: true,
  // preserves because it captures the user's screen state
  isCoarsePointer: true,
  // preserves because it captures the user's screen state
  isHoveringCanvas: false,
  // does not preserve because it's a temporary state
  openMenus: false,
  // does not preserve because it's a temporary state
  isChangingStyle: false,
  // does not preserve because it's a temporary state
  isReadonly: true,
  // preserves because it's a config option
  meta: false,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: false
  //
};
function pluckPreservingValues(val) {
  return val ? filterEntries(val, (key) => {
    return shouldKeyBePreservedBetweenSessions[key];
  }) : null;
}
idValidator("instance");
function createInstanceRecordType(stylesById) {
  const stylesForNextShapeValidators = {};
  for (const [id, style2] of stylesById) {
    stylesForNextShapeValidators[id] = optional(style2);
  }
  const instanceTypeValidator = model(
    "instance",
    object({
      typeName: literal("instance"),
      id: idValidator("instance"),
      currentPageId: pageIdValidator,
      followingUserId: string.nullable(),
      brush: boxModelValidator.nullable(),
      opacityForNextShape: opacityValidator,
      stylesForNextShape: object(stylesForNextShapeValidators),
      cursor: cursorValidator,
      scribbles: arrayOf(scribbleValidator),
      isFocusMode: boolean,
      isDebugMode: boolean,
      isToolLocked: boolean,
      exportBackground: boolean,
      screenBounds: boxModelValidator,
      insets: arrayOf(boolean),
      zoomBrush: boxModelValidator.nullable(),
      isPenMode: boolean,
      isGridMode: boolean,
      chatMessage: string,
      isChatting: boolean,
      highlightedUserIds: arrayOf(string),
      isFocused: boolean,
      devicePixelRatio: number,
      isCoarsePointer: boolean,
      isHoveringCanvas: boolean.nullable(),
      openMenus: arrayOf(string),
      isChangingStyle: boolean,
      isReadonly: boolean,
      meta: jsonValue,
      duplicateProps: object({
        shapeIds: arrayOf(idValidator("shape")),
        offset: object({
          x: number,
          y: number
        })
      }).nullable()
    })
  );
  return createRecordType("instance", {
    validator: instanceTypeValidator,
    scope: "session",
    ephemeralKeys: {
      currentPageId: false,
      meta: false,
      followingUserId: true,
      opacityForNextShape: true,
      stylesForNextShape: true,
      brush: true,
      cursor: true,
      scribbles: true,
      isFocusMode: true,
      isDebugMode: true,
      isToolLocked: true,
      exportBackground: true,
      screenBounds: true,
      insets: true,
      zoomBrush: true,
      isPenMode: true,
      isGridMode: true,
      chatMessage: true,
      isChatting: true,
      highlightedUserIds: true,
      isFocused: true,
      devicePixelRatio: true,
      isCoarsePointer: true,
      isHoveringCanvas: true,
      openMenus: true,
      isChangingStyle: true,
      isReadonly: true,
      duplicateProps: true
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: false,
      exportBackground: false,
      isDebugMode: false,
      isToolLocked: false,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [false, false, false, false],
      zoomBrush: null,
      isGridMode: false,
      isPenMode: false,
      chatMessage: "",
      isChatting: false,
      highlightedUserIds: [],
      isFocused: false,
      devicePixelRatio: typeof window === "undefined" ? 1 : window.devicePixelRatio,
      isCoarsePointer: false,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: false,
      isReadonly: false,
      meta: {},
      duplicateProps: null
    })
  );
}
const instanceVersions = createMigrationIds("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
});
const instanceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: instanceVersions.AddTransparentExportBgs,
      up: (instance) => {
        return { ...instance, exportBackground: true };
      }
    },
    {
      id: instanceVersions.RemoveDialog,
      up: ({ dialog: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddToolLockMode,
      up: (instance) => {
        return { ...instance, isToolLocked: false };
      }
    },
    {
      id: instanceVersions.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: Object.fromEntries(
            Object.entries(propsForNextShape).filter(
              ([key]) => [
                "color",
                "labelColor",
                "dash",
                "fill",
                "size",
                "font",
                "align",
                "verticalAlign",
                "icon",
                "geo",
                "arrowheadStart",
                "arrowheadEnd",
                "spline"
              ].includes(key)
            )
          )
        };
      }
    },
    {
      id: instanceVersions.AddLabelColor,
      up: ({ propsForNextShape, ...instance }) => {
        return {
          ...instance,
          propsForNextShape: {
            ...propsForNextShape,
            labelColor: "black"
          }
        };
      }
    },
    {
      id: instanceVersions.AddFollowingUserId,
      up: (instance) => {
        return { ...instance, followingUserId: null };
      }
    },
    {
      id: instanceVersions.RemoveAlignJustify,
      up: (instance) => {
        let newAlign = instance.propsForNextShape.align;
        if (newAlign === "justify") {
          newAlign = "start";
        }
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            align: newAlign
          }
        };
      }
    },
    {
      id: instanceVersions.AddZoom,
      up: (instance) => {
        return { ...instance, zoomBrush: null };
      }
    },
    {
      id: instanceVersions.AddVerticalAlign,
      up: (instance) => {
        return {
          ...instance,
          propsForNextShape: {
            ...instance.propsForNextShape,
            verticalAlign: "middle"
          }
        };
      }
    },
    {
      id: instanceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          return { ...instance, scribble: { ...instance.scribble, delay: 0 } };
        }
        return { ...instance };
      }
    },
    {
      id: instanceVersions.RemoveUserId,
      up: ({ userId: _, ...instance }) => {
        return instance;
      }
    },
    {
      id: instanceVersions.AddIsPenModeAndIsGridMode,
      up: (instance) => {
        return { ...instance, isPenMode: false, isGridMode: false };
      }
    },
    {
      id: instanceVersions.HoistOpacity,
      up: ({ propsForNextShape: { opacity, ...propsForNextShape }, ...instance }) => {
        return { ...instance, opacityForNextShape: Number(opacity ?? "1"), propsForNextShape };
      }
    },
    {
      id: instanceVersions.AddChat,
      up: (instance) => {
        return { ...instance, chatMessage: "", isChatting: false };
      }
    },
    {
      id: instanceVersions.AddHighlightedUserIds,
      up: (instance) => {
        return { ...instance, highlightedUserIds: [] };
      }
    },
    {
      id: instanceVersions.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: _, ...instance }) => {
        return { ...instance, stylesForNextShape: {} };
      }
    },
    {
      id: instanceVersions.AddMeta,
      up: (record) => {
        return {
          ...record,
          meta: {}
        };
      }
    },
    {
      id: instanceVersions.RemoveCursorColor,
      up: (record) => {
        const { color: _, ...cursor } = record.cursor;
        return {
          ...record,
          cursor
        };
      }
    },
    {
      id: instanceVersions.AddLonelyProperties,
      up: (record) => {
        return {
          ...record,
          canMoveCamera: true,
          isFocused: false,
          devicePixelRatio: 1,
          isCoarsePointer: false,
          openMenus: [],
          isChangingStyle: false,
          isReadOnly: false
        };
      }
    },
    {
      id: instanceVersions.ReadOnlyReadonly,
      up: ({ isReadOnly: _isReadOnly, ...record }) => {
        return {
          ...record,
          isReadonly: _isReadOnly
        };
      }
    },
    {
      id: instanceVersions.AddHoveringCanvas,
      up: (record) => {
        return {
          ...record,
          isHoveringCanvas: null
        };
      }
    },
    {
      id: instanceVersions.AddScribbles,
      up: ({ scribble: _, ...record }) => {
        return {
          ...record,
          scribbles: []
        };
      }
    },
    {
      id: instanceVersions.AddInset,
      up: (record) => {
        return {
          ...record,
          insets: [false, false, false, false]
        };
      },
      down: ({ insets: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.AddDuplicateProps,
      up: (record) => {
        return {
          ...record,
          duplicateProps: null
        };
      },
      down: ({ duplicateProps: _, ...record }) => {
        return {
          ...record
        };
      }
    },
    {
      id: instanceVersions.RemoveCanMoveCamera,
      up: ({ canMoveCamera: _, ...record }) => {
        return {
          ...record
        };
      },
      down: (instance) => {
        return { ...instance, canMoveCamera: true };
      }
    }
  ]
});
const TLINSTANCE_ID = "instance:instance";
const instancePageStateValidator = model(
  "instance_page_state",
  object({
    typeName: literal("instance_page_state"),
    id: idValidator("instance_page_state"),
    pageId: pageIdValidator,
    selectedShapeIds: arrayOf(shapeIdValidator),
    hintingShapeIds: arrayOf(shapeIdValidator),
    erasingShapeIds: arrayOf(shapeIdValidator),
    hoveredShapeId: shapeIdValidator.nullable(),
    editingShapeId: shapeIdValidator.nullable(),
    croppingShapeId: shapeIdValidator.nullable(),
    focusedGroupId: shapeIdValidator.nullable(),
    meta: jsonValue
  })
);
const instancePageStateVersions = createMigrationIds("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
});
const instancePageStateMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: instancePageStateVersions.AddCroppingId,
      up(instance) {
        instance.croppingShapeId = null;
      }
    },
    {
      id: instancePageStateVersions.RemoveInstanceIdAndCameraId,
      up(instance) {
        delete instance.instanceId;
        delete instance.cameraId;
      }
    },
    {
      id: instancePageStateVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePageStateVersions.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (_record) => {
      },
      down: (_record) => {
      }
    },
    {
      id: instancePageStateVersions.RenamePropertiesAgain,
      up: (record) => {
        record.selectedShapeIds = record.selectedIds;
        delete record.selectedIds;
        record.hintingShapeIds = record.hintingIds;
        delete record.hintingIds;
        record.erasingShapeIds = record.erasingIds;
        delete record.erasingIds;
        record.hoveredShapeId = record.hoveredId;
        delete record.hoveredId;
        record.editingShapeId = record.editingId;
        delete record.editingId;
        record.croppingShapeId = record.croppingShapeId ?? record.croppingId ?? null;
        delete record.croppingId;
        record.focusedGroupId = record.focusLayerId;
        delete record.focusLayerId;
      },
      down: (record) => {
        record.selectedIds = record.selectedShapeIds;
        delete record.selectedShapeIds;
        record.hintingIds = record.hintingShapeIds;
        delete record.hintingShapeIds;
        record.erasingIds = record.erasingShapeIds;
        delete record.erasingShapeIds;
        record.hoveredId = record.hoveredShapeId;
        delete record.hoveredShapeId;
        record.editingId = record.editingShapeId;
        delete record.editingShapeId;
        record.croppingId = record.croppingShapeId;
        delete record.croppingShapeId;
        record.focusLayerId = record.focusedGroupId;
        delete record.focusedGroupId;
      }
    }
  ]
});
const InstancePageStateRecordType = createRecordType(
  "instance_page_state",
  {
    validator: instancePageStateValidator,
    scope: "session",
    ephemeralKeys: {
      pageId: false,
      selectedShapeIds: false,
      editingShapeId: false,
      croppingShapeId: false,
      meta: false,
      hintingShapeIds: true,
      erasingShapeIds: true,
      hoveredShapeId: true,
      focusedGroupId: true
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
);
const pointerValidator = model(
  "pointer",
  object({
    typeName: literal("pointer"),
    id: idValidator("pointer"),
    x: number,
    y: number,
    lastActivityTimestamp: number,
    meta: jsonValue
  })
);
const pointerVersions = createMigrationIds("com.tldraw.pointer", {
  AddMeta: 1
});
const pointerMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: pointerVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const PointerRecordType = createRecordType("pointer", {
  validator: pointerValidator,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
);
const TLPOINTER_ID = PointerRecordType.createId("pointer");
const instancePresenceValidator = model(
  "instance_presence",
  object({
    typeName: literal("instance_presence"),
    id: idValidator("instance_presence"),
    userId: string,
    userName: string,
    lastActivityTimestamp: number.nullable(),
    followingUserId: string.nullable(),
    cursor: object({
      x: number,
      y: number,
      type: cursorTypeValidator,
      rotation: number
    }).nullable(),
    color: string,
    camera: object({
      x: number,
      y: number,
      z: number
    }).nullable(),
    screenBounds: boxModelValidator.nullable(),
    selectedShapeIds: arrayOf(idValidator("shape")),
    currentPageId: idValidator("page"),
    brush: boxModelValidator.nullable(),
    scribbles: arrayOf(scribbleValidator),
    chatMessage: string,
    meta: jsonValue
  })
);
const instancePresenceVersions = createMigrationIds("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5,
  NullableCameraCursor: 6
});
const instancePresenceMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: instancePresenceVersions.AddScribbleDelay,
      up: (instance) => {
        if (instance.scribble !== null) {
          instance.scribble.delay = 0;
        }
      }
    },
    {
      id: instancePresenceVersions.RemoveInstanceId,
      up: (instance) => {
        delete instance.instanceId;
      }
    },
    {
      id: instancePresenceVersions.AddChatMessage,
      up: (instance) => {
        instance.chatMessage = "";
      }
    },
    {
      id: instancePresenceVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    },
    {
      id: instancePresenceVersions.RenameSelectedShapeIds,
      up: (_record) => {
      }
    },
    {
      id: instancePresenceVersions.NullableCameraCursor,
      up: (_record) => {
      },
      down: (record) => {
        if (record.camera === null) {
          record.camera = { x: 0, y: 0, z: 1 };
        }
        if (record.lastActivityTimestamp === null) {
          record.lastActivityTimestamp = 0;
        }
        if (record.cursor === null) {
          record.cursor = { type: "default", x: 0, y: 0, rotation: 0 };
        }
        if (record.screenBounds === null) {
          record.screenBounds = { x: 0, y: 0, w: 1, h: 1 };
        }
      }
    }
  ]
});
const InstancePresenceRecordType = createRecordType(
  "instance_presence",
  {
    validator: instancePresenceValidator,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: null,
  followingUserId: null,
  color: "#FF0000",
  camera: null,
  cursor: null,
  screenBounds: null,
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
}));
const documentValidator = model(
  "document",
  object({
    typeName: literal("document"),
    id: literal("document:document"),
    gridSize: number,
    name: string,
    meta: jsonValue
  })
);
const documentVersions = createMigrationIds("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
});
const documentMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: documentVersions.AddName,
      up: (document2) => {
        document2.name = "";
      },
      down: (document2) => {
        delete document2.name;
      }
    },
    {
      id: documentVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const DocumentRecordType = createRecordType("document", {
  validator: documentValidator,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
);
const TLDOCUMENT_ID = DocumentRecordType.createId("document");
function sortByIndex(a2, b) {
  if (a2.index < b.index) {
    return -1;
  } else if (a2.index > b.index) {
    return 1;
  }
  return 0;
}
function redactRecordForErrorReporting(record) {
  if (record.typeName === "asset") {
    if ("src" in record) {
      record.src = "<redacted>";
    }
    if ("src" in record.props) {
      record.props.src = "<redacted>";
    }
  }
}
function onValidationFailure({
  error,
  phase,
  record,
  recordBefore
}) {
  const isExistingValidationIssue = (
    // if we're initializing the store for the first time, we should
    // allow invalid records so people can load old buggy data:
    phase === "initialize"
  );
  annotateError(error, {
    tags: {
      origin: "store.validateRecord",
      storePhase: phase,
      isExistingValidationIssue
    },
    extras: {
      recordBefore: recordBefore ? redactRecordForErrorReporting(structuredClone(recordBefore)) : void 0,
      recordAfter: redactRecordForErrorReporting(structuredClone(record))
    }
  });
  throw error;
}
function getDefaultPages() {
  return [
    PageRecordType.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function createIntegrityChecker(store) {
  const $pageIds = store.query.ids("page");
  const $pageStates = store.query.records("instance_page_state");
  const ensureStoreIsUsable = () => {
    if (!store.has(TLDOCUMENT_ID)) {
      store.put([DocumentRecordType.create({ id: TLDOCUMENT_ID, name: store.props.defaultName })]);
      return ensureStoreIsUsable();
    }
    if (!store.has(TLPOINTER_ID)) {
      store.put([PointerRecordType.create({ id: TLPOINTER_ID })]);
      return ensureStoreIsUsable();
    }
    const pageIds = $pageIds.get();
    if (pageIds.size === 0) {
      store.put(getDefaultPages());
      return ensureStoreIsUsable();
    }
    const getFirstPageId = () => [...pageIds].map((id) => store.get(id)).sort(sortByIndex)[0].id;
    const instanceState = store.get(TLINSTANCE_ID);
    if (!instanceState) {
      store.put([
        store.schema.types.instance.create({
          id: TLINSTANCE_ID,
          currentPageId: getFirstPageId(),
          exportBackground: true
        })
      ]);
      return ensureStoreIsUsable();
    } else if (!pageIds.has(instanceState.currentPageId)) {
      store.put([{ ...instanceState, currentPageId: getFirstPageId() }]);
      return ensureStoreIsUsable();
    }
    const missingPageStateIds = /* @__PURE__ */ new Set();
    const missingCameraIds = /* @__PURE__ */ new Set();
    for (const id of pageIds) {
      const pageStateId = InstancePageStateRecordType.createId(id);
      const pageState = store.get(pageStateId);
      if (!pageState) {
        missingPageStateIds.add(pageStateId);
      }
      const cameraId = CameraRecordType.createId(id);
      if (!store.has(cameraId)) {
        missingCameraIds.add(cameraId);
      }
    }
    if (missingPageStateIds.size > 0) {
      store.put(
        [...missingPageStateIds].map(
          (id) => InstancePageStateRecordType.create({
            id,
            pageId: InstancePageStateRecordType.parseId(id)
          })
        )
      );
    }
    if (missingCameraIds.size > 0) {
      store.put([...missingCameraIds].map((id) => CameraRecordType.create({ id })));
    }
    const pageStates = $pageStates.get();
    for (const pageState of pageStates) {
      if (!pageIds.has(pageState.pageId)) {
        store.remove([pageState.id]);
        continue;
      }
      if (pageState.croppingShapeId && !store.has(pageState.croppingShapeId)) {
        store.put([{ ...pageState, croppingShapeId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.focusedGroupId && !store.has(pageState.focusedGroupId)) {
        store.put([{ ...pageState, focusedGroupId: null }]);
        return ensureStoreIsUsable();
      }
      if (pageState.hoveredShapeId && !store.has(pageState.hoveredShapeId)) {
        store.put([{ ...pageState, hoveredShapeId: null }]);
        return ensureStoreIsUsable();
      }
      const filteredSelectedIds = pageState.selectedShapeIds.filter((id) => store.has(id));
      if (filteredSelectedIds.length !== pageState.selectedShapeIds.length) {
        store.put([{ ...pageState, selectedShapeIds: filteredSelectedIds }]);
        return ensureStoreIsUsable();
      }
      const filteredHintingIds = pageState.hintingShapeIds.filter((id) => store.has(id));
      if (filteredHintingIds.length !== pageState.hintingShapeIds.length) {
        store.put([{ ...pageState, hintingShapeIds: filteredHintingIds }]);
        return ensureStoreIsUsable();
      }
      const filteredErasingIds = pageState.erasingShapeIds.filter((id) => store.has(id));
      if (filteredErasingIds.length !== pageState.erasingShapeIds.length) {
        store.put([{ ...pageState, erasingShapeIds: filteredErasingIds }]);
        return ensureStoreIsUsable();
      }
    }
  };
  return ensureStoreIsUsable;
}
const bookmarkAssetValidator = createAssetValidator(
  "bookmark",
  object({
    title: string,
    description: string,
    image: string,
    favicon: string,
    src: srcUrl.nullable()
  })
);
const Versions$e = createMigrationIds("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
});
const bookmarkAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (asset) => asset.type === "bookmark",
  sequence: [
    {
      id: Versions$e.MakeUrlsValid,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions$e.AddFavicon,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.favicon)) {
          asset.props.favicon = "";
        }
      },
      down: (asset) => {
        delete asset.props.favicon;
      }
    }
  ]
});
const imageAssetValidator = createAssetValidator(
  "image",
  object({
    w: number,
    h: number,
    name: string,
    isAnimated: boolean,
    mimeType: string.nullable(),
    src: srcUrl.nullable(),
    fileSize: nonZeroNumber.optional()
  })
);
const Versions$d = createMigrationIds("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
const imageAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (asset) => asset.type === "image",
  sequence: [
    {
      id: Versions$d.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions$d.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions$d.MakeUrlsValid,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions$d.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions$d.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});
const videoAssetValidator = createAssetValidator(
  "video",
  object({
    w: number,
    h: number,
    name: string,
    isAnimated: boolean,
    mimeType: string.nullable(),
    src: srcUrl.nullable(),
    fileSize: number.optional()
  })
);
const Versions$c = createMigrationIds("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
});
const videoAssetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (asset) => asset.type === "video",
  sequence: [
    {
      id: Versions$c.AddIsAnimated,
      up: (asset) => {
        asset.props.isAnimated = false;
      },
      down: (asset) => {
        delete asset.props.isAnimated;
      }
    },
    {
      id: Versions$c.RenameWidthHeight,
      up: (asset) => {
        asset.props.w = asset.props.width;
        asset.props.h = asset.props.height;
        delete asset.props.width;
        delete asset.props.height;
      },
      down: (asset) => {
        asset.props.width = asset.props.w;
        asset.props.height = asset.props.h;
        delete asset.props.w;
        delete asset.props.h;
      }
    },
    {
      id: Versions$c.MakeUrlsValid,
      up: (asset) => {
        if (!srcUrl.isValid(asset.props.src)) {
          asset.props.src = "";
        }
      },
      down: (_asset) => {
      }
    },
    {
      id: Versions$c.AddFileSize,
      up: (asset) => {
        asset.props.fileSize = -1;
      },
      down: (asset) => {
        delete asset.props.fileSize;
      }
    },
    {
      id: Versions$c.MakeFileSizeOptional,
      up: (asset) => {
        if (asset.props.fileSize === -1) {
          asset.props.fileSize = void 0;
        }
      },
      down: (asset) => {
        if (asset.props.fileSize === void 0) {
          asset.props.fileSize = -1;
        }
      }
    }
  ]
});
const assetValidator = model(
  "asset",
  union("type", {
    image: imageAssetValidator,
    video: videoAssetValidator,
    bookmark: bookmarkAssetValidator
  })
);
const assetVersions = createMigrationIds("com.tldraw.asset", {
  AddMeta: 1
});
const assetMigrations = createRecordMigrationSequence({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: assetVersions.AddMeta,
      up: (record) => {
        record.meta = {};
      }
    }
  ]
});
const AssetRecordType = createRecordType("asset", {
  validator: assetValidator,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
const bookmarkShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  assetId: assetIdValidator.nullable(),
  url: linkUrl
};
const Versions$b = createShapePropsMigrationIds("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
});
const bookmarkShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$b.NullAssetId,
      up: (props) => {
        if (props.assetId === void 0) {
          props.assetId = null;
        }
      },
      down: "retired"
    },
    {
      id: Versions$b.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    }
  ]
});
const DrawShapeSegment = object({
  type: literalEnum("free", "straight"),
  points: arrayOf(vecModelValidator)
});
const drawShapeProps = {
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  segments: arrayOf(DrawShapeSegment),
  isComplete: boolean,
  isClosed: boolean,
  isPen: boolean,
  scale: nonZeroNumber
};
const Versions$a = createShapePropsMigrationIds("draw", {
  AddInPen: 1,
  AddScale: 2
});
const drawShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$a.AddInPen,
      up: (props) => {
        const { points } = props.segments[0];
        if (points.length === 0) {
          props.isPen = false;
          return;
        }
        let isPen = !(points[0].z === 0 || points[0].z === 0.5);
        if (points[1]) {
          isPen = isPen && !(points[1].z === 0 || points[1].z === 0.5);
        }
        props.isPen = isPen;
      },
      down: "retired"
    },
    {
      id: Versions$a.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});
const TLDRAW_APP_RE$1 = /(^\/r\/[^/]+\/?$)/;
const EMBED_DEFINITIONS = [
  {
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE$1)) {
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["figma.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    }
  },
  {
    hostnames: ["google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom");
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoom}z`;
      }
      return;
    }
  },
  {
    hostnames: ["val.town"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codesandbox.io"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    }
  },
  {
    hostnames: ["codepen.io"],
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["scratch.mit.edu"],
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          return `https://www.youtube.com/watch?v=${matches2[1]}`;
        }
      }
      return;
    }
  },
  {
    hostnames: ["calendar.google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj?.searchParams.get("src");
      if (urlObj?.pathname.match(/\/calendar\/embed/) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["docs.google.*"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/embed\/?$/)) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["gist.github.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["replit.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["felt.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    hostnames: ["open.spotify.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    hostnames: ["vimeo.com", "player.vimeo.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    hostnames: ["excalidraw.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hash.match(/#room=/)) {
        return url;
      }
      return;
    }
  },
  {
    hostnames: ["observablehq.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    hostnames: ["desmos.com"],
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
const embedShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  url: string
};
const Versions$9 = createShapePropsMigrationIds("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
});
const embedShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$9.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (props) => {
        try {
          const url = props.url;
          const host = new URL(url).host.replace("www.", "");
          let originalUrl;
          for (const localEmbedDef of EMBED_DEFINITIONS) {
            if (localEmbedDef.hostnames.includes(host)) {
              try {
                originalUrl = localEmbedDef.fromEmbedUrl(url);
              } catch (err) {
                console.warn(err);
              }
            }
          }
          props.tmpOldUrl = props.url;
          props.url = originalUrl ?? "";
        } catch {
          props.url = "";
          props.tmpOldUrl = props.url;
        }
      },
      down: "retired"
    },
    {
      id: Versions$9.RemoveDoesResize,
      up: (props) => {
        delete props.doesResize;
      },
      down: "retired"
    },
    {
      id: Versions$9.RemoveTmpOldUrl,
      up: (props) => {
        delete props.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: Versions$9.RemovePermissionOverrides,
      up: (props) => {
        delete props.overridePermissions;
      },
      down: "retired"
    }
  ]
});
const frameShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  name: string,
  // because shape colors are an option, we don't want them to be picked up by the editor as a
  // style prop by default, so instead of a proper style we just supply an equivalent validator.
  // Check `FrameShapeUtil.configure` for how we replace this with the original
  // `DefaultColorStyle` style when the option is turned on.
  color: literalEnum(...DefaultColorStyle.values)
};
const Versions$8 = createShapePropsMigrationIds("frame", {
  AddColorProp: 1
});
const frameShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$8.AddColorProp,
      up: (props) => {
        props.color = "black";
      },
      down: (props) => {
        delete props.color;
      }
    }
  ]
});
const richTextValidator = object({ type: string, content: arrayOf(unknown) });
function toRichText(text) {
  const lines = text.split("\n");
  const content = lines.map((text2) => {
    if (!text2) {
      return {
        type: "paragraph"
      };
    }
    return {
      type: "paragraph",
      content: [{ type: "text", text: text2 }]
    };
  });
  return {
    type: "doc",
    content
  };
}
const DefaultHorizontalAlignStyle = StyleProp.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
});
const DefaultVerticalAlignStyle = StyleProp.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
});
const GeoShapeGeoStyle = StyleProp.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
});
const geoShapeProps = {
  geo: GeoShapeGeoStyle,
  labelColor: DefaultLabelColorStyle,
  color: DefaultColorStyle,
  fill: DefaultFillStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  url: linkUrl,
  w: nonZeroNumber,
  h: nonZeroNumber,
  growY: positiveNumber,
  richText: richTextValidator,
  scale: nonZeroNumber
};
const geoShapeVersions = createShapePropsMigrationIds("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9,
  AddRichText: 10
});
const geoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: geoShapeVersions.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCheckBox,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MigrateLegacyAlign,
      up: (props) => {
        let newAlign;
        switch (props.align) {
          case "start":
            newAlign = "start-legacy";
            break;
          case "end":
            newAlign = "end-legacy";
            break;
          default:
            newAlign = "middle-legacy";
            break;
        }
        props.align = newAlign;
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.AddCloud,
      up: (_props) => {
      },
      down: "retired"
    },
    {
      id: geoShapeVersions.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: geoShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: geoShapeVersions.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});
const groupShapeProps = {};
const groupShapeMigrations = createShapePropsMigrationSequence({ sequence: [] });
const highlightShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  segments: arrayOf(DrawShapeSegment),
  isComplete: boolean,
  isPen: boolean,
  scale: nonZeroNumber
};
const Versions$7 = createShapePropsMigrationIds("highlight", {
  AddScale: 1
});
const highlightShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$7.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});
const ImageShapeCrop = object({
  topLeft: vecModelValidator,
  bottomRight: vecModelValidator
});
const imageShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  playing: boolean,
  url: linkUrl,
  assetId: assetIdValidator.nullable(),
  crop: ImageShapeCrop.nullable(),
  flipX: boolean,
  flipY: boolean,
  altText: string
};
const Versions$6 = createShapePropsMigrationIds("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4,
  AddAltText: 5
});
const imageShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$6.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions$6.AddCropProp,
      up: (props) => {
        props.crop = null;
      },
      down: (props) => {
        delete props.crop;
      }
    },
    {
      id: Versions$6.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions$6.AddFlipProps,
      up: (props) => {
        props.flipX = false;
        props.flipY = false;
      },
      down: (props) => {
        delete props.flipX;
        delete props.flipY;
      }
    },
    {
      id: Versions$6.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    }
  ]
});
const LineShapeSplineStyle = StyleProp.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
});
const lineShapePointValidator = object({
  id: string,
  index: indexKey,
  x: number,
  y: number
});
const lineShapeProps = {
  color: DefaultColorStyle,
  dash: DefaultDashStyle,
  size: DefaultSizeStyle,
  spline: LineShapeSplineStyle,
  points: dict(string, lineShapePointValidator),
  scale: nonZeroNumber
};
const lineShapeVersions = createShapePropsMigrationIds("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
});
const lineShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: lineShapeVersions.AddSnapHandles,
      up: (props) => {
        for (const handle of Object.values(props.handles)) {
          handle.canSnap = true;
        }
      },
      down: "retired"
    },
    {
      id: lineShapeVersions.RemoveExtraHandleProps,
      up: (props) => {
        props.handles = objectMapFromEntries(
          Object.values(props.handles).map((handle) => [
            handle.index,
            {
              x: handle.x,
              y: handle.y
            }
          ])
        );
      },
      down: (props) => {
        const handles = Object.entries(props.handles).map(([index2, handle]) => ({ index: index2, ...handle })).sort(sortByIndex$1);
        props.handles = Object.fromEntries(
          handles.map((handle, i) => {
            const id = i === 0 ? "start" : i === handles.length - 1 ? "end" : `handle:${handle.index}`;
            return [
              id,
              {
                id,
                type: "vertex",
                canBind: false,
                canSnap: true,
                index: handle.index,
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
      }
    },
    {
      id: lineShapeVersions.HandlesToPoints,
      up: (props) => {
        const sortedHandles = Object.entries(props.handles).map(([index2, { x, y: y2 }]) => ({ x, y: y2, index: index2 })).sort(sortByIndex$1);
        props.points = sortedHandles.map(({ x, y: y2 }) => ({ x, y: y2 }));
        delete props.handles;
      },
      down: (props) => {
        const indices = getIndices(props.points.length);
        props.handles = Object.fromEntries(
          props.points.map((handle, i) => {
            const index2 = indices[i];
            return [
              index2,
              {
                x: handle.x,
                y: handle.y
              }
            ];
          })
        );
        delete props.points;
      }
    },
    {
      id: lineShapeVersions.PointIndexIds,
      up: (props) => {
        const indices = getIndices(props.points.length);
        props.points = Object.fromEntries(
          props.points.map((point, i) => {
            const id = indices[i];
            return [
              id,
              {
                id,
                index: id,
                x: point.x,
                y: point.y
              }
            ];
          })
        );
      },
      down: (props) => {
        const sortedHandles = Object.values(props.points).sort(sortByIndex$1);
        props.points = sortedHandles.map(({ x, y: y2 }) => ({ x, y: y2 }));
      }
    },
    {
      id: lineShapeVersions.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    }
  ]
});
const noteShapeProps = {
  color: DefaultColorStyle,
  labelColor: DefaultLabelColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  fontSizeAdjustment: positiveNumber,
  align: DefaultHorizontalAlignStyle,
  verticalAlign: DefaultVerticalAlignStyle,
  growY: positiveNumber,
  url: linkUrl,
  richText: richTextValidator,
  scale: nonZeroNumber
};
const Versions$5 = createShapePropsMigrationIds("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7,
  AddLabelColor: 8,
  AddRichText: 9
});
const noteShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$5.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions$5.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions$5.MigrateLegacyAlign,
      up: (props) => {
        switch (props.align) {
          case "start":
            props.align = "start-legacy";
            return;
          case "end":
            props.align = "end-legacy";
            return;
          default:
            props.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: Versions$5.AddVerticalAlign,
      up: (props) => {
        props.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Versions$5.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions$5.AddFontSizeAdjustment,
      up: (props) => {
        props.fontSizeAdjustment = 0;
      },
      down: (props) => {
        delete props.fontSizeAdjustment;
      }
    },
    {
      id: Versions$5.AddScale,
      up: (props) => {
        props.scale = 1;
      },
      down: (props) => {
        delete props.scale;
      }
    },
    {
      id: Versions$5.AddLabelColor,
      up: (props) => {
        props.labelColor = "black";
      },
      down: (props) => {
        delete props.labelColor;
      }
    },
    {
      id: Versions$5.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});
const DefaultTextAlignStyle = StyleProp.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
});
const textShapeProps = {
  color: DefaultColorStyle,
  size: DefaultSizeStyle,
  font: DefaultFontStyle,
  textAlign: DefaultTextAlignStyle,
  w: nonZeroNumber,
  richText: richTextValidator,
  scale: nonZeroNumber,
  autoSize: boolean
};
const Versions$4 = createShapePropsMigrationIds("text", {
  RemoveJustify: 1,
  AddTextAlign: 2,
  AddRichText: 3
});
const textShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$4.RemoveJustify,
      up: (props) => {
        if (props.align === "justify") {
          props.align = "start";
        }
      },
      down: "retired"
    },
    {
      id: Versions$4.AddTextAlign,
      up: (props) => {
        props.textAlign = props.align;
        delete props.align;
      },
      down: (props) => {
        props.align = props.textAlign;
        delete props.textAlign;
      }
    },
    {
      id: Versions$4.AddRichText,
      up: (props) => {
        props.richText = toRichText(props.text);
        delete props.text;
      }
      // N.B. Explicitly no down state so that we force clients to update.
      // down: (props) => {
      // 	delete props.richText
      // },
    }
  ]
});
const videoShapeProps = {
  w: nonZeroNumber,
  h: nonZeroNumber,
  time: number,
  playing: boolean,
  url: linkUrl,
  assetId: assetIdValidator.nullable(),
  altText: string
};
const Versions$3 = createShapePropsMigrationIds("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2,
  AddAltText: 3
});
const videoShapeMigrations = createShapePropsMigrationSequence({
  sequence: [
    {
      id: Versions$3.AddUrlProp,
      up: (props) => {
        props.url = "";
      },
      down: "retired"
    },
    {
      id: Versions$3.MakeUrlsValid,
      up: (props) => {
        if (!linkUrl.isValid(props.url)) {
          props.url = "";
        }
      },
      down: (_props) => {
      }
    },
    {
      id: Versions$3.AddAltText,
      up: (props) => {
        props.altText = "";
      },
      down: (props) => {
        delete props.altText;
      }
    }
  ]
});
const Versions$2 = createMigrationIds("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4
});
const storeMigrations = createMigrationSequence({
  sequenceId: "com.tldraw.store",
  retroactive: false,
  sequence: [
    {
      id: Versions$2.RemoveCodeAndIconShapeTypes,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName === "shape" && (record.type === "icon" || record.type === "code")) {
            delete store[id];
          }
        }
      }
    },
    {
      id: Versions$2.AddInstancePresenceType,
      scope: "store",
      up(_store) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: Versions$2.RemoveTLUserAndPresenceAndAddPointer,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName.match(/^(user|user_presence)$/)) {
            delete store[id];
          }
        }
      }
    },
    {
      // remove user document records
      id: Versions$2.RemoveUserDocument,
      scope: "store",
      up: (store) => {
        for (const [id, record] of objectMapEntries(store)) {
          if (record.typeName.match("user_document")) {
            delete store[id];
          }
        }
      }
    }
  ]
});
const defaultShapeSchemas = {
  arrow: { migrations: arrowShapeMigrations, props: arrowShapeProps },
  bookmark: { migrations: bookmarkShapeMigrations, props: bookmarkShapeProps },
  draw: { migrations: drawShapeMigrations, props: drawShapeProps },
  embed: { migrations: embedShapeMigrations, props: embedShapeProps },
  frame: { migrations: frameShapeMigrations, props: frameShapeProps },
  geo: { migrations: geoShapeMigrations, props: geoShapeProps },
  group: { migrations: groupShapeMigrations, props: groupShapeProps },
  highlight: { migrations: highlightShapeMigrations, props: highlightShapeProps },
  image: { migrations: imageShapeMigrations, props: imageShapeProps },
  line: { migrations: lineShapeMigrations, props: lineShapeProps },
  note: { migrations: noteShapeMigrations, props: noteShapeProps },
  text: { migrations: textShapeMigrations, props: textShapeProps },
  video: { migrations: videoShapeMigrations, props: videoShapeProps }
};
const defaultBindingSchemas = {
  arrow: { migrations: arrowBindingMigrations, props: arrowBindingProps }
};
function createTLSchema({
  shapes = defaultShapeSchemas,
  bindings = defaultBindingSchemas,
  migrations
} = {}) {
  const stylesById = /* @__PURE__ */ new Map();
  for (const shape of objectMapValues(shapes)) {
    for (const style2 of getShapePropKeysByStyle(shape.props ?? {}).keys()) {
      if (stylesById.has(style2.id) && stylesById.get(style2.id) !== style2) {
        throw new Error(`Multiple StyleProp instances with the same id: ${style2.id}`);
      }
      stylesById.set(style2.id, style2);
    }
  }
  const ShapeRecordType = createShapeRecordType(shapes);
  const BindingRecordType = createBindingRecordType(bindings);
  const InstanceRecordType = createInstanceRecordType(stylesById);
  return StoreSchema.create(
    {
      asset: AssetRecordType,
      binding: BindingRecordType,
      camera: CameraRecordType,
      document: DocumentRecordType,
      instance: InstanceRecordType,
      instance_page_state: InstancePageStateRecordType,
      page: PageRecordType,
      instance_presence: InstancePresenceRecordType,
      pointer: PointerRecordType,
      shape: ShapeRecordType
    },
    {
      migrations: [
        storeMigrations,
        assetMigrations,
        cameraMigrations,
        documentMigrations,
        instanceMigrations,
        instancePageStateMigrations,
        pageMigrations,
        instancePresenceMigrations,
        pointerMigrations,
        rootShapeMigrations,
        bookmarkAssetMigrations,
        imageAssetMigrations,
        videoAssetMigrations,
        ...processPropsMigrations("shape", shapes),
        ...processPropsMigrations("binding", bindings),
        ...migrations ?? []
      ],
      onValidationFailure,
      createIntegrityChecker
    }
  );
}
const LANGUAGES = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ms", label: "Bahasa Melayu" },
  { locale: "ca", label: "Català" },
  { locale: "cs", label: "Čeština" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "tl", label: "Filipino" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "nl", label: "Nederlands" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "sl", label: "Slovenščina" },
  { locale: "so", label: "Somali" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "tr", label: "Türkçe" },
  { locale: "el", label: "Ελληνικά" },
  { locale: "ru", label: "Русский" },
  { locale: "uk", label: "Українська" },
  { locale: "he", label: "עברית" },
  { locale: "ur", label: "اردو" },
  { locale: "ar", label: "عربي" },
  { locale: "fa", label: "فارسی" },
  { locale: "ne", label: "नेपाली" },
  { locale: "mr", label: "मराठी" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "bn", label: "বাংলা" },
  { locale: "pa", label: "ਪੰਜਾਬੀ" },
  { locale: "gu-in", label: "ગુજરાતી" },
  { locale: "ta", label: "தமிழ்" },
  { locale: "te", label: "తెలుగు" },
  { locale: "kn", label: "ಕನ್ನಡ" },
  { locale: "ml", label: "മലയാളം" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "km-kh", label: "ភាសាខ្មែរ" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ja", label: "日本語" },
  { locale: "zh-cn", label: "简体中文" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
];
function getDefaultTranslationLocale() {
  const locales = typeof window !== "undefined" ? window.navigator.languages ?? ["en"] : ["en"];
  return _getDefaultTranslationLocale(locales);
}
function _getDefaultTranslationLocale(locales) {
  for (const locale of locales) {
    const supportedLocale = getSupportedLocale(locale);
    if (supportedLocale) {
      return supportedLocale;
    }
  }
  return "en";
}
const DEFAULT_LOCALE_REGIONS = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function getSupportedLocale(locale) {
  const exactMatch = LANGUAGES.find((t2) => t2.locale === locale.toLowerCase());
  if (exactMatch) {
    return exactMatch.locale;
  }
  const [language, region] = locale.split(/[-_]/).map((s2) => s2.toLowerCase());
  if (region) {
    const languageMatch = LANGUAGES.find((t2) => t2.locale === language);
    if (languageMatch) {
      return languageMatch.locale;
    }
  }
  if (language in DEFAULT_LOCALE_REGIONS) {
    return DEFAULT_LOCALE_REGIONS[language];
  }
  return null;
}
registerTldrawLibraryVersion(
  "@tldraw/tlschema",
  "3.13.1",
  "esm"
);
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n2 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c2, a2, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a2.key && (e = "" + a2.key);
    void 0 !== a2.ref && (h = a2.ref);
    for (b in a2) m.call(a2, b) && !p.hasOwnProperty(b) && (d[b] = a2[b]);
    if (c2 && c2.defaultProps) for (b in a2 = c2.defaultProps, a2) void 0 === d[b] && (d[b] = a2[b]);
    return { $$typeof: k, type: c2, key: e, ref: h, props: d, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames) return classnames.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  return classnames.exports;
}
var classnamesExports = requireClassnames();
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const version = "3.13.1";
const publishDates = {
  major: "2024-09-13T14:36:29.063Z",
  minor: "2025-05-22T13:38:59.946Z"
};
const initialState = { error: null };
class ErrorBoundary extends reactExports.Component {
  static getDerivedStateFromError(error) {
    return { error };
  }
  state = initialState;
  componentDidCatch(error) {
    this.props.onError?.(error);
  }
  render() {
    const { error } = this.state;
    if (error !== null) {
      const { fallback: Fallback } = this.props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Fallback, { error });
    }
    return this.props.children;
  }
}
function OptionalErrorBoundary({
  children,
  fallback,
  ...props
}) {
  if (fallback === null) {
    return children;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback, ...props, children });
}
function suffixSafeId(id, suffix) {
  return sanitizeId(`${id}_${suffix}`);
}
function useUniqueSafeId(suffix) {
  return sanitizeId(`${reactExports.useId()}${suffix ?? ""}`);
}
function useSharedSafeId(id) {
  const idScope = assertExists(reactExports.useContext(IdContext));
  return sanitizeId(`${idScope}_${id}`);
}
function sanitizeId(id) {
  return id.replace(/:/g, "_");
}
const IdContext = reactExports.createContext(null);
function IdProvider({ children }) {
  const id = useUniqueSafeId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IdContext.Provider, { value: id, children });
}
const EditorContext = reactExports.createContext(null);
function useEditor() {
  const editor = React.useContext(EditorContext);
  if (!editor) {
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  }
  return editor;
}
function useMaybeEditor() {
  return React.useContext(EditorContext);
}
function EditorProvider({
  editor,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditorContext.Provider, { value: editor, children: /* @__PURE__ */ jsxRuntimeExports.jsx(IdProvider, { children }) });
}
function DefaultBackground() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-background" });
}
function useTransform(ref, x, y2, scale, rotate, additionalOffset) {
  reactExports.useLayoutEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    if (x === void 0) return;
    let trans = `translate(${x}px, ${y2}px)`;
    if (scale !== void 0) {
      trans += ` scale(${scale})`;
    }
    if (rotate !== void 0) {
      trans += ` rotate(${rotate}rad)`;
    }
    if (additionalOffset) {
      trans += ` translate(${additionalOffset.x}px, ${additionalOffset.y}px)`;
    }
    elm.style.transform = trans;
  });
}
const EASINGS = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => t2 * (2 - t2),
  easeInOutQuad: (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2,
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => --t2 * t2 * t2 + 1,
  easeInOutCubic: (t2) => t2 < 0.5 ? 4 * t2 * t2 * t2 : (t2 - 1) * (2 * t2 - 2) * (2 * t2 - 2) + 1,
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => 1 - --t2 * t2 * t2 * t2,
  easeInOutQuart: (t2) => t2 < 0.5 ? 8 * t2 * t2 * t2 * t2 : 1 - 8 * --t2 * t2 * t2 * t2,
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => 1 + --t2 * t2 * t2 * t2 * t2,
  easeInOutQuint: (t2) => t2 < 0.5 ? 16 * t2 * t2 * t2 * t2 * t2 : 1 + 16 * --t2 * t2 * t2 * t2 * t2,
  easeInSine: (t2) => 1 - Math.cos(t2 * Math.PI / 2),
  easeOutSine: (t2) => Math.sin(t2 * Math.PI / 2),
  easeInOutSine: (t2) => -(Math.cos(Math.PI * t2) - 1) / 2,
  easeInExpo: (t2) => t2 <= 0 ? 0 : Math.pow(2, 10 * t2 - 10),
  easeOutExpo: (t2) => t2 >= 1 ? 1 : 1 - Math.pow(2, -10 * t2),
  easeInOutExpo: (t2) => t2 <= 0 ? 0 : t2 >= 1 ? 1 : t2 < 0.5 ? Math.pow(2, 20 * t2 - 10) / 2 : (2 - Math.pow(2, -20 * t2 + 10)) / 2
};
class Vec {
  constructor(x = 0, y2 = 0, z = 1) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(x = this.x, y2 = this.y, z = this.z) {
    this.x = x;
    this.y = y2;
    this.z = z;
    return this;
  }
  setTo({ x = 0, y: y2 = 0, z = 1 }) {
    this.x = x;
    this.y = y2;
    this.z = z;
    return this;
  }
  rot(r2) {
    if (r2 === 0) return this;
    const { x, y: y2 } = this;
    const s2 = Math.sin(r2);
    const c2 = Math.cos(r2);
    this.x = x * c2 - y2 * s2;
    this.y = x * s2 + y2 * c2;
    return this;
  }
  rotWith(C, r2) {
    if (r2 === 0) return this;
    const x = this.x - C.x;
    const y2 = this.y - C.y;
    const s2 = Math.sin(r2);
    const c2 = Math.cos(r2);
    this.x = C.x + (x * c2 - y2 * s2);
    this.y = C.y + (x * s2 + y2 * c2);
    return this;
  }
  clone() {
    const { x, y: y2, z } = this;
    return new Vec(x, y2, z);
  }
  sub(V2) {
    this.x -= V2.x;
    this.y -= V2.y;
    return this;
  }
  subXY(x, y2) {
    this.x -= x;
    this.y -= y2;
    return this;
  }
  subScalar(n2) {
    this.x -= n2;
    this.y -= n2;
    return this;
  }
  add(V2) {
    this.x += V2.x;
    this.y += V2.y;
    return this;
  }
  addXY(x, y2) {
    this.x += x;
    this.y += y2;
    return this;
  }
  addScalar(n2) {
    this.x += n2;
    this.y += n2;
    return this;
  }
  clamp(min2, max2) {
    this.x = Math.max(this.x, min2);
    this.y = Math.max(this.y, min2);
    if (max2 !== void 0) {
      this.x = Math.min(this.x, max2);
      this.y = Math.min(this.y, max2);
    }
    return this;
  }
  div(t2) {
    this.x /= t2;
    this.y /= t2;
    return this;
  }
  divV(V2) {
    this.x /= V2.x;
    this.y /= V2.y;
    return this;
  }
  mul(t2) {
    this.x *= t2;
    this.y *= t2;
    return this;
  }
  mulV(V2) {
    this.x *= V2.x;
    this.y *= V2.y;
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  }
  nudge(B, distance) {
    const tan = Vec.Tan(B, this);
    return this.add(tan.mul(distance));
  }
  neg() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  cross(V2) {
    this.x = this.y * V2.z - this.z * V2.y;
    this.y = this.z * V2.x - this.x * V2.z;
    return this;
  }
  dpr(V2) {
    return Vec.Dpr(this, V2);
  }
  cpr(V2) {
    return Vec.Cpr(this, V2);
  }
  len2() {
    return Vec.Len2(this);
  }
  len() {
    return Vec.Len(this);
  }
  pry(V2) {
    return Vec.Pry(this, V2);
  }
  per() {
    const { x, y: y2 } = this;
    this.x = y2;
    this.y = -x;
    return this;
  }
  uni() {
    return Vec.Uni(this);
  }
  tan(V2) {
    return Vec.Tan(this, V2);
  }
  dist(V2) {
    return Vec.Dist(this, V2);
  }
  distanceToLineSegment(A, B) {
    return Vec.DistanceToLineSegment(A, B, this);
  }
  slope(B) {
    return Vec.Slope(this, B);
  }
  snapToGrid(gridSize) {
    this.x = Math.round(this.x / gridSize) * gridSize;
    this.y = Math.round(this.y / gridSize) * gridSize;
    return this;
  }
  angle(B) {
    return Vec.Angle(this, B);
  }
  toAngle() {
    return Vec.ToAngle(this);
  }
  lrp(B, t2) {
    this.x = this.x + (B.x - this.x) * t2;
    this.y = this.y + (B.y - this.y) * t2;
    return this;
  }
  equals(B) {
    return Vec.Equals(this, B);
  }
  equalsXY(x, y2) {
    return Vec.EqualsXY(this, x, y2);
  }
  norm() {
    const l = this.len();
    this.x = l === 0 ? 0 : this.x / l;
    this.y = l === 0 ? 0 : this.y / l;
    return this;
  }
  toFixed() {
    return Vec.ToFixed(this);
  }
  toString() {
    return Vec.ToString(Vec.ToFixed(this));
  }
  toJson() {
    return Vec.ToJson(this);
  }
  toArray() {
    return Vec.ToArray(this);
  }
  static Add(A, B) {
    return new Vec(A.x + B.x, A.y + B.y);
  }
  static AddXY(A, x, y2) {
    return new Vec(A.x + x, A.y + y2);
  }
  static Sub(A, B) {
    return new Vec(A.x - B.x, A.y - B.y);
  }
  static SubXY(A, x, y2) {
    return new Vec(A.x - x, A.y - y2);
  }
  static AddScalar(A, n2) {
    return new Vec(A.x + n2, A.y + n2);
  }
  static SubScalar(A, n2) {
    return new Vec(A.x - n2, A.y - n2);
  }
  static Div(A, t2) {
    return new Vec(A.x / t2, A.y / t2);
  }
  static Mul(A, t2) {
    return new Vec(A.x * t2, A.y * t2);
  }
  static DivV(A, B) {
    return new Vec(A.x / B.x, A.y / B.y);
  }
  static MulV(A, B) {
    return new Vec(A.x * B.x, A.y * B.y);
  }
  static Neg(A) {
    return new Vec(-A.x, -A.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(A) {
    return new Vec(A.y, -A.x);
  }
  static Abs(A) {
    return new Vec(Math.abs(A.x), Math.abs(A.y));
  }
  // Get the distance between two points.
  static Dist(A, B) {
    return ((A.y - B.y) ** 2 + (A.x - B.x) ** 2) ** 0.5;
  }
  // Get the Manhattan distance between two points.
  static ManhattanDist(A, B) {
    return Math.abs(A.x - B.x) + Math.abs(A.y - B.y);
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(A, B, n2) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) < n2 ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(A, B) {
    return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(A, B) {
    return A.x * B.x + A.y * B.y;
  }
  static Cross(A, V2) {
    return new Vec(
      A.y * V2.z - A.z * V2.y,
      A.z * V2.x - A.x * V2.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(A, B) {
    return A.x * B.y - B.x * A.y;
  }
  static Len2(A) {
    return A.x * A.x + A.y * A.y;
  }
  static Len(A) {
    return (A.x * A.x + A.y * A.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(A, B) {
    return Vec.Dpr(A, B) / Vec.Len(B);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(A) {
    return Vec.Div(A, Vec.Len(A));
  }
  static Tan(A, B) {
    return Vec.Uni(Vec.Sub(A, B));
  }
  static Min(A, B) {
    return new Vec(Math.min(A.x, B.x), Math.min(A.y, B.y));
  }
  static Max(A, B) {
    return new Vec(Math.max(A.x, B.x), Math.max(A.y, B.y));
  }
  static From({ x, y: y2, z = 1 }) {
    return new Vec(x, y2, z);
  }
  static FromArray(v) {
    return new Vec(v[0], v[1]);
  }
  static Rot(A, r2 = 0) {
    const s2 = Math.sin(r2);
    const c2 = Math.cos(r2);
    return new Vec(A.x * c2 - A.y * s2, A.x * s2 + A.y * c2);
  }
  static RotWith(A, C, r2) {
    const x = A.x - C.x;
    const y2 = A.y - C.y;
    const s2 = Math.sin(r2);
    const c2 = Math.cos(r2);
    return new Vec(C.x + (x * c2 - y2 * s2), C.y + (x * s2 + y2 * c2));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(A, u, P) {
    return Vec.Mul(u, Vec.Sub(P, A).pry(u)).add(A);
  }
  static NearestPointOnLineSegment(A, B, P, clamp2 = true) {
    if (Vec.Equals(A, P)) return Vec.From(P);
    if (Vec.Equals(B, P)) return Vec.From(P);
    const u = Vec.Tan(B, A);
    const C = Vec.Add(A, Vec.Mul(u, Vec.Sub(P, A).pry(u)));
    if (clamp2) {
      if (C.x < Math.min(A.x, B.x)) return Vec.Cast(A.x < B.x ? A : B);
      if (C.x > Math.max(A.x, B.x)) return Vec.Cast(A.x > B.x ? A : B);
      if (C.y < Math.min(A.y, B.y)) return Vec.Cast(A.y < B.y ? A : B);
      if (C.y > Math.max(A.y, B.y)) return Vec.Cast(A.y > B.y ? A : B);
    }
    return C;
  }
  static DistanceToLineThroughPoint(A, u, P) {
    return Vec.Dist(P, Vec.NearestPointOnLineThroughPoint(A, u, P));
  }
  static DistanceToLineSegment(A, B, P, clamp2 = true) {
    return Vec.Dist(P, Vec.NearestPointOnLineSegment(A, B, P, clamp2));
  }
  static Snap(A, step = 1) {
    return new Vec(Math.round(A.x / step) * step, Math.round(A.y / step) * step);
  }
  static Cast(A) {
    if (A instanceof Vec) return A;
    return Vec.From(A);
  }
  static Slope(A, B) {
    if (A.x === B.y) return NaN;
    return (A.y - B.y) / (A.x - B.x);
  }
  static IsNaN(A) {
    return isNaN(A.x) || isNaN(A.y);
  }
  /**
   * Get the angle from position A to position B.
   */
  static Angle(A, B) {
    return Math.atan2(B.y - A.y, B.x - A.x);
  }
  /**
   * Get the angle between vector A and vector B. This will return the smallest angle between the
   * two vectors, between -π and π. The sign indicates direction of angle.
   */
  static AngleBetween(A, B) {
    const p = A.x * B.x + A.y * B.y;
    const n2 = Math.sqrt(
      (Math.pow(A.x, 2) + Math.pow(A.y, 2)) * (Math.pow(B.x, 2) + Math.pow(B.y, 2))
    );
    const sign = A.x * B.y - A.y * B.x < 0 ? -1 : 1;
    const angle = sign * Math.acos(p / n2);
    return angle;
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(A, B, t2) {
    return Vec.Sub(B, A).mul(t2).add(A);
  }
  static Med(A, B) {
    return new Vec((A.x + B.x) / 2, (A.y + B.y) / 2);
  }
  static Equals(A, B) {
    return Math.abs(A.x - B.x) < 1e-4 && Math.abs(A.y - B.y) < 1e-4;
  }
  static EqualsXY(A, x, y2) {
    return A.x === x && A.y === y2;
  }
  static Clockwise(A, B, C) {
    return (C.x - A.x) * (B.y - A.y) - (B.x - A.x) * (C.y - A.y) < 0;
  }
  static Rescale(A, n2) {
    const l = Vec.Len(A);
    return new Vec(n2 * A.x / l, n2 * A.y / l);
  }
  static ScaleWithOrigin(A, scale, origin) {
    return Vec.Sub(A, origin).mul(scale).add(origin);
  }
  static ToFixed(A) {
    return new Vec(toFixed(A.x), toFixed(A.y));
  }
  static ToInt(A) {
    return new Vec(
      parseInt(A.x.toFixed(0)),
      parseInt(A.y.toFixed(0)),
      parseInt((A.z ?? 0).toFixed(0))
    );
  }
  static ToCss(A) {
    return `${A.x},${A.y}`;
  }
  static Nudge(A, B, distance) {
    return Vec.Add(A, Vec.Tan(B, A).mul(distance));
  }
  static ToString(A) {
    return `${A.x}, ${A.y}`;
  }
  static ToAngle(A) {
    let r2 = Math.atan2(A.y, A.x);
    if (r2 < 0) r2 += Math.PI * 2;
    return r2;
  }
  static FromAngle(r2, length = 1) {
    return new Vec(Math.cos(r2) * length, Math.sin(r2) * length);
  }
  static ToArray(A) {
    return [A.x, A.y, A.z];
  }
  static ToJson(A) {
    const { x, y: y2, z } = A;
    return { x, y: y2, z };
  }
  static Average(arr) {
    const len = arr.length;
    const avg = new Vec(0, 0);
    if (len === 0) {
      return avg;
    }
    for (let i = 0; i < len; i++) {
      avg.add(arr[i]);
    }
    return avg.div(len);
  }
  static Clamp(A, min2, max2) {
    if (max2 === void 0) {
      return new Vec(Math.min(Math.max(A.x, min2)), Math.min(Math.max(A.y, min2)));
    }
    return new Vec(Math.min(Math.max(A.x, min2), max2), Math.min(Math.max(A.y, min2), max2));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(A, B, steps = 6) {
    const results = [];
    for (let i = 0; i < steps; i++) {
      const t2 = EASINGS.easeInQuad(i / (steps - 1));
      const point = Vec.Lrp(A, B, t2);
      point.z = Math.min(1, 0.5 + Math.abs(0.5 - ease(t2)) * 0.65);
      results.push(point);
    }
    return results;
  }
  static SnapToGrid(A, gridSize = 8) {
    return new Vec(Math.round(A.x / gridSize) * gridSize, Math.round(A.y / gridSize) * gridSize);
  }
}
const ease = (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;
function precise(A) {
  return `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `;
}
function average(A, B) {
  return `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `;
}
const PI$1 = Math.PI;
const HALF_PI = PI$1 / 2;
const PI2 = PI$1 * 2;
const SIN = Math.sin;
function clamp$3(n2, min2, max2) {
  return Math.max(min2, typeof max2 !== "undefined" ? Math.min(n2, max2) : n2);
}
function toPrecision(n2, precision = 1e10) {
  if (!n2) return 0;
  return Math.round(n2 * precision) / precision;
}
function approximately(a2, b, precision = 1e-6) {
  return Math.abs(a2 - b) <= precision;
}
function perimeterOfEllipse(rx, ry) {
  const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
  return PI$1 * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
}
function canonicalizeRotation(a2) {
  a2 = a2 % PI2;
  if (a2 < 0) {
    a2 = a2 + PI2;
  } else if (a2 === 0) {
    a2 = 0;
  }
  return a2;
}
function clockwiseAngleDist(a0, a1) {
  a0 = canonicalizeRotation(a0);
  a1 = canonicalizeRotation(a1);
  if (a0 > a1) {
    a1 += PI2;
  }
  return a1 - a0;
}
function counterClockwiseAngleDist(a0, a1) {
  return PI2 - clockwiseAngleDist(a0, a1);
}
function shortAngleDist(a0, a1) {
  const da = (a1 - a0) % PI2;
  return 2 * da % PI2 - da;
}
function clampRadians(r2) {
  return (PI2 + r2) % PI2;
}
function areAnglesCompatible(a2, b) {
  return a2 === b || approximately(a2 % (Math.PI / 2) - b % (Math.PI / 2), 0);
}
function radiansToDegrees(r2) {
  return r2 * 180 / PI$1;
}
function getPointOnCircle(center, r2, a2) {
  return new Vec(center.x, center.y).add(Vec.FromAngle(a2, r2));
}
function getPolygonVertices(width, height, sides2) {
  const cx = width / 2;
  const cy = height / 2;
  const pointsOnPerimeter = [];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < sides2; i++) {
    const step = PI2 / sides2;
    const t2 = -HALF_PI + i * step;
    const x = cx + cx * Math.cos(t2);
    const y2 = cy + cy * Math.sin(t2);
    if (x < minX) minX = x;
    if (y2 < minY) minY = y2;
    if (x > maxX) maxX = x;
    if (y2 > maxY) maxY = y2;
    pointsOnPerimeter.push(new Vec(x, y2));
  }
  const w = maxX - minX;
  const h = maxY - minY;
  const dx = width - w;
  const dy = height - h;
  if (dx !== 0 || dy !== 0) {
    for (let i = 0; i < pointsOnPerimeter.length; i++) {
      const pt = pointsOnPerimeter[i];
      pt.x = (pt.x - minX) / w * width;
      pt.y = (pt.y - minY) / h * height;
    }
  }
  return pointsOnPerimeter;
}
function rangesOverlap(a0, a1, b0, b1) {
  return a0 < b1 && b0 < a1;
}
function rangeIntersection(a0, a1, b0, b1) {
  const min2 = Math.max(a0, b0);
  const max2 = Math.min(a1, b1);
  if (min2 <= max2) {
    return [min2, max2];
  }
  return null;
}
function cross(x, y2, z) {
  return (y2.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y2.y - x.y);
}
function pointInPolygon(A, points) {
  let windingNumber = 0;
  let a2;
  let b;
  for (let i = 0; i < points.length; i++) {
    a2 = points[i];
    if (a2.x === A.x && a2.y === A.y) return true;
    b = points[(i + 1) % points.length];
    if (Vec.Dist(A, a2) + Vec.Dist(A, b) === Vec.Dist(a2, b)) return true;
    if (a2.y <= A.y) {
      if (b.y > A.y && cross(a2, b, A) > 0) {
        windingNumber += 1;
      }
    } else if (b.y <= A.y && cross(a2, b, A) < 0) {
      windingNumber -= 1;
    }
  }
  return windingNumber !== 0;
}
function toDomPrecision(v) {
  return Math.round(v * 1e4) / 1e4;
}
function toFixed(v) {
  return Math.round(v * 100) / 100;
}
const isSafeFloat = (n2) => {
  return Math.abs(n2) < Number.MAX_SAFE_INTEGER;
};
function getPointInArcT(mAB, A, B, P) {
  let mAP;
  if (Math.abs(mAB) > PI$1) {
    mAP = shortAngleDist(A, P);
    const mPB = shortAngleDist(P, B);
    if (Math.abs(mAP) < Math.abs(mPB)) {
      return mAP / mAB;
    } else {
      return (mAB - mPB) / mAB;
    }
  } else {
    mAP = shortAngleDist(A, P);
    const t2 = mAP / mAB;
    if (Math.sign(mAP) !== Math.sign(mAB)) {
      return Math.abs(t2) > 0.5 ? 1 : 0;
    }
    return t2;
  }
}
function getArcMeasure(A, B, sweepFlag, largeArcFlag) {
  const m = 2 * ((B - A) % PI2) % PI2 - (B - A) % PI2;
  if (!largeArcFlag) return m;
  return (PI2 - Math.abs(m)) * (sweepFlag ? 1 : -1);
}
function centerOfCircleFromThreePoints(a2, b, c2) {
  const u = -2 * (a2.x * (b.y - c2.y) - a2.y * (b.x - c2.x) + b.x * c2.y - c2.x * b.y);
  const x = ((a2.x * a2.x + a2.y * a2.y) * (c2.y - b.y) + (b.x * b.x + b.y * b.y) * (a2.y - c2.y) + (c2.x * c2.x + c2.y * c2.y) * (b.y - a2.y)) / u;
  const y2 = ((a2.x * a2.x + a2.y * a2.y) * (b.x - c2.x) + (b.x * b.x + b.y * b.y) * (c2.x - a2.x) + (c2.x * c2.x + c2.y * c2.y) * (a2.x - b.x)) / u;
  if (!Number.isFinite(x) || !Number.isFinite(y2)) {
    return null;
  }
  return new Vec(x, y2);
}
function getPointsOnArc(startPoint, endPoint, center, radius, numPoints) {
  if (center === null) {
    return [Vec.From(startPoint), Vec.From(endPoint)];
  }
  const results = [];
  const startAngle = Vec.Angle(center, startPoint);
  const endAngle = Vec.Angle(center, endPoint);
  const l = clockwiseAngleDist(startAngle, endAngle);
  for (let i = 0; i < numPoints; i++) {
    const t2 = i / (numPoints - 1);
    const angle = startAngle + l * t2;
    const point = getPointOnCircle(center, radius, angle);
    results.push(point);
  }
  return results;
}
const DefaultBrush = ({ brush, color, opacity, className }) => {
  const rSvg = reactExports.useRef(null);
  useTransform(rSvg, brush.x, brush.y);
  const w = toDomPrecision(Math.max(1, brush.w));
  const h = toDomPrecision(Math.max(1, brush.h));
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-overlays__item", ref: rSvg, children: color ? /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "tl-brush", opacity, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: w, height: h, fill: color, opacity: 0.75 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: w, height: h, fill: "none", stroke: color, opacity: 0.1 })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { className: `tl-brush tl-brush__default ${className}`, width: w, height: h }) });
};
const tlenv = {
  isSafari: false,
  isIos: false,
  isChromeForIos: false,
  isFirefox: false,
  isAndroid: false,
  isWebview: false,
  isDarwin: false,
  hasCanvasSupport: false
};
if (typeof window !== "undefined" && "navigator" in window) {
  tlenv.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  tlenv.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);
  tlenv.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);
  tlenv.isFirefox = /firefox/i.test(navigator.userAgent);
  tlenv.isAndroid = /android/i.test(navigator.userAgent);
  tlenv.isDarwin = window.navigator.userAgent.toLowerCase().indexOf("mac") > -1;
  tlenv.hasCanvasSupport = typeof window !== "undefined" && "Promise" in window && "HTMLCanvasElement" in window;
}
const DEFAULT_CAMERA_OPTIONS = {
  isLocked: false,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]
};
const DEFAULT_ANIMATION_OPTIONS = {
  duration: 0,
  easing: EASINGS.easeInOutCubic
};
const INTERNAL_POINTER_IDS = {
  CAMERA_MOVE: -10
};
const SIDES = ["top", "right", "bottom", "left"];
const LEFT_MOUSE_BUTTON = 0;
const RIGHT_MOUSE_BUTTON = 2;
const MIDDLE_MOUSE_BUTTON = 1;
const STYLUS_ERASER_BUTTON = 5;
const ZOOM_TO_FIT_PADDING = 128;
var define_process_env_default$1 = {};
const featureFlags = {};
const pointerCaptureTrackingObject = createDebugValue(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: false
  }
);
const debugFlags = {
  // --- DEBUG VALUES ---
  logPreventDefaults: createDebugValue("logPreventDefaults", {
    defaults: { all: false }
  }),
  logPointerCaptures: createDebugValue("logPointerCaptures", {
    defaults: { all: false }
  }),
  logElementRemoves: createDebugValue("logElementRemoves", {
    defaults: { all: false }
  }),
  debugSvg: createDebugValue("debugSvg", {
    defaults: { all: false }
  }),
  showFps: createDebugValue("showFps", {
    defaults: { all: false }
  }),
  measurePerformance: createDebugValue("measurePerformance", { defaults: { all: false } }),
  throwToBlob: createDebugValue("throwToBlob", {
    defaults: { all: false }
  }),
  reconnectOnPing: createDebugValue("reconnectOnPing", {
    defaults: { all: false }
  }),
  debugCursors: createDebugValue("debugCursors", {
    defaults: { all: false }
  }),
  forceSrgb: createDebugValue("forceSrgbColors", { defaults: { all: false } }),
  debugGeometry: createDebugValue("debugGeometry", { defaults: { all: false } }),
  hideShapes: createDebugValue("hideShapes", { defaults: { all: false } }),
  editOnType: createDebugValue("editOnType", { defaults: { all: false } }),
  a11y: createDebugValue("a11y", { defaults: { all: false } }),
  debugElbowArrows: createDebugValue("debugElbowArrows", { defaults: { all: false } })
};
if (typeof Element !== "undefined") {
  const nativeElementRemoveChild = Element.prototype.removeChild;
  react$1("element removal logging", () => {
    if (debugFlags.logElementRemoves.get()) {
      Element.prototype.removeChild = function(child) {
        console.warn("[tldraw] removing child:", child);
        return nativeElementRemoveChild.call(this, child);
      };
    } else {
      Element.prototype.removeChild = nativeElementRemoveChild;
    }
  });
}
function createDebugValue(name, {
  defaults: defaults2,
  shouldStoreForSession = true
}) {
  return createDebugValueBase({
    name,
    defaults: defaults2,
    shouldStoreForSession
  });
}
function createDebugValueBase(def) {
  const defaultValue = getDefaultValue(def);
  const storedValue = def.shouldStoreForSession ? getStoredInitialValue(def.name) : null;
  const valueAtom = atom(`debug:${def.name}`, storedValue ?? defaultValue);
  if (typeof window !== "undefined") {
    if (def.shouldStoreForSession) {
      react$1(`debug:${def.name}`, () => {
        const currentValue = valueAtom.get();
        if (currentValue === defaultValue) {
          deleteFromSessionStorage(`tldraw_debug:${def.name}`);
        } else {
          setInSessionStorage(`tldraw_debug:${def.name}`, JSON.stringify(currentValue));
        }
      });
    }
    Object.defineProperty(window, `tldraw${def.name.replace(/^[a-z]/, (l) => l.toUpperCase())}`, {
      get() {
        return valueAtom.get();
      },
      set(newValue) {
        valueAtom.set(newValue);
      },
      configurable: true
    });
  }
  return Object.assign(valueAtom, def, {
    reset: () => valueAtom.set(defaultValue)
  });
}
function getStoredInitialValue(name) {
  try {
    return JSON.parse(getFromSessionStorage(`tldraw_debug:${name}`) ?? "null");
  } catch {
    return null;
  }
}
function readEnv(fn) {
  try {
    return fn();
  } catch {
    return null;
  }
}
function getDefaultValue(def) {
  const env = readEnv(() => define_process_env_default$1.TLDRAW_ENV) ?? readEnv(() => define_process_env_default$1.VERCEL_PUBLIC_TLDRAW_ENV) ?? readEnv(() => define_process_env_default$1.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production";
  switch (env) {
    case "production":
      return def.defaults.production ?? def.defaults.all;
    case "preview":
    case "staging":
      return def.defaults.staging ?? def.defaults.all;
    default:
      return def.defaults.development ?? def.defaults.all;
  }
}
function loopToHtmlElement(elm) {
  if (elm instanceof HTMLElement) return elm;
  if (elm.parentElement) return loopToHtmlElement(elm.parentElement);
  else throw Error("Could not find a parent element of an HTML type!");
}
function preventDefault(event) {
  event.preventDefault();
  if (debugFlags.logPreventDefaults.get()) {
    console.warn("preventDefault called on event:", event);
  }
}
function setPointerCapture(element, event) {
  element.setPointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    trackingObj.set(element, (trackingObj.get(element) ?? 0) + 1);
    console.warn("setPointerCapture called on element:", element, event);
  }
}
function releasePointerCapture(element, event) {
  if (!element.hasPointerCapture(event.pointerId)) {
    return;
  }
  element.releasePointerCapture(event.pointerId);
  if (debugFlags.logPointerCaptures.get()) {
    const trackingObj = pointerCaptureTrackingObject.get();
    if (trackingObj.get(element) === 1) {
      trackingObj.delete(element);
    } else if (trackingObj.has(element)) {
      trackingObj.set(element, trackingObj.get(element) - 1);
    } else {
      console.warn("Release without capture");
    }
    console.warn("releasePointerCapture called on element:", element, event);
  }
}
const stopEventPropagation = (e) => e.stopPropagation();
const setStyleProperty = (elm, property, value) => {
  if (!elm) return;
  elm.style.setProperty(property, value);
};
function activeElementShouldCaptureKeys(allowButtons = false) {
  const { activeElement } = document;
  const elements = allowButtons ? ["input", "textarea"] : ["input", "select", "button", "textarea"];
  return !!(activeElement && (activeElement.isContentEditable || elements.indexOf(activeElement.tagName.toLowerCase()) > -1 || activeElement.classList.contains("tlui-slider__thumb")));
}
const isAccelKey = (e) => {
  return tlenv.isDarwin ? e.metaKey : e.ctrlKey || e.metaKey;
};
function getPointerInfo(e) {
  e.isKilled = true;
  return {
    point: {
      x: e.clientX,
      y: e.clientY,
      z: e.pressure
    },
    shiftKey: e.shiftKey,
    altKey: e.altKey,
    ctrlKey: e.metaKey || e.ctrlKey,
    metaKey: e.metaKey,
    accelKey: isAccelKey(e),
    pointerId: e.pointerId,
    button: e.button,
    isPen: e.pointerType === "pen"
  };
}
function useCanvasEvents() {
  const editor = useEditor();
  const currentTool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  const events = reactExports.useMemo(
    function canvasEvents() {
      let lastX, lastY;
      function onPointerDown(e) {
        if (e.isKilled) return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "canvas",
            name: "right_click",
            ...getPointerInfo(e)
          });
          return;
        }
        if (e.button !== 0 && e.button !== 1 && e.button !== 5) return;
        setPointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...getPointerInfo(e)
        });
      }
      function onPointerMove(e) {
        if (e.isKilled) return;
        if (e.clientX === lastX && e.clientY === lastY) return;
        lastX = e.clientX;
        lastY = e.clientY;
        const events2 = currentTool.useCoalescedEvents && e.nativeEvent.getCoalescedEvents ? e.nativeEvent.getCoalescedEvents() : [e];
        for (const singleEvent of events2) {
          editor.dispatch({
            type: "pointer",
            target: "canvas",
            name: "pointer_move",
            ...getPointerInfo(singleEvent)
          });
        }
      }
      function onPointerUp(e) {
        if (e.isKilled) return;
        if (e.button !== 0 && e.button !== 1 && e.button !== 2 && e.button !== 5) return;
        lastX = e.clientX;
        lastY = e.clientY;
        releasePointerCapture(e.currentTarget, e);
        editor.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...getPointerInfo(e)
        });
      }
      function onPointerEnter(e) {
        if (e.isKilled) return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen") return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? true : null });
      }
      function onPointerLeave(e) {
        if (e.isKilled) return;
        if (editor.getInstanceState().isPenMode && e.pointerType !== "pen") return;
        const canHover = e.pointerType === "mouse" || e.pointerType === "pen";
        editor.updateInstanceState({ isHoveringCanvas: canHover ? false : null });
      }
      function onTouchStart(e) {
        e.isKilled = true;
        preventDefault(e);
      }
      function onTouchEnd(e) {
        e.isKilled = true;
        if (!(e.target instanceof HTMLElement)) return;
        if (e.target.tagName !== "A" && e.target.tagName !== "TEXTAREA" && !e.target.isContentEditable && // When in EditingShape state, we are actually clicking on a 'DIV'
        // not A/TEXTAREA/contenteditable element yet. So, to preserve cursor position
        // for edit mode on mobile we need to not preventDefault.
        // TODO: Find out if we still need this preventDefault in general though.
        !(editor.getEditingShape() && e.target.className.includes("tl-text-content"))) {
          preventDefault(e);
        }
      }
      function onDragOver(e) {
        preventDefault(e);
      }
      async function onDrop(e) {
        preventDefault(e);
        stopEventPropagation(e);
        if (e.dataTransfer?.files?.length) {
          const files = Array.from(e.dataTransfer.files);
          await editor.putExternalContent({
            type: "files",
            files,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY }),
            ignoreParent: false
          });
          return;
        }
        const url = e.dataTransfer.getData("url");
        if (url) {
          await editor.putExternalContent({
            type: "url",
            url,
            point: editor.screenToPage({ x: e.clientX, y: e.clientY })
          });
          return;
        }
      }
      function onClick(e) {
        stopEventPropagation(e);
      }
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp,
        onPointerEnter,
        onPointerLeave,
        onDragOver,
        onDrop,
        onTouchStart,
        onTouchEnd,
        onClick
      };
    },
    [editor, currentTool]
  );
  return events;
}
function useCoarsePointer() {
  const editor = useEditor();
  reactExports.useEffect(() => {
    let isCoarse = editor.getInstanceState().isCoarsePointer;
    const handlePointerDown = (e) => {
      const isCoarseEvent = e.pointerType !== "mouse";
      if (isCoarse === isCoarseEvent) return;
      isCoarse = isCoarseEvent;
      editor.updateInstanceState({ isCoarsePointer: isCoarseEvent });
    };
    window.addEventListener("pointerdown", handlePointerDown, { capture: true });
    const mql = window.matchMedia && window.matchMedia("(any-pointer: coarse)");
    const isForcedFinePointer = tlenv.isFirefox && !tlenv.isAndroid && !tlenv.isIos;
    const handleMediaQueryChange = () => {
      const next = isForcedFinePointer ? false : mql.matches;
      if (isCoarse !== next) return;
      isCoarse = next;
      editor.updateInstanceState({ isCoarsePointer: next });
    };
    if (mql) {
      mql.addEventListener("change", handleMediaQueryChange);
      handleMediaQueryChange();
    }
    return () => {
      window.removeEventListener("pointerdown", handlePointerDown, { capture: true });
      if (mql) {
        mql.removeEventListener("change", handleMediaQueryChange);
      }
    };
  }, [editor]);
}
const ContainerContext = reactExports.createContext(null);
function ContainerProvider({ container, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerContext.Provider, { value: container, children });
}
function useContainer() {
  return assertExists(reactExports.useContext(ContainerContext), "useContainer used outside of <Tldraw />");
}
function useDocumentEvents() {
  const editor = useEditor();
  const container = useContainer();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId(), [editor]);
  const isAppFocused = useValue("isFocused", () => editor.getIsFocused(), [editor]);
  reactExports.useEffect(() => {
    if (!container) return;
    function onDrop(e) {
      if (e.isSpecialRedispatchedEvent) return;
      preventDefault(e);
      stopEventPropagation(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new DragEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    container.addEventListener("dragover", onDrop);
    container.addEventListener("drop", onDrop);
    return () => {
      container.removeEventListener("dragover", onDrop);
      container.removeEventListener("drop", onDrop);
    };
  }, [container]);
  reactExports.useEffect(() => {
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`;
      const media = matchMedia(mqString);
      const safariCb = (ev) => {
        if (ev.type === "change") {
          updatePixelRatio();
        }
      };
      if (media.addEventListener) {
        media.addEventListener("change", updatePixelRatio);
      } else if (media.addListener) {
        media.addListener(safariCb);
      }
      remove2 = () => {
        if (media.removeEventListener) {
          media.removeEventListener("change", updatePixelRatio);
        } else if (media.removeListener) {
          media.removeListener(safariCb);
        }
      };
      editor.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    updatePixelRatio();
    return () => {
      remove2?.();
    };
  }, [editor]);
  reactExports.useEffect(() => {
    if (!isAppFocused) return;
    const handleKeyDown2 = (e) => {
      if (e.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (editor.isIn("zoom") || !editor.getPath().endsWith(".idle")) && !areShortcutsDisabled$2(editor)) {
        preventDefault(e);
      }
      if (e.isKilled) return;
      e.isKilled = true;
      const hasSelectedShapes = !!editor.getSelectedShapeIds().length;
      switch (e.key) {
        case "=":
        case "-":
        case "0": {
          if (e.metaKey || e.ctrlKey) {
            preventDefault(e);
            return;
          }
          break;
        }
        case "Tab": {
          if (areShortcutsDisabled$2(editor)) {
            return;
          }
          if (hasSelectedShapes && !isEditing) {
            preventDefault(e);
          }
          break;
        }
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown": {
          if (areShortcutsDisabled$2(editor)) {
            return;
          }
          if (hasSelectedShapes && (e.metaKey || e.ctrlKey)) {
            preventDefault(e);
          }
          break;
        }
        case ",": {
          return;
        }
        case "Escape": {
          if (editor.getEditingShape() || editor.getSelectedShapeIds().length > 0) {
            preventDefault(e);
          }
          if (editor.menus.getOpenMenus().length > 0) return;
          if (editor.inputs.keys.has("Escape")) ;
          else {
            editor.inputs.keys.add("Escape");
            editor.cancel();
            container.focus();
          }
          return;
        }
        default: {
          if (areShortcutsDisabled$2(editor)) {
            return;
          }
        }
      }
      const info = {
        type: "keyboard",
        name: e.repeat ? "key_repeat" : "key_down",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    const handleKeyUp = (e) => {
      if (e.isKilled) return;
      e.isKilled = true;
      if (areShortcutsDisabled$2(editor)) {
        return;
      }
      if (e.key === ",") {
        return;
      }
      const info = {
        type: "keyboard",
        name: "key_up",
        key: e.key,
        code: e.code,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      };
      editor.dispatch(info);
    };
    function handleTouchStart(e) {
      if (container.contains(e.target)) {
        const touchXPosition = e.touches[0].pageX;
        const touchXRadius = e.touches[0].radiusX || 0;
        if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > editor.getViewportScreenBounds().width - 10) {
          if (e.target?.tagName === "BUTTON") {
            e.target?.click();
          }
          preventDefault(e);
        }
      }
    }
    const handleWheel = (e) => {
      if (container.contains(e.target) && (e.ctrlKey || e.metaKey)) {
        preventDefault(e);
      }
    };
    container.addEventListener("touchstart", handleTouchStart, { passive: false });
    container.addEventListener("wheel", handleWheel, { passive: false });
    document.addEventListener("gesturestart", preventDefault);
    document.addEventListener("gesturechange", preventDefault);
    document.addEventListener("gestureend", preventDefault);
    container.addEventListener("keydown", handleKeyDown2);
    container.addEventListener("keyup", handleKeyUp);
    return () => {
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("wheel", handleWheel);
      document.removeEventListener("gesturestart", preventDefault);
      document.removeEventListener("gesturechange", preventDefault);
      document.removeEventListener("gestureend", preventDefault);
      container.removeEventListener("keydown", handleKeyDown2);
      container.removeEventListener("keyup", handleKeyUp);
    };
  }, [editor, container, isAppFocused, isEditing]);
}
function areShortcutsDisabled$2(editor) {
  return editor.menus.hasOpenMenus() || activeElementShouldCaptureKeys();
}
const IGNORED_TAGS = ["textarea", "input"];
function useFixSafariDoubleTapZoomPencilEvents(ref) {
  const editor = useEditor();
  reactExports.useEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    const handleEvent = (e) => {
      if (e instanceof PointerEvent && e.pointerType === "pen") {
        e.isKilled = true;
        const { target } = e;
        if (IGNORED_TAGS.includes(target.tagName?.toLocaleLowerCase()) || target.isContentEditable || editor.isIn("select.editing_shape")) {
          return;
        }
        preventDefault(e);
      }
    };
    elm.addEventListener("touchstart", handleEvent);
    elm.addEventListener("touchend", handleEvent);
    return () => {
      elm.removeEventListener("touchstart", handleEvent);
      elm.removeEventListener("touchend", handleEvent);
    };
  }, [editor, ref]);
}
function clamp$2(v, min2, max2) {
  return Math.max(min2, Math.min(v, max2));
}
const V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min2, max2, constant = 0.15) {
  if (constant === 0) return clamp$2(position, min2, max2);
  if (position < min2) return -rubberband(min2 - position, max2 - min2, constant) + min2;
  if (position > max2) return +rubberband(position - max2, max2 - min2, constant) + max2;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint);
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r2) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e);
    r2 && (o2 = o2.filter(function(r22) {
      return Object.getOwnPropertyDescriptor(e, r22).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r22) {
      _defineProperty(e, r22, t2[r22]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r22) {
      Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t2, r22));
    });
  }
  return e;
}
const EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string2) {
  if (!string2) return "";
  return string2[0].toUpperCase() + string2.slice(1);
}
const actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e) => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey: altKey2,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop$2() {
}
function chain(...fns) {
  if (fns.length === 0) return noop$2;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
const BEFORE_LAST_KINEMATICS_DELAY = 32;
class Engine {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared: shared2,
      ingKey,
      args
    } = this;
    shared2[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared: shared2
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared2.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared2.locked = !!document.pointerLockElement;
      Object.assign(shared2, getEventDetails(event));
      shared2.down = shared2.pressed = shared2.buttons % 2 === 1 || shared2.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared2[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared2 = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo2 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared2), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo2 !== void 0) state.memo = memo2;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
}
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
class CoordinatesEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
}
const identity = (v) => v;
const DEFAULT_RUBBERBAND = 0.15;
const commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
const DEFAULT_AXIS_THRESHOLD = 0;
const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
const SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
const DEFAULT_PREVENT_SCROLL_DELAY = 250;
const DEFAULT_DRAG_DELAY = 180;
const DEFAULT_SWIPE_VELOCITY = 0.5;
const DEFAULT_SWIPE_DISTANCE = 50;
const DEFAULT_SWIPE_DURATION = 250;
const DEFAULT_KEYBOARD_DISPLACEMENT = 10;
const DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys: keys2 = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys2;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
const PINCH_WHEEL_RATIO = 100;
class PinchEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset: offset2,
      lastOffset
    } = this.state;
    this.state.movement = [offset2[0] / lastOffset[0], offset2[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
}
const pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared: shared2,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared2;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
class WheelEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
}
const wheelConfigResolver = coordinatesConfigResolver;
_objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
const EngineMap = /* @__PURE__ */ new Map();
const ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
const pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
const wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
const sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
const _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse$2(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      }
    }
  }
  return _config;
}
class EventStore {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove2 = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove2);
    };
    listeners.add(remove2);
    return remove2;
  }
  clean() {
    this._listeners.forEach((remove2) => remove2());
    this._listeners.clear();
  }
}
class TimeoutStore {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
}
class Controller {
  constructor(handlers2) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers2);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers2, nativeHandlers) {
    this.handlers = handlers2;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse$2(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
}
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers2) {
  const native = {};
  const handlers2 = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers2) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers2[key] = _handlers2[key];
    } else {
      native[key] = _handlers2[key];
    }
  }
  return [handlers2, native, actions];
}
function registerGesture(actions, handlers2, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    return;
  }
  const startKey2 = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo2 = void 0;
    if (state.first && startKey2 in handlers2) handlers2[startKey2](state);
    if (handlerKey in handlers2) memo2 = handlers2[handlerKey](state);
    if (state.last && endKey in handlers2) handlers2[endKey](state);
    return memo2;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers2, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers2, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers2, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}
function useRecognizers(handlers2, config = {}, gestureKey, nativeHandlers) {
  const ctrl = React.useMemo(() => new Controller(handlers2), []);
  ctrl.applyHandlers(handlers2, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  React.useEffect(ctrl.effect.bind(ctrl));
  React.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers2, _config) {
    const {
      handlers: handlers2,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers2, _config || {});
    return useRecognizers(handlers2, config, void 0, nativeHandlers);
  };
}
const MAX_ZOOM_STEP = 10;
const IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof window === "undefined" ? "node" : window.navigator.platform
);
function normalizeWheel(event) {
  let { deltaY, deltaX } = event;
  let deltaZ = 0;
  if (event.ctrlKey || event.altKey || event.metaKey) {
    deltaZ = (Math.abs(deltaY) > MAX_ZOOM_STEP ? MAX_ZOOM_STEP * Math.sign(deltaY) : deltaY) / 100;
  } else {
    if (event.shiftKey && !IS_DARWIN) {
      deltaX = deltaY;
      deltaY = 0;
    }
  }
  return { x: -deltaX, y: -deltaY, z: -deltaZ };
}
const useGesture = createUseGesture([wheelAction, pinchAction]);
let lastWheelTime = void 0;
const isWheelEndEvent = (time2) => {
  if (lastWheelTime === void 0) {
    lastWheelTime = time2;
    return false;
  }
  if (time2 - lastWheelTime > 120 && time2 - lastWheelTime < 160) {
    lastWheelTime = time2;
    return true;
  }
  lastWheelTime = time2;
  return false;
};
function useGestureEvents(ref) {
  const editor = useEditor();
  const events = reactExports.useMemo(() => {
    let pinchState = "not sure";
    const onWheel = ({ event }) => {
      if (!editor.getInstanceState().isFocused) {
        return;
      }
      pinchState = "not sure";
      if (isWheelEndEvent(Date.now())) {
        return;
      }
      const editingShapeId = editor.getEditingShapeId();
      if (editingShapeId) {
        const shape = editor.getShape(editingShapeId);
        if (shape) {
          const util2 = editor.getShapeUtil(shape);
          if (util2.canScroll(shape)) {
            const bounds = editor.getShapePageBounds(editingShapeId);
            if (bounds?.containsPoint(editor.inputs.currentPagePoint)) {
              return;
            }
          }
        }
      }
      preventDefault(event);
      stopEventPropagation(event);
      const delta = normalizeWheel(event);
      if (delta.x === 0 && delta.y === 0) return;
      const info = {
        type: "wheel",
        name: "wheel",
        delta,
        point: new Vec(event.clientX, event.clientY),
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      };
      editor.dispatch(info);
    };
    let initDistanceBetweenFingers = 1;
    let initZoom = 1;
    let currDistanceBetweenFingers = 0;
    const initPointBetweenFingers = new Vec();
    const prevPointBetweenFingers = new Vec();
    const onPinchStart = (gesture) => {
      const elm = ref.current;
      pinchState = "not sure";
      const { event, origin, da } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || elm?.contains(event.target))) return;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      initPointBetweenFingers.x = origin[0];
      initPointBetweenFingers.y = origin[1];
      initDistanceBetweenFingers = da[0];
      initZoom = editor.getZoomLevel();
      editor.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: origin[0], y: origin[1], z: editor.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        ctrlKey: event.metaKey || event.ctrlKey,
        metaKey: event.metaKey,
        accelKey: isAccelKey(event)
      });
    };
    const updatePinchState = (isSafariTrackpadPinch) => {
      if (isSafariTrackpadPinch) {
        pinchState = "zooming";
      }
      if (pinchState === "zooming") {
        return;
      }
      const touchDistance = Math.abs(currDistanceBetweenFingers - initDistanceBetweenFingers);
      const originDistance = Vec.Dist(initPointBetweenFingers, prevPointBetweenFingers);
      switch (pinchState) {
        case "not sure": {
          if (touchDistance > 24) {
            pinchState = "zooming";
          } else if (originDistance > 16) {
            pinchState = "panning";
          }
          break;
        }
        case "panning": {
          if (touchDistance > 64) {
            pinchState = "zooming";
          }
          break;
        }
      }
    };
    const onPinch = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset2, da } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || elm?.contains(event.target))) return;
      const isSafariTrackpadPinch = gesture.type === "gesturechange" || gesture.type === "gestureend";
      currDistanceBetweenFingers = da[0];
      const dx = origin[0] - prevPointBetweenFingers.x;
      const dy = origin[1] - prevPointBetweenFingers.y;
      prevPointBetweenFingers.x = origin[0];
      prevPointBetweenFingers.y = origin[1];
      updatePinchState(isSafariTrackpadPinch);
      switch (pinchState) {
        case "zooming": {
          const currZoom = offset2[0] ** editor.getCameraOptions().zoomSpeed;
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: currZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
        case "panning": {
          editor.dispatch({
            type: "pinch",
            name: "pinch",
            point: { x: origin[0], y: origin[1], z: initZoom },
            delta: { x: dx, y: dy },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey,
            metaKey: event.metaKey,
            accelKey: isAccelKey(event)
          });
          break;
        }
      }
    };
    const onPinchEnd = (gesture) => {
      const elm = ref.current;
      const { event, origin, offset: offset2 } = gesture;
      if (event instanceof WheelEvent) return;
      if (!(event.target === elm || elm?.contains(event.target))) return;
      const scale = offset2[0] ** editor.getCameraOptions().zoomSpeed;
      pinchState = "not sure";
      editor.timers.requestAnimationFrame(() => {
        editor.dispatch({
          type: "pinch",
          name: "pinch_end",
          point: { x: origin[0], y: origin[1], z: scale },
          delta: { x: origin[0], y: origin[1] },
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          ctrlKey: event.metaKey || event.ctrlKey,
          metaKey: event.metaKey,
          accelKey: isAccelKey(event)
        });
      });
    };
    return {
      onWheel,
      onPinchStart,
      onPinchEnd,
      onPinch
    };
  }, [editor, ref]);
  useGesture(events, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: () => {
        const { zoomSpeed } = editor.getCameraOptions();
        const level = editor.getZoomLevel() ** (1 / zoomSpeed);
        return [level, 0];
      },
      // Return the camera z to use when pinch starts
      scaleBounds: () => {
        const baseZoom = editor.getBaseZoom();
        const { zoomSteps, zoomSpeed } = editor.getCameraOptions();
        const zoomMin = zoomSteps[0] * baseZoom;
        const zoomMax = zoomSteps[zoomSteps.length - 1] * baseZoom;
        return {
          max: zoomMax ** (1 / zoomSpeed),
          min: zoomMin ** (1 / zoomSpeed)
        };
      }
    }
  });
}
function getHandle(editor, id, handleId) {
  const shape = editor.getShape(id);
  const handles = editor.getShapeHandles(shape);
  return { shape, handle: handles.find((h) => h.id === handleId) };
}
function useHandleEvents(id, handleId) {
  const editor = useEditor();
  return reactExports.useMemo(() => {
    const onPointerDown = (e) => {
      if (e.isKilled) return;
      const target = loopToHtmlElement(e.currentTarget);
      setPointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_down",
        ...getPointerInfo(e)
      });
    };
    let lastX, lastY;
    const onPointerMove = (e) => {
      if (e.isKilled) return;
      if (e.clientX === lastX && e.clientY === lastY) return;
      lastX = e.clientX;
      lastY = e.clientY;
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_move",
        ...getPointerInfo(e)
      });
    };
    const onPointerUp = (e) => {
      if (e.isKilled) return;
      const target = loopToHtmlElement(e.currentTarget);
      releasePointerCapture(target, e);
      const { shape, handle } = getHandle(editor, id, handleId);
      if (!handle) return;
      editor.dispatch({
        type: "pointer",
        target: "handle",
        handle,
        shape,
        name: "pointer_up",
        ...getPointerInfo(e)
      });
    };
    return {
      onPointerDown,
      onPointerMove,
      onPointerUp
    };
  }, [editor, id, handleId]);
}
function useScreenBounds(ref) {
  const editor = useEditor();
  reactExports.useLayoutEffect(() => {
    const updateBounds = throttle(
      () => {
        if (!ref.current) return;
        editor.updateViewportScreenBounds(ref.current);
      },
      200,
      {
        trailing: true
      }
    );
    const interval = editor.timers.setInterval(updateBounds, 1e3);
    window.addEventListener("resize", updateBounds);
    const resizeObserver = new ResizeObserver((entries) => {
      if (!entries[0].contentRect) return;
      updateBounds();
    });
    const container = ref.current;
    let scrollingParent = null;
    if (container) {
      resizeObserver.observe(container);
      scrollingParent = getNearestScrollableContainer(container);
      scrollingParent.addEventListener("scroll", updateBounds);
    }
    return () => {
      clearInterval(interval);
      window.removeEventListener("resize", updateBounds);
      resizeObserver.disconnect();
      scrollingParent?.removeEventListener("scroll", updateBounds);
      updateBounds.cancel();
    };
  }, [editor, ref]);
}
/*!
 * Author: excalidraw
 * MIT License: https://github.com/excalidraw/excalidraw/blob/master/LICENSE
 * https://github.com/excalidraw/excalidraw/blob/48c3465b19f10ec755b3eb84e21a01a468e96e43/packages/excalidraw/utils.ts#L600
 */
const getNearestScrollableContainer = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent === document.body) {
      return document;
    }
    const { overflowY } = window.getComputedStyle(parent);
    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
    if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document;
};
class Box {
  constructor(x = 0, y2 = 0, w = 0, h = 0) {
    this.x = x;
    this.y = y2;
    this.w = w;
    this.h = h;
  }
  x = 0;
  y = 0;
  w = 0;
  h = 0;
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new Vec(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(val) {
    this.x = val.x;
    this.y = val.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(n2) {
    this.x = n2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get left() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get right() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(n2) {
    this.y = n2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get top() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get bottom() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(n2) {
    this.w = n2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(n2) {
    this.h = n2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new Vec(this.midX, this.midY);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(v) {
    this.minX = v.x - this.width / 2;
    this.minY = v.y - this.height / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new Vec(this.minX, this.minY),
      new Vec(this.maxX, this.minY),
      new Vec(this.maxX, this.maxY),
      new Vec(this.minX, this.maxY)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new Vec(this.minX, this.minY),
      new Vec(this.maxX, this.minY),
      new Vec(this.maxX, this.maxY),
      new Vec(this.minX, this.maxY),
      this.center
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners } = this;
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new Vec(this.w, this.h);
  }
  toFixed() {
    this.x = toPrecision(this.x);
    this.y = toPrecision(this.y);
    this.w = toPrecision(this.w);
    this.h = toPrecision(this.h);
    return this;
  }
  setTo(B) {
    this.x = B.x;
    this.y = B.y;
    this.w = B.w;
    this.h = B.h;
    return this;
  }
  set(x = 0, y2 = 0, w = 0, h = 0) {
    this.x = x;
    this.y = y2;
    this.w = w;
    this.h = h;
    return this;
  }
  expand(A) {
    const minX = Math.min(this.minX, A.minX);
    const minY = Math.min(this.minY, A.minY);
    const maxX = Math.max(this.maxX, A.maxX);
    const maxY = Math.max(this.maxY, A.maxY);
    this.x = minX;
    this.y = minY;
    this.w = maxX - minX;
    this.h = maxY - minY;
    return this;
  }
  expandBy(n2) {
    this.x -= n2;
    this.y -= n2;
    this.w += n2 * 2;
    this.h += n2 * 2;
    return this;
  }
  scale(n2) {
    this.x /= n2;
    this.y /= n2;
    this.w /= n2;
    this.h /= n2;
    return this;
  }
  clone() {
    const { x, y: y2, w, h } = this;
    return new Box(x, y2, w, h);
  }
  translate(delta) {
    this.x += delta.x;
    this.y += delta.y;
    return this;
  }
  snapToGrid(size2) {
    const minX = Math.round(this.minX / size2) * size2;
    const minY = Math.round(this.minY / size2) * size2;
    const maxX = Math.round(this.maxX / size2) * size2;
    const maxY = Math.round(this.maxY / size2) * size2;
    this.minX = minX;
    this.minY = minY;
    this.width = Math.max(1, maxX - minX);
    this.height = Math.max(1, maxY - minY);
  }
  collides(B) {
    return Box.Collides(this, B);
  }
  contains(B) {
    return Box.Contains(this, B);
  }
  includes(B) {
    return Box.Includes(this, B);
  }
  containsPoint(V2, margin = 0) {
    return Box.ContainsPoint(this, V2, margin);
  }
  getHandlePoint(handle) {
    switch (handle) {
      case "top_left":
        return new Vec(this.minX, this.minY);
      case "top_right":
        return new Vec(this.maxX, this.minY);
      case "bottom_left":
        return new Vec(this.minX, this.maxY);
      case "bottom_right":
        return new Vec(this.maxX, this.maxY);
      case "top":
        return new Vec(this.midX, this.minY);
      case "right":
        return new Vec(this.maxX, this.midY);
      case "bottom":
        return new Vec(this.midX, this.maxY);
      case "left":
        return new Vec(this.minX, this.midY);
    }
  }
  toJson() {
    return { x: this.minX, y: this.minY, w: this.w, h: this.h };
  }
  resize(handle, dx, dy) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = this;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = this;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    this.minX = b0x;
    this.minY = b0y;
    this.width = Math.abs(b1x - b0x);
    this.height = Math.abs(b1y - b0y);
  }
  union(box) {
    const minX = Math.min(this.minX, box.x);
    const minY = Math.min(this.minY, box.y);
    const maxX = Math.max(this.maxX, box.w + box.x);
    const maxY = Math.max(this.maxY, box.h + box.y);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
    return this;
  }
  static From(box) {
    return new Box(box.x, box.y, box.w, box.h);
  }
  static FromCenter(center, size2) {
    return new Box(center.x - size2.x / 2, center.y - size2.y / 2, size2.x, size2.y);
  }
  static FromPoints(points) {
    if (points.length === 0) return new Box();
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let point;
    for (let i = 0, n2 = points.length; i < n2; i++) {
      point = points[i];
      minX = Math.min(point.x, minX);
      minY = Math.min(point.y, minY);
      maxX = Math.max(point.x, maxX);
      maxY = Math.max(point.y, maxY);
    }
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Expand(A, B) {
    const minX = Math.min(B.minX, A.minX);
    const minY = Math.min(B.minY, A.minY);
    const maxX = Math.max(B.maxX, A.maxX);
    const maxY = Math.max(B.maxY, A.maxY);
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  static ExpandBy(A, n2) {
    return new Box(A.minX - n2, A.minY - n2, A.width + n2 * 2, A.height + n2 * 2);
  }
  static Collides(A, B) {
    return !(A.maxX < B.minX || A.minX > B.maxX || A.maxY < B.minY || A.minY > B.maxY);
  }
  static Contains(A, B) {
    return A.minX < B.minX && A.minY < B.minY && A.maxY > B.maxY && A.maxX > B.maxX;
  }
  static Includes(A, B) {
    return Box.Collides(A, B) || Box.Contains(A, B);
  }
  static ContainsPoint(A, B, margin = 0) {
    return !(B.x < A.minX - margin || B.y < A.minY - margin || B.x > A.maxX + margin || B.y > A.maxY + margin);
  }
  static Common(boxes) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < boxes.length; i++) {
      const B = boxes[i];
      minX = Math.min(minX, B.minX);
      minY = Math.min(minY, B.minY);
      maxX = Math.max(maxX, B.maxX);
      maxY = Math.max(maxY, B.maxY);
    }
    return new Box(minX, minY, maxX - minX, maxY - minY);
  }
  static Sides(A, inset = 0) {
    const { corners } = A;
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  }
  static Resize(box, handle, dx, dy, isAspectRatioLocked = false) {
    const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = box;
    let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = box;
    switch (handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        b0x += dx;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        b1x += dx;
        break;
      }
    }
    switch (handle) {
      case "top":
      case "top_left":
      case "top_right": {
        b0y += dy;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        b1y += dy;
        break;
      }
    }
    const scaleX = (b1x - b0x) / (a1x - a0x);
    const scaleY = (b1y - b0y) / (a1y - a0y);
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    if (isAspectRatioLocked) {
      const aspectRatio = (a1x - a0x) / (a1y - a0y);
      const bw = Math.abs(b1x - b0x);
      const bh = Math.abs(b1y - b0y);
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / aspectRatio);
      const th = bh * (scaleX < 0 ? 1 : -1) * aspectRatio;
      const isTall = aspectRatio < bw / bh;
      switch (handle) {
        case "top_left": {
          if (isTall) b0y = b1y + tw;
          else b0x = b1x + th;
          break;
        }
        case "top_right": {
          if (isTall) b0y = b1y + tw;
          else b1x = b0x - th;
          break;
        }
        case "bottom_right": {
          if (isTall) b1y = b0y - tw;
          else b1x = b0x - th;
          break;
        }
        case "bottom_left": {
          if (isTall) b1y = b0y - tw;
          else b0x = b1x + th;
          break;
        }
        case "bottom":
        case "top": {
          const m = (b0x + b1x) / 2;
          const w = bh * aspectRatio;
          b0x = m - w / 2;
          b1x = m + w / 2;
          break;
        }
        case "left":
        case "right": {
          const m = (b0y + b1y) / 2;
          const h = bw / aspectRatio;
          b0y = m - h / 2;
          b1y = m + h / 2;
          break;
        }
      }
    }
    if (flipX) {
      const t2 = b1x;
      b1x = b0x;
      b0x = t2;
    }
    if (flipY) {
      const t2 = b1y;
      b1y = b0y;
      b0y = t2;
    }
    const final = new Box(b0x, b0y, Math.abs(b1x - b0x), Math.abs(b1y - b0y));
    return {
      box: final,
      scaleX: +(final.width / box.width * (scaleX > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(final.height / box.height * (scaleY > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(other) {
    return Box.Equals(this, other);
  }
  static Equals(a2, b) {
    return b.x === a2.x && b.y === a2.y && b.w === a2.w && b.h === a2.h;
  }
  zeroFix() {
    this.w = Math.max(1, this.w);
    this.h = Math.max(1, this.h);
    return this;
  }
  static ZeroFix(other) {
    return new Box(other.x, other.y, Math.max(1, other.w), Math.max(1, other.h));
  }
}
function flipSelectionHandleY(handle) {
  switch (handle) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return handle;
  }
}
function flipSelectionHandleX(handle) {
  switch (handle) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return handle;
  }
}
function isSelectionCorner(selection) {
  return selection === "top_left" || selection === "top_right" || selection === "bottom_right" || selection === "bottom_left";
}
class Mat {
  constructor(a2, b, c2, d, e, f) {
    this.a = a2;
    this.b = b;
    this.c = c2;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  a = 1;
  b = 0;
  c = 0;
  d = 1;
  e = 0;
  f = 0;
  equals(m) {
    return this === m || this.a === m.a && this.b === m.b && this.c === m.c && this.d === m.d && this.e === m.e && this.f === m.f;
  }
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    return this;
  }
  multiply(m) {
    const m2 = m;
    const { a: a2, b, c: c2, d, e, f } = this;
    this.a = a2 * m2.a + c2 * m2.b;
    this.c = a2 * m2.c + c2 * m2.d;
    this.e = a2 * m2.e + c2 * m2.f + e;
    this.b = b * m2.a + d * m2.b;
    this.d = b * m2.c + d * m2.d;
    this.f = b * m2.e + d * m2.f + f;
    return this;
  }
  rotate(r2, cx, cy) {
    if (r2 === 0) return this;
    if (cx === void 0) return this.multiply(Mat.Rotate(r2));
    return this.translate(cx, cy).multiply(Mat.Rotate(r2)).translate(-cx, -cy);
  }
  translate(x, y2) {
    return this.multiply(Mat.Translate(x, y2));
  }
  scale(x, y2) {
    return this.multiply(Mat.Scale(x, y2));
  }
  invert() {
    const { a: a2, b, c: c2, d, e, f } = this;
    const denom = a2 * d - b * c2;
    this.a = d / denom;
    this.b = b / -denom;
    this.c = c2 / -denom;
    this.d = a2 / denom;
    this.e = (d * e - c2 * f) / -denom;
    this.f = (b * e - a2 * f) / denom;
    return this;
  }
  applyToPoint(point) {
    return Mat.applyToPoint(this, point);
  }
  applyToPoints(points) {
    return Mat.applyToPoints(this, points);
  }
  rotation() {
    return Mat.Rotation(this);
  }
  point() {
    return Mat.Point(this);
  }
  decomposed() {
    return Mat.Decompose(this);
  }
  toCssString() {
    return Mat.toCssString(this);
  }
  setTo(model2) {
    Object.assign(this, model2);
    return this;
  }
  decompose() {
    return Mat.Decompose(this);
  }
  clone() {
    return new Mat(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new Mat(1, 0, 0, 1, 0, 0);
  }
  static Translate(x, y2) {
    return new Mat(1, 0, 0, 1, x, y2);
  }
  static Rotate(r2, cx, cy) {
    if (r2 === 0) return Mat.Identity();
    const cosAngle = Math.cos(r2);
    const sinAngle = Math.sin(r2);
    const rotationMatrix = new Mat(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);
    if (cx === void 0) return rotationMatrix;
    return Mat.Compose(Mat.Translate(cx, cy), rotationMatrix, Mat.Translate(-cx, -cy));
  }
  static Scale(x, y2, cx, cy) {
    const scaleMatrix = new Mat(x, 0, 0, y2, 0, 0);
    if (cx === void 0) return scaleMatrix;
    return Mat.Translate(cx, cy).multiply(scaleMatrix).translate(-cx, -cy);
  }
  static Multiply(m1, m2) {
    return {
      a: m1.a * m2.a + m1.c * m2.b,
      c: m1.a * m2.c + m1.c * m2.d,
      e: m1.a * m2.e + m1.c * m2.f + m1.e,
      b: m1.b * m2.a + m1.d * m2.b,
      d: m1.b * m2.c + m1.d * m2.d,
      f: m1.b * m2.e + m1.d * m2.f + m1.f
    };
  }
  static Inverse(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / -denom,
      f: (m.b * m.e - m.a * m.f) / denom
    };
  }
  static Absolute(m) {
    const denom = m.a * m.d - m.b * m.c;
    return {
      a: m.d / denom,
      b: m.b / -denom,
      c: m.c / -denom,
      d: m.a / denom,
      e: (m.d * m.e - m.c * m.f) / denom,
      f: (m.b * m.e - m.a * m.f) / -denom
    };
  }
  static Compose(...matrices) {
    const matrix = Mat.Identity();
    for (let i = 0, n2 = matrices.length; i < n2; i++) {
      matrix.multiply(matrices[i]);
    }
    return matrix;
  }
  static Point(m) {
    return new Vec(m.e, m.f);
  }
  static Rotation(m) {
    let rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      rotation = 0;
    }
    return clampRadians(rotation);
  }
  static Decompose(m) {
    let scaleX, scaleY, rotation;
    if (m.a !== 0 || m.c !== 0) {
      const hypotAc = (m.a * m.a + m.c * m.c) ** 0.5;
      scaleX = hypotAc;
      scaleY = (m.a * m.d - m.b * m.c) / hypotAc;
      rotation = Math.acos(m.a / hypotAc) * (m.c > 0 ? -1 : 1);
    } else if (m.b !== 0 || m.d !== 0) {
      const hypotBd = (m.b * m.b + m.d * m.d) ** 0.5;
      scaleX = (m.a * m.d - m.b * m.c) / hypotBd;
      scaleY = hypotBd;
      rotation = HALF_PI + Math.acos(m.b / hypotBd) * (m.d > 0 ? -1 : 1);
    } else {
      scaleX = 0;
      scaleY = 0;
      rotation = 0;
    }
    return {
      x: m.e,
      y: m.f,
      scaleX,
      scaleY,
      rotation: clampRadians(rotation)
    };
  }
  static Smooth(m, precision = 1e10) {
    m.a = Math.round(m.a * precision) / precision;
    m.b = Math.round(m.b * precision) / precision;
    m.c = Math.round(m.c * precision) / precision;
    m.d = Math.round(m.d * precision) / precision;
    m.e = Math.round(m.e * precision) / precision;
    m.f = Math.round(m.f * precision) / precision;
    return m;
  }
  static toCssString(m) {
    return `matrix(${toDomPrecision(m.a)}, ${toDomPrecision(m.b)}, ${toDomPrecision(
      m.c
    )}, ${toDomPrecision(m.d)}, ${toDomPrecision(m.e)}, ${toDomPrecision(m.f)})`;
  }
  static applyToPoint(m, point) {
    return new Vec(
      m.a * point.x + m.c * point.y + m.e,
      m.b * point.x + m.d * point.y + m.f,
      point.z
    );
  }
  static applyToXY(m, x, y2) {
    return [m.a * x + m.c * y2 + m.e, m.b * x + m.d * y2 + m.f];
  }
  static applyToPoints(m, points) {
    return points.map(
      (point) => new Vec(m.a * point.x + m.c * point.y + m.e, m.b * point.x + m.d * point.y + m.f, point.z)
    );
  }
  static applyToBounds(m, box) {
    return new Box(m.e + box.minX, m.f + box.minY, box.width, box.height);
  }
  static From(m) {
    return new Mat(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  static Cast(m) {
    return m instanceof Mat ? m : Mat.From(m);
  }
}
function gcd(a2, b) {
  return b === 0 ? a2 : gcd(b, a2 % b);
}
function nearestMultiple(float) {
  const decimal = float.toString().split(".")[1];
  if (!decimal) return 1;
  const denominator = Math.pow(10, decimal.length);
  const numerator = parseInt(decimal, 10);
  return denominator / gcd(numerator, denominator);
}
function intersectLineSegmentLineSegment(a1, a2, b1, b2) {
  const ABx = a1.x - b1.x;
  const ABy = a1.y - b1.y;
  const BVx = b2.x - b1.x;
  const BVy = b2.y - b1.y;
  const AVx = a2.x - a1.x;
  const AVy = a2.y - a1.y;
  const ua_t = BVx * ABy - BVy * ABx;
  const ub_t = AVx * ABy - AVy * ABx;
  const u_b = BVy * AVx - BVx * AVy;
  if (ua_t === 0 || ub_t === 0) return null;
  if (u_b === 0) return null;
  if (u_b !== 0) {
    const ua = ua_t / u_b;
    const ub = ub_t / u_b;
    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return Vec.AddXY(a1, ua * AVx, ua * AVy);
    }
  }
  return null;
}
function intersectLineSegmentCircle(a1, a2, c2, r2) {
  const a3 = (a2.x - a1.x) * (a2.x - a1.x) + (a2.y - a1.y) * (a2.y - a1.y);
  const b = 2 * ((a2.x - a1.x) * (a1.x - c2.x) + (a2.y - a1.y) * (a1.y - c2.y));
  const cc = c2.x * c2.x + c2.y * c2.y + a1.x * a1.x + a1.y * a1.y - 2 * (c2.x * a1.x + c2.y * a1.y) - r2 * r2;
  const deter = b * b - 4 * a3 * cc;
  if (deter < 0) return null;
  if (deter === 0) return null;
  const e = Math.sqrt(deter);
  const u1 = (-b + e) / (2 * a3);
  const u2 = (-b - e) / (2 * a3);
  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
    return null;
  }
  const result = [];
  if (0 <= u1 && u1 <= 1) result.push(Vec.Lrp(a1, a2, u1));
  if (0 <= u2 && u2 <= 1) result.push(Vec.Lrp(a1, a2, u2));
  if (result.length === 0) return null;
  return result;
}
function intersectLineSegmentPolyline(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 0, n2 = points.length - 1; i < n2; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(a1, a2, points[i], points[i + 1]);
    if (segmentIntersection) result.push(segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectLineSegmentPolygon(a1, a2, points) {
  const result = [];
  let segmentIntersection;
  for (let i = 1, n2 = points.length; i < n2 + 1; i++) {
    segmentIntersection = intersectLineSegmentLineSegment(
      a1,
      a2,
      points[i - 1],
      points[i % points.length]
    );
    if (segmentIntersection) result.push(segmentIntersection);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectCircleCircle(c1, r1, c2, r2) {
  let dx = c2.x - c1.x;
  let dy = c2.y - c1.y;
  const d = Math.sqrt(dx * dx + dy * dy), x = (d * d - r2 * r2 + r1 * r1) / (2 * d), y2 = Math.sqrt(r1 * r1 - x * x);
  dx /= d;
  dy /= d;
  return [
    new Vec(c1.x + dx * x - dy * y2, c1.y + dy * x + dx * y2),
    new Vec(c1.x + dx * x + dy * y2, c1.y + dy * x - dx * y2)
  ];
}
function intersectCirclePolygon(c2, r2, points) {
  const result = [];
  let a2, b, int;
  for (let i = 0, n2 = points.length; i < n2; i++) {
    a2 = points[i];
    b = points[(i + 1) % points.length];
    int = intersectLineSegmentCircle(a2, b, c2, r2);
    if (int) result.push(...int);
  }
  if (result.length === 0) return null;
  return result;
}
function intersectCirclePolyline(c2, r2, points) {
  const result = [];
  let a2, b, int;
  for (let i = 1, n2 = points.length; i < n2; i++) {
    a2 = points[i - 1];
    b = points[i];
    int = intersectLineSegmentCircle(a2, b, c2, r2);
    if (int) result.push(...int);
  }
  if (result.length === 0) return null;
  return result;
}
function ccw(A, B, C) {
  return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
}
function linesIntersect(A, B, C, D) {
  return ccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D);
}
function intersectPolygonPolygon(polygonA, polygonB) {
  const result = /* @__PURE__ */ new Map();
  let a2, b, c2, d;
  for (let i = 0, n2 = polygonA.length; i < n2; i++) {
    a2 = polygonA[i];
    if (pointInPolygon(a2, polygonB)) {
      const id = getPointId(a2);
      if (!result.has(id)) {
        result.set(id, a2);
      }
    }
  }
  for (let i = 0, n2 = polygonB.length; i < n2; i++) {
    a2 = polygonB[i];
    if (pointInPolygon(a2, polygonA)) {
      const id = getPointId(a2);
      if (!result.has(id)) {
        result.set(id, a2);
      }
    }
  }
  for (let i = 0, n2 = polygonA.length; i < n2; i++) {
    a2 = polygonA[i];
    b = polygonA[(i + 1) % polygonA.length];
    for (let j = 0, m = polygonB.length; j < m; j++) {
      c2 = polygonB[j];
      d = polygonB[(j + 1) % polygonB.length];
      const intersection = intersectLineSegmentLineSegment(a2, b, c2, d);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  if (result.size === 0) return null;
  return orderClockwise([...result.values()]);
}
function intersectPolys(polyA, polyB, isAClosed, isBClosed) {
  const result = /* @__PURE__ */ new Map();
  for (let i = 0, n2 = isAClosed ? polyA.length : polyA.length - 1; i < n2; i++) {
    const currentA = polyA[i];
    const nextA = polyA[(i + 1) % polyA.length];
    for (let j = 0, m = isBClosed ? polyB.length : polyB.length - 1; j < m; j++) {
      const currentB = polyB[j];
      const nextB = polyB[(j + 1) % polyB.length];
      const intersection = intersectLineSegmentLineSegment(currentA, nextA, currentB, nextB);
      if (intersection !== null) {
        const id = getPointId(intersection);
        if (!result.has(id)) {
          result.set(id, intersection);
        }
      }
    }
  }
  return [...result.values()];
}
function getPointId(point) {
  return `${point.x},${point.y}`;
}
function orderClockwise(points) {
  const C = Vec.Average(points);
  return points.sort((A, B) => Vec.Angle(C, A) - Vec.Angle(C, B));
}
function polygonsIntersect(a2, b) {
  let a0, a1, b0, b1;
  for (let i = 0, n2 = a2.length; i < n2; i++) {
    a0 = a2[i];
    a1 = a2[(i + 1) % n2];
    for (let j = 0, m = b.length; j < m; j++) {
      b0 = b[j];
      b1 = b[(j + 1) % m];
      if (linesIntersect(a0, a1, b0, b1)) return true;
    }
  }
  return false;
}
function polygonIntersectsPolyline(polygon, polyline) {
  let a2, b, c2, d;
  for (let i = 0, n2 = polygon.length; i < n2; i++) {
    a2 = polygon[i];
    b = polygon[(i + 1) % n2];
    for (let j = 1, m = polyline.length; j < m; j++) {
      c2 = polyline[j - 1];
      d = polyline[j];
      if (linesIntersect(a2, b, c2, d)) return true;
    }
  }
  return false;
}
const Geometry2dFilters = {
  EXCLUDE_NON_STANDARD: {
    includeLabels: false,
    includeInternal: false
  },
  EXCLUDE_LABELS: { includeLabels: false, includeInternal: true }
};
class Geometry2d {
  isFilled = false;
  isClosed = true;
  isLabel = false;
  isInternal = false;
  debugColor;
  ignore;
  constructor(opts) {
    this.isFilled = opts.isFilled;
    this.isClosed = opts.isClosed;
    this.isLabel = opts.isLabel ?? false;
    this.isInternal = opts.isInternal ?? false;
    this.debugColor = opts.debugColor;
    this.ignore = opts.ignore;
  }
  isExcludedByFilter(filters) {
    if (!filters) return false;
    if (this.isLabel && !filters.includeLabels) return true;
    if (this.isInternal && !filters.includeInternal) return true;
    return false;
  }
  hitTestPoint(point, margin = 0, hitInside = false, _filters) {
    if (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices)) {
      return true;
    }
    return Vec.Dist2(point, this.nearestPoint(point)) <= margin * margin;
  }
  distanceToPoint(point, hitInside = false, filters) {
    return Vec.Dist(point, this.nearestPoint(point, filters)) * (this.isClosed && (this.isFilled || hitInside) && pointInPolygon(point, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(A, B, filters) {
    if (Vec.Equals(A, B)) return this.distanceToPoint(A, false, filters);
    const { vertices } = this;
    let nearest;
    let dist = Infinity;
    let d, p, q;
    for (let i = 0; i < vertices.length; i++) {
      p = vertices[i];
      q = Vec.NearestPointOnLineSegment(A, B, p, true);
      d = Vec.Dist2(p, q);
      if (d < dist) {
        dist = d;
        nearest = q;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return this.isClosed && this.isFilled && pointInPolygon(nearest, this.vertices) ? -dist : dist;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.distanceToLineSegment(A, B, filters) <= distance;
  }
  intersectLineSegment(A, B, _filters) {
    const intersections = this.isClosed ? intersectLineSegmentPolygon(A, B, this.vertices) : intersectLineSegmentPolyline(A, B, this.vertices);
    return intersections ?? [];
  }
  intersectCircle(center, radius, _filters) {
    const intersections = this.isClosed ? intersectCirclePolygon(center, radius, this.vertices) : intersectCirclePolyline(center, radius, this.vertices);
    return intersections ?? [];
  }
  intersectPolygon(polygon, _filters) {
    return intersectPolys(polygon, this.vertices, true, this.isClosed);
  }
  intersectPolyline(polyline, _filters) {
    return intersectPolys(polyline, this.vertices, false, this.isClosed);
  }
  /**
   * Find a point along the edge of the geometry that is a fraction `t` along the entire way round.
   */
  interpolateAlongEdge(t2, _filters) {
    const { vertices } = this;
    if (t2 <= 0) return vertices[0];
    const distanceToTravel = t2 * this.length;
    let distanceTraveled = 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const dist = Vec.Dist(curr, next);
      const newDistanceTraveled = distanceTraveled + dist;
      if (newDistanceTraveled >= distanceToTravel) {
        const p = Vec.Lrp(
          curr,
          next,
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel)
        );
        return p;
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.isClosed ? vertices[0] : vertices[vertices.length - 1];
  }
  /**
   * Take `point`, find the closest point to it on the edge of the geometry, and return how far
   * along the edge it is as a fraction of the total length.
   */
  uninterpolateAlongEdge(point, _filters) {
    const { vertices, length } = this;
    let closestSegment = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    for (let i = 0; i < (this.isClosed ? vertices.length : vertices.length - 1); i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      const nearestPoint = Vec.NearestPointOnLineSegment(curr, next, point, true);
      const distance = Vec.Dist(nearestPoint, point);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestSegment = {
          start: curr,
          end: next,
          nearestPoint,
          distanceToStart: distanceTraveled
        };
      }
      distanceTraveled += Vec.Dist(curr, next);
    }
    assert(closestSegment);
    const distanceAlongRoute = closestSegment.distanceToStart + Vec.Dist(closestSegment.start, closestSegment.nearestPoint);
    return distanceAlongRoute / length;
  }
  /** @deprecated Iterate the vertices instead. */
  nearestPointOnLineSegment(A, B) {
    const { vertices } = this;
    let nearest;
    let dist = Infinity;
    let d, p, q;
    for (let i = 0; i < vertices.length; i++) {
      p = vertices[i];
      q = Vec.NearestPointOnLineSegment(A, B, p, true);
      d = Vec.Dist2(p, q);
      if (d < dist) {
        dist = d;
        nearest = q;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  isPointInBounds(point, margin = 0) {
    const { bounds } = this;
    return !(point.x < bounds.minX - margin || point.y < bounds.minY - margin || point.x > bounds.maxX + margin || point.y > bounds.maxY + margin);
  }
  transform(transform, opts) {
    return new TransformedGeometry2d(this, transform, opts);
  }
  _vertices;
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    if (!this._vertices) {
      this._vertices = this.getVertices(Geometry2dFilters.EXCLUDE_LABELS);
    }
    return this._vertices;
  }
  getBounds() {
    return Box.FromPoints(this.vertices);
  }
  _bounds;
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    if (!this._bounds) {
      this._bounds = this.getBounds();
    }
    return this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  _area;
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    if (!this._area) {
      this._area = this.getArea();
    }
    return this._area;
  }
  getArea() {
    if (!this.isClosed) {
      return 0;
    }
    const { vertices } = this;
    let area = 0;
    for (let i = 0, n2 = vertices.length; i < n2; i++) {
      const curr = vertices[i];
      const next = vertices[(i + 1) % n2];
      area += curr.x * next.y - next.x * curr.y;
    }
    return area / 2;
  }
  toSimpleSvgPath() {
    let path = "";
    const { vertices } = this;
    const n2 = vertices.length;
    if (n2 === 0) return path;
    path += `M${vertices[0].x},${vertices[0].y}`;
    for (let i = 1; i < n2; i++) {
      path += `L${vertices[i].x},${vertices[i].y}`;
    }
    if (this.isClosed) {
      path += "Z";
    }
    return path;
  }
  _length;
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    if (this._length) return this._length;
    this._length = this.getLength(Geometry2dFilters.EXCLUDE_LABELS);
    return this._length;
  }
  getLength(_filters) {
    const vertices = this.getVertices(_filters ?? Geometry2dFilters.EXCLUDE_LABELS);
    if (vertices.length === 0) return 0;
    let prev = vertices[0];
    let length = 0;
    for (let i = 1; i < vertices.length; i++) {
      const next = vertices[i];
      length += Vec.Dist(prev, next);
      prev = next;
    }
    if (this.isClosed) {
      length += Vec.Dist(vertices[vertices.length - 1], vertices[0]);
    }
    return length;
  }
}
class TransformedGeometry2d extends Geometry2d {
  constructor(geometry, matrix, opts) {
    super(geometry);
    this.geometry = geometry;
    this.matrix = matrix;
    this.inverse = Mat.Inverse(matrix);
    this.decomposed = Mat.Decompose(matrix);
    if (opts) {
      if (opts.isLabel != null) this.isLabel = opts.isLabel;
      if (opts.isInternal != null) this.isInternal = opts.isInternal;
      if (opts.debugColor != null) this.debugColor = opts.debugColor;
      if (opts.ignore != null) this.ignore = opts.ignore;
    }
    assert(
      approximately(this.decomposed.scaleX, this.decomposed.scaleY),
      "non-uniform scaling is not yet supported"
    );
  }
  inverse;
  decomposed;
  getVertices(filters) {
    return this.geometry.getVertices(filters).map((v) => Mat.applyToPoint(this.matrix, v));
  }
  nearestPoint(point, filters) {
    return Mat.applyToPoint(
      this.matrix,
      this.geometry.nearestPoint(Mat.applyToPoint(this.inverse, point), filters)
    );
  }
  hitTestPoint(point, margin = 0, hitInside, filters) {
    return this.geometry.hitTestPoint(
      Mat.applyToPoint(this.inverse, point),
      margin / this.decomposed.scaleX,
      hitInside,
      filters
    );
  }
  distanceToPoint(point, hitInside = false, filters) {
    return this.geometry.distanceToPoint(Mat.applyToPoint(this.inverse, point), hitInside, filters) * this.decomposed.scaleX;
  }
  distanceToLineSegment(A, B, filters) {
    return this.geometry.distanceToLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      filters
    ) * this.decomposed.scaleX;
  }
  hitTestLineSegment(A, B, distance = 0, filters) {
    return this.geometry.hitTestLineSegment(
      Mat.applyToPoint(this.inverse, A),
      Mat.applyToPoint(this.inverse, B),
      distance / this.decomposed.scaleX,
      filters
    );
  }
  intersectLineSegment(A, B, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectLineSegment(
        Mat.applyToPoint(this.inverse, A),
        Mat.applyToPoint(this.inverse, B),
        filters
      )
    );
  }
  intersectCircle(center, radius, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectCircle(
        Mat.applyToPoint(this.inverse, center),
        radius / this.decomposed.scaleX,
        filters
      )
    );
  }
  intersectPolygon(polygon, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolygon(Mat.applyToPoints(this.inverse, polygon), filters)
    );
  }
  intersectPolyline(polyline, filters) {
    return Mat.applyToPoints(
      this.matrix,
      this.geometry.intersectPolyline(Mat.applyToPoints(this.inverse, polyline), filters)
    );
  }
  transform(transform, opts) {
    return new TransformedGeometry2d(this.geometry, Mat.Multiply(transform, this.matrix), {
      isLabel: opts?.isLabel ?? this.isLabel,
      isInternal: opts?.isInternal ?? this.isInternal,
      debugColor: opts?.debugColor ?? this.debugColor,
      ignore: opts?.ignore ?? this.ignore
    });
  }
  getSvgPathData() {
    throw new Error("Cannot get SVG path data for transformed geometry.");
  }
}
class Group2d extends Geometry2d {
  children = [];
  ignoredChildren = [];
  constructor(config) {
    super({ ...config, isClosed: true, isFilled: false });
    for (const child of config.children) {
      if (child.ignore) {
        this.ignoredChildren.push(child);
      } else {
        this.children.push(child);
      }
    }
    if (this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices(filters) {
    if (this.isExcludedByFilter(filters)) return [];
    return this.children.filter((c2) => !c2.isExcludedByFilter(filters)).flatMap((c2) => c2.getVertices(filters));
  }
  nearestPoint(point, filters) {
    let dist = Infinity;
    let nearest;
    const { children } = this;
    if (children.length === 0) {
      throw Error("no children");
    }
    let p;
    let d;
    for (const child of children) {
      if (child.isExcludedByFilter(filters)) continue;
      p = child.nearestPoint(point, filters);
      d = Vec.Dist2(p, point);
      if (d < dist) {
        dist = d;
        nearest = p;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  distanceToPoint(point, hitInside = false, filters) {
    let smallestDistance = Infinity;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const distance = child.distanceToPoint(point, hitInside, filters);
      if (distance < smallestDistance) {
        smallestDistance = distance;
      }
    }
    return smallestDistance;
  }
  hitTestPoint(point, margin, hitInside, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c2) => !c2.isExcludedByFilter(filters)).find((c2) => c2.hitTestPoint(point, margin, hitInside));
  }
  hitTestLineSegment(A, B, zoom, filters = Geometry2dFilters.EXCLUDE_LABELS) {
    return !!this.children.filter((c2) => !c2.isExcludedByFilter(filters)).find((c2) => c2.hitTestLineSegment(A, B, zoom));
  }
  intersectLineSegment(A, B, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectLineSegment(A, B, filters);
    });
  }
  intersectCircle(center, radius, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectCircle(center, radius, filters);
    });
  }
  intersectPolygon(polygon, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectPolygon(polygon, filters);
    });
  }
  intersectPolyline(polyline, filters) {
    return this.children.flatMap((child) => {
      if (child.isExcludedByFilter(filters)) return EMPTY_ARRAY;
      return child.intersectPolyline(polyline, filters);
    });
  }
  interpolateAlongEdge(t2, filters) {
    const totalLength = this.getLength(filters);
    const distanceToTravel = t2 * totalLength;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const childLength = child.length;
      const newDistanceTraveled = distanceTraveled + childLength;
      if (newDistanceTraveled >= distanceToTravel) {
        return child.interpolateAlongEdge(
          invLerp(distanceTraveled, newDistanceTraveled, distanceToTravel),
          filters
        );
      }
      distanceTraveled = newDistanceTraveled;
    }
    return this.children[this.children.length - 1].interpolateAlongEdge(1, filters);
  }
  uninterpolateAlongEdge(point, filters) {
    const totalLength = this.getLength(filters);
    let closestChild = null;
    let closestDistance = Infinity;
    let distanceTraveled = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      const childLength = child.getLength(filters);
      const newDistanceTraveled = distanceTraveled + childLength;
      const distance = child.distanceToPoint(point, false, filters);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestChild = {
          startLength: distanceTraveled,
          endLength: newDistanceTraveled,
          child
        };
      }
      distanceTraveled = newDistanceTraveled;
    }
    assert(closestChild);
    const normalizedDistanceInChild = closestChild.child.uninterpolateAlongEdge(point, filters);
    const childTLength = lerp(
      closestChild.startLength,
      closestChild.endLength,
      normalizedDistanceInChild
    );
    return childTLength / totalLength;
  }
  transform(transform) {
    return new Group2d({
      children: this.children.map((c2) => c2.transform(transform)),
      isLabel: this.isLabel,
      debugColor: this.debugColor,
      ignore: this.ignore
    });
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let path = "";
    for (const child of this.children) {
      path += child.toSimpleSvgPath();
    }
    const corners = Box.FromPoints(this.vertices).corners;
    for (let i = 0, n2 = corners.length; i < n2; i++) {
      const corner = corners[i];
      const prevCorner = corners[(i - 1 + n2) % n2];
      const prevDist = corner.dist(prevCorner);
      const nextCorner = corners[(i + 1) % n2];
      const nextDist = corner.dist(nextCorner);
      const A = corner.clone().lrp(prevCorner, 4 / prevDist);
      const B = corner;
      const C = corner.clone().lrp(nextCorner, 4 / nextDist);
      path += `M${A.x},${A.y} L${B.x},${B.y} L${C.x},${C.y} `;
    }
    return path;
  }
  getLength(filters) {
    let length = 0;
    for (const child of this.children) {
      if (child.isExcludedByFilter(filters)) continue;
      length += child.length;
    }
    return length;
  }
  getSvgPathData() {
    return this.children.map((c2, i) => c2.isLabel ? "" : c2.getSvgPathData(i === 0)).join(" ");
  }
}
function useTick$1(isEnabled = true) {
  const [_, setTick] = reactExports.useState(0);
  const editor = useEditor();
  reactExports.useEffect(() => {
    if (!isEnabled) return;
    const update = () => setTick((tick2) => tick2 + 1);
    editor.on("tick", update);
    return () => {
      editor.off("tick", update);
    };
  }, [editor, isEnabled]);
}
const GeometryDebuggingView = track(function GeometryDebuggingView2({
  showStroke = true,
  showVertices = true,
  showClosestPointOnOutline = true
}) {
  const editor = useEditor();
  useTick$1(showClosestPointOnOutline);
  const zoomLevel = editor.getZoomLevel();
  const renderingShapes = editor.getRenderingShapes();
  const {
    inputs: { currentPagePoint }
  } = editor;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: renderingShapes.map((result) => {
        const shape = editor.getShape(result.id);
        if (shape.type === "group") return null;
        const geometry = editor.getShapeGeometry(shape);
        const pageTransform = editor.getShapePageTransform(shape);
        const pointInShapeSpace = editor.getPointInShapeSpace(shape, currentPagePoint);
        const nearestPointOnShape = geometry.nearestPoint(pointInShapeSpace);
        const distanceToPoint = geometry.distanceToPoint(pointInShapeSpace, true);
        const dist = Math.abs(distanceToPoint) * zoomLevel;
        const hitInside = distanceToPoint < 0;
        const { vertices } = geometry;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "g",
          {
            transform: pageTransform.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              showStroke && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "g",
                {
                  stroke: geometry.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / zoomLevel,
                  fill: "none",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeometryStroke, { geometry })
                }
              ),
              showVertices && vertices.map((v, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  cx: v.x,
                  cy: v.y,
                  r: 2 / zoomLevel,
                  fill: `hsl(${modulate(i, [0, vertices.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / zoomLevel
                },
                `v${i}`
              )),
              showClosestPointOnOutline && dist < 150 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: nearestPointOnShape.x,
                  y1: nearestPointOnShape.y,
                  x2: pointInShapeSpace.x,
                  y2: pointInShapeSpace.y,
                  opacity: 1 - dist / 150,
                  stroke: hitInside ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / zoomLevel
                }
              )
            ]
          },
          result.id + "_outline"
        );
      })
    }
  );
});
function GeometryStroke({ geometry }) {
  if (geometry instanceof Group2d) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { stroke: geometry.debugColor, children: [...geometry.children, ...geometry.ignoredChildren].map((child, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(GeometryStroke, { geometry: child }, i)) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: geometry.toSimpleSvgPath(), stroke: geometry.debugColor });
}
function uniq(array2) {
  return _uniq(array2);
}
function usePeerIds() {
  const editor = useEditor();
  const $userIds = useComputed(
    "userIds",
    () => uniq(editor.getCollaborators().map((p) => p.userId)).sort(),
    { isEqual: (a2, b) => a2.join(",") === b.join?.(",") },
    [editor]
  );
  return useValue($userIds);
}
function usePresence$1(userId) {
  const editor = useEditor();
  const latestPresence = useValue(
    `latestPresence:${userId}`,
    () => {
      return editor.getCollaborators().find((c2) => c2.userId === userId);
    },
    [editor, userId]
  );
  return latestPresence ?? null;
}
const LiveCollaborators = track(function Collaborators() {
  const peerIds = usePeerIds();
  return peerIds.map((id) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollaboratorGuard, { collaboratorId: id }, id));
});
const CollaboratorGuard = track(function CollaboratorGuard2({
  collaboratorId
}) {
  const editor = useEditor();
  const presence = usePresence$1(collaboratorId);
  const collaboratorState = useCollaboratorState(editor, presence);
  if (!(presence && presence.currentPageId === editor.getCurrentPageId())) {
    return null;
  }
  switch (collaboratorState) {
    case "inactive": {
      const { followingUserId, highlightedUserIds } = editor.getInstanceState();
      if (!(followingUserId === presence.userId || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
    case "idle": {
      const { highlightedUserIds } = editor.getInstanceState();
      if (presence.followingUserId === editor.user.getId() && !(presence.chatMessage || highlightedUserIds.includes(presence.userId))) {
        return null;
      }
      break;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collaborator, { latestPresence: presence });
});
const Collaborator = track(function Collaborator2({
  latestPresence
}) {
  const editor = useEditor();
  const {
    CollaboratorBrush,
    CollaboratorScribble,
    CollaboratorCursor,
    CollaboratorHint,
    CollaboratorShapeIndicator
  } = useEditorComponents();
  const zoomLevel = editor.getZoomLevel();
  const viewportPageBounds = editor.getViewportPageBounds();
  const { userId, chatMessage, brush, scribbles, selectedShapeIds, userName, cursor, color } = latestPresence;
  if (!cursor) return null;
  const isCursorInViewport = !(cursor.x < viewportPageBounds.minX - 12 / zoomLevel || cursor.y < viewportPageBounds.minY - 16 / zoomLevel || cursor.x > viewportPageBounds.maxX - 12 / zoomLevel || cursor.y > viewportPageBounds.maxY - 16 / zoomLevel);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    brush && CollaboratorBrush ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorBrush,
      {
        className: "tl-collaborator__brush",
        userId,
        brush,
        color,
        opacity: 0.1
      },
      userId + "_brush"
    ) : null,
    isCursorInViewport && CollaboratorCursor ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorCursor,
      {
        className: "tl-collaborator__cursor",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        name: userName !== "New User" ? userName : null,
        chatMessage: chatMessage ?? ""
      },
      userId + "_cursor"
    ) : CollaboratorHint ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorHint,
      {
        className: "tl-collaborator__cursor-hint",
        userId,
        point: cursor,
        color,
        zoom: zoomLevel,
        viewport: viewportPageBounds
      },
      userId + "_cursor_hint"
    ) : null,
    CollaboratorScribble && scribbles.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: scribbles.map((scribble) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorScribble,
      {
        className: "tl-collaborator__scribble",
        userId,
        scribble,
        color,
        zoom: zoomLevel,
        opacity: scribble.color === "laser" ? 0.5 : 0.1
      },
      userId + "_scribble_" + scribble.id
    )) }) : null,
    CollaboratorShapeIndicator && selectedShapeIds.filter((id) => !editor.isShapeHidden(id)).map((shapeId) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      CollaboratorShapeIndicator,
      {
        className: "tl-collaborator__shape-indicator",
        userId,
        shapeId,
        color,
        opacity: 0.5
      },
      userId + "_" + shapeId
    ))
  ] });
});
function getStateFromElapsedTime(editor, elapsed) {
  return elapsed > editor.options.collaboratorInactiveTimeoutMs ? "inactive" : elapsed > editor.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function useCollaboratorState(editor, latestPresence) {
  const rLastActivityTimestamp = reactExports.useRef(latestPresence?.lastActivityTimestamp ?? -1);
  const [state, setState] = reactExports.useState(
    () => getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current)
  );
  reactExports.useEffect(() => {
    const interval = editor.timers.setInterval(() => {
      setState(getStateFromElapsedTime(editor, Date.now() - rLastActivityTimestamp.current));
    }, editor.options.collaboratorCheckIntervalMs);
    return () => clearInterval(interval);
  }, [editor]);
  if (latestPresence) {
    rLastActivityTimestamp.current = latestPresence.lastActivityTimestamp ?? Infinity;
  }
  return state;
}
function MenuClickCapture() {
  const editor = useEditor();
  const isMenuOpen = useValue("is menu open", () => editor.menus.hasAnyOpenMenus(), [editor]);
  const [isPointing, setIsPointing] = reactExports.useState(false);
  const showElement = isMenuOpen || isPointing;
  const canvasEvents = useCanvasEvents();
  const rPointerState = reactExports.useRef({
    isDown: false,
    isDragging: false,
    start: new Vec()
  });
  const handlePointerDown = reactExports.useCallback(
    (e) => {
      if (e.button === 0) {
        setIsPointing(true);
        rPointerState.current = {
          isDown: true,
          isDragging: false,
          start: new Vec(e.clientX, e.clientY)
        };
      }
      editor.menus.clearOpenMenus();
    },
    [editor]
  );
  const handlePointerMove = reactExports.useCallback(
    (e) => {
      if (!rPointerState.current.isDown) return;
      if (rPointerState.current.isDragging) {
        canvasEvents.onPointerMove?.(e);
        return;
      }
      if (
        // We're pointing, but are we dragging?
        Vec.Dist2(rPointerState.current.start, new Vec(e.clientX, e.clientY)) > editor.options.dragDistanceSquared
      ) {
        rPointerState.current = {
          ...rPointerState.current,
          isDown: true,
          isDragging: true
        };
        const { x, y: y2 } = rPointerState.current.start;
        canvasEvents.onPointerDown?.({
          ...e,
          clientX: x,
          clientY: y2,
          button: 0
        });
        canvasEvents.onPointerMove?.(e);
      }
    },
    [canvasEvents, editor]
  );
  const handlePointerUp = reactExports.useCallback(
    (e) => {
      canvasEvents.onPointerUp?.(e);
      setIsPointing(false);
      rPointerState.current = {
        isDown: false,
        isDragging: false,
        start: new Vec(e.clientX, e.clientY)
      };
    },
    [canvasEvents]
  );
  return showElement && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "tlui-menu-click-capture",
      "data-testid": "menu-click-capture.content",
      ...canvasEvents,
      onPointerDown: handlePointerDown,
      onPointerMove: handlePointerMove,
      onPointerUp: handlePointerUp
    }
  );
}
const areShapesContentEqual = (a2, b) => a2.props === b.props && a2.meta === b.meta;
const Shape = reactExports.memo(function Shape2({
  id,
  shape,
  util: util2,
  index: index2,
  backgroundIndex,
  opacity,
  dprMultiple
}) {
  const editor = useEditor();
  const { ShapeErrorFallback } = useEditorComponents();
  const containerRef = reactExports.useRef(null);
  const bgContainerRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return react$1("load fonts", () => {
      const fonts = editor.fonts.getShapeFontFaces(id);
      editor.fonts.requestFonts(fonts);
    });
  }, [editor, id]);
  const memoizedStuffRef = reactExports.useRef({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: false
  });
  useQuickReactor(
    "set shape stuff",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2) return;
      const prev = memoizedStuffRef.current;
      const clipPath = editor.getShapeClipPath(id) ?? "none";
      if (clipPath !== prev.clipPath) {
        setStyleProperty(containerRef.current, "clip-path", clipPath);
        setStyleProperty(bgContainerRef.current, "clip-path", clipPath);
        prev.clipPath = clipPath;
      }
      const pageTransform = editor.getShapePageTransform(id);
      const transform = Mat.toCssString(pageTransform);
      const bounds = editor.getShapeGeometry(shape2).bounds;
      if (transform !== prev.transform) {
        setStyleProperty(containerRef.current, "transform", transform);
        setStyleProperty(bgContainerRef.current, "transform", transform);
        prev.transform = transform;
      }
      const widthRemainder = bounds.w % dprMultiple;
      const heightRemainder = bounds.h % dprMultiple;
      const width = widthRemainder === 0 ? bounds.w : bounds.w + (dprMultiple - widthRemainder);
      const height = heightRemainder === 0 ? bounds.h : bounds.h + (dprMultiple - heightRemainder);
      if (width !== prev.width || height !== prev.height) {
        setStyleProperty(containerRef.current, "width", Math.max(width, dprMultiple) + "px");
        setStyleProperty(containerRef.current, "height", Math.max(height, dprMultiple) + "px");
        setStyleProperty(bgContainerRef.current, "width", Math.max(width, dprMultiple) + "px");
        setStyleProperty(bgContainerRef.current, "height", Math.max(height, dprMultiple) + "px");
        prev.width = width;
        prev.height = height;
      }
    },
    [editor]
  );
  reactExports.useLayoutEffect(() => {
    const container = containerRef.current;
    const bgContainer = bgContainerRef.current;
    setStyleProperty(container, "opacity", opacity);
    setStyleProperty(bgContainer, "opacity", opacity);
    setStyleProperty(container, "z-index", index2);
    setStyleProperty(bgContainer, "z-index", backgroundIndex);
  }, [opacity, index2, backgroundIndex]);
  useQuickReactor(
    "set display",
    () => {
      const shape2 = editor.getShape(id);
      if (!shape2) return;
      const culledShapes = editor.getCulledShapes();
      const isCulled = culledShapes.has(id);
      if (isCulled !== memoizedStuffRef.current.isCulled) {
        setStyleProperty(containerRef.current, "display", isCulled ? "none" : "block");
        setStyleProperty(bgContainerRef.current, "display", isCulled ? "none" : "block");
        memoizedStuffRef.current.isCulled = isCulled;
      }
    },
    [editor]
  );
  const annotateError2 = reactExports.useCallback(
    (error) => editor.annotateError(error, { origin: "shape", willCrashApp: false }),
    [editor]
  );
  if (!shape) return null;
  const isFilledShape = "fill" in shape.props && shape.props.fill !== "none";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    util2.backgroundComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: bgContainerRef,
        className: "tl-shape tl-shape-background",
        "data-shape-type": shape.type,
        "data-shape-id": shape.id,
        draggable: false,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerShapeBackground, { shape, util: util2 }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: containerRef,
        className: "tl-shape",
        "data-shape-type": shape.type,
        "data-shape-is-filled": isFilledShape,
        "data-shape-id": shape.id,
        draggable: false,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalErrorBoundary, { fallback: ShapeErrorFallback, onError: annotateError2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerShape, { shape, util: util2 }) })
      }
    )
  ] });
});
const InnerShape = reactExports.memo(
  function InnerShape2({ shape, util: util2 }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util2.component(util2.editor.store.unsafeGetWithoutCapture(shape.id))
      ),
      [util2, shape.id]
    );
  },
  (prev, next) => areShapesContentEqual(prev.shape, next.shape) && prev.util === next.util
);
const InnerShapeBackground = reactExports.memo(
  function InnerShapeBackground2({
    shape,
    util: util2
  }) {
    return useStateTracking(
      "InnerShape:" + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util2.backgroundComponent?.(util2.editor.store.unsafeGetWithoutCapture(shape.id))
      ),
      [util2, shape.id]
    );
  },
  (prev, next) => prev.shape.props === next.shape.props && prev.shape.meta === next.shape.meta && prev.util === next.util
);
function DefaultCanvas({ className }) {
  const editor = useEditor();
  const { SelectionBackground, Background, SvgDefs, ShapeIndicators } = useEditorComponents();
  const rCanvas = reactExports.useRef(null);
  const rHtmlLayer = reactExports.useRef(null);
  const rHtmlLayer2 = reactExports.useRef(null);
  const container = useContainer();
  useScreenBounds(rCanvas);
  useDocumentEvents();
  useCoarsePointer();
  useGestureEvents(rCanvas);
  useFixSafariDoubleTapZoomPencilEvents(rCanvas);
  const rMemoizedStuff = reactExports.useRef({ lodDisableTextOutline: false, allowTextOutline: true });
  useQuickReactor(
    "position layers",
    function positionLayersWhenCameraMoves() {
      const { x, y: y2, z } = editor.getCamera();
      if (rMemoizedStuff.current.allowTextOutline && tlenv.isSafari) {
        container.style.setProperty("--tl-text-outline", "none");
        rMemoizedStuff.current.allowTextOutline = false;
      }
      if (rMemoizedStuff.current.allowTextOutline && z < editor.options.textShadowLod !== rMemoizedStuff.current.lodDisableTextOutline) {
        const lodDisableTextOutline = z < editor.options.textShadowLod;
        container.style.setProperty(
          "--tl-text-outline",
          lodDisableTextOutline ? "none" : `var(--tl-text-outline-reference)`
        );
        rMemoizedStuff.current.lodDisableTextOutline = lodDisableTextOutline;
      }
      const offset2 = z >= 1 ? modulate(z, [1, 8], [0.125, 0.5], true) : modulate(z, [0.1, 1], [-2, 0.125], true);
      const transform = `scale(${toDomPrecision(z)}) translate(${toDomPrecision(
        x + offset2
      )}px,${toDomPrecision(y2 + offset2)}px)`;
      setStyleProperty(rHtmlLayer.current, "transform", transform);
      setStyleProperty(rHtmlLayer2.current, "transform", transform);
    },
    [editor, container]
  );
  const events = useCanvasEvents();
  const shapeSvgDefs = useValue(
    "shapeSvgDefs",
    () => {
      const shapeSvgDefsByKey = /* @__PURE__ */ new Map();
      for (const util2 of objectMapValues(editor.shapeUtils)) {
        if (!util2) return;
        const defs = util2.getCanvasSvgDefs();
        for (const { key, component: Component } of defs) {
          if (shapeSvgDefsByKey.has(key)) continue;
          shapeSvgDefsByKey.set(key, /* @__PURE__ */ jsxRuntimeExports.jsx(Component, {}, key));
        }
      }
      return [...shapeSvgDefsByKey.values()];
    },
    [editor]
  );
  const hideShapes = useValue("debug_shapes", () => debugFlags.hideShapes.get(), [debugFlags]);
  const debugSvg = useValue("debug_svg", () => debugFlags.debugSvg.get(), [debugFlags]);
  const debugGeometry = useValue("debug_geometry", () => debugFlags.debugGeometry.get(), [
    debugFlags
  ]);
  const isEditingAnything = useValue(
    "isEditingAnything",
    () => editor.getEditingShapeId() !== null,
    [editor]
  );
  const isSelectingAnything = useValue(
    "isSelectingAnything",
    () => !!editor.getSelectedShapeIds().length,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: rCanvas,
        draggable: false,
        "data-iseditinganything": isEditingAnything,
        "data-isselectinganything": isSelectingAnything,
        className: classNames("tl-canvas", className),
        "data-testid": "canvas",
        ...events,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-svg-context", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
            shapeSvgDefs,
            /* @__PURE__ */ jsxRuntimeExports.jsx(CursorDef, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CollaboratorHintDef, {}),
            SvgDefs && /* @__PURE__ */ jsxRuntimeExports.jsx(SvgDefs, {})
          ] }) }),
          Background && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-background__wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Background, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(GridWrapper, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: rHtmlLayer, className: "tl-html-layer tl-shapes", draggable: false, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(OnTheCanvasWrapper, {}),
            SelectionBackground && /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionBackgroundWrapper, {}),
            hideShapes ? null : debugSvg ? /* @__PURE__ */ jsxRuntimeExports.jsx(ShapesWithSVGs, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ShapesToDisplay, {})
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-overlays", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: rHtmlLayer2, className: "tl-html-layer", children: [
            debugGeometry ? /* @__PURE__ */ jsxRuntimeExports.jsx(GeometryDebuggingView, {}) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsx(BrushWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ScribbleWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomBrushWrapper, {}),
            ShapeIndicators && /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeIndicators, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(HintedShapeIndicator, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SnapIndicatorWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionForegroundWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(HandlesWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(OverlaysWrapper, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(LiveCollaborators, {})
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MovingCameraHitTestBlocker, {})
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MenuClickCapture, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(InFrontOfTheCanvasWrapper, {})
  ] });
}
function InFrontOfTheCanvasWrapper() {
  const { InFrontOfTheCanvas } = useEditorComponents();
  if (!InFrontOfTheCanvas) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InFrontOfTheCanvas, {});
}
function GridWrapper() {
  const editor = useEditor();
  const gridSize = useValue("gridSize", () => editor.getDocumentSettings().gridSize, [editor]);
  const { x, y: y2, z } = useValue("camera", () => editor.getCamera(), [editor]);
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  const { Grid } = useEditorComponents();
  if (!(Grid && isGridMode)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { x, y: y2, z, size: gridSize });
}
function ScribbleWrapper() {
  const editor = useEditor();
  const scribbles = useValue("scribbles", () => editor.getInstanceState().scribbles, [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const { Scribble } = useEditorComponents();
  if (!(Scribble && scribbles.length)) return null;
  return scribbles.map((scribble) => /* @__PURE__ */ jsxRuntimeExports.jsx(Scribble, { className: "tl-user-scribble", scribble, zoom: zoomLevel }, scribble.id));
}
function BrushWrapper() {
  const editor = useEditor();
  const brush = useValue("brush", () => editor.getInstanceState().brush, [editor]);
  const { Brush } = useEditorComponents();
  if (!(Brush && brush)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Brush, { className: "tl-user-brush", brush });
}
function ZoomBrushWrapper() {
  const editor = useEditor();
  const zoomBrush = useValue("zoomBrush", () => editor.getInstanceState().zoomBrush, [editor]);
  const { ZoomBrush } = useEditorComponents();
  if (!(ZoomBrush && zoomBrush)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomBrush, { className: "tl-user-brush tl-zoom-brush", brush: zoomBrush });
}
function SnapIndicatorWrapper() {
  const editor = useEditor();
  const lines = useValue("snapLines", () => editor.snaps.getIndicators(), [editor]);
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const { SnapIndicator } = useEditorComponents();
  if (!(SnapIndicator && lines.length > 0)) return null;
  return lines.map((line) => /* @__PURE__ */ jsxRuntimeExports.jsx(SnapIndicator, { className: "tl-user-snapline", line, zoom: zoomLevel }, line.id));
}
function HandlesWrapper() {
  const editor = useEditor();
  const shapeIdWithHandles = useValue(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly, isChangingStyle } = editor.getInstanceState();
      if (isReadonly || isChangingStyle) return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      const handles = editor.getShapeHandles(onlySelectedShape);
      if (!handles) return false;
      return onlySelectedShape.id;
    },
    [editor]
  );
  if (!shapeIdWithHandles) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(HandlesWrapperInner, { shapeId: shapeIdWithHandles });
}
function HandlesWrapperInner({ shapeId }) {
  const editor = useEditor();
  const { Handles } = useEditorComponents();
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const isCoarse = useValue("coarse pointer", () => editor.getInstanceState().isCoarsePointer, [
    editor
  ]);
  const transform = useValue("handles transform", () => editor.getShapePageTransform(shapeId), [
    editor,
    shapeId
  ]);
  const handles = useValue(
    "handles",
    () => {
      const handles2 = editor.getShapeHandles(shapeId);
      if (!handles2) return null;
      const minDistBetweenVirtualHandlesAndRegularHandles = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoomLevel * 2;
      return handles2.filter(
        (handle) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          handle.type !== "virtual" || !handles2.some(
            (h) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              h !== handle && // only check against vertex handles
              h.type === "vertex" && Vec.Dist(handle, h) < minDistBetweenVirtualHandlesAndRegularHandles
            )
          )
        )
      ).sort((a2) => a2.type === "vertex" ? 1 : -1);
    },
    [editor, zoomLevel, isCoarse, shapeId]
  );
  const isHidden2 = useValue("isHidden", () => editor.isShapeHidden(shapeId), [editor, shapeId]);
  if (!Handles || !handles || !transform || isHidden2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Handles, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: Mat.toCssString(transform), children: handles.map((handle) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      HandleWrapper,
      {
        shapeId,
        handle,
        zoom: zoomLevel,
        isCoarse
      },
      handle.id
    );
  }) }) });
}
function HandleWrapper({
  shapeId,
  handle,
  zoom,
  isCoarse
}) {
  const events = useHandleEvents(shapeId, handle.id);
  const { Handle } = useEditorComponents();
  if (!Handle) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "g",
    {
      role: "button",
      "aria-label": handle.label || "handle",
      transform: `translate(${handle.x}, ${handle.y})`,
      ...events,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Handle, { shapeId, handle, zoom, isCoarse })
    }
  );
}
function OverlaysWrapper() {
  const { Overlays } = useEditorComponents();
  if (!Overlays) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-custom-overlays tl-overlays__item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Overlays, {}) });
}
function ShapesWithSVGs() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const dprMultiple = useValue(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      nearestMultiple(Math.floor(editor.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [editor]
  );
  return renderingShapes.map((result) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Shape, { ...result, dprMultiple }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugSvgCopy, { id: result.id, mode: "iframe" })
  ] }, result.id + "_fragment"));
}
function ReflowIfNeeded() {
  const editor = useEditor();
  const culledShapesRef = reactExports.useRef(/* @__PURE__ */ new Set());
  useQuickReactor(
    "reflow for culled shapes",
    () => {
      const culledShapes = editor.getCulledShapes();
      if (culledShapesRef.current.size === culledShapes.size && [...culledShapes].every((id) => culledShapesRef.current.has(id)))
        return;
      culledShapesRef.current = culledShapes;
      const canvas = document.getElementsByClassName("tl-canvas");
      if (canvas.length === 0) return;
      canvas[0].offsetHeight;
    },
    [editor]
  );
  return null;
}
function ShapesToDisplay() {
  const editor = useEditor();
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const dprMultiple = useValue(
    "dpr multiple",
    () => (
      // dprMultiple is the smallest number we can multiply dpr by to get an integer
      // it's usually 1, 2, or 4 (for e.g. dpr of 2, 2.5 and 2.25 respectively)
      nearestMultiple(Math.floor(editor.getInstanceState().devicePixelRatio * 100) / 100)
    ),
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    renderingShapes.map((result) => /* @__PURE__ */ jsxRuntimeExports.jsx(Shape, { ...result, dprMultiple }, result.id + "_shape")),
    tlenv.isSafari && /* @__PURE__ */ jsxRuntimeExports.jsx(ReflowIfNeeded, {})
  ] });
}
function HintedShapeIndicator() {
  const editor = useEditor();
  const { ShapeIndicator } = useEditorComponents();
  const ids = useValue("hinting shape ids", () => dedupe(editor.getHintingShapeIds()), [editor]);
  if (!ids.length) return null;
  if (!ShapeIndicator) return null;
  return ids.map((id) => /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeIndicator, { className: "tl-user-indicator__hint", shapeId: id }, id + "_hinting"));
}
function CursorDef() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: useSharedSafeId("cursor"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function CollaboratorHintDef() {
  const cursorHintId = useSharedSafeId("cursor_hint");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: cursorHintId, fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function DebugSvgCopy({ id, mode }) {
  const editor = useEditor();
  const [image, setImage] = reactExports.useState(null);
  const isInRoot = useValue(
    "is in root",
    () => {
      const shape = editor.getShape(id);
      return shape?.parentId === editor.getCurrentPageId();
    },
    [editor, id]
  );
  reactExports.useEffect(() => {
    if (!isInRoot) return;
    let latest = null;
    const unsubscribe = react$1("shape to svg", async () => {
      const renderId = Math.random();
      latest = renderId;
      const isSingleFrame = editor.isShapeOfType(id, "frame");
      const padding = isSingleFrame ? 0 : 10;
      let bounds = editor.getShapePageBounds(id);
      if (!bounds) return;
      bounds = bounds.clone().expandBy(padding);
      const result = await editor.getSvgString([id], { padding });
      if (latest !== renderId || !result) return;
      const svgDataUrl = `data:image/svg+xml;utf8,${encodeURIComponent(result.svg)}`;
      setImage({ src: svgDataUrl, bounds });
    });
    return () => {
      latest = null;
      unsubscribe();
    };
  }, [editor, id, isInRoot]);
  if (!isInRoot || !image) return null;
  if (mode === "iframe") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        src: image.src,
        width: image.bounds.width,
        height: image.bounds.height,
        referrerPolicy: "no-referrer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          border: "none",
          transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
          outline: "1px solid black",
          maxWidth: "none"
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: image.src,
      width: image.bounds.width,
      height: image.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${image.bounds.x}px, ${image.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function SelectionForegroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue(
    "selection rotation",
    function getSelectionRotation() {
      return editor.getSelectionRotation();
    },
    [editor]
  );
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionForeground } = useEditorComponents();
  if (!selectionBounds || !SelectionForeground) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionForeground, { bounds: selectionBounds, rotation: selectionRotation });
}
function SelectionBackgroundWrapper() {
  const editor = useEditor();
  const selectionRotation = useValue("selection rotation", () => editor.getSelectionRotation(), [
    editor
  ]);
  const selectionBounds = useValue(
    "selection bounds",
    () => editor.getSelectionRotatedPageBounds(),
    [editor]
  );
  const { SelectionBackground } = useEditorComponents();
  if (!selectionBounds || !SelectionBackground) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectionBackground, { bounds: selectionBounds, rotation: selectionRotation });
}
function OnTheCanvasWrapper() {
  const { OnTheCanvas } = useEditorComponents();
  if (!OnTheCanvas) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(OnTheCanvas, {});
}
function MovingCameraHitTestBlocker() {
  const editor = useEditor();
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": cameraState === "idle"
      })
    }
  );
}
function DefaultCollaboratorHint({
  className,
  zoom,
  point,
  color,
  viewport,
  opacity = 1
}) {
  const rSvg = reactExports.useRef(null);
  useTransform(
    rSvg,
    clamp$3(point.x, viewport.minX + 5 / zoom, viewport.maxX - 5 / zoom),
    clamp$3(point.y, viewport.minY + 5 / zoom, viewport.maxY - 5 / zoom),
    1 / zoom,
    Vec.Angle(viewport.center, point)
  );
  const cursorHintId = useSharedSafeId("cursor_hint");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { ref: rSvg, className: classNames("tl-overlays__item", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "use",
      {
        href: `#${cursorHintId}`,
        color,
        strokeWidth: 3,
        stroke: "var(--color-background)"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("use", { href: `#${cursorHintId}`, color, opacity })
  ] });
}
const DefaultCursor = reactExports.memo(function DefaultCursor2({
  className,
  zoom,
  point,
  color,
  name,
  chatMessage
}) {
  const rCursor = reactExports.useRef(null);
  useTransform(rCursor, point?.x, point?.y, 1 / zoom);
  const cursorId = useSharedSafeId("cursor");
  if (!point) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: rCursor, className: classNames("tl-overlays__item", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-cursor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("use", { href: `#${cursorId}`, color }) }),
    chatMessage ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-nametag-title", style: { color }, children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-nametag-chat", style: { backgroundColor: color }, children: chatMessage })
    ] }) : name && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-nametag", style: { backgroundColor: color }, children: name })
  ] });
});
function DefaultGrid({ x, y: y2, z, size: size2 }) {
  const id = useUniqueSafeId("grid");
  const editor = useEditor();
  const { gridSteps } = editor.options;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: gridSteps.map(({ min: min2, mid, step }, i) => {
      const s2 = step * size2 * z;
      const xo = 0.5 + x * z;
      const yo = 0.5 + y2 * z;
      const gxo = xo > 0 ? xo % s2 : s2 + xo % s2;
      const gyo = yo > 0 ? yo % s2 : s2 + yo % s2;
      const opacity = z < mid ? modulate(z, [min2, mid], [0, 1]) : 1;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "pattern",
        {
          id: suffixSafeId(id, `${step}`),
          width: s2,
          height: s2,
          patternUnits: "userSpaceOnUse",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-grid-dot", cx: gxo, cy: gyo, r: 1, opacity })
        },
        i
      );
    }) }),
    gridSteps.map(({ step }, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "100%", height: "100%", fill: `url(#${id}_${step})` }, i))
  ] });
}
function DefaultHandle({ handle, isCoarse, className, zoom }) {
  const editor = useEditor();
  const br = (isCoarse ? editor.options.coarseHandleRadius : editor.options.handleRadius) / zoom;
  if (handle.type === "clone") {
    const fr2 = 3 / zoom;
    const path = `M0,${-fr2} A${fr2},${fr2} 0 0,1 0,${fr2}`;
    const index2 = SIDES.indexOf(handle.id);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: classNames(`tl-handle tl-handle__${handle.type}`, className), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-handle__bg", r: br }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "tl-handle__fg", d: path, transform: `rotate(${-90 + 90 * index2})` })
    ] });
  }
  const fr = (handle.type === "create" && isCoarse ? 3 : 4) / Math.max(zoom, 0.25);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: classNames(`tl-handle tl-handle__${handle.type}`, className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-handle__bg", r: br }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "tl-handle__fg", r: fr })
  ] });
}
const DefaultHandles = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-user-handles tl-overlays__item", children });
};
const DefaultLoadingScreen = () => {
  const { Spinner: Spinner2 } = useEditorComponents();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen, { children: Spinner2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {}) : null });
};
function getSvgPathFromPoints(points, closed = true) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a2 = points[0];
  let b = points[1];
  if (len === 2) {
    return `M${precise(a2)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max2 = len - 1; i < max2; i++) {
    a2 = points[i];
    b = points[i + 1];
    result += average(a2, b);
  }
  if (closed) {
    return `M${average(points[0], points[1])}Q${precise(points[1])}${average(
      points[1],
      points[2]
    )}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`;
  } else {
    return `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1])}`;
  }
}
function DefaultScribble({ scribble, zoom, color, opacity, className }) {
  if (!scribble.points.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: className ? classNames("tl-overlays__item", className) : className, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "tl-scribble",
      d: getSvgPathFromPoints(scribble.points, false),
      stroke: color ?? `var(--color-${scribble.color})`,
      fill: "none",
      strokeWidth: 8 / zoom,
      opacity: opacity ?? scribble.opacity
    }
  ) });
}
function DefaultSelectionForeground({ bounds, rotation }) {
  const editor = useEditor();
  const rSvg = reactExports.useRef(null);
  const onlyShape = useValue("only selected shape", () => editor.getOnlySelectedShape(), [editor]);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  useTransform(rSvg, bounds?.x, bounds?.y, 1, rotation, {
    x: -expandOutlineBy,
    y: -expandOutlineBy
  });
  bounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      ref: rSvg,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          className: classNames("tl-selection__fg__outline"),
          width: toDomPrecision(bounds.width),
          height: toDomPrecision(bounds.height)
        }
      )
    }
  );
}
const DefaultShapeErrorFallback = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-shape-error-boundary" });
};
const EvenInnererIndicator = reactExports.memo(
  ({ shape, util: util2 }) => {
    return useStateTracking(
      "Indicator: " + shape.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        util2.indicator(util2.editor.store.unsafeGetWithoutCapture(shape.id))
      )
    );
  },
  (prevProps, nextProps) => {
    return prevProps.shape.props === nextProps.shape.props && prevProps.shape.meta === nextProps.shape.meta;
  }
);
const InnerIndicator = reactExports.memo(({ editor, id }) => {
  const shape = useValue("shape for indicator", () => editor.store.get(id), [editor, id]);
  const { ShapeIndicatorErrorFallback } = useEditorComponents();
  if (!shape || shape.isLocked) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    OptionalErrorBoundary,
    {
      fallback: ShapeIndicatorErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.shapeIndicator", willCrashApp: false }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(EvenInnererIndicator, { shape, util: editor.getShapeUtil(shape) }, shape.id)
    }
  );
});
const DefaultShapeIndicator = reactExports.memo(function DefaultShapeIndicator2({
  shapeId,
  className,
  color,
  hidden,
  opacity
}) {
  const editor = useEditor();
  const rIndicator = reactExports.useRef(null);
  useQuickReactor(
    "indicator transform",
    () => {
      if (hidden) return;
      const elm = rIndicator.current;
      if (!elm) return;
      const pageTransform = editor.getShapePageTransform(shapeId);
      if (!pageTransform) return;
      elm.style.setProperty("transform", pageTransform.toCssString());
    },
    [editor, shapeId, hidden]
  );
  reactExports.useLayoutEffect(() => {
    const elm = rIndicator.current;
    if (!elm) return;
    elm.style.setProperty("display", hidden ? "none" : "block");
  }, [hidden]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { ref: rIndicator, className: classNames("tl-overlays__item", className), children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "tl-shape-indicator", stroke: color ?? "var(--color-selected)", opacity, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InnerIndicator, { editor, id: shapeId }) }) });
});
const DefaultShapeIndicatorErrorFallback = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
};
const DefaultShapeIndicators = reactExports.memo(function DefaultShapeIndicators2({
  hideAll,
  showAll
}) {
  const editor = useEditor();
  if (hideAll && showAll)
    throw Error("You cannot set both hideAll and showAll props to true, cmon now");
  const rPreviousSelectedShapeIds = reactExports.useRef(/* @__PURE__ */ new Set());
  const idsToDisplay = useValue(
    "should display selected ids",
    () => {
      const prev = rPreviousSelectedShapeIds.current;
      const next = /* @__PURE__ */ new Set();
      const instanceState = editor.getInstanceState();
      const isChangingStyle = instanceState.isChangingStyle;
      const isIdleOrEditing = editor.isInAny("select.idle", "select.editing_shape");
      const isInSelectState = editor.isInAny(
        "select.brushing",
        "select.scribble_brushing",
        "select.pointing_shape",
        "select.pointing_selection",
        "select.pointing_handle"
      );
      if (isChangingStyle || !(isIdleOrEditing || isInSelectState)) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of editor.getSelectedShapeIds()) {
        next.add(id);
      }
      if (isIdleOrEditing && instanceState.isHoveringCanvas && !instanceState.isCoarsePointer) {
        const hovered = editor.getHoveredShapeId();
        if (hovered) next.add(hovered);
      }
      if (prev.size !== next.size) {
        rPreviousSelectedShapeIds.current = next;
        return next;
      }
      for (const id of next) {
        if (!prev.has(id)) {
          rPreviousSelectedShapeIds.current = next;
          return next;
        }
      }
      return prev;
    },
    [editor]
  );
  const renderingShapes = useValue("rendering shapes", () => editor.getRenderingShapes(), [editor]);
  const { ShapeIndicator } = useEditorComponents();
  if (!ShapeIndicator) return null;
  return renderingShapes.map(({ id }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    ShapeIndicator,
    {
      shapeId: id,
      hidden: !showAll && (hideAll || !idsToDisplay.has(id))
    },
    id + "_indicator"
  ));
});
function PointsSnapIndicator({ points, zoom }) {
  const l = 2.5 / zoom;
  const minX = points.reduce((acc, p) => Math.min(acc, p.x), Infinity);
  const maxX = points.reduce((acc, p) => Math.max(acc, p.x), -Infinity);
  const minY = points.reduce((acc, p) => Math.min(acc, p.y), Infinity);
  const maxY = points.reduce((acc, p) => Math.max(acc, p.y), -Infinity);
  const useNWtoSEdireciton = points.some((p) => p.x === minX && p.y === minY);
  let firstX, firstY, secondX, secondY;
  if (useNWtoSEdireciton) {
    firstX = minX;
    firstY = minY;
    secondX = maxX;
    secondY = maxY;
  } else {
    firstX = minX;
    firstY = maxY;
    secondX = maxX;
    secondY = minY;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: firstX, y1: firstY, x2: secondX, y2: secondY }),
    points.map((p, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(${p.x},${p.y})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-l},${-l} L ${l},${l} M ${-l},${l} L ${l},${-l}`
      }
    ) }, i))
  ] });
}
function GapsSnapIndicator({ gaps, direction, zoom }) {
  const l = 3.5 / zoom;
  let edgeIntersection = [-Infinity, Infinity];
  let nextEdgeIntersection = null;
  const horizontal = direction === "horizontal";
  for (const gap of gaps) {
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.startEdge[0].y : gap.startEdge[0].x,
      horizontal ? gap.startEdge[1].y : gap.startEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
    nextEdgeIntersection = rangeIntersection(
      edgeIntersection[0],
      edgeIntersection[1],
      horizontal ? gap.endEdge[0].y : gap.endEdge[0].x,
      horizontal ? gap.endEdge[1].y : gap.endEdge[1].x
    );
    if (nextEdgeIntersection) {
      edgeIntersection = nextEdgeIntersection;
    } else {
      continue;
    }
  }
  if (edgeIntersection === null) {
    return null;
  }
  const midPoint2 = (edgeIntersection[0] + edgeIntersection[1]) / 2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "tl-snap-indicator", stroke: "cyan", children: gaps.map(({ startEdge, endEdge }, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: horizontal ? (
    // horizontal gap
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: startEdge[0].x,
          y1: midPoint2 - 2 * l,
          x2: startEdge[1].x,
          y2: midPoint2 + 2 * l
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: endEdge[0].x,
          y1: midPoint2 - 2 * l,
          x2: endEdge[1].x,
          y2: midPoint2 + 2 * l
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: startEdge[0].x, y1: midPoint2, x2: endEdge[0].x, y2: midPoint2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: (startEdge[0].x + endEdge[0].x) / 2,
          y1: midPoint2 - l,
          x2: (startEdge[0].x + endEdge[0].x) / 2,
          y2: midPoint2 + l
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: midPoint2 - 2 * l,
          y1: startEdge[0].y,
          x2: midPoint2 + 2 * l,
          y2: startEdge[1].y
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: midPoint2 - 2 * l,
          y1: endEdge[0].y,
          x2: midPoint2 + 2 * l,
          y2: endEdge[1].y
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: midPoint2, y1: startEdge[0].y, x2: midPoint2, y2: endEdge[0].y }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: midPoint2 - l,
          y1: (startEdge[0].y + endEdge[0].y) / 2,
          x2: midPoint2 + l,
          y2: (startEdge[0].y + endEdge[0].y) / 2
        }
      )
    ] })
  ) }, i)) });
}
function DefaultSnapIndicator({ className, line, zoom }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: classNames("tl-overlays__item", className), children: line.type === "points" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PointsSnapIndicator, { ...line, zoom }) : line.type === "gaps" ? /* @__PURE__ */ jsxRuntimeExports.jsx(GapsSnapIndicator, { ...line, zoom }) : null });
}
function DefaultSpinner() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", "aria-hidden": "false", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const DefaultSvgDefs = () => {
  return null;
};
function useIdentity(value, isEqual2) {
  const ref = reactExports.useRef(value);
  if (isEqual2(value, ref.current)) {
    return ref.current;
  }
  ref.current = value;
  return value;
}
const areNullableArraysShallowEqual = (a2, b) => {
  a2 ??= null;
  b ??= null;
  if (a2 === b) {
    return true;
  }
  if (!a2 || !b) {
    return false;
  }
  return areArraysShallowEqual(a2, b);
};
function useShallowArrayIdentity(arr) {
  return useIdentity(arr, areNullableArraysShallowEqual);
}
const areNullableObjectsShallowEqual = (a2, b) => {
  a2 ??= null;
  b ??= null;
  if (a2 === b) {
    return true;
  }
  if (!a2 || !b) {
    return false;
  }
  return areObjectsShallowEqual(a2, b);
};
function useShallowObjectIdentity(obj) {
  return useIdentity(obj, areNullableObjectsShallowEqual);
}
const EditorComponentsContext = reactExports.createContext(null);
function EditorComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const value = reactExports.useMemo(
    () => ({
      Background: DefaultBackground,
      Brush: DefaultBrush,
      Canvas: DefaultCanvas,
      CollaboratorBrush: DefaultBrush,
      CollaboratorCursor: DefaultCursor,
      CollaboratorHint: DefaultCollaboratorHint,
      CollaboratorScribble: DefaultScribble,
      CollaboratorShapeIndicator: DefaultShapeIndicator,
      Cursor: DefaultCursor,
      Grid: DefaultGrid,
      Handle: DefaultHandle,
      Handles: DefaultHandles,
      InFrontOfTheCanvas: null,
      LoadingScreen: DefaultLoadingScreen,
      OnTheCanvas: null,
      Overlays: null,
      Scribble: DefaultScribble,
      SelectionBackground: null,
      SelectionForeground: DefaultSelectionForeground,
      ShapeIndicator: DefaultShapeIndicator,
      ShapeIndicators: DefaultShapeIndicators,
      SnapIndicator: DefaultSnapIndicator,
      Spinner: DefaultSpinner,
      SvgDefs: DefaultSvgDefs,
      ZoomBrush: DefaultBrush,
      ErrorFallback: DefaultErrorFallback,
      ShapeErrorFallback: DefaultShapeErrorFallback,
      ShapeIndicatorErrorFallback: DefaultShapeIndicatorErrorFallback,
      ..._overrides
    }),
    [_overrides]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditorComponentsContext.Provider, { value, children });
}
function useEditorComponents() {
  const components = reactExports.useContext(EditorComponentsContext);
  if (!components) {
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  }
  return components;
}
const runtime = {
  openWindow(url, target) {
    window.open(url, target, "noopener noreferrer");
  },
  refreshPage() {
    window.location.reload();
  },
  async hardReset() {
    return await window.__tldraw__hardReset?.();
  }
};
function hardResetEditor() {
  runtime.hardReset();
}
function refreshPage() {
  runtime.refreshPage();
}
const BASE_ERROR_URL = "https://github.com/tldraw/tldraw/issues/new";
const DefaultErrorFallback = ({ error, editor }) => {
  const containerRef = reactExports.useRef(null);
  const [shouldShowError, setShouldShowError] = reactExports.useState(false);
  const [didCopy, setDidCopy] = reactExports.useState(false);
  const [shouldShowResetConfirmation, setShouldShowResetConfirmation] = reactExports.useState(false);
  let Canvas = null;
  try {
    const components = useEditorComponents();
    Canvas = components.Canvas ?? null;
  } catch {
  }
  const errorMessage = error instanceof Error ? error.message : String(error);
  const errorStack = error instanceof Error ? error.stack : null;
  const isDarkModeFromApp = useValue(
    "isDarkMode",
    () => {
      try {
        if (editor) {
          return editor.user.getIsDarkMode();
        }
      } catch {
      }
      return null;
    },
    [editor]
  );
  const [isDarkMode, setIsDarkMode] = reactExports.useState(null);
  reactExports.useLayoutEffect(() => {
    if (isDarkModeFromApp !== null) {
      setIsDarkMode(isDarkModeFromApp);
    }
    let parent = containerRef.current?.parentElement;
    let foundParentThemeClass = false;
    while (parent) {
      if (parent.classList.contains("tl-theme__dark") || parent.classList.contains("tl-theme__light")) {
        foundParentThemeClass = true;
        break;
      }
      parent = parent.parentElement;
    }
    if (foundParentThemeClass) {
      setIsDarkMode(null);
      return;
    }
    if (typeof window !== "undefined" && "matchMedia" in window) {
      setIsDarkMode(window.matchMedia("(prefers-color-scheme: dark)").matches);
    }
  }, [isDarkModeFromApp]);
  reactExports.useEffect(() => {
    if (didCopy) {
      const timeout = editor?.timers.setTimeout(() => {
        setDidCopy(false);
      }, 2e3);
      return () => clearTimeout(timeout);
    }
  }, [didCopy, editor]);
  const copyError = () => {
    const textarea = document.createElement("textarea");
    textarea.value = errorStack ?? errorMessage;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    textarea.remove();
    setDidCopy(true);
  };
  const refresh = () => {
    refreshPage();
  };
  const resetLocalState = async () => {
    hardResetEditor();
  };
  const url = new URL(BASE_ERROR_URL);
  url.searchParams.set("title", errorMessage);
  url.searchParams.set("labels", `bug`);
  url.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${errorStack ?? errorMessage}
\`\`\`

My browser: ${navigator.userAgent}`
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: containerRef,
      className: classNames(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        isDarkMode === null ? "" : isDarkMode ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-error-boundary__overlay" }),
        editor && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { onError: noop$3, fallback: () => null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { editor, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-overlay tl-error-boundary__canvas", children: Canvas ? /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}) : null }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classNames("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": shouldShowError && !shouldShowResetConfirmation
            }),
            children: shouldShowResetConfirmation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button", onClick: () => setShouldShowResetConfirmation(false), children: "Cancel" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button tl-error-boundary__reset", onClick: resetLocalState, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Something went wrong" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Please refresh your browser." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "If the issue continues after refreshing, you may need to reset the tldraw data stored on your device." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Note:" }),
                " Resetting will erase your current project and any unsaved work."
              ] }),
              false,
              shouldShowError && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                "Message:",
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: errorMessage }) }),
                "Stack trace:",
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__error", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: errorStack ?? errorMessage }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button", onClick: copyError, children: didCopy ? "Copied!" : "Copy" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button", onClick: () => setShouldShowError(!shouldShowError), children: shouldShowError ? "Hide details" : "Show details" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      className: "tlui-button tl-error-boundary__reset",
                      onClick: () => setShouldShowResetConfirmation(true),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "tlui-button tl-error-boundary__refresh", onClick: refresh, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};
const USER_DATA_KEY = "TLDRAW_USER_DATA_v3";
const userTypeValidator = object({
  id: string,
  name: string.nullable().optional(),
  color: string.nullable().optional(),
  // N.B. These are duplicated in TLdrawAppUser.
  locale: string.nullable().optional(),
  animationSpeed: number.nullable().optional(),
  edgeScrollSpeed: number.nullable().optional(),
  colorScheme: literalEnum("light", "dark", "system").optional(),
  isSnapMode: boolean.nullable().optional(),
  isWrapMode: boolean.nullable().optional(),
  isDynamicSizeMode: boolean.nullable().optional(),
  isPasteAtCursorMode: boolean.nullable().optional()
});
const Versions$1 = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8
};
const CURRENT_VERSION = Math.max(...Object.values(Versions$1));
function migrateSnapshot(data) {
  if (data.version < Versions$1.AddAnimationSpeed) {
    data.user.animationSpeed = 1;
  }
  if (data.version < Versions$1.AddIsSnapMode) {
    data.user.isSnapMode = false;
  }
  if (data.version < Versions$1.MakeFieldsNullable) ;
  if (data.version < Versions$1.AddEdgeScrollSpeed) {
    data.user.edgeScrollSpeed = 1;
  }
  if (data.version < Versions$1.AddExcalidrawSelectMode) {
    data.user.isWrapMode = false;
  }
  if (data.version < Versions$1.AllowSystemColorScheme) {
    if (data.user.isDarkMode === true) {
      data.user.colorScheme = "dark";
    } else if (data.user.isDarkMode === false) {
      data.user.colorScheme = "light";
    }
    delete data.user.isDarkMode;
  }
  if (data.version < Versions$1.AddDynamicSizeMode) {
    data.user.isDynamicSizeMode = false;
  }
  if (data.version < Versions$1.AddPasteAtCursor) {
    data.user.isPasteAtCursorMode = false;
  }
  data.version = CURRENT_VERSION;
}
const USER_COLORS = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function getRandomColor() {
  return USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)];
}
function userPrefersReducedMotion() {
  if (typeof window !== "undefined" && "matchMedia" in window) {
    return window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;
  }
  return false;
}
const defaultUserPreferences = Object.freeze({
  name: "",
  locale: getDefaultTranslationLocale(),
  color: getRandomColor(),
  // N.B. These are duplicated in TLdrawAppUser.
  edgeScrollSpeed: 1,
  animationSpeed: userPrefersReducedMotion() ? 0 : 1,
  isSnapMode: false,
  isWrapMode: false,
  isDynamicSizeMode: false,
  isPasteAtCursorMode: false,
  colorScheme: "light"
});
function getFreshUserPreferences() {
  return {
    id: uniqueId(),
    color: getRandomColor()
  };
}
function migrateUserPreferences(userData) {
  if (userData === null || typeof userData !== "object") {
    return getFreshUserPreferences();
  }
  if (!("version" in userData) || !("user" in userData) || typeof userData.version !== "number") {
    return getFreshUserPreferences();
  }
  const snapshot = structuredClone(userData);
  migrateSnapshot(snapshot);
  try {
    return userTypeValidator.validate(snapshot.user);
  } catch {
    return getFreshUserPreferences();
  }
}
function loadUserPreferences() {
  const userData = JSON.parse(getFromLocalStorage(USER_DATA_KEY) || "null") ?? null;
  return migrateUserPreferences(userData);
}
const globalUserPreferences = atom("globalUserData", null);
function storeUserPreferences() {
  setInLocalStorage(
    USER_DATA_KEY,
    JSON.stringify({
      version: CURRENT_VERSION,
      user: globalUserPreferences.get()
    })
  );
}
function setUserPreferences(user) {
  userTypeValidator.validate(user);
  globalUserPreferences.set(user);
  storeUserPreferences();
  broadcastUserPreferencesChange();
}
const channel = typeof BroadcastChannel !== "undefined" && true ? new BroadcastChannel("tldraw-user-sync") : null;
channel?.addEventListener("message", (e) => {
  const data = e.data;
  if (data?.type === broadcastEventKey && data?.origin !== getBroadcastOrigin()) {
    globalUserPreferences.set(migrateUserPreferences(data.data));
  }
});
let _broadcastOrigin = null;
function getBroadcastOrigin() {
  if (_broadcastOrigin === null) {
    _broadcastOrigin = uniqueId();
  }
  return _broadcastOrigin;
}
const broadcastEventKey = "tldraw-user-preferences-change";
function broadcastUserPreferencesChange() {
  channel?.postMessage({
    type: broadcastEventKey,
    origin: getBroadcastOrigin(),
    data: {
      user: getUserPreferences(),
      version: CURRENT_VERSION
    }
  });
}
function getUserPreferences() {
  let prefs = globalUserPreferences.get();
  if (!prefs) {
    prefs = loadUserPreferences();
    setUserPreferences(prefs);
  }
  return prefs;
}
const defaultLocalStorageUserPrefs = computed(
  "defaultLocalStorageUserPrefs",
  () => getUserPreferences()
);
function createTLUser(opts = {}) {
  return {
    userPreferences: opts.userPreferences ?? defaultLocalStorageUserPrefs,
    setUserPreferences: opts.setUserPreferences ?? setUserPreferences
  };
}
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has2 = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has2.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i = 0, l = handlers2.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
const tabIdKey = "TLDRAW_TAB_ID_v2";
const window$1 = globalThis.window;
function iOS() {
  if (!window$1) return false;
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    window$1.navigator.platform
  ) || // iPad on iOS 13 detection
  tlenv.isDarwin && "ontouchend" in document;
}
const TAB_ID = window$1 ? window$1[tabIdKey] ?? getFromSessionStorage(tabIdKey) ?? `TLDRAW_INSTANCE_STATE_V1_` + uniqueId() : "<error>";
if (window$1) {
  window$1[tabIdKey] = TAB_ID;
  if (iOS()) {
    setInSessionStorage(tabIdKey, TAB_ID);
  } else {
    deleteFromSessionStorage(tabIdKey);
  }
}
window$1?.addEventListener("beforeunload", () => {
  setInSessionStorage(tabIdKey, TAB_ID);
});
const Versions = {
  Initial: 0
};
const CURRENT_SESSION_STATE_SNAPSHOT_VERSION = Math.max(...Object.values(Versions));
function migrate(snapshot) {
  if (snapshot.version < Versions.Initial) ;
  snapshot.version = CURRENT_SESSION_STATE_SNAPSHOT_VERSION;
}
const sessionStateSnapshotValidator = object({
  version: number,
  currentPageId: pageIdValidator.optional(),
  isFocusMode: boolean.optional(),
  exportBackground: boolean.optional(),
  isDebugMode: boolean.optional(),
  isToolLocked: boolean.optional(),
  isGridMode: boolean.optional(),
  pageStates: arrayOf(
    object({
      pageId: pageIdValidator,
      camera: object({
        x: number,
        y: number,
        z: number
      }).optional(),
      selectedShapeIds: arrayOf(shapeIdValidator).optional(),
      focusedGroupId: shapeIdValidator.nullable().optional()
    })
  ).optional()
});
function migrateAndValidateSessionStateSnapshot(state) {
  if (!state || typeof state !== "object") {
    console.warn("Invalid instance state");
    return null;
  }
  if (!("version" in state) || typeof state.version !== "number") {
    console.warn("No version in instance state");
    return null;
  }
  if (state.version !== CURRENT_SESSION_STATE_SNAPSHOT_VERSION) {
    state = structuredClone(state);
    migrate(state);
  }
  try {
    return sessionStateSnapshotValidator.validate(state);
  } catch (e) {
    console.warn(e);
    return null;
  }
}
function createSessionStateSnapshotSignal(store) {
  const $allPageIds = store.query.ids("page");
  return computed(
    "sessionStateSnapshot",
    () => {
      const instanceState = store.get(TLINSTANCE_ID);
      if (!instanceState) return null;
      const allPageIds = [...$allPageIds.get()];
      return {
        version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
        currentPageId: instanceState.currentPageId,
        exportBackground: instanceState.exportBackground,
        isFocusMode: instanceState.isFocusMode,
        isDebugMode: instanceState.isDebugMode,
        isToolLocked: instanceState.isToolLocked,
        isGridMode: instanceState.isGridMode,
        pageStates: allPageIds.map((id) => {
          const ps = store.get(InstancePageStateRecordType.createId(id));
          const camera = store.get(CameraRecordType.createId(id));
          return {
            pageId: id,
            camera: {
              x: camera?.x ?? 0,
              y: camera?.y ?? 0,
              z: camera?.z ?? 1
            },
            selectedShapeIds: ps?.selectedShapeIds ?? [],
            focusedGroupId: ps?.focusedGroupId ?? null
          };
        })
      };
    },
    { isEqual }
  );
}
function loadSessionStateSnapshotIntoStore(store, snapshot, opts) {
  const res = migrateAndValidateSessionStateSnapshot(snapshot);
  if (!res) return;
  const preserved = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const primary = opts?.forceOverwrite ? res : preserved;
  const secondary = opts?.forceOverwrite ? preserved : res;
  const instanceState = store.schema.types.instance.create({
    id: TLINSTANCE_ID,
    ...preserved,
    // the integrity checker will ensure that the currentPageId is valid
    currentPageId: res.currentPageId,
    isDebugMode: primary?.isDebugMode ?? secondary?.isDebugMode,
    isFocusMode: primary?.isFocusMode ?? secondary?.isFocusMode,
    isToolLocked: primary?.isToolLocked ?? secondary?.isToolLocked,
    isGridMode: primary?.isGridMode ?? secondary?.isGridMode,
    exportBackground: primary?.exportBackground ?? secondary?.exportBackground
  });
  store.atomic(() => {
    for (const ps of res.pageStates ?? []) {
      if (!store.has(ps.pageId)) continue;
      const cameraId = CameraRecordType.createId(ps.pageId);
      const instancePageState = InstancePageStateRecordType.createId(ps.pageId);
      const previousCamera = store.get(cameraId);
      const previousInstanceState = store.get(instancePageState);
      store.put([
        CameraRecordType.create({
          id: cameraId,
          x: ps.camera?.x ?? previousCamera?.x,
          y: ps.camera?.y ?? previousCamera?.y,
          z: ps.camera?.z ?? previousCamera?.z
        }),
        InstancePageStateRecordType.create({
          id: instancePageState,
          pageId: ps.pageId,
          selectedShapeIds: ps.selectedShapeIds ?? previousInstanceState?.selectedShapeIds,
          focusedGroupId: ps.focusedGroupId ?? previousInstanceState?.focusedGroupId
        })
      ]);
    }
    store.put([instanceState]);
    store.ensureStoreIsUsable();
  });
}
function extractSessionStateFromLegacySnapshot(store) {
  const instanceRecords = [];
  for (const record of Object.values(store)) {
    if (record.typeName?.match(/^(instance.*|pointer|camera)$/)) {
      instanceRecords.push(record);
    }
  }
  const oldInstance = instanceRecords.filter(
    (r2) => r2.typeName === "instance" && r2.id !== TLINSTANCE_ID
  )[0];
  if (!oldInstance) return null;
  const result = {
    version: CURRENT_SESSION_STATE_SNAPSHOT_VERSION,
    currentPageId: oldInstance.currentPageId,
    exportBackground: !!oldInstance.exportBackground,
    isFocusMode: !!oldInstance.isFocusMode,
    isDebugMode: !!oldInstance.isDebugMode,
    isToolLocked: !!oldInstance.isToolLocked,
    isGridMode: false,
    pageStates: instanceRecords.filter((r2) => r2.typeName === "instance_page_state" && r2.instanceId === oldInstance.id).map((ps) => {
      const camera = store[ps.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: ps.pageId,
        camera: {
          x: camera.x,
          y: camera.y,
          z: camera.z
        },
        selectedShapeIds: ps.selectedShapeIds,
        focusedGroupId: ps.focusedGroupId
      };
    })
  };
  try {
    sessionStateSnapshotValidator.validate(result);
    return result;
  } catch {
    return null;
  }
}
function loadSnapshot(store, _snapshot, opts) {
  let snapshot = {};
  if ("store" in _snapshot) {
    const migrationResult = store.schema.migrateStoreSnapshot(_snapshot);
    if (migrationResult.type !== "success") {
      throw new Error("Failed to migrate store snapshot: " + migrationResult.reason);
    }
    snapshot.document = {
      schema: store.schema.serialize(),
      store: filterEntries(
        migrationResult.value,
        (_, { typeName }) => store.scopedTypes.document.has(typeName)
      )
    };
  } else {
    snapshot = _snapshot;
  }
  const preservingInstanceState = pluckPreservingValues(store.get(TLINSTANCE_ID));
  const preservingSessionState = sessionStateCache.get(store, createSessionStateSnapshotSignal).get();
  store.atomic(() => {
    if (snapshot.document) {
      store.loadStoreSnapshot(snapshot.document);
    }
    if (preservingInstanceState) {
      store.update(TLINSTANCE_ID, (r2) => ({ ...r2, ...preservingInstanceState }));
    }
    if (preservingSessionState) {
      loadSessionStateSnapshotIntoStore(store, preservingSessionState);
    }
    if (snapshot.session) {
      loadSessionStateSnapshotIntoStore(store, snapshot.session, {
        forceOverwrite: opts?.forceOverwriteSessionState
      });
    }
  });
}
const sessionStateCache = new WeakCache();
function getSnapshot(store) {
  const sessionState$ = sessionStateCache.get(store, createSessionStateSnapshotSignal);
  const session = sessionState$.get();
  if (!session) {
    throw new Error("Session state is not ready yet");
  }
  return {
    document: store.getStoreSnapshot(),
    session
  };
}
function checkBindings(customBindings) {
  const bindings = [];
  const addedCustomBindingTypes = /* @__PURE__ */ new Set();
  for (const customBinding of customBindings) {
    if (addedCustomBindingTypes.has(customBinding.type)) {
      throw new Error(`Binding type "${customBinding.type}" is defined more than once`);
    }
    bindings.push(customBinding);
    addedCustomBindingTypes.add(customBinding.type);
  }
  return bindings;
}
function SVGContainer({ children, className = "", ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { ...rest, className: classNames("tl-svg-container", className), children });
}
class Edge2d extends Geometry2d {
  start;
  end;
  d;
  u;
  ul;
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    const { start, end } = config;
    this.start = start;
    this.end = end;
    this.d = start.clone().sub(end);
    this.u = this.d.clone().uni();
    this.ul = this.u.len();
  }
  getLength() {
    return this.d.len();
  }
  midPoint() {
    return this.start.lrp(this.end, 0.5);
  }
  getVertices() {
    return [this.start, this.end];
  }
  nearestPoint(point) {
    const { start, end, d, u, ul: l } = this;
    if (d.len() === 0) return start;
    if (l === 0) return start;
    const k = Vec.Sub(point, start).dpr(u) / l;
    const cx = start.x + u.x * k;
    if (cx < Math.min(start.x, end.x)) return start.x < end.x ? start : end;
    if (cx > Math.max(start.x, end.x)) return start.x > end.x ? start : end;
    const cy = start.y + u.y * k;
    if (cy < Math.min(start.y, end.y)) return start.y < end.y ? start : end;
    if (cy > Math.max(start.y, end.y)) return start.y > end.y ? start : end;
    return new Vec(cx, cy);
  }
  hitTestLineSegment(A, B, distance = 0) {
    return linesIntersect(A, B, this.start, this.end) || this.distanceToLineSegment(A, B) <= distance;
  }
  getSvgPathData(first2 = true) {
    const { start, end } = this;
    return `${first2 ? `M${start.toFixed()}` : ``} L${end.toFixed()}`;
  }
}
class Polyline2d extends Geometry2d {
  points;
  constructor(config) {
    super({ isClosed: false, isFilled: false, ...config });
    const { points } = config;
    this.points = points;
  }
  _segments;
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices } = this;
      for (let i = 0, n2 = vertices.length - 1; i < n2; i++) {
        const start = vertices[i];
        const end = vertices[i + 1];
        this._segments.push(new Edge2d({ start, end }));
      }
      if (this.isClosed) {
        this._segments.push(new Edge2d({ start: vertices[vertices.length - 1], end: vertices[0] }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    return this.points;
  }
  nearestPoint(A) {
    const { segments } = this;
    let nearest = this.points[0];
    let dist = Infinity;
    let p;
    let d;
    for (let i = 0; i < segments.length; i++) {
      p = segments[i].nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { segments } = this;
    for (let i = 0, n2 = segments.length; i < n2; i++) {
      if (segments[i].hitTestLineSegment(A, B, distance)) {
        return true;
      }
    }
    return false;
  }
  getSvgPathData() {
    const { vertices } = this;
    if (vertices.length < 2) return "";
    return vertices.reduce((acc, vertex, i) => {
      if (i === 0) return `M ${vertex.x} ${vertex.y}`;
      return `${acc} L ${vertex.x} ${vertex.y}`;
    }, "");
  }
}
class Polygon2d extends Polyline2d {
  constructor(config) {
    super({ ...config });
    this.isClosed = true;
  }
}
class Rectangle2d extends Polygon2d {
  x;
  y;
  w;
  h;
  constructor(config) {
    const { x = 0, y: y2 = 0, width, height } = config;
    super({
      ...config,
      points: [
        new Vec(x, y2),
        new Vec(x + width, y2),
        new Vec(x + width, y2 + height),
        new Vec(x, y2 + height)
      ]
    });
    this.x = x;
    this.y = y2;
    this.w = width;
    this.h = height;
  }
  getBounds() {
    return new Box(this.x, this.y, this.w, this.h);
  }
  getSvgPathData() {
    const { x, y: y2, w, h } = this;
    return `M${x},${y2} h${w} v${h} h-${w}z`;
  }
}
class ShapeUtil {
  constructor(editor) {
    this.editor = editor;
  }
  /** Configure this shape utils {@link ShapeUtil.options | `options`}. */
  static configure(options) {
    return class extends this {
      // @ts-expect-error
      options = { ...this.options, ...options };
    };
  }
  /**
   * Options for this shape util. If you're implementing a custom shape util, you can override
   * this to provide customization options for your shape. If using an existing shape util, you
   * can customizing this by calling {@link ShapeUtil.configure}.
   */
  options = {};
  /**
   * Props allow you to define the shape's properties in a way that the editor can understand.
   * This has two main uses:
   *
   * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
   * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
   *    once, and will be remembered from one shape to the next.
   *
   * @example
   * ```tsx
   * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
   *
   * type MyShape = TLBaseShape<'mine', {
   *      color: TLDefaultColorStyle,
   *      text: string,
   * }>
   *
   * class MyShapeUtil extends ShapeUtil<MyShape> {
   *     static props = {
   *         // we use tldraw's built-in color style:
   *         color: DefaultColorStyle,
   *         // validate that the text prop is a string:
   *         text: T.string,
   *     }
   * }
   * ```
   */
  static props;
  /**
   * Migrations allow you to make changes to a shape's props over time. Read the
   * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
   * guide for more information.
   */
  static migrations;
  /**
   * The type of the shape util, which should match the shape's type.
   *
   * @public
   */
  static type;
  /**
   * Get the font faces that should be rendered in the document in order for this shape to render
   * correctly.
   *
   * @param shape - The shape.
   * @public
   */
  getFontFaces(shape) {
    return EMPTY_ARRAY;
  }
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @param shape - The shape.
   * @public
   */
  canSnap(_shape) {
    return true;
  }
  /**
   * Whether the shape can be tabbed to.
   *
   * @param shape - The shape.
   * @public
   */
  canTabTo(_shape) {
    return true;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll(_shape) {
    return false;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(_opts) {
    return true;
  }
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit(_shape) {
    return false;
  }
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize(_shape) {
    return true;
  }
  /**
   * Whether the shape can be edited in read-only mode.
   *
   * @public
   */
  canEditInReadonly(_shape) {
    return false;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop(_shape) {
    return false;
  }
  /**
   * Whether the shape can participate in layout functions such as alignment or distribution.
   *
   * @param shape - The shape.
   * @param info - Additional context information: the type of action causing the layout and the
   * @public
   *
   * @public
   */
  canBeLaidOut(_shape, _info) {
    return true;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its rotation handles when selected.
   *
   * @public
   */
  hideRotateHandle(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg(_shape) {
    return false;
  }
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg(_shape) {
    return false;
  }
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked(_shape) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape.
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(_shape, _type) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(_shape, _shapes) {
    return false;
  }
  /** @internal */
  expandSelectionOutlinePx(shape) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(_shape) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(_shape) {
    return {};
  }
  getText(_shape) {
    return void 0;
  }
  getAriaDescriptor(_shape) {
    return void 0;
  }
}
function getPerfectDashProps(totalLength, strokeWidth, opts = {}) {
  const {
    closed = false,
    snap = 1,
    start = "outset",
    end = "outset",
    lengthRatio = 2,
    style: style2 = "dashed",
    forceSolid = false
  } = opts;
  let dashLength = 0;
  let dashCount = 0;
  let ratio = 1;
  let gapLength = 0;
  let strokeDashoffset = 0;
  if (forceSolid) {
    return {
      strokeDasharray: "none",
      strokeDashoffset: "none"
    };
  }
  switch (style2) {
    case "dashed": {
      ratio = 1;
      dashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4);
      break;
    }
    case "dotted": {
      ratio = 100;
      dashLength = strokeWidth / ratio;
      break;
    }
    default: {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
  }
  if (!closed) {
    if (start === "outset") {
      totalLength += dashLength / 2;
      strokeDashoffset += dashLength / 2;
    } else if (start === "skip") {
      totalLength -= dashLength;
      strokeDashoffset -= dashLength;
    }
    if (end === "outset") {
      totalLength += dashLength / 2;
    } else if (end === "skip") {
      totalLength -= dashLength;
    }
  }
  dashCount = Math.floor(totalLength / dashLength / (2 * ratio));
  dashCount -= dashCount % snap;
  if (dashCount < 3 && style2 === "dashed") {
    if (totalLength / strokeWidth < 4) {
      dashLength = totalLength;
      dashCount = 1;
      gapLength = 0;
    } else {
      dashLength = totalLength * (1 / 3);
      gapLength = totalLength * (1 / 3);
    }
  } else {
    dashLength = totalLength / dashCount / (2 * ratio);
    if (closed) {
      strokeDashoffset = dashLength / 2;
      gapLength = (totalLength - dashCount * dashLength) / dashCount;
    } else {
      gapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1);
    }
  }
  return {
    strokeDasharray: [dashLength, gapLength].join(" "),
    strokeDashoffset: strokeDashoffset.toString()
  };
}
function DashedOutlineBox({ bounds, className }) {
  const editor = useEditor();
  const zoomLevel = useValue("zoom level", () => editor.getZoomLevel(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: bounds.sides.map((side, i) => {
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      side[0].dist(side[1]),
      1 / zoomLevel,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        x1: side[0].x,
        y1: side[0].y,
        x2: side[1].x,
        y2: side[1].y,
        strokeDasharray,
        strokeDashoffset
      },
      i
    );
  }) });
}
class GroupShapeUtil extends ShapeUtil {
  static type = "group";
  static props = groupShapeProps;
  static migrations = groupShapeMigrations;
  hideSelectionBoundsFg() {
    return true;
  }
  canBind() {
    return false;
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(shape) {
    const children = this.editor.getSortedChildIdsForParent(shape.id);
    if (children.length === 0) {
      return new Rectangle2d({ width: 1, height: 1, isFilled: false });
    }
    return new Group2d({
      children: children.map((childId) => {
        const shape2 = this.editor.getShape(childId);
        return this.editor.getShapeGeometry(childId).transform(this.editor.getShapeLocalTransform(shape2), { isLabel: false });
      })
    });
  }
  component(shape) {
    const isErasing = this.editor.getErasingShapeIds().includes(shape.id);
    const { hintingShapeIds } = this.editor.getCurrentPageState();
    const isHintingOtherGroup = hintingShapeIds.length > 0 && hintingShapeIds.some(
      (id) => id !== shape.id && this.editor.isShapeOfType(this.editor.getShape(id), "group")
    );
    const isFocused = this.editor.getCurrentPageState().focusedGroupId !== shape.id;
    if (!isErasing && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (isFocused || isHintingOtherGroup)) {
      return null;
    }
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DashedOutlineBox, { className: "tl-group", bounds }) });
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DashedOutlineBox, { className: "", bounds });
  }
  onChildrenChange(group) {
    const children = this.editor.getSortedChildIdsForParent(group.id);
    if (children.length === 0) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.deleteShapes([group.id]);
      return;
    } else if (children.length === 1) {
      if (this.editor.getCurrentPageState().focusedGroupId === group.id) {
        this.editor.popFocusedGroupId();
      }
      this.editor.reparentShapes(children, group.parentId);
      this.editor.deleteShapes([group.id]);
      return;
    }
  }
}
const coreShapes = [
  // created by grouping interactions, probably the corest core shape that we have
  GroupShapeUtil
];
const coreShapeTypes = new Set(coreShapes.map((s2) => s2.type));
function checkShapesAndAddCore(customShapes) {
  const shapes = [...coreShapes];
  const addedCustomShapeTypes = /* @__PURE__ */ new Set();
  for (const customShape of customShapes) {
    if (coreShapeTypes.has(customShape.type)) {
      throw new Error(
        `Shape type "${customShape.type}" is a core shapes type and cannot be overridden`
      );
    }
    if (addedCustomShapeTypes.has(customShape.type)) {
      throw new Error(`Shape type "${customShape.type}" is defined more than once`);
    }
    shapes.push(customShape);
    addedCustomShapeTypes.add(customShape.type);
  }
  return shapes;
}
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f(a2, b) {
      var c2 = a2.length;
      a2.push(b);
      a: for (; 0 < c2; ) {
        var d = c2 - 1 >>> 1, e = a2[d];
        if (0 < g(e, b)) a2[d] = b, a2[c2] = e, c2 = d;
        else break a;
      }
    }
    function h(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k(a2) {
      if (0 === a2.length) return null;
      var b = a2[0], c2 = a2.pop();
      if (c2 !== b) {
        a2[0] = c2;
        a: for (var d = 0, e = a2.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a2[m], n2 = m + 1, x = a2[n2];
          if (0 > g(C, c2)) n2 < e && 0 > g(x, C) ? (a2[d] = x, a2[n2] = c2, d = n2) : (a2[d] = C, a2[m] = c2, d = m);
          else if (n2 < e && 0 > g(x, c2)) a2[d] = x, a2[n2] = c2, d = n2;
          else break a;
        }
      }
      return b;
    }
    function g(a2, b) {
      var c2 = a2.sortIndex - b.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r2 = [], t2 = [], u = 1, v = null, y2 = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a2) {
      for (var b = h(t2); null !== b; ) {
        if (null === b.callback) k(t2);
        else if (b.startTime <= a2) k(t2), b.sortIndex = b.expirationTime, f(r2, b);
        else break;
        b = h(t2);
      }
    }
    function H(a2) {
      B = false;
      G(a2);
      if (!A) if (null !== h(r2)) A = true, I(J);
      else {
        var b = h(t2);
        null !== b && K(H, b.startTime - a2);
      }
    }
    function J(a2, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c2 = y2;
      try {
        G(b);
        for (v = h(r2); null !== v && (!(v.expirationTime > b) || a2 && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y2 = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r2) && k(r2);
            G(b);
          } else k(r2);
          v = h(r2);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t2);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y2 = c2, z = false;
      }
    }
    var N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a2 = exports.unstable_now();
        Q = a2;
        var b = true;
        try {
          b = O(true, a2);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a2) {
      O = a2;
      N || (N = true, S());
    }
    function K(a2, b) {
      L = D(function() {
        a2(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r2);
    };
    exports.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y2;
      }
      var c2 = y2;
      y2 = b;
      try {
        return a2();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a2, b) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y2;
      y2 = a2;
      try {
        return b();
      } finally {
        y2 = c2;
      }
    };
    exports.unstable_scheduleCallback = function(a2, b, c2) {
      var d = exports.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d + c2 : d) : c2 = d;
      switch (a2) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c2 + e;
      a2 = { id: u++, callback: b, priorityLevel: a2, startTime: c2, expirationTime: e, sortIndex: -1 };
      c2 > d ? (a2.sortIndex = c2, f(t2, a2), null === h(r2) && a2 === h(t2) && (B ? (E(L), L = -1) : B = true, K(H, c2 - d))) : (a2.sortIndex = e, f(r2, a2), A || z || (A = true, I(J)));
      return a2;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a2) {
      var b = y2;
      return function() {
        var c2 = y2;
        y2 = b;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p(a2) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b) {
    ha(a2, b);
    ha(a2 + "Capture", b);
  }
  function ha(a2, b) {
    ea[a2] = b;
    for (a2 = 0; a2 < b.length; a2++) da.add(b[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2)) return true;
    if (ja.call(la, a2)) return false;
    if (ka.test(a2)) return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b, c2, d) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b, c2, d) {
    if (null === b || "undefined" === typeof b || pa(a2, b, c2, d)) return true;
    if (d) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a2, b, c2, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z[a2] = new v(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b = a2[0];
    z[b] = new v(b, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z[a2] = new v(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z[a2] = new v(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z[a2] = new v(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z[a2] = new v(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z[a2] = new v(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z[a2] = new v(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z[a2] = new v(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b = a2.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b = a2.replace(ra, sa);
    z[b] = new v(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z[a2] = new v(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta2(a2, b, c2, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c2, e, d) && (c2 = null), d || null === e ? oa(b) && (null === c2 ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c2)) : e.mustUseProperty ? a2[e.propertyName] = null === c2 ? 3 === e.type ? false : "" : c2 : (b = e.attributeName, d = e.attributeNamespace, null === c2 ? a2.removeAttribute(b) : (e = e.type, c2 = 3 === e || 4 === e && true === c2 ? "" : "" + c2, d ? a2.setAttributeNS(d, b, c2) : a2.setAttribute(b, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La) try {
      throw Error();
    } catch (c2) {
      var b = c2.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b) {
    if (!a2 || Na) return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a2, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a2.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a2();
      }
    } catch (l) {
      if (l && d && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a2.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a2.displayName));
                return k;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b.displayName || b.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b = a2.displayName || null, null !== b ? b : Qa(a2.type) || "Memo";
      case Ha:
        b = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b.render, a2 = a2.displayName || a2.name || "", b.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a2) {
    var b = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b), d = "" + a2[b];
    if (!a2.hasOwnProperty(b) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e = c2.get, f = c2.set;
      Object.defineProperty(a2, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a3) {
        d = "" + a3;
        f.call(this, a3);
      } });
      Object.defineProperty(a2, b, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a3) {
        d = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b = a2._valueTracker;
    if (!b) return true;
    var c2 = b.getValue();
    var d = "";
    a2 && (d = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d;
    return a2 !== c2 ? (b.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b) {
      return a2.body;
    }
  }
  function Ya(a2, b) {
    var c2 = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b) {
    var c2 = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c2 = Sa(null != b.value ? b.value : c2);
    a2._wrapperState = { initialChecked: d, initialValue: c2, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a2, b) {
    b = b.checked;
    null != b && ta2(a2, "checked", b, false);
  }
  function bb(a2, b) {
    ab(a2, b);
    var c2 = Sa(b.value), d = b.type;
    if (null != c2) if ("number" === d) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d || "reset" === d) {
      a2.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a2, b.type, c2) : b.hasOwnProperty("defaultValue") && cb(a2, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
  }
  function db(a2, b, c2) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a2._wrapperState.initialValue;
      c2 || b === a2.value || (a2.value = b);
      a2.defaultValue = b;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b, c2) {
    if ("number" !== b || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b, c2, d) {
    a2 = a2.options;
    if (b) {
      b = {};
      for (var e = 0; e < c2.length; e++) b["$" + c2[e]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e = b.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e && (a2[c2].selected = e), e && d && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b = null;
      for (e = 0; e < a2.length; e++) {
        if (a2[e].value === c2) {
          a2[e].selected = true;
          d && (a2[e].defaultSelected = true);
          return;
        }
        null !== b || a2[e].disabled || (b = a2[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a2, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b) {
    var c2 = b.value;
    if (null == c2) {
      c2 = b.children;
      b = b.defaultValue;
      if (null != c2) {
        if (null != b) throw Error(p(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p(93));
          c2 = c2[0];
        }
        b = c2;
      }
      null == b && (b = "");
      c2 = b;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b) {
    var c2 = Sa(b.value), d = Sa(b.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d && (a2.defaultValue = "" + d);
  }
  function jb(a2) {
    var b = a2.textContent;
    b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c2, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b, c2, d, e);
      });
    } : a2;
  }(function(a2, b) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b.firstChild; ) a2.appendChild(b.firstChild);
    }
  });
  function ob(a2, b) {
    if (b) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b;
        return;
      }
    }
    a2.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b) {
      b = b + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b] = pb[a2];
    });
  });
  function rb(a2, b, c2) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c2 || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b).trim() : b + "px";
  }
  function sb(a2, b) {
    a2 = a2.style;
    for (var c2 in b) if (b.hasOwnProperty(c2)) {
      var d = 0 === c2.indexOf("--"), e = rb(c2, b[c2], d);
      "float" === c2 && (c2 = "cssFloat");
      d ? a2.setProperty(c2, e) : a2[c2] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b) {
    if (b) {
      if (tb[a2] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a2));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a2, b) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a2.stateNode;
      b && (b = Db(b), yb(a2.stateNode, a2.type, b));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b) for (a2 = 0; a2 < b.length; a2++) Bb(b[a2]);
    }
  }
  function Gb(a2, b) {
    return a2(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b, c2) {
    if (Ib) return a2(b, c2);
    Ib = true;
    try {
      return Gb(a2, b, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d = Db(c2);
    if (null === d) return null;
    c2 = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a2 = a2.type, d = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p(231, b, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b, c2, d, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c2, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b, c2, d, e, f, g, h, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b, c2, d, e, f, g, h, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a2) {
    var b = a2, c2 = a2;
    if (a2.alternate) for (; b.return; ) b = b.return;
    else {
      a2 = b;
      do
        b = a2, 0 !== (b.flags & 4098) && (c2 = b.return), a2 = b.return;
      while (a2);
    }
    return 3 === b.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b = a2.memoizedState;
      null === b && (a2 = a2.alternate, null !== a2 && (b = a2.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p(188));
  }
  function Yb(a2) {
    var b = a2.alternate;
    if (!b) {
      b = Vb(a2);
      if (null === b) throw Error(p(188));
      return b !== a2 ? null : a2;
    }
    for (var c2 = a2, d = b; ; ) {
      var e = c2.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d = e.return;
        if (null !== d) {
          c2 = d;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c2) return Xb(e), a2;
          if (f === d) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c2.return !== d.return) c2 = e, d = f;
      else {
        for (var g = false, h = e.child; h; ) {
          if (h === c2) {
            g = true;
            c2 = e;
            d = f;
            break;
          }
          if (h === d) {
            g = true;
            d = e;
            c2 = f;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f.child; h; ) {
            if (h === c2) {
              g = true;
              c2 = f;
              d = e;
              break;
            }
            if (h === d) {
              g = true;
              d = f;
              c2 = e;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c2.alternate !== d) throw Error(p(190));
    }
    if (3 !== c2.tag) throw Error(p(188));
    return c2.stateNode.current === c2 ? a2 : b;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b = $b(a2);
      if (null !== b) return b;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b) {
    }
  }
  var oc2 = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d = 0, e = a2.suspendedLanes, f = a2.pingedLanes, g = c2 & 268435455;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c2 & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c2 & 16);
    b = a2.entangledLanes;
    if (0 !== b) for (a2 = a2.entanglements, b &= d; 0 < b; ) c2 = 31 - oc2(b), e = 1 << c2, d |= a2[c2], b &= ~e;
    return d;
  }
  function vc(a2, b) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b) {
    for (var c2 = a2.suspendedLanes, d = a2.pingedLanes, e = a2.expirationTimes, f = a2.pendingLanes; 0 < f; ) {
      var g = 31 - oc2(f), h = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h & c2) || 0 !== (h & d)) e[g] = vc(h, b);
      } else k <= b && (a2.expiredLanes |= h);
      f &= ~h;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b = [], c2 = 0; 31 > c2; c2++) b.push(a2);
    return b;
  }
  function Ac(a2, b, c2) {
    a2.pendingLanes |= b;
    536870912 !== b && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b = 31 - oc2(b);
    a2[b] = c2;
  }
  function Bc(a2, b) {
    var c2 = a2.pendingLanes & ~b;
    a2.pendingLanes = b;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b;
    a2.mutableReadLanes &= b;
    a2.entangledLanes &= b;
    b = a2.entanglements;
    var d = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e = 31 - oc2(c2), f = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a2[e] = -1;
      c2 &= ~f;
    }
  }
  function Cc(a2, b) {
    var c2 = a2.entangledLanes |= b;
    for (a2 = a2.entanglements; c2; ) {
      var d = 31 - oc2(c2), e = 1 << d;
      e & b | a2[d] & b && (a2[d] |= b);
      c2 &= ~e;
    }
  }
  var C = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a2, b, c2, d, e, f) {
    if (null === a2 || a2.nativeEvent !== f) return a2 = { blockedOn: b, domEventName: c2, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a2;
    a2.eventSystemFlags |= d;
    b = a2.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a2;
  }
  function Uc(a2, b, c2, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a2, b, c2, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b, c2, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b, c2, d, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a2, b, c2, d, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a2, b, c2, d, e)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b = Wc(a2.target);
    if (null !== b) {
      var c2 = Vb(b);
      if (null !== c2) {
        if (b = c2.tag, 13 === b) {
          if (b = Wb(c2), null !== b) {
            a2.blockedOn = b;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b = a2.targetContainers; 0 < b.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d = new c2.constructor(c2.type, c2);
        wb = d;
        c2.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c2), null !== b && Fc(b), a2.blockedOn = c2, false;
      b.shift();
    }
    return true;
  }
  function Zc(a2, b, c2) {
    Xc(a2) && c2.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b) {
    a2.blockedOn === b && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b(b2) {
      return ad(b2, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d = Kc[c2];
        d.blockedOn === a2 && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c2 = 0; c2 < Qc.length; c2++) d = Qc[c2], d.blockedOn === a2 && (d.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b, c2, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a2, b, c2, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a2, b, c2, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a2, b, c2, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a2, b, c2, d) {
    if (dd) {
      var e = Yc(a2, b, c2, d);
      if (null === e) hd(a2, b, d, id, c2), Sc(a2, d);
      else if (Uc(e, a2, b, c2, d)) d.stopPropagation();
      else if (Sc(a2, d), b & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a2, b, c2, d);
          null === f && hd(a2, b, d, id, c2);
          if (f === e) break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else hd(a2, b, d, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b, c2, d) {
    id = null;
    a2 = xb(d);
    a2 = Wc(a2);
    if (null !== a2) if (b = Vb(a2), null === b) a2 = null;
    else if (c2 = b.tag, 13 === c2) {
      a2 = Wb(b);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a2 = null;
    } else b !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b = ld, c2 = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a2 = 0; a2 < c2 && b[a2] === e[a2]; a2++) ;
    var g = c2 - a2;
    for (d = 1; d <= g && b[c2 - d] === e[f - d]; d++) ;
    return md = e.slice(a2, 1 < d ? 1 - d : void 0);
  }
  function od(a2) {
    var b = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b && (a2 = 13)) : a2 = b;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b(b2, d, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b2 = a2[c2], this[c2] = b2 ? b2(f) : f[c2]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a2) : (a2 = Od[a2]) ? !!b[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a2) {
    if (a2.key) {
      var b = Md[a2.key] || a2.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a2, b) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie2 = false;
  function je(a2, b) {
    switch (a2) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a2 = b.data, a2 === ee && fe ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b) {
    if (ie2) return "compositionend" === a2 || !ae && ge(a2, b) ? (a2 = nd(), md = ld = kd = null, ie2 = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b ? !!le[a2.type] : "textarea" === b ? true : false;
  }
  function ne(a2, b, c2, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c2 = new td("onChange", "change", null, c2, d), a2.push({ event: c2, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a2) {
    se(a2, 0);
  }
  function te(a2) {
    var b = ue(a2);
    if (Wa(b)) return a2;
  }
  function ve(a2, b) {
    if ("change" === a2) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a2, xb(a2));
      Jb(re, b);
    }
  }
  function Ce(a2, b, c2) {
    "focusin" === a2 ? (Ae(), pe = b, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
  }
  function Ee(a2, b) {
    if ("click" === a2) return te(b);
  }
  function Fe(a2, b) {
    if ("input" === a2 || "change" === a2) return te(b);
  }
  function Ge(a2, b) {
    return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a2, b) {
    if (He(a2, b)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b) return false;
    var c2 = Object.keys(a2), d = Object.keys(b);
    if (c2.length !== d.length) return false;
    for (d = 0; d < c2.length; d++) {
      var e = c2[d];
      if (!ja.call(b, e) || !He(a2[e], b[e])) return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d; c2; ) {
      if (3 === c2.nodeType) {
        d = a2 + c2.textContent.length;
        if (a2 <= b && d >= b) return { node: c2, offset: b - a2 };
        a2 = d;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b) {
    return a2 && b ? a2 === b ? true : a2 && 3 === a2.nodeType ? false : b && 3 === b.nodeType ? Le(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a2 = window, b = Xa(); b instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c2 = false;
      }
      if (c2) a2 = b.contentWindow;
      else break;
      b = Xa(a2.document);
    }
    return b;
  }
  function Ne(a2) {
    var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b = Me(), c2 = a2.focusedElem, d = a2.selectionRange;
    if (b !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d && Ne(c2)) {
        if (b = d.start, a2 = d.end, void 0 === a2 && (a2 = b), "selectionStart" in c2) c2.selectionStart = b, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b = c2.ownerDocument || document) && b.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e = c2.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e);
          !a2.extend && f > d && (e = d, d = f, f = e);
          e = Ke(c2, f);
          var g = Ke(
            c2,
            d
          );
          e && g && (1 !== a2.rangeCount || a2.anchorNode !== e.node || a2.anchorOffset !== e.offset || a2.focusNode !== g.node || a2.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a2.removeAllRanges(), f > d ? (a2.addRange(b), a2.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a2.addRange(b)));
        }
      }
      b = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b.length; c2++) a2 = b[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a2, b, c2) {
    var d = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c2), a2.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a2, b) {
    var c2 = {};
    c2[a2.toLowerCase()] = b.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b;
    c2["Moz" + a2] = "moz" + b;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2]) return Xe[a2];
    if (!We[a2]) return a2;
    var b = We[a2], c2;
    for (c2 in b) if (b.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b[c2];
    return a2;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b) {
    df.set(a2, b);
    fa(b, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b, c2) {
    var d = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d, b, void 0, a2);
    a2.currentTarget = null;
  }
  function se(a2, b) {
    b = 0 !== (b & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d = a2[c2], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D(a2, b) {
    var c2 = b[of];
    void 0 === c2 && (c2 = b[of] = /* @__PURE__ */ new Set());
    var d = a2 + "__bubble";
    c2.has(d) || (pf(b, a2, 2, false), c2.add(d));
  }
  function qf(a2, b, c2) {
    var d = 0;
    b && (d |= 4);
    pf(c2, a2, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a2), qf(b2, true, a2));
      });
      var b = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a2, b, c2, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c2 = e.bind(null, b, c2, a2);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a2.addEventListener(b, c2, { capture: true, passive: e }) : a2.addEventListener(b, c2, true) : void 0 !== e ? a2.addEventListener(b, c2, { passive: e }) : a2.addEventListener(b, c2, false);
  }
  function hd(a2, b, c2, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e2 = xb(c2), g2 = [];
      a: {
        var h2 = df.get(a2);
        if (void 0 !== h2) {
          var k2 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t2 = 0 !== (b & 4), J = !t2 && "scroll" === a2, x = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
          t2 = [];
          for (var w = d2, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t2.push(tf(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t2.length && (h2 = new k2(h2, n2, null, c2, e2), g2.push({ event: h2, listeners: t2 }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a2 || "pointerover" === a2;
          k2 = "mouseout" === a2 || "pointerout" === a2;
          if (h2 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k2 || h2) {
            h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k2) {
              if (n2 = c2.relatedTarget || c2.toElement, k2 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J = Vb(n2), n2 !== J || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k2 = null, n2 = d2;
            if (k2 !== n2) {
              t2 = Bd;
              F = "onMouseLeave";
              x = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
              J = null == k2 ? h2 : ue(k2);
              u = null == n2 ? h2 : ue(n2);
              h2 = new t2(F, w + "leave", k2, c2, e2);
              h2.target = J;
              h2.relatedTarget = u;
              F = null;
              Wc(e2) === d2 && (t2 = new t2(x, w + "enter", n2, c2, e2), t2.target = u, t2.relatedTarget = J, F = t2);
              J = F;
              if (k2 && n2) b: {
                t2 = k2;
                x = n2;
                w = 0;
                for (u = t2; u; u = vf(u)) w++;
                u = 0;
                for (F = x; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t2 = vf(t2), w--;
                for (; 0 < u - w; ) x = vf(x), u--;
                for (; w--; ) {
                  if (t2 === x || null !== x && t2 === x.alternate) break b;
                  t2 = vf(t2);
                  x = vf(x);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k2 && wf(g2, h2, k2, t2, false);
              null !== n2 && null !== J && wf(g2, J, n2, t2, true);
            }
          }
        }
        a: {
          h2 = d2 ? ue(d2) : window;
          k2 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a2, d2))) {
            ne(g2, na, c2, e2);
            break a;
          }
          xa && xa(a2, h2, d2);
          "focusout" === a2 && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c2, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c2, e2);
        }
        var $a;
        if (ae) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie2 ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie2 && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie2 = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a2, c2) : ke(a2, c2)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c2, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a2, b, c2) {
    return { instance: a2, listener: b, currentTarget: c2 };
  }
  function oe(a2, b) {
    for (var c2 = b + "Capture", d = []; null !== a2; ) {
      var e = a2, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a2, c2), null != f && d.unshift(tf(a2, f, e)), f = Kb(a2, b), null != f && d.push(tf(a2, f, e)));
      a2 = a2.return;
    }
    return d;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b, c2, d, e) {
    for (var f = b._reactName, g = []; null !== c2 && c2 !== d; ) {
      var h = c2, k = h.alternate, l = h.stateNode;
      if (null !== k && k === d) break;
      5 === h.tag && null !== l && (h = l, e ? (k = Kb(c2, f), null != k && g.unshift(tf(c2, k, h))) : e || (k = Kb(c2, f), null != k && g.push(tf(c2, k, h))));
      c2 = c2.return;
    }
    0 !== g.length && a2.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b, c2) {
    b = zf(b);
    if (zf(a2) !== b && c2) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b) {
    var c2 = b, d = 0;
    do {
      var e = c2.nextSibling;
      a2.removeChild(c2);
      if (e && 8 === e.nodeType) if (c2 = e.data, "/$" === c2) {
        if (0 === d) {
          a2.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d++;
      c2 = e;
    } while (c2);
    bd(b);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b = a2.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a2.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b) return a2;
          b--;
        } else "/$" === c2 && b++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b = a2[Of];
    if (b) return b;
    for (var c2 = a2.parentNode; c2; ) {
      if (b = c2[uf] || c2[Of]) {
        c2 = b.alternate;
        if (null !== b.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of]) return c2;
          a2 = Mf(a2);
        }
        return b;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a2, b) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d = a2.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c2) e[f] = b[f];
    d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a2, b, c2) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c2);
  }
  function bg(a2, b, c2) {
    var d = a2.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c2;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a2) || "Unknown", e));
    return A({}, c2, d);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a2);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a2, b, c2) {
    var d = a2.stateNode;
    if (!d) throw Error(p(169));
    c2 ? (a2 = bg(a2, b, Xf), d.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
    G(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b = C;
      try {
        var c2 = eg;
        for (C = 1; a2 < c2.length; a2++) {
          var d = c2[a2];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b;
  }
  function ug(a2, b, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d = rg;
    a2 = sg;
    var e = 32 - oc2(d) - 1;
    d &= ~(1 << e);
    c2 += 1;
    var f = 32 - oc2(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc2(b) + e | c2 << e | d;
      sg = f + a2;
    } else rg = 1 << f | c2 << e | d, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a2, b) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b;
    c2.return = a2;
    b = a2.deletions;
    null === b ? (a2.deletions = [c2], a2.flags |= 16) : b.push(c2);
  }
  function Cg(a2, b) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b = 1 !== b.nodeType || c2.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a2.stateNode = b, xg = a2, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a2.stateNode = b, xg = a2, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I) {
      var b = yg;
      if (b) {
        var c2 = b;
        if (!Cg(a2, b)) {
          if (Dg(a2)) throw Error(p(418));
          b = Lf(c2.nextSibling);
          var d = xg;
          b && Cg(a2, b) ? Ag(d, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p(418));
        a2.flags = a2.flags & -4097 | 2;
        I = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I) return Fg(a2), I = true, false;
    var b;
    (b = 3 !== a2.tag) && !(b = 5 !== a2.tag) && (b = a2.type, b = "head" !== b && "body" !== b && !Ef(a2.type, a2.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a2)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a2, b), b = Lf(b.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p(317));
      a: {
        a2 = a2.nextSibling;
        for (b = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p(309));
          var d = c2.stateNode;
        }
        if (!d) throw Error(p(147, a2));
        var e = d, f = "" + a2;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a3) {
          var b2 = e.refs;
          null === a3 ? delete b2[f] : b2[f] = a3;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a2) throw Error(p(284));
      if (!c2._owner) throw Error(p(290, a2));
    }
    return a2;
  }
  function Mg(a2, b) {
    a2 = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b = a2._init;
    return b(a2._payload);
  }
  function Og(a2) {
    function b(b2, c3) {
      if (a2) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c3], b2.flags |= 16) : d2.push(c3);
      }
    }
    function c2(c3, d2) {
      if (!a2) return null;
      for (; null !== d2; ) b(c3, d2), d2 = d2.sibling;
      return null;
    }
    function d(a3, b2) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
      return a3;
    }
    function e(a3, b2) {
      a3 = Pg(a3, b2);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f(b2, c3, d2) {
      b2.index = d2;
      if (!a2) return b2.flags |= 1048576, c3;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c3 ? (b2.flags |= 2, c3) : d2;
      b2.flags |= 2;
      return c3;
    }
    function g(b2) {
      a2 && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a3, b2, c3, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c3, a3.mode, d2), b2.return = a3, b2;
      b2 = e(b2, c3);
      b2.return = a3;
      return b2;
    }
    function k(a3, b2, c3, d2) {
      var f2 = c3.type;
      if (f2 === ya) return m(a3, b2, c3.props.children, d2, c3.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c3.props), d2.ref = Lg(a3, b2, c3), d2.return = a3, d2;
      d2 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d2);
      d2.ref = Lg(a3, b2, c3);
      d2.return = a3;
      return d2;
    }
    function l(a3, b2, c3, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c3.containerInfo || b2.stateNode.implementation !== c3.implementation) return b2 = Sg(c3, a3.mode, d2), b2.return = a3, b2;
      b2 = e(b2, c3.children || []);
      b2.return = a3;
      return b2;
    }
    function m(a3, b2, c3, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c3, a3.mode, d2, f2), b2.return = a3, b2;
      b2 = e(b2, c3);
      b2.return = a3;
      return b2;
    }
    function q(a3, b2, c3) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a3.mode, c3), b2.return = a3, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c3 = Rg(b2.type, b2.key, b2.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b2), c3.return = a3, c3;
          case wa:
            return b2 = Sg(b2, a3.mode, c3), b2.return = a3, b2;
          case Ha:
            var d2 = b2._init;
            return q(a3, d2(b2._payload), c3);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a3.mode, c3, null), b2.return = a3, b2;
        Mg(a3, b2);
      }
      return null;
    }
    function r2(a3, b2, c3, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e2 ? null : h(a3, b2, "" + c3, d2);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e2 ? k(a3, b2, c3, d2) : null;
          case wa:
            return c3.key === e2 ? l(a3, b2, c3, d2) : null;
          case Ha:
            return e2 = c3._init, r2(
              a3,
              b2,
              e2(c3._payload),
              d2
            );
        }
        if (eb(c3) || Ka(c3)) return null !== e2 ? null : m(a3, b2, c3, d2, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y2(a3, b2, c3, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a3 = a3.get(c3) || null, h(b2, a3, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, k(b2, a3, d2, e2);
          case wa:
            return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, l(b2, a3, d2, e2);
          case Ha:
            var f2 = d2._init;
            return y2(a3, b2, c3, f2(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a3 = a3.get(c3) || null, m(b2, a3, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n2(e2, g2, h2, k2) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
        u.index > w ? (x = u, u = null) : x = u.sibling;
        var n3 = r2(e2, u, h2[w], k2);
        if (null === n3) {
          null === u && (u = x);
          break;
        }
        a2 && u && null === n3.alternate && b(e2, u);
        g2 = f(n3, g2, w);
        null === m2 ? l2 = n3 : m2.sibling = n3;
        m2 = n3;
        u = x;
      }
      if (w === h2.length) return c2(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d(e2, u); w < h2.length; w++) x = y2(u, e2, w, h2[w], k2), null !== x && (a2 && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
      a2 && u.forEach(function(a3) {
        return b(e2, a3);
      });
      I && tg(e2, w);
      return l2;
    }
    function t2(e2, g2, h2, k2) {
      var l2 = Ka(h2);
      if ("function" !== typeof l2) throw Error(p(150));
      h2 = l2.call(h2);
      if (null == h2) throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n3 = h2.next(); null !== m2 && !n3.done; w++, n3 = h2.next()) {
        m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
        var t3 = r2(e2, m2, n3.value, k2);
        if (null === t3) {
          null === m2 && (m2 = x);
          break;
        }
        a2 && m2 && null === t3.alternate && b(e2, m2);
        g2 = f(t3, g2, w);
        null === u ? l2 = t3 : u.sibling = t3;
        u = t3;
        m2 = x;
      }
      if (n3.done) return c2(
        e2,
        m2
      ), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n3.done; w++, n3 = h2.next()) n3 = q(e2, n3.value, k2), null !== n3 && (g2 = f(n3, g2, w), null === u ? l2 = n3 : u.sibling = n3, u = n3);
        I && tg(e2, w);
        return l2;
      }
      for (m2 = d(e2, m2); !n3.done; w++, n3 = h2.next()) n3 = y2(m2, e2, w, n3.value, k2), null !== n3 && (a2 && null !== n3.alternate && m2.delete(null === n3.key ? w : n3.key), g2 = f(n3, g2, w), null === u ? l2 = n3 : u.sibling = n3, u = n3);
      a2 && m2.forEach(function(a3) {
        return b(e2, a3);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a3, d2, f2, h2) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l2.tag) {
                      c2(a3, l2.sibling);
                      d2 = e(l2, f2.props.children);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                    c2(a3, l2.sibling);
                    d2 = e(l2, f2.props);
                    d2.ref = Lg(a3, l2, f2);
                    d2.return = a3;
                    a3 = d2;
                    break a;
                  }
                  c2(a3, l2);
                  break;
                } else b(a3, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a3.mode, h2, f2.key), d2.return = a3, a3 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a3.mode, h2), h2.ref = Lg(a3, d2, f2), h2.return = a3, a3 = h2);
            }
            return g(a3);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c2(a3, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a3;
                  a3 = d2;
                  break a;
                } else {
                  c2(a3, d2);
                  break;
                }
                else b(a3, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a3.mode, h2);
              d2.return = a3;
              a3 = d2;
            }
            return g(a3);
          case Ha:
            return l2 = f2._init, J(a3, d2, l2(f2._payload), h2);
        }
        if (eb(f2)) return n2(a3, d2, f2, h2);
        if (Ka(f2)) return t2(a3, d2, f2, h2);
        Mg(a3, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c2(a3, d2.sibling), d2 = e(d2, f2), d2.return = a3, a3 = d2) : (c2(a3, d2), d2 = Qg(f2, a3.mode, h2), d2.return = a3, a3 = d2), g(a3)) : c2(a3, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b = Wg.current;
    E(Wg);
    a2._currentValue = b;
  }
  function bh(a2, b, c2) {
    for (; null !== a2; ) {
      var d = a2.alternate;
      (a2.childLanes & b) !== b ? (a2.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function ch(a2, b) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b = a2._currentValue;
    if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg = Yg.next = a2;
    return b;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b, c2, d) {
    var e = b.interleaved;
    null === e ? (c2.next = c2, gh(b)) : (c2.next = e.next, e.next = c2);
    b.interleaved = c2;
    return ih(a2, d);
  }
  function ih(a2, b) {
    a2.lanes |= b;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b) {
    a2 = a2.updateQueue;
    b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b) {
    return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b, c2) {
    var d = a2.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a2, c2);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a2, c2);
  }
  function oh(a2, b, c2) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c2 & 4194240))) {
      var d = b.lanes;
      d &= a2.pendingLanes;
      c2 |= d;
      b.lanes = c2;
      Cc(a2, c2);
    }
  }
  function ph(a2, b) {
    var c2 = a2.updateQueue, d = a2.alternate;
    if (null !== d && (d = d.updateQueue, c2 === d)) {
      var e = null, f = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c2 = c2.next;
        } while (null !== c2);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c2 = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b : a2.next = b;
    c2.lastBaseUpdate = b;
  }
  function qh(a2, b, c2, d) {
    var e = a2.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k = h, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m = a2.alternate;
      null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m = l = k = null;
      h = f;
      do {
        var r2 = h.lane, y2 = h.eventTime;
        if ((d & r2) === r2) {
          null !== m && (m = m.next = {
            eventTime: y2,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h;
            r2 = b;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q = n2.call(y2, q, r2);
                  break a;
                }
                q = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q = A({}, q, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a2.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
        } else y2 = { eventTime: y2, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y2, k = q) : m = m.next = y2, g |= r2;
        h = h.next;
        if (null === h) if (h = e.shared.pending, null === h) break;
        else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
      } while (1);
      null === m && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a2.lanes = g;
      a2.memoizedState = q;
    }
  }
  function sh(a2, b, c2) {
    a2 = b.effects;
    b.effects = null;
    if (null !== a2) for (b = 0; b < a2.length; b++) {
      var d = a2[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c2;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a2) {
    if (a2 === th) throw Error(p(174));
    return a2;
  }
  function yh(a2, b) {
    G(wh, b);
    G(vh, a2);
    G(uh, th);
    a2 = b.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b.parentNode : b, b = a2.namespaceURI || null, a2 = a2.tagName, b = lb(b, a2);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b = xh(uh.current);
    var c2 = lb(b, a2.type);
    b !== c2 && (G(vh, a2), G(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a2) {
    for (var b = a2; null !== b; ) {
      if (13 === b.tag) {
        var c2 = b.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a2) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a2) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p(321));
  }
  function Mh(a2, b) {
    if (null === b) return false;
    for (var c2 = 0; c2 < b.length && c2 < a2.length; c2++) if (!He(a2[c2], b[c2])) return false;
    return true;
  }
  function Nh(a2, b, c2, d, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a2 : O = O.next = a2;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a2 = M.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a2;
    else {
      if (null === a2) throw Error(p(310));
      N = a2;
      a2 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a2 : O = O.next = a2;
    }
    return O;
  }
  function Vh(a2, b) {
    return "function" === typeof b ? b(a2) : b;
  }
  function Wh(a2) {
    var b = Uh(), c2 = b.queue;
    if (null === c2) throw Error(p(311));
    c2.lastRenderedReducer = a2;
    var d = N, e = d.baseQueue, f = c2.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d.baseQueue = e = f;
      c2.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d = d.baseState;
      var h = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a2(d, l.action);
        else {
          var q = {
            lane: m,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h = k = q, g = d) : k = k.next = q;
          M.lanes |= m;
          rh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c2.lastRenderedState = d;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e = a2;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a2);
    } else null === e && (c2.lanes = 0);
    return [b.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b = Uh(), c2 = b.queue;
    if (null === c2) throw Error(p(311));
    c2.lastRenderedReducer = a2;
    var d = c2.dispatch, e = c2.pending, f = b.memoizedState;
    if (null !== e) {
      c2.pending = null;
      var g = e = e.next;
      do
        f = a2(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c2.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a2, b) {
    var c2 = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
    f && (d.memoizedState = e, dh = true);
    d = d.queue;
    $h(ai.bind(null, c2, d, a2), [a2]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c2, b, e);
    }
    return e;
  }
  function di(a2, b, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b, value: c2 };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a2]) : (c2 = b.stores, null === c2 ? b.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b, c2, d) {
    b.value = c2;
    b.getSnapshot = d;
    ei(b) && fi(a2);
  }
  function ai(a2, b, c2) {
    return c2(function() {
      ei(b) && fi(a2);
    });
  }
  function ei(a2) {
    var b = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b();
      return !He(a2, c2);
    } catch (d) {
      return true;
    }
  }
  function fi(a2) {
    var b = ih(a2, 1);
    null !== b && gi(b, a2, 1, -1);
  }
  function hi(a2) {
    var b = Th();
    "function" === typeof a2 && (a2 = a2());
    b.memoizedState = b.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M, a2);
    return [b.memoizedState, a2];
  }
  function bi(a2, b, c2, d) {
    a2 = { tag: a2, create: b, destroy: c2, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a2.next = a2) : (c2 = b.lastEffect, null === c2 ? b.lastEffect = a2.next = a2 : (d = c2.next, c2.next = a2, a2.next = d, b.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a2, b, c2, d) {
    var e = Th();
    M.flags |= a2;
    e.memoizedState = bi(1 | b, c2, void 0, void 0 === d ? null : d);
  }
  function li(a2, b, c2, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c2, f, d);
        return;
      }
    }
    M.flags |= a2;
    e.memoizedState = bi(1 | b, c2, f, d);
  }
  function mi(a2, b) {
    return ki(8390656, 8, a2, b);
  }
  function $h(a2, b) {
    return li(2048, 8, a2, b);
  }
  function ni(a2, b) {
    return li(4, 2, a2, b);
  }
  function oi(a2, b) {
    return li(4, 4, a2, b);
  }
  function pi(a2, b) {
    if ("function" === typeof b) return a2 = a2(), b(a2), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a2 = a2(), b.current = a2, function() {
      b.current = null;
    };
  }
  function qi(a2, b, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi.bind(null, b, a2), c2);
  }
  function ri() {
  }
  function si(a2, b) {
    var c2 = Uh();
    b = void 0 === b ? null : b;
    var d = c2.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c2.memoizedState = [a2, b];
    return a2;
  }
  function ti(a2, b) {
    var c2 = Uh();
    b = void 0 === b ? null : b;
    var d = c2.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a2 = a2();
    c2.memoizedState = [a2, b];
    return a2;
  }
  function ui(a2, b, c2) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He(c2, b) || (c2 = yc(), M.lanes |= c2, rh |= c2, a2.baseState = true);
    return b;
  }
  function vi(a2, b) {
    var c2 = C;
    C = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b();
    } finally {
      C = c2, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a2, b, c2) {
    var d = yi(a2);
    c2 = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b, c2);
    else if (c2 = hh(a2, b, c2, d), null !== c2) {
      var e = R();
      gi(c2, a2, d, e);
      Bi(c2, b, d);
    }
  }
  function ii(a2, b, c2) {
    var d = yi(a2), e = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b, e);
    else {
      var f = a2.alternate;
      if (0 === a2.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h = f(g, c2);
        e.hasEagerState = true;
        e.eagerState = h;
        if (He(h, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c2 = hh(a2, b, e, d);
      null !== c2 && (e = R(), gi(c2, a2, d, e), Bi(c2, b, d));
    }
  }
  function zi(a2) {
    var b = a2.alternate;
    return a2 === M || null !== b && b === M;
  }
  function Ai(a2, b) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b.next = b : (b.next = c2.next, c2.next = b);
    a2.pending = b;
  }
  function Bi(a2, b, c2) {
    if (0 !== (c2 & 4194240)) {
      var d = b.lanes;
      d &= a2.pendingLanes;
      c2 |= d;
      b.lanes = c2;
      Cc(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b) {
    Th().memoizedState = [a2, void 0 === b ? null : b];
    return a2;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b) {
    return ki(4194308, 4, a2, b);
  }, useInsertionEffect: function(a2, b) {
    return ki(4, 2, a2, b);
  }, useMemo: function(a2, b) {
    var c2 = Th();
    b = void 0 === b ? null : b;
    a2 = a2();
    c2.memoizedState = [a2, b];
    return a2;
  }, useReducer: function(a2, b, c2) {
    var d = Th();
    b = void 0 !== c2 ? c2(b) : b;
    d.memoizedState = d.baseState = b;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b };
    d.queue = a2;
    a2 = a2.dispatch = xi.bind(null, M, a2);
    return [d.memoizedState, a2];
  }, useRef: function(a2) {
    var b = Th();
    a2 = { current: a2 };
    return b.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b = a2[0];
    a2 = vi.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b, c2) {
    var d = M, e = Th();
    if (I) {
      if (void 0 === c2) throw Error(p(407));
      c2 = c2();
    } else {
      c2 = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d, b, c2);
    }
    e.memoizedState = c2;
    var f = { value: c2, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a2
    ), [a2]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c2, b), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b = Q.identifierPrefix;
    if (I) {
      var c2 = sg;
      var d = rg;
      c2 = (d & ~(1 << 32 - oc2(d) - 1)).toString(32) + c2;
      b = ":" + b + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b += "H" + c2.toString(32));
      b += ":";
    } else c2 = Lh++, b = ":" + b + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b = Uh();
      return ui(b, N.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b = Uh().memoizedState;
      return [a2, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b = Uh();
    return null === N ? b.memoizedState = a2 : ui(b, N.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b = Uh().memoizedState;
    return [a2, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a2, b) {
    if (a2 && a2.defaultProps) {
      b = A({}, b);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b[c2] && (b[c2] = a2[c2]);
      return b;
    }
    return b;
  }
  function Di(a2, b, c2, d) {
    b = a2.memoizedState;
    c2 = c2(d, b);
    c2 = null === c2 || void 0 === c2 ? b : A({}, b, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b, c2) {
    a2 = a2._reactInternals;
    var d = R(), e = yi(a2), f = mh(d, e);
    f.payload = b;
    void 0 !== c2 && null !== c2 && (f.callback = c2);
    b = nh(a2, f, e);
    null !== b && (gi(b, a2, e, d), oh(b, a2, e));
  }, enqueueReplaceState: function(a2, b, c2) {
    a2 = a2._reactInternals;
    var d = R(), e = yi(a2), f = mh(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c2 && null !== c2 && (f.callback = c2);
    b = nh(a2, f, e);
    null !== b && (gi(b, a2, e, d), oh(b, a2, e));
  }, enqueueForceUpdate: function(a2, b) {
    a2 = a2._reactInternals;
    var c2 = R(), d = yi(a2), e = mh(c2, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a2, e, d);
    null !== b && (gi(b, a2, d, c2), oh(b, a2, d));
  } };
  function Fi(a2, b, c2, d, e, f, g) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c2, d) || !Ie(e, f) : true;
  }
  function Gi(a2, b, c2) {
    var d = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a2, e) : Vf);
    b = new b(c2, f);
    a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a2.stateNode = b;
    b._reactInternals = a2;
    d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a2, b, c2, d) {
    a2 = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c2, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c2, d);
    b.state !== a2 && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a2, b, c2, d) {
    var e = a2.stateNode;
    e.props = c2;
    e.state = a2.memoizedState;
    e.refs = {};
    kh(a2);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a2, f));
    e.state = a2.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a2, b, f, c2), e.state = a2.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a2, c2, e, d), e.state = a2.memoizedState);
    "function" === typeof e.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b) {
    try {
      var c2 = "", d = b;
      do
        c2 += Pa(d), d = d.return;
      while (d);
      var e = c2;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a2, source: b, stack: e, digest: null };
  }
  function Ki(a2, b, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b ? b : null };
  }
  function Li(a2, b) {
    try {
      console.error(b.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a2, b, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d = b.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a2, b);
    };
    return c2;
  }
  function Qi(a2, b, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d = a2.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c2.payload = function() {
        return d(e);
      };
      c2.callback = function() {
        Li(a2, b);
      };
    }
    var f = a2.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c2.callback = function() {
      Li(a2, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b, c2) {
    var d = a2.pingCache;
    if (null === d) {
      d = a2.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c2) || (e.add(c2), a2 = Ti.bind(null, a2, b, c2), b.then(a2, a2));
  }
  function Ui(a2) {
    do {
      var b;
      if (b = 13 === a2.tag) b = a2.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b, c2, d, e) {
    if (0 === (a2.mode & 1)) return a2 === b ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c2, b, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e;
    return a2;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a2, b, c2, d) {
    b.child = null === a2 ? Vg(b, null, c2, d) : Ug(b, a2.child, c2, d);
  }
  function Yi(a2, b, c2, d, e) {
    c2 = c2.render;
    var f = b.ref;
    ch(b, e);
    d = Nh(a2, b, c2, d, f, e);
    c2 = Sh();
    if (null !== a2 && !dh) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, Zi(a2, b, e);
    I && c2 && vg(b);
    b.flags |= 1;
    Xi(a2, b, d, e);
    return b.child;
  }
  function $i(a2, b, c2, d, e) {
    if (null === a2) {
      var f = c2.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b.tag = 15, b.type = f, bj(a2, b, f, d, e);
      a2 = Rg(c2.type, null, d, b, b.mode, e);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    f = a2.child;
    if (0 === (a2.lanes & e)) {
      var g = f.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g, d) && a2.ref === b.ref) return Zi(a2, b, e);
    }
    b.flags |= 1;
    a2 = Pg(f, d);
    a2.ref = b.ref;
    a2.return = b;
    return b.child = a2;
  }
  function bj(a2, b, c2, d, e) {
    if (null !== a2) {
      var f = a2.memoizedProps;
      if (Ie(f, d) && a2.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a2.lanes & e)) 0 !== (a2.flags & 131072) && (dh = true);
      else return b.lanes = a2.lanes, Zi(a2, b, e);
    }
    return cj(a2, b, c2, d, e);
  }
  function dj(a2, b, c2) {
    var d = b.pendingProps, e = d.children, f = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f ? f.baseLanes | c2 : c2, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a2, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c2;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c2, b.memoizedState = null) : d = c2, G(ej, fj), fj |= d;
    Xi(a2, b, e, c2);
    return b.child;
  }
  function gj(a2, b) {
    var c2 = b.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a2, b, c2, d, e) {
    var f = Zf(c2) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c2 = Nh(a2, b, c2, d, f, e);
    d = Sh();
    if (null !== a2 && !dh) return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e, Zi(a2, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a2, b, c2, e);
    return b.child;
  }
  function hj(a2, b, c2, d, e) {
    if (Zf(c2)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a2, b), Gi(b, c2, d), Ii(b, c2, d, e), d = true;
    else if (null === a2) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l = c2.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c2) ? Xf : H.current, l = Yf(b, l));
      var m = c2.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
      jh = false;
      var r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e);
      k = b.memoizedState;
      h !== d || r2 !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c2, m, d), k = b.memoizedState), (h = jh || Fi(b, c2, h, d, r2, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a2, b);
      h = b.memoizedProps;
      l = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l;
      q = b.pendingProps;
      r2 = g.context;
      k = c2.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c2) ? Xf : H.current, k = Yf(b, k));
      var y2 = c2.getDerivedStateFromProps;
      (m = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r2 !== k) && Hi(b, g, d, k);
      jh = false;
      r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e);
      var n2 = b.memoizedState;
      h !== q || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c2, y2, d), n2 = b.memoizedState), (l = jh || Fi(b, c2, l, d, r2, n2, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a2, b, c2, d, f, e);
  }
  function jj(a2, b, c2, d, e, f) {
    gj(a2, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c2, false), Zi(a2, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c2.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a2 && g ? (b.child = Ug(b, a2.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a2, b, h, f);
    b.memoizedState = d.state;
    e && dg(b, c2, true);
    return b.child;
  }
  function kj(a2) {
    var b = a2.stateNode;
    b.pendingContext ? ag(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a2, b.context, false);
    yh(a2, b.containerInfo);
  }
  function lj(a2, b, c2, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a2, b, c2, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b, c2) {
    var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a2 && null === a2.memoizedState ? false : 0 !== (e & 2));
    if (h) f = true, b.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a2) {
      Eg(b);
      a2 = b.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a2.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a2 = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a2 = Tg(a2, d, c2, null), f.return = b, a2.return = b, f.sibling = a2, b.child = f, b.child.memoizedState = nj(c2), b.memoizedState = mj, a2) : qj(b, g);
    }
    e = a2.memoizedState;
    if (null !== e && (h = e.dehydrated, null !== h)) return rj(a2, b, g, d, h, e, c2);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e = a2.child;
      h = e.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h ? f = Pg(h, f) : (f = Tg(f, g, c2, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a2.child.memoizedState;
      g = null === g ? nj(c2) : { baseLanes: g.baseLanes | c2, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a2.childLanes & ~c2;
      b.memoizedState = mj;
      return d;
    }
    f = a2.child;
    a2 = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c2);
    d.return = b;
    d.sibling = null;
    null !== a2 && (c2 = b.deletions, null === c2 ? (b.deletions = [a2], b.flags |= 16) : c2.push(a2));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a2, b) {
    b = pj({ mode: "visible", children: b }, a2.mode, 0, null);
    b.return = a2;
    return a2.child = b;
  }
  function sj(a2, b, c2, d) {
    null !== d && Jg(d);
    Ug(b, a2.child, null, c2);
    a2 = qj(b, b.pendingProps.children);
    a2.flags |= 2;
    b.memoizedState = null;
    return a2;
  }
  function rj(a2, b, c2, d, e, f, g) {
    if (c2) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a2, b, g, d);
      if (null !== b.memoizedState) return b.child = a2.child, b.flags |= 128, null;
      f = d.fallback;
      e = b.mode;
      d = pj({ mode: "visible", children: d.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a2.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a2, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h = d.dgst;
      d = h;
      f = Error(p(419));
      d = Ki(f, d, void 0);
      return sj(a2, b, g, d);
    }
    h = 0 !== (g & a2.childLanes);
    if (dh || h) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a2, e), gi(d, a2, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a2, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a2.child, b = uj.bind(null, a2), e._reactRetry = b, null;
    a2 = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a2, b, c2) {
    a2.lanes |= b;
    var d = a2.alternate;
    null !== d && (d.lanes |= b);
    bh(a2.return, b, c2);
  }
  function wj(a2, b, c2, d, e) {
    var f = a2.memoizedState;
    null === f ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c2, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c2, f.tailMode = e);
  }
  function xj(a2, b, c2) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    Xi(a2, b, d.children, c2);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b);
        else if (19 === a2.tag) vj(a2, c2, b);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c2 = b.child;
        for (e = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e = c2), c2 = c2.sibling;
        c2 = e;
        null === c2 ? (e = b.child, b.child = null) : (e = c2.sibling, c2.sibling = null);
        wj(b, false, e, c2, f);
        break;
      case "backwards":
        c2 = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a2 = e.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b.child = e;
            break;
          }
          a2 = e.sibling;
          e.sibling = c2;
          c2 = e;
          e = a2;
        }
        wj(b, true, c2, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a2, b) {
    0 === (b.mode & 1) && null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a2, b, c2) {
    null !== a2 && (b.dependencies = a2.dependencies);
    rh |= b.lanes;
    if (0 === (c2 & b.childLanes)) return null;
    if (null !== a2 && b.child !== a2.child) throw Error(p(153));
    if (null !== b.child) {
      a2 = b.child;
      c2 = Pg(a2, a2.pendingProps);
      b.child = c2;
      for (c2.return = b; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b;
      c2.sibling = null;
    }
    return b.child;
  }
  function yj(a2, b, c2) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c2 & b.child.childLanes)) return oj(a2, b, c2);
          G(L, L.current & 1);
          a2 = Zi(a2, b, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c2 & b.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d) return xj(a2, b, c2);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a2, b, c2);
    }
    return Zi(a2, b, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b) {
    for (var c2 = b.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b, c2, d) {
    var e = a2.memoizedProps;
    if (e !== d) {
      a2 = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c2) {
        case "input":
          e = Ya(a2, e);
          d = Ya(a2, d);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a2, e);
          d = gb(a2, d);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a2.onclick = Bf);
      }
      ub(c2, d);
      var g;
      c2 = null;
      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];
        for (g in h) h.hasOwnProperty(g) && (c2 || (c2 = {}), c2[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        h = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c2 || (c2 = {}), c2[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c2 || (c2 = {}), c2[g] = k[g]);
        } else c2 || (f || (f = []), f.push(
          l,
          c2
        )), c2 = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a2), f || h === k || (f = [])) : (f = f || []).push(l, k));
      }
      c2 && (f = f || []).push("style", c2);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a2, b, c2, d) {
    c2 !== d && (b.flags |= 4);
  };
  function Dj(a2, b) {
    if (!I) switch (a2.tailMode) {
      case "hidden":
        b = a2.tail;
        for (var c2 = null; null !== b; ) null !== b.alternate && (c2 = b), b = b.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d = null; null !== c2; ) null !== c2.alternate && (d = c2), c2 = c2.sibling;
        null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a2) {
    var b = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d = 0;
    if (b) for (var e = a2.child; null !== e; ) c2 |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a2, e = e.sibling;
    else for (e = a2.child; null !== e; ) c2 |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a2, e = e.sibling;
    a2.subtreeFlags |= d;
    a2.childLanes = c2;
    return b;
  }
  function Ej(a2, b, c2) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b) ? b.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c2 = b.type;
        if (null !== a2 && null != b.stateNode) Bj(a2, b, c2, d, e), a2.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c2 = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a2 = 0 !== (b.mode & 1);
            switch (c2) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c2, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a2), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h,
                a2
              ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
            switch (c2) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d.is ? a2 = g.createElement(c2, { is: d.is }) : (a2 = g.createElement(c2), "select" === c2 && (g = a2, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a2 = g.createElementNS(a2, c2);
            a2[Of] = b;
            a2[Pf] = d;
            zj(a2, b, false, false);
            b.stateNode = a2;
            a: {
              g = vb(c2, d);
              switch (c2) {
                case "dialog":
                  D("cancel", a2);
                  D("close", a2);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a2);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a2);
                  e = d;
                  break;
                case "source":
                  D("error", a2);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a2
                  );
                  D("load", a2);
                  e = d;
                  break;
                case "details":
                  D("toggle", a2);
                  e = d;
                  break;
                case "input":
                  Za(a2, d);
                  e = Ya(a2, d);
                  D("invalid", a2);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d.multiple };
                  e = A({}, d, { value: void 0 });
                  D("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d);
                  e = gb(a2, d);
                  D("invalid", a2);
                  break;
                default:
                  e = d;
              }
              ub(c2, e);
              h = e;
              for (f in h) if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a2, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a2, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c2 || "" !== k) && ob(a2, k) : "number" === typeof k && ob(a2, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a2) : null != k && ta2(a2, f, k, g));
              }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d.value && a2.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a2.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a2, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a2,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a2 && null != b.stateNode) Cj(a2, b, a2.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c2 = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a2) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c2, b;
        d = null !== d;
        d !== (null !== a2 && null !== a2.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a2, b), null === a2 && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b.child; null !== a2; ) {
            g = Ch(a2);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c2;
              for (c2 = b.child; null !== c2; ) f = c2, a2 = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a2, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a2 = g.dependencies, f.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a2 = a2.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a2 = Ch(g), null !== a2) {
            if (b.flags |= 128, d = true, c2 = a2.updateQueue, null !== c2 && (b.updateQueue = c2, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c2 && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c2 = f.last, null !== c2 ? c2.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c2 = L.current, G(L, d ? c2 & 1 | 2 : c2 & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a2 && null !== a2.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a2, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a2 = b.flags, a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a2 = b.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b.flags = a2 & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a2 = b.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a2 = b.flags;
        return a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V2 = null;
  function Lj(a2, b) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d) {
      W(a2, b, d);
    }
    else c2.current = null;
  }
  function Mj(a2, b, c2) {
    try {
      c2();
    } catch (d) {
      W(a2, b, d);
    }
  }
  var Nj = false;
  function Oj(a2, b) {
    Cf = dd;
    a2 = Me();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d = c2.getSelection && c2.getSelection();
        if (d && 0 !== d.rangeCount) {
          c2 = d.anchorNode;
          var e = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c2.nodeType, f.nodeType;
          } catch (F) {
            c2 = null;
            break a;
          }
          var g = 0, h = -1, k = -1, l = 0, m = 0, q = a2, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q !== c2 || 0 !== e && 3 !== q.nodeType || (h = g + e);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y2 = q.firstChild)) break;
              r2 = q;
              q = y2;
            }
            for (; ; ) {
              if (q === a2) break b;
              r2 === c2 && ++l === e && (h = g);
              r2 === f && ++m === d && (k = g);
              if (null !== (y2 = q.nextSibling)) break;
              q = r2;
              r2 = q.parentNode;
            }
            q = y2;
          }
          c2 = -1 === h || -1 === k ? null : { start: h, end: k };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V2 = b; null !== V2; ) if (b = V2, a2 = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a2) a2.return = b, V2 = a2;
    else for (; null !== V2; ) {
      b = V2;
      try {
        var n2 = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J = n2.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a2 = b.sibling;
      if (null !== a2) {
        a2.return = b.return;
        V2 = a2;
        break;
      }
      V2 = b.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a2, b, c2) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a2) === a2) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c2, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a2, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c2 = b = b.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d = c2.create;
          c2.destroy = d();
        }
        c2 = c2.next;
      } while (c2 !== b);
    }
  }
  function Rj(a2) {
    var b = a2.ref;
    if (null !== b) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b ? b(a2) : b.current = a2;
    }
  }
  function Sj(a2) {
    var b = a2.alternate;
    null !== b && (a2.alternate = null, Sj(b));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b = a2.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b, c2) {
    var d = a2.tag;
    if (5 === d || 6 === d) a2 = a2.stateNode, b ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b) : c2.insertBefore(a2, b) : (8 === c2.nodeType ? (b = c2.parentNode, b.insertBefore(a2, c2)) : (b = c2, b.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a2 = a2.child, null !== a2)) for (Vj(a2, b, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b, c2), a2 = a2.sibling;
  }
  function Wj(a2, b, c2) {
    var d = a2.tag;
    if (5 === d || 6 === d) a2 = a2.stateNode, b ? c2.insertBefore(a2, b) : c2.appendChild(a2);
    else if (4 !== d && (a2 = a2.child, null !== a2)) for (Wj(a2, b, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b, c2), a2 = a2.sibling;
  }
  var X = null, Xj = false;
  function Yj(a2, b, c2) {
    for (c2 = c2.child; null !== c2; ) Zj(a2, b, c2), c2 = c2.sibling;
  }
  function Zj(a2, b, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h) {
    }
    switch (c2.tag) {
      case 5:
        U || Lj(c2, b);
      case 6:
        var d = X, e = Xj;
        X = null;
        Yj(a2, b, c2);
        X = d;
        Xj = e;
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
        break;
      case 4:
        d = X;
        e = Xj;
        X = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b, c2);
        X = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c2.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c2, b, g) : 0 !== (f & 4) && Mj(c2, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a2, b, c2);
        break;
      case 1:
        if (!U && (Lj(c2, b), d = c2.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c2.memoizedProps, d.state = c2.memoizedState, d.componentWillUnmount();
        } catch (h) {
          W(c2, b, h);
        }
        Yj(a2, b, c2);
        break;
      case 21:
        Yj(a2, b, c2);
        break;
      case 22:
        c2.mode & 1 ? (U = (d = U) || null !== c2.memoizedState, Yj(a2, b, c2), U = d) : Yj(a2, b, c2);
        break;
      default:
        Yj(a2, b, c2);
    }
  }
  function ak(a2) {
    var b = a2.updateQueue;
    if (null !== b) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a2, b2);
        c2.has(b2) || (c2.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a2, b) {
    var c2 = b.deletions;
    if (null !== c2) for (var d = 0; d < c2.length; d++) {
      var e = c2[d];
      try {
        var f = a2, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f, g, e);
        X = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a2), b = b.sibling;
  }
  function dk(a2, b) {
    var c2 = a2.alternate, d = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a2);
        ek(a2);
        if (d & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b, a2);
        ek(a2);
        d & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b, a2);
        ek(a2);
        d & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e = a2.stateNode;
          try {
            ob(e, "");
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        if (d & 4 && (e = a2.stateNode, null != e)) {
          var f = a2.memoizedProps, g = null !== c2 ? c2.memoizedProps : f, h = a2.type, k = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k) try {
            "input" === h && "radio" === f.type && null != f.name && ab(e, f);
            vb(h, g);
            var l = vb(h, f);
            for (g = 0; g < k.length; g += 2) {
              var m = k[g], q = k[g + 1];
              "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta2(e, m, q, l);
            }
            switch (h) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y2 = f.value;
                null != y2 ? fb(e, !!f.multiple, y2, false) : r2 !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        ck(b, a2);
        ek(a2);
        if (d & 4) {
          if (null === a2.stateNode) throw Error(p(162));
          e = a2.stateNode;
          f = a2.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b, a2);
        ek(a2);
        if (d & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        break;
      case 4:
        ck(b, a2);
        ek(a2);
        break;
      case 13:
        ck(b, a2);
        ek(a2);
        e = a2.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a2);
        break;
      case 22:
        m = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U = (l = U) || m, ck(b, a2), U = l) : ck(b, a2);
        ek(a2);
        if (d & 8192) {
          l = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l) && !m && 0 !== (a2.mode & 1)) for (V2 = a2, m = a2.child; null !== m; ) {
            for (q = V2 = m; null !== V2; ) {
              r2 = V2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d = r2;
                    c2 = r2.return;
                    try {
                      b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V2 = y2) : gk(q);
            }
            m = m.sibling;
          }
          a: for (m = null, q = a2; ; ) {
            if (5 === q.tag) {
              if (null === m) {
                m = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q.tag) {
              if (null === m) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a2) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a2) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a2) break a;
              m === q && (m = null);
              q = q.return;
            }
            m === q && (m = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a2);
        ek(a2);
        d & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b = a2.flags;
    if (b & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f = Uj(a2);
            Wj(a2, f, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h = Uj(a2);
            Vj(a2, h, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a2, a2.return, k);
      }
      a2.flags &= -3;
    }
    b & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b, c2) {
    V2 = a2;
    ik(a2);
  }
  function ik(a2, b, c2) {
    for (var d = 0 !== (a2.mode & 1); null !== V2; ) {
      var e = V2, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V2 = e; null !== V2; ) g = V2, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V2 = k) : jk(e);
          for (; null !== f; ) V2 = f, ik(f), f = f.sibling;
          V2 = e;
          Jj = h;
          U = l;
        }
        kk(a2);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V2 = f) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V2; ) {
      var b = V2;
      if (0 !== (b.flags & 8772)) {
        var c2 = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c2) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c2.memoizedProps : Ci(b.type, c2.memoizedProps);
                d.componentDidUpdate(e, c2.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c2 = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c2 = b.child.stateNode;
                    break;
                  case 1:
                    c2 = b.child.stateNode;
                }
                sh(b, g, c2);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c2 && b.flags & 4) {
                c2 = h;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c2.focus();
                    break;
                  case "img":
                    k.src && (c2.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m = l.memoizedState;
                  if (null !== m) {
                    var q = m.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r2) {
          W(b, b.return, r2);
        }
      }
      if (b === a2) {
        V2 = null;
        break;
      }
      c2 = b.sibling;
      if (null !== c2) {
        c2.return = b.return;
        V2 = c2;
        break;
      }
      V2 = b.return;
    }
  }
  function gk(a2) {
    for (; null !== V2; ) {
      var b = V2;
      if (b === a2) {
        V2 = null;
        break;
      }
      var c2 = b.sibling;
      if (null !== c2) {
        c2.return = b.return;
        V2 = c2;
        break;
      }
      V2 = b.return;
    }
  }
  function jk(a2) {
    for (; null !== V2; ) {
      var b = V2;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c2, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a2) {
        V2 = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V2 = h;
        break;
      }
      V2 = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk2 = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a2 = C;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi(a2, b, c2, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a2, c2, d);
    if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d), 1 === c2 && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a2, b) {
    var c2 = a2.callbackNode;
    wc(a2, b);
    var d = uc(a2, a2 === Q ? Z : 0);
    if (0 === d) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b = d & -d, a2.callbackPriority !== b) {
      null != c2 && bc(c2);
      if (1 === b) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2) return null;
    var d = uc(a2, a2 === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a2.expiredLanes) || b) b = Ik(a2, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a2 || Z !== b) uk = null, Gj = B() + 500, Kk(a2, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a2, h);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a2), 0 !== e && (d = e, b = Nk(a2, e)));
      if (1 === b) throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
      if (6 === b) Ck(a2, d);
      else {
        e = a2.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a2, d), 2 === b && (f = xc(a2), 0 !== f && (d = f, b = Nk(a2, f))), 1 === b)) throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
        a2.finishedWork = e;
        a2.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a2, tk2, uk);
            break;
          case 3:
            Ck(a2, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a2, 0)) break;
              e = a2.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a2.pingedLanes |= a2.suspendedLanes & e;
                break;
              }
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk2, uk), b);
              break;
            }
            Pk(a2, tk2, uk);
            break;
          case 4:
            Ck(a2, d);
            if ((d & 4194240) === d) break;
            b = a2.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc2(d);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk2, uk), d);
              break;
            }
            Pk(a2, tk2, uk);
            break;
          case 5:
            Pk(a2, tk2, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a2, B());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b).flags |= 256);
    a2 = Ik(a2, b);
    2 !== a2 && (b = tk2, tk2 = c2, null !== b && Fj(b));
    return a2;
  }
  function Fj(a2) {
    null === tk2 ? tk2 = a2 : tk2.push.apply(tk2, a2);
  }
  function Ok(a2) {
    for (var b = a2; ; ) {
      if (b.flags & 16384) {
        var c2 = b.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d = 0; d < c2.length; d++) {
          var e = c2[d], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c2 = b.child;
      if (b.subtreeFlags & 16384 && null !== c2) c2.return = b, b = c2;
      else {
        if (b === a2) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b) {
    b &= ~rk;
    b &= ~qk;
    a2.suspendedLanes |= b;
    a2.pingedLanes &= ~b;
    for (a2 = a2.expirationTimes; 0 < b; ) {
      var c2 = 31 - oc2(b), d = 1 << c2;
      a2[c2] = -1;
      b &= ~d;
    }
  }
  function Ek(a2) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a2, 0);
    if (0 === (b & 1)) return Dk(a2, B()), null;
    var c2 = Ik(a2, b);
    if (0 !== a2.tag && 2 === c2) {
      var d = xc(a2);
      0 !== d && (b = d, c2 = Nk(a2, d));
    }
    if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b), Dk(a2, B()), c2;
    if (6 === c2) throw Error(p(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b;
    Pk(a2, tk2, uk);
    Dk(a2, B());
    return null;
  }
  function Qk(a2, b) {
    var c2 = K;
    K |= 1;
    try {
      return a2(b);
    } finally {
      K = c2, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c2 = ok.transition, d = C;
    try {
      if (ok.transition = null, C = 1, a2) return a2();
    } finally {
      C = d, ok.transition = c2, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a2, b) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y) for (c2 = Y.return; null !== c2; ) {
      var d = c2;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
    Q = a2;
    Y = a2 = Pg(a2.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk2 = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c2 = fh[b], d = c2.interleaved, null !== d) {
        c2.interleaved = null;
        var e = d.next, f = c2.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }
        c2.pending = d;
      }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b) {
    do {
      var c2 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a2, g = c2.return, h = c2, k = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m = h, q = m.tag;
            if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r2 = m.alternate;
              r2 ? (m.updateQueue = r2.updateQueue, m.memoizedState = r2.memoizedState, m.lanes = r2.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y2 = Ui(g);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g, h, f, b);
              y2.mode & 1 && Si(f, l, b);
              b = y2;
              k = l;
              var n2 = b.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k);
                b.updateQueue = t2;
              } else n2.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h, f, b);
              Jg(Ji(k, h));
              break a;
            }
          }
          f = k = Ji(k, h);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x = Ni(f, k, b);
                ph(f, x);
                break a;
              case 1:
                h = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c2);
      } catch (na) {
        b = na;
        Y === c2 && null !== c2 && (Y = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a2, b) {
    var c2 = K;
    K |= 2;
    var d = Jk();
    if (Q !== a2 || Z !== b) uk = null, Kk(a2, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a2, e);
      }
    while (1);
    $g();
    K = c2;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a2) {
    var b = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b ? Sk(a2) : Y = b;
    nk.current = null;
  }
  function Sk(a2) {
    var b = a2;
    do {
      var c2 = b.alternate;
      a2 = b.return;
      if (0 === (b.flags & 32768)) {
        if (c2 = Ej(c2, b, fj), null !== c2) {
          Y = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b);
        if (null !== c2) {
          c2.flags &= 32767;
          Y = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a2;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a2, b, c2) {
    var d = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a2, b, c2, d);
    } finally {
      ok.transition = e, C = d;
    }
    return null;
  }
  function Wk(a2, b, c2, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c2 = a2.finishedWork;
    var e = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f = c2.lanes | c2.childLanes;
    Bc(a2, f);
    a2 === Q && (Y = Q = null, Z = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      hk(c2);
      dc();
      K = h;
      C = g;
      ok.transition = f;
    } else a2.current = c2;
    vk && (vk = false, wk = a2, xk = e);
    f = a2.pendingLanes;
    0 === f && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B());
    if (null !== b) for (d = a2.onRecoverableError, c2 = 0; c2 < b.length; c2++) e = b[c2], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f = a2.pendingLanes;
    0 !== (f & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b = ok.transition, c2 = C;
      try {
        ok.transition = null;
        C = 16 > a2 ? 16 : a2;
        if (null === wk) var d = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V2 = a2.current; null !== V2; ) {
            var f = V2, g = f.child;
            if (0 !== (V2.flags & 16)) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l = h[k];
                  for (V2 = l; null !== V2; ) {
                    var m = V2;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q) q.return = m, V2 = q;
                    else for (; null !== V2; ) {
                      m = V2;
                      var r2 = m.sibling, y2 = m.return;
                      Sj(m);
                      if (m === l) {
                        V2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V2 = r2;
                        break;
                      }
                      V2 = y2;
                    }
                  }
                }
                var n2 = f.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J = t2.sibling;
                      t2.sibling = null;
                      t2 = J;
                    } while (null !== t2);
                  }
                }
                V2 = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V2 = g;
            else b: for (; null !== V2; ) {
              f = V2;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x = f.sibling;
              if (null !== x) {
                x.return = f.return;
                V2 = x;
                break b;
              }
              V2 = f.return;
            }
          }
          var w = a2.current;
          for (V2 = w; null !== V2; ) {
            g = V2;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V2 = u;
            else b: for (g = w; null !== V2; ) {
              h = V2;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V2 = null;
                break b;
              }
              var F = h.sibling;
              if (null !== F) {
                F.return = h.return;
                V2 = F;
                break b;
              }
              V2 = h.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C = c2, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a2, b, c2) {
    b = Ji(c2, b);
    b = Ni(a2, b, 1);
    a2 = nh(a2, b, 1);
    b = R();
    null !== a2 && (Ac(a2, 1, b), Dk(a2, b));
  }
  function W(a2, b, c2) {
    if (3 === a2.tag) Xk(a2, a2, c2);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a2, c2);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b, a2, 1);
          b = nh(b, a2, 1);
          a2 = R();
          null !== b && (Ac(b, 1, a2), Dk(b, a2));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a2, b, c2) {
    var d = a2.pingCache;
    null !== d && d.delete(b);
    b = R();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b);
  }
  function Yk(a2, b) {
    0 === b && (0 === (a2.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R();
    a2 = ih(a2, b);
    null !== a2 && (Ac(a2, b, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b = a2.memoizedState, c2 = 0;
    null !== b && (c2 = b.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d = a2.stateNode;
        var e = a2.memoizedState;
        null !== e && (c2 = e.retryLane);
        break;
      case 19:
        d = a2.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b, c2) {
    if (null !== a2) if (a2.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b.flags & 128)) return dh = false, yj(a2, b, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a2, b);
        a2 = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c2);
        e = Nh(null, b, d, a2, e, c2);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a2, c2), b = jj(null, b, d, true, f, c2)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c2), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a2, b);
          a2 = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a2 = Ci(d, a2);
          switch (e) {
            case 0:
              b = cj(null, b, d, a2, c2);
              break a;
            case 1:
              b = hj(null, b, d, a2, c2);
              break a;
            case 11:
              b = Yi(null, b, d, a2, c2);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a2), c2);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a2, b, d, e, c2);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a2, b, d, e, c2);
      case 3:
        a: {
          kj(b);
          if (null === a2) throw Error(p(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a2, b);
          qh(b, d, null, c2);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a2, b, d, c2, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a2, b, d, c2, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c2 = Vg(b, null, d, c2), b.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a2, b, c2);
              break a;
            }
            Xi(a2, b, d, c2);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a2 && Eg(b), d = b.type, e = b.pendingProps, f = null !== a2 ? a2.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a2, b), Xi(a2, b, g, c2), b.child;
      case 6:
        return null === a2 && Eg(b), null;
      case 13:
        return oj(a2, b, c2);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = Ug(b, null, d, c2) : Xi(a2, b, d, c2), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a2, b, d, e, c2);
      case 7:
        return Xi(a2, b, b.pendingProps, c2), b.child;
      case 8:
        return Xi(a2, b, b.pendingProps.children, c2), b.child;
      case 12:
        return Xi(a2, b, b.pendingProps.children, c2), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a2, b, c2);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h = f.dependencies;
            if (null !== h) {
              g = f.child;
              for (var k = h.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c2 & -c2);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m = l.pending;
                      null === m ? k.next = k : (k.next = m.next, m.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c2;
                  k = f.alternate;
                  null !== k && (k.lanes |= c2);
                  bh(
                    f.return,
                    c2,
                    b
                  );
                  h.lanes |= c2;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c2;
              h = g.alternate;
              null !== h && (h.lanes |= c2);
              bh(g, c2, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a2, b, e.children, c2);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c2), e = eh(e), d = d(e), b.flags |= 1, Xi(a2, b, d, c2), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a2, b, d, e, c2);
      case 15:
        return bj(a2, b, b.type, b.pendingProps, c2);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a2, b), b.tag = 1, Zf(d) ? (a2 = true, cg(b)) : a2 = false, ch(b, c2), Gi(b, d, e), Ii(b, d, e, c2), jj(null, b, d, true, a2, c2);
      case 19:
        return xj(a2, b, c2);
      case 22:
        return dj(a2, b, c2);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a2, b) {
    return ac(a2, b);
  }
  function $k(a2, b, c2, d) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b, c2, d) {
    return new $k(a2, b, c2, d);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga) return 14;
    }
    return 2;
  }
  function Pg(a2, b) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b = a2.dependencies;
    c2.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b, c2, d, e, f) {
    var g = 2;
    d = a2;
    if ("function" === typeof a2) aj(a2) && (g = 1);
    else if ("string" === typeof a2) g = 5;
    else a: switch (a2) {
      case ya:
        return Tg(c2.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a2 = Bg(12, c2, b, e | 2), a2.elementType = Aa, a2.lanes = f, a2;
      case Ea:
        return a2 = Bg(13, c2, b, e), a2.elementType = Ea, a2.lanes = f, a2;
      case Fa:
        return a2 = Bg(19, c2, b, e), a2.elementType = Fa, a2.lanes = f, a2;
      case Ia:
        return pj(c2, e, f, b);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a2 ? a2 : typeof a2, ""));
    }
    b = Bg(g, c2, b, e);
    b.elementType = a2;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a2, b, c2, d) {
    a2 = Bg(7, a2, d, b);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b, c2, d) {
    a2 = Bg(22, a2, d, b);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b, c2) {
    a2 = Bg(6, a2, null, b);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b, c2) {
    b = Bg(4, null !== a2.children ? a2.children : [], a2.key, b);
    b.lanes = c2;
    b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b;
  }
  function al(a2, b, c2, d, e) {
    this.tag = b;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b, c2, d, e, f, g, h, k) {
    a2 = new al(a2, b, c2, h, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a2.current = f;
    f.stateNode = a2;
    f.memoizedState = { element: d, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a2;
  }
  function cl(a2, b, c2) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a2, containerInfo: b, implementation: c2 };
  }
  function dl(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p(170));
      var b = a2;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b);
    }
    return b;
  }
  function el(a2, b, c2, d, e, f, g, h, k) {
    a2 = bl(c2, d, true, a2, e, f, g, h, k);
    a2.context = dl(null);
    c2 = a2.current;
    d = R();
    e = yi(c2);
    f = mh(d, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c2, f, e);
    a2.current.lanes = e;
    Ac(a2, e, d);
    Dk(a2, d);
    return a2;
  }
  function fl(a2, b, c2, d) {
    var e = b.current, f = R(), g = yi(e);
    c2 = dl(c2);
    null === b.context ? b.context = c2 : b.pendingContext = c2;
    b = mh(f, g);
    b.payload = { element: a2 };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a2 = nh(e, b, g);
    null !== a2 && (gi(a2, e, g, f), oh(a2, e, g));
    return g;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b ? c2 : b;
    }
  }
  function il(a2, b) {
    hl(a2, b);
    (a2 = a2.alternate) && hl(a2, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a2, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b = Hc();
      a2 = { blockedOn: null, target: a2, priority: b };
      for (var c2 = 0; c2 < Qc.length && 0 !== b && b < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b, c2, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a3 = gl(g);
          f.call(a3);
        };
      }
      var g = el(b, d, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g;
      a2[uf] = g.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g;
    }
    for (; e = a2.lastChild; ) a2.removeChild(e);
    if ("function" === typeof d) {
      var h = d;
      d = function() {
        var a3 = gl(k);
        h.call(a3);
      };
    }
    var k = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k;
    a2[uf] = k.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b, k, c2, d);
    });
    return k;
  }
  function rl(a2, b, c2, d, e) {
    var f = c2._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h = e;
        e = function() {
          var a3 = gl(g);
          h.call(a3);
        };
      }
      fl(b, g, a2, e);
    } else g = ql(c2, b, a2, e, d);
    return gl(g);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b = a2.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c2 = tc(b.pendingLanes);
          0 !== c2 && (Cc(b, c2 | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a2, 1);
          if (null !== b2) {
            var c3 = R();
            gi(b2, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b = ih(a2, 134217728);
      if (null !== b) {
        var c2 = R();
        gi(b, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b = yi(a2), c2 = ih(a2, b);
      if (null !== c2) {
        var d = R();
        gi(c2, a2, b, d);
      }
      il(a2, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a2, b) {
    var c2 = C;
    try {
      return C = a2, b();
    } finally {
      C = c2;
    }
  };
  yb = function(a2, b, c2) {
    switch (b) {
      case "input":
        bb(a2, c2);
        b = c2.name;
        if ("radio" === c2.type && null != b) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c2.length; b++) {
            var d = c2[b];
            if (d !== a2 && d.form === a2.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b = c2.value, null != b && fb(a2, !!c2.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a2, b, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b) {
    if (!nl(a2)) throw Error(p(299));
    var c2 = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c2 = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a2, 1, false, null, null, c2, false, d, e);
    a2[uf] = b.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b = a2._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a2.render) throw Error(p(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p(268, a2));
    }
    a2 = Zb(b);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b, c2) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a2, b, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b, c2) {
    if (!nl(a2)) throw Error(p(405));
    var d = null != c2 && c2.hydratedSources || null, e = false, f = "", g = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e = true), void 0 !== c2.identifierPrefix && (f = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g = c2.onRecoverableError));
    b = el(b, null, a2, 1, null != c2 ? c2 : null, e, false, f, g);
    a2[uf] = b.current;
    sf(a2);
    if (d) for (a2 = 0; a2 < d.length; a2++) c2 = d[a2], e = c2._getVersion, e = e(c2._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c2, e] : b.mutableSourceEagerHydrationData.push(
      c2,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a2, b, c2) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a2, b, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2)) throw Error(p(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c2, d) {
    if (!ol(c2)) throw Error(p(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p(38));
    return rl(a2, b, c2, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var client = {};
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m = requireReactDom();
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
function fetchCache(cb, init2) {
  const cache = /* @__PURE__ */ new Map();
  return async function fetchCached(url) {
    const existing = cache.get(url);
    if (existing) return existing;
    const promise = (async () => {
      try {
        const response = await fetch$1(url, init2);
        assert(response.ok);
        return await cb(response);
      } catch (err) {
        console.error(err);
        return null;
      }
    })();
    cache.set(url, promise);
    return promise;
  };
}
const resourceToDataUrl = fetchCache(async (response) => {
  return await FileHelpers.blobToDataUrl(await response.blob());
});
const importsRegex = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi;
const fontFaceRegex = /@font-face\s*{([^}]+)}/gi;
const urlsRegex = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi;
const fontFamilyRegex = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function parseCssImports(css) {
  return Array.from(css.matchAll(importsRegex), (m) => ({
    url: m[1] || m[2] || m[3] || m[4] || m[5],
    extras: m[6]
  }));
}
function parseCssFontFaces(css, baseUrl) {
  return Array.from(css.matchAll(fontFaceRegex), (m) => {
    const fontFace = m[1];
    const urls = Array.from(fontFace.matchAll(urlsRegex), (m2) => {
      const original = m2[1] || m2[2] || m2[3];
      return {
        original,
        resolved: safeParseUrl(original, baseUrl)?.href ?? null
      };
    });
    const fontFamilies = new Set(
      Array.from(fontFace.matchAll(fontFamilyRegex), (m2) => (m2[1] || m2[2] || m2[3]).toLowerCase())
    );
    return { fontFace, urls, fontFamilies };
  });
}
function parseCssFontFamilyValue(value) {
  const valueRegex = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi;
  const separatorRegex = /\s*,\s*/gi;
  const fontFamilies = /* @__PURE__ */ new Set();
  while (true) {
    const valueMatch = valueRegex.exec(value);
    if (!valueMatch) {
      break;
    }
    const fontFamily = valueMatch[1] || valueMatch[2] || valueMatch[3];
    fontFamilies.add(fontFamily.toLowerCase());
    separatorRegex.lastIndex = valueRegex.lastIndex;
    const separatorMatch = separatorRegex.exec(value);
    if (!separatorMatch) {
      break;
    }
    valueRegex.lastIndex = separatorRegex.lastIndex;
  }
  return fontFamilies;
}
function shouldIncludeCssProperty(property) {
  if (property.startsWith("-")) return false;
  if (property.startsWith("animation")) return false;
  if (property.startsWith("transition")) return false;
  if (property === "cursor") return false;
  if (property === "pointer-events") return false;
  if (property === "user-select") return false;
  if (property === "touch-action") return false;
  return true;
}
function parseCss(css, baseUrl) {
  return {
    imports: parseCssImports(css),
    fontFaces: parseCssFontFaces(css, baseUrl)
  };
}
function parseCssValueUrls(value) {
  return Array.from(value.matchAll(urlsRegex), (m) => ({
    original: m[0],
    url: m[1] || m[2] || m[3]
  }));
}
var __create$b = Object.create;
var __defProp$b = Object.defineProperty;
var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
var __knownSymbol$b = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$b = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$b = (base2) => [, , , __create$b(null)];
var __decoratorStrings$b = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$b = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$b("Function expected") : fn;
var __decoratorContext$b = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$b[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$b("Already initialized") : fns.push(__expectFn$b(fn || null)) });
var __decoratorMetadata$b = (array2, target) => __defNormalProp$b(target, __knownSymbol$b("metadata"), array2[3]);
var __runInitializers$b = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$b = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$b[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$b(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$b(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$b(it) && (desc[key] = it);
  }
  return desc && __defProp$b(target, name, desc), target;
};
var __publicField$b = (obj, key, value) => __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
var _onFontFamilyValue_dec, _init$b;
const SVG_EXPORT_CLASSNAME = "tldraw-svg-export";
_onFontFamilyValue_dec = [bind$1];
class FontEmbedder {
  constructor() {
    __runInitializers$b(_init$b, 5, this);
    __publicField$b(this, "fontFacesPromise", null);
    __publicField$b(this, "foundFontNames", /* @__PURE__ */ new Set());
    __publicField$b(this, "fontFacesToEmbed", /* @__PURE__ */ new Set());
    __publicField$b(this, "pendingPromises", []);
  }
  startFindingCurrentDocumentFontFaces() {
    assert(!this.fontFacesPromise, "FontEmbedder already started");
    this.fontFacesPromise = getCurrentDocumentFontFaces();
  }
  onFontFamilyValue(fontFamilyValue) {
    assert(this.fontFacesPromise, "FontEmbedder not started");
    const fonts = parseCssFontFamilyValue(fontFamilyValue);
    for (const font of fonts) {
      if (this.foundFontNames.has(font)) return;
      this.foundFontNames.add(font);
      this.pendingPromises.push(
        this.fontFacesPromise.then((fontFaces) => {
          const relevantFontFaces = fontFaces.filter((fontFace) => fontFace.fontFamilies.has(font));
          for (const fontFace of relevantFontFaces) {
            if (this.fontFacesToEmbed.has(fontFace)) continue;
            this.fontFacesToEmbed.add(fontFace);
            for (const url of fontFace.urls) {
              if (!url.resolved || url.embedded) continue;
              url.embedded = resourceToDataUrl(url.resolved);
            }
          }
        })
      );
    }
  }
  async createCss() {
    await Promise.all(this.pendingPromises);
    let css = "";
    for (const fontFace of this.fontFacesToEmbed) {
      let fontFaceString = `@font-face {${fontFace.fontFace}}`;
      for (const url of fontFace.urls) {
        if (!url.embedded) continue;
        const dataUrl = await url.embedded;
        if (!dataUrl) continue;
        fontFaceString = fontFaceString.replace(url.original, dataUrl);
      }
      css += fontFaceString;
    }
    return css;
  }
}
_init$b = __decoratorStart$b();
__decorateElement$b(_init$b, 1, "onFontFamilyValue", _onFontFamilyValue_dec, FontEmbedder);
__decoratorMetadata$b(_init$b, FontEmbedder);
async function getCurrentDocumentFontFaces() {
  const fontFaces = [];
  const styleSheetsWithoutSvgExports = Array.from(document.styleSheets).filter(
    (styleSheet) => !styleSheet.ownerNode?.closest(`.${SVG_EXPORT_CLASSNAME}`)
  );
  for (const styleSheet of styleSheetsWithoutSvgExports) {
    let cssRules2;
    try {
      cssRules2 = styleSheet.cssRules;
    } catch {
    }
    if (cssRules2) {
      for (const rule of styleSheet.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          fontFaces.push(parseCssFontFaces(rule.cssText, styleSheet.href ?? document.baseURI));
        } else if (rule instanceof CSSImportRule) {
          const absoluteUrl = new URL(rule.href, rule.parentStyleSheet?.href ?? document.baseURI);
          fontFaces.push(fetchCssFontFaces(absoluteUrl.href));
        }
      }
    } else if (styleSheet.href) {
      fontFaces.push(fetchCssFontFaces(styleSheet.href));
    }
  }
  return compact$1(await Promise.all(fontFaces)).flat();
}
const fetchCssFontFaces = fetchCache(async (response) => {
  const parsed = parseCss(await response.text(), response.url);
  const importedFontFaces = await Promise.all(
    parsed.imports.map(({ url }) => fetchCssFontFaces(new URL(url, response.url).href))
  );
  return [...parsed.fontFaces, ...compact$1(importedFontFaces).flat()];
});
const isCoveredByCurrentColor = (value, property, { currentColor }) => {
  return value === "currentColor" || value === currentColor;
};
const isInherited = (value, property, { parentStyles }) => {
  return parentStyles[property] === value;
};
const isExcludedBorder = (borderDirection) => (value, property, { getStyle }) => {
  const borderWidth = getStyle(`border-${borderDirection}-width`);
  const borderStyle = getStyle(`border-${borderDirection}-style`);
  if (borderWidth === "0px") return true;
  if (borderStyle === "none") return true;
  return false;
};
const cssRules = {
  // currentColor properties:
  "border-block-end-color": isCoveredByCurrentColor,
  "border-block-start-color": isCoveredByCurrentColor,
  "border-bottom-color": isCoveredByCurrentColor,
  "border-inline-end-color": isCoveredByCurrentColor,
  "border-inline-start-color": isCoveredByCurrentColor,
  "border-left-color": isCoveredByCurrentColor,
  "border-right-color": isCoveredByCurrentColor,
  "border-top-color": isCoveredByCurrentColor,
  "caret-color": isCoveredByCurrentColor,
  "column-rule-color": isCoveredByCurrentColor,
  "outline-color": isCoveredByCurrentColor,
  "text-decoration": (value, property, { currentColor }) => {
    return value === "none solid currentColor" || value === "none solid " + currentColor;
  },
  "text-decoration-color": isCoveredByCurrentColor,
  "text-emphasis-color": isCoveredByCurrentColor,
  // inherited properties:
  "border-collapse": isInherited,
  "border-spacing": isInherited,
  "caption-side": isInherited,
  // N.B. We shouldn't inherit 'color' because there's some UA styling, e.g. `mark` elements
  // 'color': isInherited,
  cursor: isInherited,
  direction: isInherited,
  "empty-cells": isInherited,
  "font-family": isInherited,
  "font-size": isInherited,
  "font-style": isInherited,
  "font-variant": isInherited,
  "font-weight": isInherited,
  "font-size-adjust": isInherited,
  "font-stretch": isInherited,
  font: isInherited,
  "letter-spacing": isInherited,
  "line-height": isInherited,
  "list-style-image": isInherited,
  "list-style-position": isInherited,
  "list-style-type": isInherited,
  "list-style": isInherited,
  orphans: isInherited,
  "overflow-wrap": isInherited,
  quotes: isInherited,
  "stroke-linecap": isInherited,
  "stroke-linejoin": isInherited,
  "tab-size": isInherited,
  "text-align": isInherited,
  "text-align-last": isInherited,
  "text-indent": isInherited,
  "text-justify": isInherited,
  "text-shadow": isInherited,
  "text-transform": isInherited,
  visibility: isInherited,
  "white-space": isInherited,
  "white-space-collapse": isInherited,
  widows: isInherited,
  "word-break": isInherited,
  "word-spacing": isInherited,
  "word-wrap": isInherited,
  // special border cases - we have a weird case (tailwind seems to trigger this) where all
  // border-styles sometimes get set to 'solid', but the border-width is 0 so they don't render.
  // but in SVGs, **sometimes**, the border-width defaults (i think from a UA style-sheet? but
  // honestly can't tell) to 1.5px so the border displays. we work around this by only including
  // border styles at all if both the border-width and border-style are set to something that
  // would show a border.
  "border-top": isExcludedBorder("top"),
  "border-right": isExcludedBorder("right"),
  "border-bottom": isExcludedBorder("bottom"),
  "border-left": isExcludedBorder("left"),
  "border-block-end": isExcludedBorder("block-end"),
  "border-block-start": isExcludedBorder("block-start"),
  "border-inline-end": isExcludedBorder("inline-end"),
  "border-inline-start": isExcludedBorder("inline-start"),
  "border-top-style": isExcludedBorder("top"),
  "border-right-style": isExcludedBorder("right"),
  "border-bottom-style": isExcludedBorder("bottom"),
  "border-left-style": isExcludedBorder("left"),
  "border-block-end-style": isExcludedBorder("block-end"),
  "border-block-start-style": isExcludedBorder("block-start"),
  "border-inline-end-style": isExcludedBorder("inline-end"),
  "border-inline-start-style": isExcludedBorder("inline-start"),
  "border-top-width": isExcludedBorder("top"),
  "border-right-width": isExcludedBorder("right"),
  "border-bottom-width": isExcludedBorder("bottom"),
  "border-left-width": isExcludedBorder("left"),
  "border-block-end-width": isExcludedBorder("block-end"),
  "border-block-start-width": isExcludedBorder("block-start"),
  "border-inline-end-width": isExcludedBorder("inline-end")
};
function getRenderedChildNodes(node) {
  if (node.shadowRoot) {
    return node.shadowRoot.childNodes;
  }
  if (isShadowSlotElement(node)) {
    const assignedNodes = node.assignedNodes();
    if (assignedNodes?.length) {
      return assignedNodes;
    }
  }
  return node.childNodes;
}
function* getRenderedChildren(node) {
  for (const child of getRenderedChildNodes(node)) {
    if (isElement$1(child)) yield child;
  }
}
function getWindow$1(node) {
  return node.ownerDocument?.defaultView ?? globalThis;
}
function isElement$1(node) {
  return node instanceof getWindow$1(node).Element;
}
function isShadowRoot$1(node) {
  return node instanceof getWindow$1(node).ShadowRoot;
}
function isInShadowRoot(node) {
  return "getRootNode" in node && isShadowRoot$1(node.getRootNode());
}
function isShadowSlotElement(node) {
  return isInShadowRoot(node) && node instanceof getWindow$1(node).HTMLSlotElement;
}
function elementStyle(element) {
  return element.style;
}
function getComputedStyle$2(element, pseudoElement) {
  return getWindow$1(element).getComputedStyle(element, pseudoElement);
}
const NO_STYLES = {};
class StyleEmbedder {
  constructor(root) {
    this.root = root;
  }
  styles = /* @__PURE__ */ new Map();
  fonts = new FontEmbedder();
  readRootElementStyles(rootElement) {
    this.readElementStyles(rootElement, {
      shouldRespectDefaults: false,
      shouldSkipInheritedParentStyles: false
    });
    const children = Array.from(getRenderedChildren(rootElement));
    while (children.length) {
      const child = children.pop();
      children.push(...getRenderedChildren(child));
      this.readElementStyles(child, {
        shouldRespectDefaults: true,
        shouldSkipInheritedParentStyles: true
      });
    }
  }
  readElementStyles(element, { shouldRespectDefaults = true, shouldSkipInheritedParentStyles = true }) {
    const defaultStyles = shouldRespectDefaults ? getDefaultStylesForTagName(element.tagName.toLowerCase()) : NO_STYLES;
    const parentStyles = Object.assign({}, NO_STYLES);
    if (shouldSkipInheritedParentStyles) {
      let el = element.parentElement;
      while (el) {
        const currentStyles = this.styles.get(el)?.self;
        for (const style2 in currentStyles) {
          if (!parentStyles[style2]) {
            parentStyles[style2] = currentStyles[style2];
          }
        }
        el = el.parentElement;
      }
    }
    const info = {
      self: styleFromElement(element, { defaultStyles, parentStyles }),
      before: styleFromPseudoElement(element, "::before"),
      after: styleFromPseudoElement(element, "::after")
    };
    this.styles.set(element, info);
  }
  fetchResources() {
    const promises = [];
    for (const info of this.styles.values()) {
      for (const styles of objectMapValues(info)) {
        if (!styles) continue;
        for (const [property, value] of Object.entries(styles)) {
          if (!value) continue;
          if (property === "font-family") {
            this.fonts.onFontFamilyValue(value);
          }
          const urlMatches = parseCssValueUrls(value);
          if (urlMatches.length === 0) continue;
          promises.push(
            ...urlMatches.map(async ({ url, original }) => {
              const dataUrl = await resourceToDataUrl(url) ?? "data:";
              styles[property] = value.replace(original, `url("${dataUrl}")`);
            })
          );
        }
      }
    }
    return Promise.all(promises);
  }
  // custom elements are tricky. if we serialize the dom as-is, the custom elements wont have
  // their shadow-dom contents serialized. after we've read all the styles, we need to unwrap the
  // contents of each custom elements shadow dom directly into the parent element itself.
  unwrapCustomElements() {
    const visited = /* @__PURE__ */ new Set();
    const visit = (element, clonedParent) => {
      if (visited.has(element)) return;
      visited.add(element);
      const shadowRoot = element.shadowRoot;
      if (shadowRoot) {
        const clonedCustomEl = document.createElement("div");
        this.styles.set(clonedCustomEl, this.styles.get(element));
        clonedCustomEl.setAttribute("data-tl-custom-element", element.tagName);
        (clonedParent ?? element.parentElement).appendChild(clonedCustomEl);
        for (const child of shadowRoot.childNodes) {
          if (child instanceof Element) {
            visit(child, clonedCustomEl);
          } else {
            clonedCustomEl.appendChild(child.cloneNode(true));
          }
        }
        element.remove();
      } else if (clonedParent) {
        if (element.tagName.toLowerCase() === "style") {
          return;
        }
        const clonedEl = element.cloneNode(false);
        this.styles.set(clonedEl, this.styles.get(element));
        clonedParent.appendChild(clonedEl);
        for (const child of getRenderedChildNodes(element)) {
          if (child instanceof Element) {
            visit(child, clonedEl);
          } else {
            clonedEl.appendChild(child.cloneNode(true));
          }
        }
      }
    };
    for (const element of this.styles.keys()) {
      visit(element, null);
    }
  }
  embedStyles() {
    let css = "";
    for (const [element, info] of this.styles) {
      if (info.after || info.before) {
        const className = `pseudo-${uniqueId()}`;
        element.classList.add(className);
        if (info.before) {
          css += `.${className}::before {${formatCss(info.before)}}
`;
        }
        if (info.after) {
          css += `.${className}::after {${formatCss(info.after)}}
`;
        }
      }
      const style2 = elementStyle(element);
      for (const [property, value] of Object.entries(info.self)) {
        if (!value) continue;
        style2.setProperty(property, value);
      }
      if (style2.fontKerning === "auto") {
        style2.fontKerning = "normal";
      }
    }
    return css;
  }
  async getFontFaceCss() {
    return await this.fonts.createCss();
  }
  dispose() {
    destroyDefaultStyleFrame();
  }
}
function styleFromElement(element, { defaultStyles, parentStyles }) {
  if (element.computedStyleMap) {
    return styleFromComputedStyleMap(element.computedStyleMap(), { defaultStyles, parentStyles });
  }
  return styleFromComputedStyle(getComputedStyle$2(element), { defaultStyles, parentStyles });
}
function styleFromPseudoElement(element, pseudo) {
  const style2 = getComputedStyle$2(element, pseudo);
  const content = style2.getPropertyValue("content");
  if (content === "" || content === "none") {
    return void 0;
  }
  return styleFromComputedStyle(style2, { defaultStyles: NO_STYLES, parentStyles: NO_STYLES });
}
function styleFromComputedStyleMap(style2, { defaultStyles, parentStyles }) {
  const styles = {};
  const currentColor = style2.get("color")?.toString() || "";
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => style2.get(property)?.toString() ?? ""
  };
  for (const property of style2.keys()) {
    if (!shouldIncludeCssProperty(property)) continue;
    const value = style2.get(property).toString();
    if (defaultStyles[property] === value) continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions)) continue;
    styles[property] = value;
  }
  return styles;
}
function styleFromComputedStyle(style2, { defaultStyles, parentStyles }) {
  const styles = {};
  const currentColor = style2.color;
  const ruleOptions = {
    currentColor,
    parentStyles,
    defaultStyles,
    getStyle: (property) => style2.getPropertyValue(property)
  };
  for (const property in style2) {
    if (!shouldIncludeCssProperty(property)) continue;
    const value = style2.getPropertyValue(property);
    if (defaultStyles[property] === value) continue;
    const rule = getOwnProperty(cssRules, property);
    if (rule && rule(value, property, ruleOptions)) continue;
    styles[property] = value;
  }
  return styles;
}
function formatCss(style2) {
  let cssText = "";
  for (const [property, value] of Object.entries(style2)) {
    cssText += `${property}: ${value};`;
  }
  return cssText;
}
let defaultStyleFrame;
const defaultStylesByTagName = {};
function getDefaultStyleFrame() {
  if (!defaultStyleFrame) {
    const frame2 = document.createElement("iframe");
    frame2.style.display = "none";
    document.body.appendChild(frame2);
    const frameDocument = assertExists(frame2.contentDocument, "frame must have a document");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    svg.appendChild(foreignObject);
    frameDocument.body.appendChild(svg);
    defaultStyleFrame = { iframe: frame2, foreignObject, document: frameDocument };
  }
  return defaultStyleFrame;
}
function destroyDefaultStyleFrame() {
  if (defaultStyleFrame) {
    document.body.removeChild(defaultStyleFrame.iframe);
    defaultStyleFrame = void 0;
  }
}
const defaultStyleReadOptions = { defaultStyles: NO_STYLES, parentStyles: NO_STYLES };
function getDefaultStylesForTagName(tagName) {
  let existing = defaultStylesByTagName[tagName];
  if (!existing) {
    const { foreignObject, document: document2 } = getDefaultStyleFrame();
    const element = document2.createElement(tagName);
    foreignObject.appendChild(element);
    existing = element.computedStyleMap ? styleFromComputedStyleMap(element.computedStyleMap(), defaultStyleReadOptions) : styleFromComputedStyle(getComputedStyle$2(element), defaultStyleReadOptions);
    foreignObject.removeChild(element);
    defaultStylesByTagName[tagName] = existing;
  }
  return existing;
}
function copyAttrs(source, target) {
  const attrs = Array.from(source.attributes);
  attrs.forEach((attr) => {
    target.setAttribute(attr.name, attr.value);
  });
}
function replace$1(original, replacement) {
  original.replaceWith(replacement);
  return replacement;
}
async function createImage(dataUrl, cloneAttributesFrom) {
  const image = document.createElement("img");
  if (cloneAttributesFrom) {
    copyAttrs(cloneAttributesFrom, image);
  }
  image.setAttribute("src", dataUrl ?? "data:");
  image.setAttribute("decoding", "sync");
  image.setAttribute("loading", "eager");
  try {
    await image.decode();
  } catch {
  }
  return image;
}
async function getCanvasReplacement(canvas) {
  try {
    const dataURL = canvas.toDataURL();
    return await createImage(dataURL, canvas);
  } catch {
    return await createImage(null, canvas);
  }
}
async function getVideoReplacement(video) {
  try {
    const dataUrl = await MediaHelpers.getVideoFrameAsDataUrl(video);
    return createImage(dataUrl, video);
  } catch (err) {
    console.error("Could not get video frame", err);
  }
  if (video.poster) {
    const dataUrl = await resourceToDataUrl(video.poster);
    return createImage(dataUrl, video);
  }
  return createImage(null, video);
}
async function embedMedia(node) {
  if (node instanceof HTMLCanvasElement) {
    return replace$1(node, await getCanvasReplacement(node));
  } else if (node instanceof HTMLVideoElement) {
    return replace$1(node, await getVideoReplacement(node));
  } else if (node instanceof HTMLImageElement) {
    const src = node.currentSrc || node.src;
    const dataUrl = await resourceToDataUrl(src);
    node.setAttribute("src", dataUrl ?? "data:");
    node.setAttribute("decoding", "sync");
    node.setAttribute("loading", "eager");
    try {
      await node.decode();
    } catch {
    }
    return node;
  } else if (node instanceof HTMLInputElement) {
    node.setAttribute("value", node.value);
  } else if (node instanceof HTMLTextAreaElement) {
    node.textContent = node.value;
  }
  await Promise.all(
    Array.from(getRenderedChildren(node), (child) => embedMedia(child))
  );
}
function useEvent(handler) {
  const handlerRef = reactExports.useRef();
  reactExports.useLayoutEffect(() => {
    handlerRef.current = handler;
  });
  reactExports.useDebugValue(handler);
  return reactExports.useCallback((...args) => {
    const fn = handlerRef.current;
    assert(fn, "fn does not exist");
    return fn(...args);
  }, []);
}
const Context = reactExports.createContext(null);
function SvgExportContextProvider({
  context,
  editor,
  children
}) {
  const Provider2 = editor.options.exportProvider;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { editor, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerProvider, { container: editor.getContainer(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value: context, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider2, { children }) }) }) });
}
function useSvgExportContext() {
  return reactExports.useContext(Context);
}
function useDelaySvgExport() {
  const ctx = reactExports.useContext(Context);
  const [promise] = reactExports.useState(promiseWithResolve);
  reactExports.useEffect(() => {
    ctx?.waitUntil(promise);
    return () => {
      promise.resolve();
    };
  }, [promise, ctx]);
  return useEvent(() => {
    promise.resolve();
  });
}
var __create$a = Object.create;
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __knownSymbol$a = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$a = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$a = (base2) => [, , , __create$a(null)];
var __decoratorStrings$a = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$a = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$a("Function expected") : fn;
var __decoratorContext$a = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$a[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$a("Already initialized") : fns.push(__expectFn$a(fn || null)) });
var __decoratorMetadata$a = (array2, target) => __defNormalProp$a(target, __knownSymbol$a("metadata"), array2[3]);
var __runInitializers$a = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$a = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$a[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$a(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$a(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$a(it) && (desc[key] = it);
  }
  return desc && __defProp$a(target, name, desc), target;
};
var __publicField$a = (obj, key, value) => __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
var _waitUntil_dec, _init$a;
_waitUntil_dec = [bind$1];
class ExportDelay {
  constructor(maxDelayTimeMs) {
    this.maxDelayTimeMs = maxDelayTimeMs;
    __runInitializers$a(_init$a, 5, this);
    __publicField$a(this, "isResolved", false);
    __publicField$a(this, "promisesToWaitFor", []);
  }
  waitUntil(promise) {
    if (this.isResolved) {
      throw new Error(
        "Cannot `waitUntil` - the export has already been resolved. Make sure to call `waitUntil` as soon as possible during an export - ie within the first react effect after rendering."
      );
    }
    this.promisesToWaitFor.push(
      promise.catch((err) => console.error("Error while waiting for export:", err))
    );
  }
  async resolvePromises() {
    let lastLength = null;
    while (this.promisesToWaitFor.length !== lastLength) {
      lastLength = this.promisesToWaitFor.length;
      await Promise.allSettled(this.promisesToWaitFor);
      await sleep(0);
    }
  }
  async resolve() {
    const timeoutPromise = sleep(this.maxDelayTimeMs).then(() => "timeout");
    const resolvePromise = this.resolvePromises().then(() => "resolved");
    const result = await Promise.race([timeoutPromise, resolvePromise]);
    if (result === "timeout") {
      console.warn("[tldraw] Export delay timed out after ${this.maxDelayTimeMs}ms");
    }
    this.isResolved = true;
  }
}
_init$a = __decoratorStart$a();
__decorateElement$a(_init$a, 1, "waitUntil", _waitUntil_dec, ExportDelay);
__decoratorMetadata$a(_init$a, ExportDelay);
function getSvgJsx(editor, ids, opts = {}) {
  if (!window.document) throw Error("No document");
  const {
    scale = 1,
    // should we include the background in the export? or is it transparent?
    background = editor.getInstanceState().exportBackground,
    padding = editor.options.defaultSvgPadding,
    preserveAspectRatio
  } = opts;
  const isDarkMode = opts.darkMode ?? editor.user.getIsDarkMode();
  const shapeIdsToInclude = editor.getShapeAndDescendantIds(ids);
  const renderingShapes = editor.getUnorderedRenderingShapes(false).filter(({ id }) => shapeIdsToInclude.has(id));
  let bbox = null;
  if (opts.bounds) {
    bbox = opts.bounds;
  } else {
    for (const { id } of renderingShapes) {
      const maskedPageBounds = editor.getShapeMaskedPageBounds(id);
      if (!maskedPageBounds) continue;
      if (bbox) {
        bbox.union(maskedPageBounds);
      } else {
        bbox = maskedPageBounds.clone();
      }
    }
  }
  if (!bbox) return;
  const singleFrameShapeId = ids.length === 1 && editor.isShapeOfType(editor.getShape(ids[0]), "frame") ? ids[0] : null;
  if (!singleFrameShapeId) {
    bbox.expandBy(padding);
  }
  const w = bbox.width * scale;
  const h = bbox.height * scale;
  try {
    document.body.focus?.();
  } catch {
  }
  const exportDelay = new ExportDelay(editor.options.maxExportDelayMs);
  const initialEffectPromise = promiseWithResolve();
  exportDelay.waitUntil(initialEffectPromise);
  const svg = /* @__PURE__ */ jsxRuntimeExports.jsx(
    SvgExport,
    {
      editor,
      preserveAspectRatio,
      scale,
      pixelRatio: opts.pixelRatio ?? null,
      bbox,
      background,
      singleFrameShapeId,
      isDarkMode,
      renderingShapes,
      onMount: initialEffectPromise.resolve,
      waitUntil: exportDelay.waitUntil
    }
  );
  return { jsx: svg, width: w, height: h, exportDelay };
}
function SvgExport({
  editor,
  preserveAspectRatio,
  scale,
  pixelRatio,
  bbox,
  background,
  singleFrameShapeId,
  isDarkMode,
  renderingShapes,
  onMount,
  waitUntil
}) {
  const masksId = useUniqueSafeId();
  const theme = getDefaultColorTheme({ isDarkMode });
  const stateAtom = useAtom("export state", { defsById: {}, shapeElements: null });
  const { defsById, shapeElements } = useValue(stateAtom);
  const addExportDef = useEvent((def) => {
    stateAtom.update((state) => {
      if (hasOwnProperty(state.defsById, def.key)) return state;
      const promise = Promise.resolve(def.getElement());
      waitUntil(
        promise.then((result) => {
          stateAtom.update((state2) => ({
            ...state2,
            defsById: { ...state2.defsById, [def.key]: { pending: false, element: result } }
          }));
        })
      );
      return {
        ...state,
        defsById: { ...state.defsById, [def.key]: { pending: true, element: promise } }
      };
    });
  });
  const exportContext = reactExports.useMemo(
    () => ({
      isDarkMode,
      waitUntil,
      addExportDef,
      scale,
      pixelRatio,
      async resolveAssetUrl(assetId, width) {
        const asset = editor.getAsset(assetId);
        if (!asset || asset.type !== "image" && asset.type !== "video") return null;
        return await editor.resolveAssetUrl(assetId, {
          screenScale: scale * (width / asset.props.w),
          shouldResolveToOriginal: pixelRatio === null,
          dpr: pixelRatio ?? void 0
        });
      }
    }),
    [isDarkMode, waitUntil, addExportDef, scale, pixelRatio, editor]
  );
  const didRenderRef = reactExports.useRef(false);
  reactExports.useLayoutEffect(() => {
    if (didRenderRef.current) {
      throw new Error("SvgExport should only render once - do not use with react strict mode");
    }
    didRenderRef.current = true;
    (async () => {
      const shapeDefs = {};
      const unorderedShapeElementPromises = renderingShapes.map(
        async ({ id, opacity, index: index2, backgroundIndex }) => {
          if (id === singleFrameShapeId) return [];
          const shape = editor.getShape(id);
          if (editor.isShapeOfType(shape, "group")) return [];
          const elements = [];
          const util2 = editor.getShapeUtil(shape);
          if (util2.toSvg || util2.toBackgroundSvg) {
            const [toSvgResult, toBackgroundSvgResult] = await Promise.all([
              util2.toSvg?.(shape, exportContext),
              util2.toBackgroundSvg?.(shape, exportContext)
            ]);
            const pageTransform = editor.getShapePageTransform(shape);
            let pageTransformString = pageTransform.toCssString();
            let scale2 = 1;
            if ("scale" in shape.props) {
              if (shape.props.scale !== 1) {
                scale2 = shape.props.scale;
                pageTransformString = `${pageTransformString} scale(${shape.props.scale}, ${shape.props.scale})`;
              }
            }
            const pageMask = editor.getShapeMask(shape.id);
            const shapeMask = pageMask ? Mat.From(Mat.Inverse(pageTransform)).applyToPoints(pageMask) : null;
            const shapeMaskId = suffixSafeId(masksId, shape.id);
            if (shapeMask) {
              shapeDefs[shapeMaskId] = {
                pending: false,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: shapeMaskId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: `M${shapeMask.map(({ x, y: y2 }) => `${x / scale2},${y2 / scale2}`).join("L")}Z`
                  }
                ) })
              };
            }
            if (toSvgResult) {
              elements.push({
                zIndex: index2,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toSvgResult
                  },
                  `fg_${shape.id}`
                )
              });
            }
            if (toBackgroundSvgResult) {
              elements.push({
                zIndex: backgroundIndex,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "g",
                  {
                    transform: pageTransformString,
                    opacity,
                    clipPath: pageMask ? `url(#${shapeMaskId})` : void 0,
                    children: toBackgroundSvgResult
                  },
                  `bg_${shape.id}`
                )
              });
            }
          } else {
            elements.push({
              zIndex: index2,
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                ForeignObjectShape,
                {
                  shape,
                  util: util2,
                  component: InnerShape,
                  className: "tl-shape",
                  bbox,
                  opacity
                },
                `fg_${shape.id}`
              )
            });
            if (util2.backgroundComponent) {
              elements.push({
                zIndex: backgroundIndex,
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ForeignObjectShape,
                  {
                    shape,
                    util: util2,
                    component: InnerShapeBackground,
                    className: "tl-shape tl-shape-background",
                    bbox,
                    opacity
                  },
                  `bg_${shape.id}`
                )
              });
            }
          }
          return elements;
        }
      );
      const unorderedShapeElements = (await Promise.all(unorderedShapeElementPromises)).flat();
      reactDomExports.flushSync(() => {
        stateAtom.update((state) => ({
          ...state,
          shapeElements: unorderedShapeElements.sort((a2, b) => a2.zIndex - b.zIndex).map(({ element }) => element),
          defsById: { ...state.defsById, ...shapeDefs }
        }));
      });
    })();
  }, [bbox, editor, exportContext, masksId, renderingShapes, singleFrameShapeId, stateAtom]);
  reactExports.useEffect(() => {
    const fontsInUse = /* @__PURE__ */ new Set();
    for (const { id } of renderingShapes) {
      for (const font of editor.fonts.getShapeFontFaces(id)) {
        fontsInUse.add(font);
      }
    }
    for (const font of fontsInUse) {
      addExportDef({
        key: uniqueId(),
        getElement: async () => {
          const declaration = await editor.fonts.toEmbeddedCssDeclaration(font);
          return /* @__PURE__ */ jsxRuntimeExports.jsx("style", { nonce: editor.options.nonce, children: declaration });
        }
      });
    }
  }, [editor, renderingShapes, addExportDef]);
  reactExports.useEffect(() => {
    if (shapeElements === null) return;
    onMount();
  }, [onMount, shapeElements]);
  let backgroundColor = background ? theme.background : "transparent";
  if (singleFrameShapeId && background) {
    const frameShapeUtil = editor.getShapeUtil("frame");
    if (frameShapeUtil?.options.showColors) {
      const shape = editor.getShape(singleFrameShapeId);
      const color = theme[shape.props.color];
      backgroundColor = color.frame.fill;
    } else {
      backgroundColor = theme.solid;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgExportContextProvider, { editor, context: exportContext, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      preserveAspectRatio,
      direction: "ltr",
      width: bbox.width * scale,
      height: bbox.height * scale,
      viewBox: `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: { backgroundColor },
      "data-color-mode": isDarkMode ? "dark" : "light",
      className: `tl-container tl-theme__force-sRGB ${isDarkMode ? "tl-theme__dark" : "tl-theme__light"}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: Object.entries(defsById).map(
          ([key, def]) => def.pending ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: def.element }, key)
        ) }),
        shapeElements
      ]
    }
  ) });
}
function ForeignObjectShape({
  shape,
  util: util2,
  className,
  component: Component,
  bbox,
  opacity
}) {
  const editor = useEditor();
  const transform = Mat.Translate(-bbox.minX, -bbox.minY).multiply(
    editor.getShapePageTransform(shape.id)
  );
  const bounds = editor.getShapeGeometry(shape.id).bounds;
  const width = Math.max(bounds.width, 1);
  const height = Math.max(bounds.height, 1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { fallback: () => null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "foreignObject",
    {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.w,
      height: bbox.h,
      className: "tl-shape-foreign-object tl-export-embed-styles",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className,
          "data-shape-type": shape.type,
          style: {
            clipPath: editor.getShapeClipPath(shape.id),
            transform: transform.toCssString(),
            width,
            height,
            opacity
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { shape, util: util2 })
        }
      )
    }
  ) });
}
let idCounter$1 = 1;
async function exportToSvg(editor, shapeIds, opts = {}) {
  const result = getSvgJsx(editor, shapeIds, opts);
  if (!result) return void 0;
  const container = editor.getContainer();
  const renderTarget = document.createElement("div");
  renderTarget.className = SVG_EXPORT_CLASSNAME;
  renderTarget.inert = true;
  renderTarget.tabIndex = -1;
  Object.assign(renderTarget.style, {
    position: "absolute",
    top: "0px",
    left: "0px",
    width: result.width + "px",
    height: result.height + "px",
    pointerEvents: "none",
    opacity: 0
  });
  container.appendChild(renderTarget);
  const root = clientExports.createRoot(renderTarget, { identifierPrefix: `export_${idCounter$1++}_` });
  try {
    await Promise.resolve();
    reactDomExports.flushSync(() => {
      root.render(result.jsx);
    });
    await result.exportDelay.resolve();
    const svg = renderTarget.firstElementChild;
    assert(svg instanceof SVGSVGElement, "Expected an SVG element");
    await applyChangesToForeignObjects(svg);
    return { svg, width: result.width, height: result.height };
  } finally {
    setTimeout(() => {
      root.unmount();
      container.removeChild(renderTarget);
    }, 0);
  }
}
async function applyChangesToForeignObjects(svg) {
  const foreignObjectChildren = [
    ...svg.querySelectorAll("foreignObject.tl-export-embed-styles > *")
  ];
  if (!foreignObjectChildren.length) return;
  const styleEmbedder = new StyleEmbedder(svg);
  try {
    styleEmbedder.fonts.startFindingCurrentDocumentFontFaces();
    await Promise.all(foreignObjectChildren.map((el) => embedMedia(el)));
    for (const el of foreignObjectChildren) {
      styleEmbedder.readRootElementStyles(el);
    }
    await styleEmbedder.fetchResources();
    const fontCss = await styleEmbedder.getFontFaceCss();
    styleEmbedder.unwrapCustomElements();
    const pseudoCss = styleEmbedder.embedStyles();
    if (fontCss || pseudoCss) {
      const style2 = document.createElementNS("http://www.w3.org/2000/svg", "style");
      style2.textContent = `${fontCss}
${pseudoCss}`;
      svg.prepend(style2);
    }
  } finally {
    styleEmbedder.dispose();
  }
}
let maxCanvasSizes = null;
function getBrowserCanvasMaxSize() {
  if (!maxCanvasSizes) {
    maxCanvasSizes = {
      maxWidth: getCanvasSize("width"),
      // test very wide but 1 pixel tall canvases
      maxHeight: getCanvasSize("height"),
      // test very tall but 1 pixel wide canvases
      maxArea: getCanvasSize("area")
      // test square canvases
    };
  }
  return maxCanvasSizes;
}
/*!
 * Extracted from https://github.com/jhildenbiddle/canvas-size
 * MIT License: https://github.com/jhildenbiddle/canvas-size/blob/master/LICENSE
 * Copyright (c) John Hildenbiddle
 */
const MAX_SAFE_CANVAS_DIMENSION = 8192;
const MAX_SAFE_CANVAS_AREA = 4096 * 4096;
const TEST_SIZES = {
  area: [
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4)
    // Edge 17 (Win)
    // Safari 7-12 (Mac)
    16384,
    // Chrome 68 (Android 7.1-9)
    14188,
    // Chrome 68 (Android 5)
    11402,
    // Firefox 63 (Mac, Win)
    11180,
    // Chrome 68 (Android 6)
    10836,
    // IE 9-11 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    // Safari (iOS 9 - 12)
    4096
  ],
  height: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    8388607,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ],
  width: [
    // Safari 7-12 (Mac)
    // Safari (iOS 9-12)
    4194303,
    // Chrome 83 (Mac, Win)
    65535,
    // Chrome 70 (Mac, Win)
    // Chrome 68 (Android 4.4-9)
    // Firefox 63 (Mac, Win)
    32767,
    // Edge 17 (Win)
    // IE11 (Win)
    16384,
    // IE 9-10 (Win)
    8192,
    // IE Mobile (Windows Phone 8.x)
    4096
  ]
};
function getCanvasSize(dimension) {
  const cropCvs = document.createElement("canvas");
  cropCvs.width = 1;
  cropCvs.height = 1;
  const cropCtx = cropCvs.getContext("2d");
  for (const size2 of TEST_SIZES[dimension]) {
    const w = dimension === "height" ? 1 : size2;
    const h = dimension === "width" ? 1 : size2;
    const testCvs = document.createElement("canvas");
    testCvs.width = w;
    testCvs.height = h;
    const testCtx = testCvs.getContext("2d");
    testCtx.fillRect(w - 1, h - 1, 1, 1);
    cropCtx.drawImage(testCvs, w - 1, h - 1, 1, 1, 0, 0, 1, 1);
    const isTestPassed = cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;
    testCvs.width = 0;
    testCvs.height = 0;
    if (isTestPassed) {
      cropCvs.width = 0;
      cropCvs.height = 0;
      if (dimension === "area") {
        return size2 * size2;
      } else {
        return size2;
      }
    }
  }
  cropCvs.width = 0;
  cropCvs.height = 0;
  throw Error("Failed to determine maximum canvas dimension");
}
function clampToBrowserMaxCanvasSize(width, height) {
  if (width <= MAX_SAFE_CANVAS_DIMENSION && height <= MAX_SAFE_CANVAS_DIMENSION && width * height <= MAX_SAFE_CANVAS_AREA) {
    return [width, height];
  }
  const { maxWidth, maxHeight, maxArea } = getBrowserCanvasMaxSize();
  const aspectRatio = width / height;
  if (width > maxWidth) {
    width = maxWidth;
    height = width / aspectRatio;
  }
  if (height > maxHeight) {
    height = maxHeight;
    width = height * aspectRatio;
  }
  if (width * height > maxArea) {
    const ratio = Math.sqrt(maxArea / (width * height));
    width *= ratio;
    height *= ratio;
  }
  return [width, height];
}
async function getSvgAsImage(svgString, options) {
  const { type, width, height, quality = 1, pixelRatio = 2 } = options;
  let [clampedWidth, clampedHeight] = clampToBrowserMaxCanvasSize(
    width * pixelRatio,
    height * pixelRatio
  );
  clampedWidth = Math.floor(clampedWidth);
  clampedHeight = Math.floor(clampedHeight);
  const effectiveScale = clampedWidth / width;
  const svgUrl = await FileHelpers.blobToDataUrl(new Blob([svgString], { type: "image/svg+xml" }));
  const canvas = await new Promise((resolve) => {
    const image = Image();
    image.crossOrigin = "anonymous";
    image.onload = async () => {
      if (tlenv.isSafari) {
        await sleep(250);
      }
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      canvas2.width = clampedWidth;
      canvas2.height = clampedHeight;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(image, 0, 0, clampedWidth, clampedHeight);
      URL.revokeObjectURL(svgUrl);
      resolve(canvas2);
    };
    image.onerror = () => {
      resolve(null);
    };
    image.src = svgUrl;
  });
  if (!canvas) return null;
  const blob = await new Promise(
    (resolve) => canvas.toBlob(
      (blob2) => {
        if (!blob2 || debugFlags.throwToBlob.get()) {
          resolve(null);
        }
        resolve(blob2);
      },
      "image/" + type,
      quality
    )
  );
  if (!blob) return null;
  if (type === "png") {
    const view = new DataView(await blob.arrayBuffer());
    return PngHelpers.setPhysChunk(view, effectiveScale, {
      type: "image/" + type
    });
  } else {
    return blob;
  }
}
const tlmenus = {
  /**
   * A set of strings representing any open menus. When menus are open,
   * certain interactions will behave differently; for example, when a
   * draw tool is selected and a menu is open, a pointer-down will not
   * create a dot (because the user is probably trying to close the menu)
   * however a pointer-down event followed by a drag will begin drawing
   * a line (because the user is BOTH trying to close the menu AND start
   * drawing a line).
   *
   * @public
   */
  menus: atom("open menus", []),
  /**
   * Get the current open menus.
   *
   * @param contextId - An optional context to get menus for.
   *
   * @public
   */
  getOpenMenus(contextId) {
    if (contextId) return this.menus.get().filter((m) => m.endsWith("-" + contextId));
    return this.menus.get();
  },
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * addOpenMenu('menu-id')
   * addOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to add.
   * @param contextId - An optional context to add the menu to.
   *
   * @public
   */
  addOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (!menus.has(idWithContext)) {
      menus.add(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * deleteOpenMenu('menu-id')
   * deleteOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to delete.
   * @param contextId - An optional context to delete the menu from.
   *
   * @public
   */
  deleteOpenMenu(id, contextId = "") {
    const idWithContext = contextId ? `${id}-${contextId}` : id;
    const menus = new Set(this.menus.get());
    if (menus.has(idWithContext)) {
      menus.delete(idWithContext);
      this.menus.set([...menus]);
    }
  },
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * clearOpenMenus()
   * clearOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to clear menus for.
   *
   * @public
   */
  clearOpenMenus(contextId) {
    this.menus.set(contextId ? this.menus.get().filter((m) => !m.endsWith("-" + contextId)) : []);
  },
  _hiddenMenus: [],
  /**
   * Hide all open menus. Restore them with the `showOpenMenus` method.
   *
   * @example
   * ```ts
   * hideOpenMenus()
   * hideOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to hide menus for.
   *
   * @public
   */
  hideOpenMenus(contextId) {
    this._hiddenMenus = [...this.getOpenMenus(contextId)];
    if (this._hiddenMenus.length === 0) return;
    for (const menu of this._hiddenMenus) {
      this.deleteOpenMenu(menu, contextId);
    }
  },
  /**
   * Show all hidden menus.
   *
   * @example
   * ```ts
   * showOpenMenus()
   * showOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to show menus for.
   *
   * @public
   */
  showOpenMenus(contextId) {
    if (this._hiddenMenus.length === 0) return;
    for (const menu of this._hiddenMenus) {
      this.addOpenMenu(menu, contextId);
    }
    this._hiddenMenus = [];
  },
  /**
   * Get whether a menu is open for a given context.
   *
   * @example
   * ```ts
   * isMenuOpem(id, myEditorId)
   * ```
   *
   * @param id - The id of the menu to check.
   * @param contextId - An optional context to check menus for.
   *
   * @public
   */
  isMenuOpen(id, contextId) {
    return this.getOpenMenus(contextId).includes(id);
  },
  /**
   * Get whether any menus are open for a given context.
   *
   * @example
   * ```ts
   * hasOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - A context to check menus for.
   *
   * @public
   */
  hasOpenMenus(contextId) {
    return this.getOpenMenus(contextId).length > 0;
  },
  /**
   * Get whether any menus are open for any context.
   *
   * @example
   * ```ts
   * hasAnyOpenMenus()
   * ```
   *
   * @public
   */
  hasAnyOpenMenus() {
    return this.getOpenMenus().length > 0;
  },
  forContext(contextId) {
    return {
      getOpenMenus: () => this.getOpenMenus(contextId),
      addOpenMenu: (id) => this.addOpenMenu(id, contextId),
      deleteOpenMenu: (id) => this.deleteOpenMenu(id, contextId),
      clearOpenMenus: () => this.clearOpenMenus(contextId),
      // Gets whether any menus are open
      isMenuOpen: (id) => this.isMenuOpen(id, contextId),
      hasOpenMenus: () => this.hasOpenMenus(contextId),
      hasAnyOpenMenus: () => this.hasAnyOpenMenus()
    };
  }
};
const tltime = new Timers();
const defaultTldrawOptions = {
  maxShapesPerPage: 4e3,
  maxFilesAtOnce: 100,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16,
  laserDelayMs: 1200,
  maxExportDelayMs: 5e3,
  temporaryAssetPreviewLifetimeMs: 18e4,
  actionShortcutsLocation: "swap",
  createTextOnCanvasDoubleClick: true,
  exportProvider: reactExports.Fragment,
  enableToolbarKeyboardShortcuts: true,
  maxFontsToLoadBeforeRender: Infinity,
  nonce: void 0
};
function sharedStyleEquals(a2, b) {
  if (!b) return false;
  switch (a2.type) {
    case "mixed":
      return b.type === "mixed";
    case "shared":
      return b.type === "shared" && a2.value === b.value;
    default:
      throw exhaustiveSwitchError$1(a2);
  }
}
class ReadonlySharedStyleMap {
  /** @internal */
  map;
  constructor(entries) {
    this.map = new Map(entries);
  }
  get(prop) {
    return this.map.get(prop);
  }
  getAsKnownValue(prop) {
    const value = this.get(prop);
    if (!value) return void 0;
    if (value.type === "mixed") return void 0;
    return value.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(other) {
    if (this.size !== other.size) return false;
    const checkedKeys = /* @__PURE__ */ new Set();
    for (const [styleProp, value] of this) {
      if (!sharedStyleEquals(value, other.get(styleProp))) return false;
      checkedKeys.add(styleProp);
    }
    for (const [styleProp, value] of other) {
      if (checkedKeys.has(styleProp)) continue;
      if (!sharedStyleEquals(value, this.get(styleProp))) return false;
    }
    return true;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
}
class SharedStyleMap extends ReadonlySharedStyleMap {
  set(prop, value) {
    this.map.set(prop, value);
  }
  applyValue(prop, value) {
    const existingValue = this.get(prop);
    if (!existingValue) {
      this.set(prop, { type: "shared", value });
      return;
    }
    switch (existingValue.type) {
      case "mixed":
        return;
      case "shared":
        if (existingValue.value !== value) {
          this.set(prop, { type: "mixed" });
        }
        return;
      default:
        exhaustiveSwitchError$1(existingValue, "type");
    }
  }
}
function dataUrlToFile(url, filename, mimeType) {
  return fetch$1(url).then(function(res) {
    return res.arrayBuffer();
  }).then(function(buf) {
    return new File([buf], filename, { type: mimeType });
  });
}
const CDN_BASE_URL = "https://cdn.tldraw.com";
function getDefaultCdnBaseUrl() {
  return `${CDN_BASE_URL}/${version}`;
}
function createDeepLinkString(deepLink) {
  switch (deepLink.type) {
    case "shapes": {
      const ids = deepLink.shapeIds.map((id) => encodeId(id.slice("shape:".length)));
      return `s${ids.join(".")}`;
    }
    case "page": {
      return "p" + encodeId(PageRecordType.parseId(deepLink.pageId));
    }
    case "viewport": {
      const { bounds, pageId } = deepLink;
      let res = `v${Math.round(bounds.x)}.${Math.round(bounds.y)}.${Math.round(bounds.w)}.${Math.round(bounds.h)}`;
      if (pageId) {
        res += "." + encodeId(PageRecordType.parseId(pageId));
      }
      return res;
    }
    default:
      exhaustiveSwitchError$1(deepLink);
  }
}
function parseDeepLinkString(deepLinkString) {
  const type = deepLinkString[0];
  switch (type) {
    case "s": {
      const shapeIds = deepLinkString.slice(1).split(".").filter(Boolean).map((id) => createShapeId(decodeURIComponent(id)));
      return { type: "shapes", shapeIds };
    }
    case "p": {
      const pageId = PageRecordType.createId(decodeURIComponent(deepLinkString.slice(1)));
      return { type: "page", pageId };
    }
    case "v": {
      const [x, y2, w, h, pageId] = deepLinkString.slice(1).split(".");
      return {
        type: "viewport",
        bounds: new Box(Number(x), Number(y2), Number(w), Number(h)),
        pageId: pageId ? PageRecordType.createId(decodeURIComponent(pageId)) : void 0
      };
    }
    default:
      throw Error("Invalid deep link string");
  }
}
function encodeId(str2) {
  return encodeURIComponent(str2).replace(/\./g, "%2E");
}
function getIncrementedName(name, others) {
  let result = name;
  const set = new Set(others);
  while (set.has(result)) {
    result = /^.*(\d+)$/.exec(result)?.[1] ? result.replace(/(\d+)(?=\D?)$/, (m) => {
      return (+m + 1).toString();
    }) : `${result} 1`;
  }
  return result;
}
function getReorderingShapesChanges(editor, operation, ids, opts) {
  if (ids.length === 0) return [];
  const parents = /* @__PURE__ */ new Map();
  for (const shape of compact$1(ids.map((id) => editor.getShape(id)))) {
    const { parentId } = shape;
    if (!parents.has(parentId)) {
      parents.set(parentId, {
        children: compact$1(
          editor.getSortedChildIdsForParent(parentId).map((id) => editor.getShape(id))
        ),
        moving: /* @__PURE__ */ new Set()
      });
    }
    parents.get(parentId).moving.add(shape);
  }
  const changes = [];
  switch (operation) {
    case "toBack": {
      parents.forEach(({ moving, children }) => reorderToBack(moving, children, changes));
      break;
    }
    case "toFront": {
      parents.forEach(({ moving, children }) => reorderToFront(moving, children, changes));
      break;
    }
    case "forward": {
      parents.forEach(
        ({ moving, children }) => reorderForward(editor, moving, children, changes, opts)
      );
      break;
    }
    case "backward": {
      parents.forEach(
        ({ moving, children }) => reorderBackward(editor, moving, children, changes, opts)
      );
      break;
    }
  }
  return changes;
}
function reorderToBack(moving, children, changes) {
  const len = children.length;
  if (moving.size === len) return;
  let below;
  let above;
  for (let i = 0; i < len; i++) {
    const shape = children[i];
    if (moving.has(shape)) {
      below = shape.index;
      moving.delete(shape);
    } else {
      above = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex$1).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function reorderToFront(moving, children, changes) {
  const len = children.length;
  if (moving.size === len) return;
  let below;
  let above;
  for (let i = len - 1; i > -1; i--) {
    const shape = children[i];
    if (moving.has(shape)) {
      above = shape.index;
      moving.delete(shape);
    } else {
      below = shape.index;
      break;
    }
  }
  if (moving.size === 0) {
    return;
  } else {
    const indices = getIndicesBetween(below, above, moving.size);
    changes.push(
      ...Array.from(moving.values()).sort(sortByIndex$1).map((shape, i) => ({ ...shape, index: indices[i] }))
    );
  }
}
function getOverlapChecker(editor, moving) {
  const movingVertices = Array.from(moving).map((shape) => {
    const vertices = editor.getShapePageGeometry(shape).vertices;
    if (!vertices) return null;
    return { shape, vertices };
  }).filter(Boolean);
  const isOverlapping = (child) => {
    const vertices = editor.getShapePageGeometry(child).vertices;
    if (!vertices) return false;
    return movingVertices.some((other) => {
      return polygonsIntersect(other.vertices, vertices);
    });
  };
  return isOverlapping;
}
function reorderForward(editor, moving, children, changes, opts) {
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len) return;
  let state = { name: "skipping" };
  for (let i = 0; i < len; i++) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving) continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving) continue;
        if (!opts?.considerAllShapes && !isOverlapping(children[i])) continue;
        const { selectIndex } = state;
        getIndicesBetween(children[i].index, children[i + 1]?.index, i - selectIndex).forEach(
          (index2, k) => {
            const child = children[selectIndex + k];
            if (!moving.has(child)) return;
            changes.push({ ...child, index: index2 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}
function reorderBackward(editor, moving, children, changes, opts) {
  const isOverlapping = getOverlapChecker(editor, moving);
  const len = children.length;
  if (moving.size === len) return;
  let state = { name: "skipping" };
  for (let i = len - 1; i > -1; i--) {
    const isMoving = moving.has(children[i]);
    switch (state.name) {
      case "skipping": {
        if (!isMoving) continue;
        state = { name: "selecting", selectIndex: i };
        break;
      }
      case "selecting": {
        if (isMoving) continue;
        if (!opts?.considerAllShapes && !isOverlapping(children[i])) continue;
        getIndicesBetween(children[i - 1]?.index, children[i].index, state.selectIndex - i).forEach(
          (index2, k) => {
            const child = children[i + k + 1];
            if (!moving.has(child)) return;
            changes.push({ ...child, index: index2 });
          }
        );
        state = { name: "skipping" };
        break;
      }
    }
  }
}
function getRotationSnapshot({
  editor,
  ids
}) {
  const shapes = compact$1(ids.map((id) => editor.getShape(id)));
  const rotation = editor.getShapesSharedRotation(ids);
  const rotatedPageBounds = editor.getShapesRotatedPageBounds(ids);
  if (!rotatedPageBounds) {
    return null;
  }
  const initialPageCenter = rotatedPageBounds.center.clone().rotWith(rotatedPageBounds.point, rotation);
  return {
    initialPageCenter,
    initialCursorAngle: initialPageCenter.angle(editor.inputs.originPagePoint),
    initialShapesRotation: rotation,
    shapeSnapshots: shapes.map((shape) => ({
      shape,
      initialPagePoint: editor.getShapePageTransform(shape.id).point()
    }))
  };
}
function applyRotationToSnapshotShapes({
  delta,
  editor,
  snapshot,
  stage,
  centerOverride
}) {
  const { initialPageCenter, shapeSnapshots } = snapshot;
  editor.updateShapes(
    shapeSnapshots.map(({ shape, initialPagePoint }) => {
      const parentTransform = isShapeId(shape.parentId) ? editor.getShapePageTransform(shape.parentId) : Mat.Identity();
      const newPagePoint = Vec.RotWith(initialPagePoint, centerOverride ?? initialPageCenter, delta);
      const newLocalPoint = Mat.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        Mat.Inverse(parentTransform),
        newPagePoint
      );
      const newRotation = canonicalizeRotation(shape.rotation + delta);
      return {
        id: shape.id,
        type: shape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        rotation: newRotation
      };
    })
  );
  const changes = [];
  shapeSnapshots.forEach(({ shape }) => {
    const current = editor.getShape(shape.id);
    if (!current) return;
    const util2 = editor.getShapeUtil(shape);
    {
      const changeStart = util2.onRotateStart?.(shape);
      if (changeStart) changes.push(changeStart);
    }
    const changeUpdate = util2.onRotate?.(shape, current);
    if (changeUpdate) changes.push(changeUpdate);
    {
      const changeEnd = util2.onRotateEnd?.(shape, current);
      if (changeEnd) changes.push(changeEnd);
    }
  });
  if (changes.length > 0) {
    editor.updateShapes(changes);
  }
}
const bindingsIndex = (editor) => {
  const { store } = editor;
  const bindingsHistory = store.query.filterHistory("binding");
  const bindingsQuery = store.query.records("binding");
  function fromScratch() {
    const allBindings = bindingsQuery.get();
    const shape2Binding = /* @__PURE__ */ new Map();
    for (const binding of allBindings) {
      const { fromId, toId } = binding;
      const bindingsForFromShape = shape2Binding.get(fromId);
      if (!bindingsForFromShape) {
        shape2Binding.set(fromId, [binding]);
      } else {
        bindingsForFromShape.push(binding);
      }
      const bindingsForToShape = shape2Binding.get(toId);
      if (!bindingsForToShape) {
        shape2Binding.set(toId, [binding]);
      } else {
        bindingsForToShape.push(binding);
      }
    }
    return shape2Binding;
  }
  return computed("arrowBindingsIndex", (_lastValue, lastComputedEpoch) => {
    if (isUninitialized(_lastValue)) {
      return fromScratch();
    }
    const lastValue = _lastValue;
    const diff = bindingsHistory.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch();
    }
    let nextValue = void 0;
    function removingBinding(binding) {
      nextValue ??= new Map(lastValue);
      const prevFrom = nextValue.get(binding.fromId);
      const nextFrom = prevFrom?.filter((b) => b.id !== binding.id);
      if (!nextFrom?.length) {
        nextValue.delete(binding.fromId);
      } else {
        nextValue.set(binding.fromId, nextFrom);
      }
      const prevTo = nextValue.get(binding.toId);
      const nextTo = prevTo?.filter((b) => b.id !== binding.id);
      if (!nextTo?.length) {
        nextValue.delete(binding.toId);
      } else {
        nextValue.set(binding.toId, nextTo);
      }
    }
    function ensureNewArray(shapeId) {
      nextValue ??= new Map(lastValue);
      let result = nextValue.get(shapeId);
      if (!result) {
        result = [];
        nextValue.set(shapeId, result);
      } else if (result === lastValue.get(shapeId)) {
        result = result.slice(0);
        nextValue.set(shapeId, result);
      }
      return result;
    }
    function addBinding(binding) {
      ensureNewArray(binding.fromId).push(binding);
      ensureNewArray(binding.toId).push(binding);
    }
    for (const changes of diff) {
      for (const newBinding of objectMapValues(changes.added)) {
        addBinding(newBinding);
      }
      for (const [prev, next] of objectMapValues(changes.updated)) {
        removingBinding(prev);
        addBinding(next);
      }
      for (const prev of objectMapValues(changes.removed)) {
        removingBinding(prev);
      }
    }
    return nextValue ?? lastValue;
  });
};
function isShapeNotVisible(editor, id, viewportPageBounds) {
  const maskedPageBounds = editor.getShapeMaskedPageBounds(id);
  if (maskedPageBounds === void 0) return true;
  return !viewportPageBounds.includes(maskedPageBounds);
}
const notVisibleShapes = (editor) => {
  function fromScratch(editor2) {
    const shapes = editor2.getCurrentPageShapeIds();
    const viewportPageBounds = editor2.getViewportPageBounds();
    const notVisibleShapes2 = /* @__PURE__ */ new Set();
    shapes.forEach((id) => {
      if (isShapeNotVisible(editor2, id, viewportPageBounds)) {
        notVisibleShapes2.add(id);
      }
    });
    return notVisibleShapes2;
  }
  return computed("notVisibleShapes", (prevValue) => {
    if (isUninitialized(prevValue)) {
      return fromScratch(editor);
    }
    const nextValue = fromScratch(editor);
    if (prevValue.size !== nextValue.size) return nextValue;
    for (const prev of prevValue) {
      if (!nextValue.has(prev)) {
        return nextValue;
      }
    }
    return prevValue;
  });
};
const parentsToChildren = (store) => {
  const shapeIdsQuery = store.query.ids("shape");
  const shapeHistory = store.query.filterHistory("shape");
  function fromScratch() {
    const result = {};
    const shapeIds = shapeIdsQuery.get();
    const shapes = Array(shapeIds.size);
    shapeIds.forEach((id) => shapes.push(store.get(id)));
    shapes.sort(sortByIndex$1);
    shapes.forEach((shape) => {
      if (!result[shape.parentId]) {
        result[shape.parentId] = [];
      }
      result[shape.parentId].push(shape.id);
    });
    return result;
  }
  return computed(
    "parentsToChildrenWithIndexes",
    (lastValue, lastComputedEpoch) => {
      if (isUninitialized(lastValue)) {
        return fromScratch();
      }
      const diff = shapeHistory.getDiffSince(lastComputedEpoch);
      if (diff === RESET_VALUE) {
        return fromScratch();
      }
      if (diff.length === 0) return lastValue;
      let newValue = null;
      const ensureNewArray = (parentId) => {
        if (!newValue) {
          newValue = { ...lastValue };
        }
        if (!newValue[parentId]) {
          newValue[parentId] = [];
        } else if (newValue[parentId] === lastValue[parentId]) {
          newValue[parentId] = [...newValue[parentId]];
        }
      };
      const toSort = /* @__PURE__ */ new Set();
      let changes;
      for (let i = 0, n2 = diff.length; i < n2; i++) {
        changes = diff[i];
        for (const record of Object.values(changes.added)) {
          if (!isShape(record)) continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].push(record.id);
          toSort.add(newValue[record.parentId]);
        }
        for (const [from2, to] of Object.values(changes.updated)) {
          if (!isShape(to)) continue;
          if (!isShape(from2)) continue;
          if (from2.parentId !== to.parentId) {
            ensureNewArray(from2.parentId);
            ensureNewArray(to.parentId);
            newValue[from2.parentId].splice(newValue[from2.parentId].indexOf(to.id), 1);
            newValue[to.parentId].push(to.id);
            toSort.add(newValue[to.parentId]);
          } else if (from2.index !== to.index) {
            ensureNewArray(to.parentId);
            const idx = newValue[to.parentId].indexOf(to.id);
            newValue[to.parentId][idx] = to.id;
            toSort.add(newValue[to.parentId]);
          }
        }
        for (const record of Object.values(changes.removed)) {
          if (!isShape(record)) continue;
          ensureNewArray(record.parentId);
          newValue[record.parentId].splice(newValue[record.parentId].indexOf(record.id), 1);
        }
      }
      for (const arr of toSort) {
        const shapesInArr = compact$1(arr.map((id) => store.get(id)));
        shapesInArr.sort(sortByIndex$1);
        arr.splice(0, arr.length, ...shapesInArr.map((shape) => shape.id));
      }
      return newValue ?? lastValue;
    }
  );
};
const isShapeInPage = (store, pageId, shape) => {
  while (!isPageId(shape.parentId)) {
    const parent = store.get(shape.parentId);
    if (!parent) return false;
    shape = parent;
  }
  return shape.parentId === pageId;
};
const deriveShapeIdsInCurrentPage = (store, getCurrentPageId) => {
  const shapesIndex = store.query.ids("shape");
  let lastPageId = null;
  function fromScratch() {
    const currentPageId = getCurrentPageId();
    lastPageId = currentPageId;
    return new Set(
      [...shapesIndex.get()].filter((id) => isShapeInPage(store, currentPageId, store.get(id)))
    );
  }
  return computed("_shapeIdsInCurrentPage", (prevValue, lastComputedEpoch) => {
    if (isUninitialized(prevValue)) {
      return fromScratch();
    }
    const currentPageId = getCurrentPageId();
    if (currentPageId !== lastPageId) {
      return fromScratch();
    }
    const diff = store.history.getDiffSince(lastComputedEpoch);
    if (diff === RESET_VALUE) {
      return fromScratch();
    }
    const builder = new IncrementalSetConstructor(
      prevValue
    );
    for (const changes of diff) {
      for (const record of Object.values(changes.added)) {
        if (isShape(record) && isShapeInPage(store, currentPageId, record)) {
          builder.add(record.id);
        }
      }
      for (const [_from, to] of Object.values(changes.updated)) {
        if (isShape(to)) {
          if (isShapeInPage(store, currentPageId, to)) {
            builder.add(to.id);
          } else {
            builder.remove(to.id);
          }
        }
      }
      for (const id of Object.keys(changes.removed)) {
        if (isShapeId(id)) {
          builder.remove(id);
        }
      }
    }
    const result = builder.get();
    if (!result) {
      return prevValue;
    }
    return withDiff(result.value, result.diff);
  });
};
var __create$9 = Object.create;
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __knownSymbol$9 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$9 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$9 = (base2) => [, , , __create$9(null)];
var __decoratorStrings$9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$9 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$9("Function expected") : fn;
var __decoratorContext$9 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$9[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$9("Already initialized") : fns.push(__expectFn$9(fn || null)) });
var __decoratorMetadata$9 = (array2, target) => __defNormalProp$9(target, __knownSymbol$9("metadata"), array2[3]);
var __runInitializers$9 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$9 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$9[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$9(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$9(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$9(it) && (desc[key] = it);
  }
  return desc && __defProp$9(target, name, desc), target;
};
var __publicField$9 = (obj, key, value) => __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
var _cancelDoubleClickTimeout_dec, __getClickTimeout_dec, _init$9;
const MAX_CLICK_DISTANCE = 40;
__getClickTimeout_dec = [bind$1], _cancelDoubleClickTimeout_dec = [bind$1];
class ClickManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$9(_init$9, 5, this);
    __publicField$9(this, "_clickId", "");
    __publicField$9(this, "_clickTimeout");
    __publicField$9(this, "_clickScreenPoint");
    __publicField$9(this, "_previousScreenPoint");
    __publicField$9(this, "_clickState", "idle");
    __publicField$9(this, "lastPointerInfo", {});
  }
  _getClickTimeout(state, id = uniqueId()) {
    this._clickId = id;
    clearTimeout(this._clickTimeout);
    this._clickTimeout = this.editor.timers.setTimeout(
      () => {
        if (this._clickState === state && this._clickId === id) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
          }
          this._clickState = "idle";
        }
      },
      state === "idle" || state === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
    );
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
  handlePointerEvent(info) {
    switch (info.name) {
      case "pointer_down": {
        if (!this._clickState) return info;
        this._clickScreenPoint = Vec.From(info.point);
        if (this._previousScreenPoint && Vec.Dist2(this._previousScreenPoint, this._clickScreenPoint) > MAX_CLICK_DISTANCE ** 2) {
          this._clickState = "idle";
        }
        this._previousScreenPoint = this._clickScreenPoint;
        this.lastPointerInfo = info;
        switch (this._clickState) {
          case "pendingDouble": {
            this._clickState = "pendingTriple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "double_click",
              phase: "down"
            };
          }
          case "pendingTriple": {
            this._clickState = "pendingQuadruple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "triple_click",
              phase: "down"
            };
          }
          case "pendingQuadruple": {
            this._clickState = "pendingOverflow";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return {
              ...info,
              type: "click",
              name: "quadruple_click",
              phase: "down"
            };
          }
          case "idle": {
            this._clickState = "pendingDouble";
            break;
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            break;
          }
        }
        this._clickTimeout = this._getClickTimeout(this._clickState);
        return info;
      }
      case "pointer_up": {
        if (!this._clickState) return info;
        this._clickScreenPoint = Vec.From(info.point);
        switch (this._clickState) {
          case "pendingTriple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "double_click",
              phase: "up"
            };
          }
          case "pendingQuadruple": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "triple_click",
              phase: "up"
            };
          }
          case "pendingOverflow": {
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "quadruple_click",
              phase: "up"
            };
          }
        }
        return info;
      }
      case "pointer_move": {
        if (this._clickState !== "idle" && this._clickScreenPoint && Vec.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared)) {
          this.cancelDoubleClickTimeout();
        }
        return info;
      }
    }
    return info;
  }
  cancelDoubleClickTimeout() {
    this._clickTimeout = clearTimeout(this._clickTimeout);
    this._clickState = "idle";
  }
}
_init$9 = __decoratorStart$9();
__decorateElement$9(_init$9, 1, "_getClickTimeout", __getClickTimeout_dec, ClickManager);
__decorateElement$9(_init$9, 1, "cancelDoubleClickTimeout", _cancelDoubleClickTimeout_dec, ClickManager);
__decoratorMetadata$9(_init$9, ClickManager);
class EdgeScrollManager {
  constructor(editor) {
    this.editor = editor;
  }
  _isEdgeScrolling = false;
  _edgeScrollDuration = -1;
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(elapsed) {
    const { editor } = this;
    const edgeScrollProximityFactor = this.getEdgeScroll();
    if (edgeScrollProximityFactor.x === 0 && edgeScrollProximityFactor.y === 0) {
      if (this._isEdgeScrolling) {
        this._isEdgeScrolling = false;
        this._edgeScrollDuration = 0;
      }
    } else {
      if (!this._isEdgeScrolling) {
        this._isEdgeScrolling = true;
        this._edgeScrollDuration = 0;
      }
      this._edgeScrollDuration += elapsed;
      if (this._edgeScrollDuration > editor.options.edgeScrollDelay) {
        const eased = editor.options.edgeScrollEaseDuration > 0 ? EASINGS.easeInCubic(
          Math.min(
            1,
            this._edgeScrollDuration / (editor.options.edgeScrollDelay + editor.options.edgeScrollEaseDuration)
          )
        ) : 1;
        this.moveCameraWhenCloseToEdge({
          x: edgeScrollProximityFactor.x * eased,
          y: edgeScrollProximityFactor.y * eased
        });
      }
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @param isCoarse - Whether the pointer is coarse.
   * @param insetStart - Whether the pointer is inset at the start of the axis.
   * @param insetEnd - Whether the pointer is inset at the end of the axis.
   * @internal
   */
  getEdgeProximityFactors(position, dimension, isCoarse, insetStart, insetEnd) {
    const { editor } = this;
    const dist = editor.options.edgeScrollDistance;
    const pw = isCoarse ? editor.options.coarsePointerWidth : 0;
    const pMin = position - pw;
    const pMax = position + pw;
    const min2 = insetStart ? 0 : dist;
    const max2 = insetEnd ? dimension : dimension - dist;
    if (pMin < min2) {
      return Math.min(1, (min2 - pMin) / dist);
    } else if (pMax > max2) {
      return -Math.min(1, (pMax - max2) / dist);
    }
    return 0;
  }
  getEdgeScroll() {
    const { editor } = this;
    const {
      inputs: {
        currentScreenPoint: { x, y: y2 }
      }
    } = editor;
    const screenBounds = editor.getViewportScreenBounds();
    const {
      isCoarsePointer,
      insets: [t2, r2, b, l]
    } = editor.getInstanceState();
    const proximityFactorX = this.getEdgeProximityFactors(x, screenBounds.w, isCoarsePointer, l, r2);
    const proximityFactorY = this.getEdgeProximityFactors(y2, screenBounds.h, isCoarsePointer, t2, b);
    return {
      x: proximityFactorX,
      y: proximityFactorY
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(proximityFactor) {
    const { editor } = this;
    if (!editor.inputs.isDragging || editor.inputs.isPanning || editor.getCameraOptions().isLocked)
      return;
    if (proximityFactor.x === 0 && proximityFactor.y === 0) return;
    const screenBounds = editor.getViewportScreenBounds();
    const screenSizeFactorX = screenBounds.w < 1e3 ? 0.612 : 1;
    const screenSizeFactorY = screenBounds.h < 1e3 ? 0.612 : 1;
    const zoomLevel = editor.getZoomLevel();
    const pxSpeed = editor.user.getEdgeScrollSpeed() * editor.options.edgeScrollSpeed;
    const scrollDeltaX = pxSpeed * proximityFactor.x * screenSizeFactorX / zoomLevel;
    const scrollDeltaY = pxSpeed * proximityFactor.y * screenSizeFactorY / zoomLevel;
    const { x, y: y2, z } = editor.getCamera();
    editor.setCamera(new Vec(x + scrollDeltaX, y2 + scrollDeltaY, z));
  }
}
class FocusManager {
  constructor(editor, autoFocus) {
    this.editor = editor;
    this.disposeSideEffectListener = editor.sideEffects.registerAfterChangeHandler(
      "instance",
      (prev, next) => {
        if (prev.isFocused !== next.isFocused) {
          this.updateContainerClass();
        }
      }
    );
    const currentFocusState = editor.getInstanceState().isFocused;
    if (autoFocus !== currentFocusState) {
      editor.updateInstanceState({ isFocused: !!autoFocus });
    }
    this.updateContainerClass();
    document.body.addEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.addEventListener("mousedown", this.handleMouseDown.bind(this));
  }
  disposeSideEffectListener;
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const container = this.editor.getContainer();
    const instanceState = this.editor.getInstanceState();
    if (instanceState.isFocused) {
      container.classList.add("tl-container__focused");
    } else {
      container.classList.remove("tl-container__focused");
    }
    container.classList.add("tl-container__no-focus-ring");
  }
  handleKeyDown(keyEvent2) {
    const container = this.editor.getContainer();
    if (["Tab", "ArrowUp", "ArrowDown"].includes(keyEvent2.key)) {
      container.classList.remove("tl-container__no-focus-ring");
    }
  }
  handleMouseDown() {
    const container = this.editor.getContainer();
    container.classList.add("tl-container__no-focus-ring");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete();
    this.editor.getContainer().blur();
  }
  dispose() {
    document.body.removeEventListener("keydown", this.handleKeyDown.bind(this));
    document.body.removeEventListener("mousedown", this.handleMouseDown.bind(this));
    this.disposeSideEffectListener?.();
  }
}
class FontManager {
  constructor(editor, assetUrls) {
    this.editor = editor;
    this.assetUrls = assetUrls;
    this.shapeFontFacesCache = editor.store.createComputedCache(
      "shape font faces",
      (shape) => {
        const shapeUtil = this.editor.getShapeUtil(shape);
        return shapeUtil.getFontFaces(shape);
      },
      { areResultsEqual: areArraysShallowEqual, areRecordsEqual: (a2, b) => a2.props === b.props }
    );
    this.shapeFontLoadStateCache = editor.store.createCache(
      (id) => {
        const fontFacesComputed = computed("font faces", () => this.getShapeFontFaces(id));
        return computed(
          "font load state",
          () => {
            const states = fontFacesComputed.get().map((face) => this.getFontState(face));
            return states;
          },
          { isEqual: areArraysShallowEqual }
        );
      }
    );
  }
  shapeFontFacesCache;
  shapeFontLoadStateCache;
  getShapeFontFaces(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    return this.shapeFontFacesCache.get(shapeId) ?? EMPTY_ARRAY;
  }
  trackFontsForShape(shape) {
    const shapeId = typeof shape === "string" ? shape : shape.id;
    this.shapeFontLoadStateCache.get(shapeId);
  }
  async loadRequiredFontsForCurrentPage(limit2 = Infinity) {
    const neededFonts = /* @__PURE__ */ new Set();
    for (const shapeId of this.editor.getCurrentPageShapeIds()) {
      for (const font of this.getShapeFontFaces(this.editor.getShape(shapeId))) {
        neededFonts.add(font);
      }
    }
    if (neededFonts.size > limit2) {
      return;
    }
    const promises = Array.from(neededFonts, (font) => this.ensureFontIsLoaded(font));
    await Promise.all(promises);
  }
  fontStates = new AtomMap("font states");
  getFontState(font) {
    return this.fontStates.get(font) ?? null;
  }
  ensureFontIsLoaded(font) {
    const existingState = this.getFontState(font);
    if (existingState) return existingState.loadingPromise;
    const instance = this.findOrCreateFontFace(font);
    const state = {
      state: "loading",
      instance,
      loadingPromise: instance.load().then(() => {
        document.fonts.add(instance);
        this.fontStates.update(font, (s2) => ({ ...s2, state: "ready" }));
      }).catch((err) => {
        console.error(err);
        this.fontStates.update(font, (s2) => ({ ...s2, state: "error" }));
      })
    };
    this.fontStates.set(font, state);
    return state.loadingPromise;
  }
  fontsToLoad = /* @__PURE__ */ new Set();
  requestFonts(fonts) {
    if (!this.fontsToLoad.size) {
      queueMicrotask(() => {
        if (this.editor.isDisposed) return;
        const toLoad = this.fontsToLoad;
        this.fontsToLoad = /* @__PURE__ */ new Set();
        transact(() => {
          for (const font of toLoad) {
            this.ensureFontIsLoaded(font);
          }
        });
      });
    }
    for (const font of fonts) {
      this.fontsToLoad.add(font);
    }
  }
  findOrCreateFontFace(font) {
    for (const existing of document.fonts) {
      if (existing.family === font.family && objectMapEntries(defaultFontFaceDescriptors).every(
        ([key, defaultValue]) => existing[key] === (font[key] ?? defaultValue)
      )) {
        return existing;
      }
    }
    const url = this.assetUrls?.[font.src.url] ?? font.src.url;
    const instance = new FontFace(font.family, `url(${JSON.stringify(url)})`, {
      ...mapObjectMapValues(defaultFontFaceDescriptors, (key) => font[key]),
      display: "swap"
    });
    document.fonts.add(instance);
    return instance;
  }
  async toEmbeddedCssDeclaration(font) {
    const url = this.assetUrls?.[font.src.url] ?? font.src.url;
    const dataUrl = await FileHelpers.urlToDataUrl(url);
    const src = compact$1([
      `url("${dataUrl}")`,
      font.src.format ? `format(${font.src.format})` : null,
      font.src.tech ? `tech(${font.src.tech})` : null
    ]).join(" ");
    return compact$1([
      `@font-face {`,
      `  font-family: "${font.family}";`,
      font.ascentOverride ? `  ascent-override: ${font.ascentOverride};` : null,
      font.descentOverride ? `  descent-override: ${font.descentOverride};` : null,
      font.stretch ? `  font-stretch: ${font.stretch};` : null,
      font.style ? `  font-style: ${font.style};` : null,
      font.weight ? `  font-weight: ${font.weight};` : null,
      font.featureSettings ? `  font-feature-settings: ${font.featureSettings};` : null,
      font.lineGapOverride ? `  line-gap-override: ${font.lineGapOverride};` : null,
      font.unicodeRange ? `  unicode-range: ${font.unicodeRange};` : null,
      `  src: ${src};`,
      `}`
    ]).join("\n");
  }
}
const defaultFontFaceDescriptors = {
  style: "normal",
  weight: "normal",
  stretch: "normal",
  unicodeRange: "U+0-10FFFF",
  featureSettings: "normal",
  ascentOverride: "normal",
  descentOverride: "normal",
  lineGapOverride: "normal"
};
function stack(items) {
  return EMPTY_STACK_ITEM;
}
class EmptyStackItem {
  length = 0;
  head = null;
  tail = this;
  push(head) {
    return new StackItem(head, this);
  }
  toArray() {
    return EMPTY_ARRAY;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: true };
      }
    };
  }
}
const EMPTY_STACK_ITEM = new EmptyStackItem();
class StackItem {
  constructor(head, tail) {
    this.head = head;
    this.tail = tail;
    this.length = tail.length + 1;
  }
  length;
  push(head) {
    return new StackItem(head, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let stack2 = this;
    return {
      next() {
        if (stack2.length) {
          const value = stack2.head;
          stack2 = stack2.tail;
          return { value, done: false };
        } else {
          return { value: void 0, done: true };
        }
      }
    };
  }
}
class HistoryManager {
  store;
  dispose;
  state = "recording";
  pendingDiff = new PendingDiff();
  stacks = atom(
    "HistoryManager.stacks",
    {
      undos: stack(),
      redos: stack()
    },
    {
      isEqual: (a2, b) => a2.undos === b.undos && a2.redos === b.redos
    }
  );
  annotateError;
  constructor(opts) {
    this.store = opts.store;
    this.annotateError = opts.annotateError ?? noop$3;
    this.dispose = this.store.addHistoryInterceptor((entry2, source) => {
      if (source !== "user") return;
      switch (this.state) {
        case "recording":
          this.pendingDiff.apply(entry2.changes);
          this.stacks.update(({ undos }) => ({ undos, redos: stack() }));
          break;
        case "recordingPreserveRedoStack":
          this.pendingDiff.apply(entry2.changes);
          break;
        case "paused":
          break;
        default:
          exhaustiveSwitchError$1(this.state);
      }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty()) return;
    const diff = this.pendingDiff.clear();
    this.stacks.update(({ undos, redos }) => ({
      undos: undos.push({ type: "diff", diff }),
      redos
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  /** @internal */
  _isInBatch = false;
  batch(fn, opts) {
    const previousState = this.state;
    if (previousState !== "paused" && opts?.history) {
      this.state = modeToState[opts.history];
    }
    try {
      if (this._isInBatch) {
        transact(fn);
        return this;
      }
      this._isInBatch = true;
      try {
        transact(fn);
      } catch (error) {
        this.annotateError(error);
        throw error;
      } finally {
        this._isInBatch = false;
      }
      return this;
    } finally {
      this.state = previousState;
    }
  }
  // History
  _undo({ pushToRedoStack, toMark = void 0 }) {
    const previousState = this.state;
    this.state = "paused";
    try {
      let { undos, redos } = this.stacks.get();
      const pendingDiff = this.pendingDiff.clear();
      const isPendingDiffEmpty = isRecordsDiffEmpty(pendingDiff);
      const diffToUndo = reverseRecordsDiff(pendingDiff);
      if (pushToRedoStack && !isPendingDiffEmpty) {
        redos = redos.push({ type: "diff", diff: pendingDiff });
      }
      let didFindMark = false;
      if (isPendingDiffEmpty) {
        while (undos.head?.type === "stop") {
          const mark = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(mark);
          }
          if (mark.id === toMark) {
            didFindMark = true;
            break;
          }
        }
      }
      if (!didFindMark) {
        loop: while (undos.head) {
          const undo2 = undos.head;
          undos = undos.tail;
          if (pushToRedoStack) {
            redos = redos.push(undo2);
          }
          switch (undo2.type) {
            case "diff":
              squashRecordDiffsMutable(diffToUndo, [reverseRecordsDiff(undo2.diff)]);
              break;
            case "stop":
              if (!toMark) break loop;
              if (undo2.id === toMark) {
                didFindMark = true;
                break loop;
              }
              break;
            default:
              exhaustiveSwitchError$1(undo2);
          }
        }
      }
      if (!didFindMark && toMark) {
        return this;
      }
      this.store.applyDiff(diffToUndo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  undo() {
    this._undo({ pushToRedoStack: true });
    return this;
  }
  redo() {
    const previousState = this.state;
    this.state = "paused";
    try {
      this.flushPendingDiff();
      let { undos, redos } = this.stacks.get();
      if (redos.length === 0) {
        return this;
      }
      while (redos.head?.type === "stop") {
        undos = undos.push(redos.head);
        redos = redos.tail;
      }
      const diffToRedo = createEmptyRecordsDiff();
      while (redos.head) {
        const redo2 = redos.head;
        undos = undos.push(redo2);
        redos = redos.tail;
        if (redo2.type === "diff") {
          squashRecordDiffsMutable(diffToRedo, [redo2.diff]);
        } else {
          break;
        }
      }
      this.store.applyDiff(diffToRedo, { ignoreEphemeralKeys: true });
      this.store.ensureStoreIsUsable();
      this.stacks.set({ undos, redos });
    } finally {
      this.state = previousState;
    }
    return this;
  }
  bail() {
    this._undo({ pushToRedoStack: false });
    return this;
  }
  bailToMark(id) {
    this._undo({ pushToRedoStack: false, toMark: id });
    return this;
  }
  squashToMark(id) {
    let top = this.stacks.get().undos;
    const popped = [];
    while (top.head && !(top.head.type === "stop" && top.head.id === id)) {
      if (top.head.type === "diff") {
        popped.push(top.head.diff);
      }
      top = top.tail;
    }
    if (!top.head || top.head?.id !== id) {
      console.error("Could not find mark to squash to: ", id);
      return this;
    }
    if (popped.length === 0) {
      return this;
    }
    const diff = createEmptyRecordsDiff();
    squashRecordDiffsMutable(diff, popped.reverse());
    this.stacks.update(({ redos }) => ({
      undos: top.push({
        type: "diff",
        diff
      }),
      redos
    }));
    return this;
  }
  /** @internal */
  _mark(id) {
    transact(() => {
      this.flushPendingDiff();
      this.stacks.update(({ undos, redos }) => ({ undos: undos.push({ type: "stop", id }), redos }));
    });
  }
  clear() {
    this.stacks.set({ undos: stack(), redos: stack() });
    this.pendingDiff.clear();
  }
  /** @internal */
  getMarkIdMatching(idSubstring) {
    let top = this.stacks.get().undos;
    while (top.head) {
      if (top.head.type === "stop" && top.head.id.includes(idSubstring)) {
        return top.head.id;
      }
      top = top.tail;
    }
    return null;
  }
  /** @internal */
  debug() {
    const { undos, redos } = this.stacks.get();
    return {
      undos: undos.toArray(),
      redos: redos.toArray(),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
}
const modeToState = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
class PendingDiff {
  diff = createEmptyRecordsDiff();
  isEmptyAtom = atom("PendingDiff.isEmpty", true);
  clear() {
    const diff = this.diff;
    this.diff = createEmptyRecordsDiff();
    this.isEmptyAtom.set(true);
    return diff;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(diff) {
    squashRecordDiffsMutable(this.diff, [diff]);
    this.isEmptyAtom.set(isRecordsDiffEmpty(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
}
class ScribbleManager {
  constructor(editor) {
    this.editor = editor;
  }
  scribbleItems = /* @__PURE__ */ new Map();
  state = "paused";
  addScribble(scribble, id = uniqueId()) {
    const item = {
      id,
      scribble: {
        id,
        size: 20,
        color: "accent",
        opacity: 0.8,
        delay: 0,
        points: [],
        shrink: 0.1,
        taper: true,
        ...scribble,
        state: "starting"
      },
      timeoutMs: 0,
      delayRemaining: scribble.delay ?? 0,
      prev: null,
      next: null
    };
    this.scribbleItems.set(id, item);
    return item;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] });
    this.scribbleItems.clear();
  }
  /**
   * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
   *
   * @public
   */
  stop(id) {
    const item = this.scribbleItems.get(id);
    if (!item) throw Error(`Scribble with id ${id} not found`);
    item.delayRemaining = Math.min(item.delayRemaining, 200);
    item.scribble.state = "stopping";
    return item;
  }
  /**
   * Set the scribble's next point.
   *
   * @param id - The id of the scribble to add a point to.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   * @public
   */
  addPoint(id, x, y2, z = 0.5) {
    const item = this.scribbleItems.get(id);
    if (!item) throw Error(`Scribble with id ${id} not found`);
    const { prev } = item;
    const point = { x, y: y2, z };
    if (!prev || Vec.Dist(prev, point) >= 1) {
      item.next = point;
    }
    return item;
  }
  /**
   * Update on each animation frame.
   *
   * @param elapsed - The number of milliseconds since the last tick.
   * @public
   */
  tick(elapsed) {
    if (this.scribbleItems.size === 0) return;
    this.editor.run(() => {
      this.scribbleItems.forEach((item) => {
        if (item.scribble.state === "starting") {
          const { next: next2, prev: prev2 } = item;
          if (next2 && next2 !== prev2) {
            item.prev = next2;
            item.scribble.points.push(next2);
          }
          if (item.scribble.points.length > 8) {
            item.scribble.state = "active";
          }
          return;
        }
        if (item.delayRemaining > 0) {
          item.delayRemaining = Math.max(0, item.delayRemaining - elapsed);
        }
        item.timeoutMs += elapsed;
        if (item.timeoutMs >= 16) {
          item.timeoutMs = 0;
        }
        const { delayRemaining, timeoutMs, prev, next, scribble } = item;
        switch (scribble.state) {
          case "active": {
            if (next && next !== prev) {
              item.prev = next;
              scribble.points.push(next);
              if (delayRemaining === 0) {
                if (scribble.points.length > 8) {
                  scribble.points.shift();
                }
              }
            } else {
              if (timeoutMs === 0) {
                if (scribble.points.length > 1) {
                  scribble.points.shift();
                } else {
                  item.delayRemaining = scribble.delay;
                }
              }
            }
            break;
          }
          case "stopping": {
            if (item.delayRemaining === 0) {
              if (timeoutMs === 0) {
                if (scribble.points.length === 1) {
                  this.scribbleItems.delete(item.id);
                  return;
                }
                if (scribble.shrink) {
                  scribble.size = Math.max(1, scribble.size * (1 - scribble.shrink));
                }
                scribble.points.shift();
              }
            }
            break;
          }
        }
      });
      this.editor.updateInstanceState({
        scribbles: Array.from(this.scribbleItems.values()).map(({ scribble }) => ({
          ...scribble,
          points: [...scribble.points]
        })).slice(-5)
        // limit to three as a minor sanity check
      });
    });
  }
}
var __create$8 = Object.create;
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __knownSymbol$8 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$8 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$8 = (base2) => [, , , __create$8(null)];
var __decoratorStrings$8 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$8 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$8("Function expected") : fn;
var __decoratorContext$8 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$8[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$8("Already initialized") : fns.push(__expectFn$8(fn || null)) });
var __decoratorMetadata$8 = (array2, target) => __defNormalProp$8(target, __knownSymbol$8("metadata"), array2[3]);
var __runInitializers$8 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$8 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$8[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$8(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$8(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$8(it) && (desc[key] = it);
  }
  return desc && __defProp$8(target, name, desc), target;
};
var __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, key + "", value);
var _getVisibleGaps_dec, _getSnappableGapNodes_dec, _getSnappablePoints_dec, _getSnapPointsCache_dec, _init$8;
const round$1 = (x) => {
  const decimalPlacesTolerance = 8;
  return Math.round(x * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance;
};
function findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection) {
  const matches2 = gaps.filter(
    (gap) => (direction === "forward" ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) && round$1(gap.length) === round$1(gapLength) && rangeIntersection(
      gap.breadthIntersection[0],
      gap.breadthIntersection[1],
      intersection[0],
      intersection[1]
    )
  );
  if (matches2.length === 0) return [];
  const nextNodes = /* @__PURE__ */ new Set();
  matches2.forEach((match) => {
    const node = direction === "forward" ? match.endNode.id : match.startNode.id;
    if (!nextNodes.has(node)) {
      nextNodes.add(node);
      const foundGaps = findAdjacentGaps(
        gaps,
        node,
        gapLength,
        direction,
        rangeIntersection(
          match.breadthIntersection[0],
          match.breadthIntersection[1],
          intersection[0],
          intersection[1]
        )
      );
      matches2.push(...foundGaps);
    }
  });
  return matches2;
}
function dedupeGapSnaps(snaps) {
  snaps.sort((a2, b) => b.gaps.length - a2.gaps.length);
  for (let i = snaps.length - 1; i > 0; i--) {
    const snap = snaps[i];
    for (let j = i - 1; j >= 0; j--) {
      const otherSnap = snaps[j];
      if (otherSnap.direction === snap.direction && snap.gaps.every(
        (gap) => otherSnap.gaps.some(
          (otherGap) => round$1(gap.startEdge[0].x) === round$1(otherGap.startEdge[0].x) && round$1(gap.startEdge[0].y) === round$1(otherGap.startEdge[0].y) && round$1(gap.startEdge[1].x) === round$1(otherGap.startEdge[1].x) && round$1(gap.startEdge[1].y) === round$1(otherGap.startEdge[1].y)
        ) && otherSnap.gaps.some(
          (otherGap) => round$1(gap.endEdge[0].x) === round$1(otherGap.endEdge[0].x) && round$1(gap.endEdge[0].y) === round$1(otherGap.endEdge[0].y) && round$1(gap.endEdge[1].x) === round$1(otherGap.endEdge[1].x) && round$1(gap.endEdge[1].y) === round$1(otherGap.endEdge[1].y)
        )
      )) {
        snaps.splice(i, 1);
        break;
      }
    }
  }
}
_getSnapPointsCache_dec = [computed], _getSnappablePoints_dec = [computed], _getSnappableGapNodes_dec = [computed], _getVisibleGaps_dec = [computed];
class BoundsSnaps {
  constructor(manager) {
    this.manager = manager;
    __runInitializers$8(_init$8, 5, this);
    __publicField$8(this, "editor");
    this.editor = manager.editor;
  }
  getSnapPointsCache() {
    const { editor } = this;
    return editor.store.createComputedCache("snapPoints", (shape) => {
      const pageTransform = editor.getShapePageTransform(shape.id);
      if (!pageTransform) return void 0;
      const boundsSnapGeometry = editor.getShapeUtil(shape).getBoundsSnapGeometry(shape);
      const snapPoints = boundsSnapGeometry.points ?? editor.getShapeGeometry(shape).bounds.cornersAndCenter;
      if (!pageTransform || !snapPoints) return void 0;
      return snapPoints.map((point, i) => {
        const { x, y: y2 } = Mat.applyToPoint(pageTransform, point);
        return { x, y: y2, id: `${shape.id}:${i}` };
      });
    });
  }
  getSnapPoints(shapeId) {
    return this.getSnapPointsCache().get(shapeId) ?? [];
  }
  getSnappablePoints() {
    const snapPointsCache = this.getSnapPointsCache();
    const snappableShapes = this.manager.getSnappableShapes();
    const result = [];
    for (const shapeId of snappableShapes) {
      const snapPoints = snapPointsCache.get(shapeId);
      if (snapPoints) {
        result.push(...snapPoints);
      }
    }
    return result;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (shapeId) => ({
      id: shapeId,
      pageBounds: assertExists(this.editor.getShapePageBounds(shapeId))
    }));
  }
  getVisibleGaps() {
    const horizontal = [];
    const vertical = [];
    let startNode, endNode;
    const sortedShapesOnCurrentPageHorizontal = this.getSnappableGapNodes().sort((a2, b) => {
      return a2.pageBounds.minX - b.pageBounds.minX;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageHorizontal.length; i++) {
      startNode = sortedShapesOnCurrentPageHorizontal[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageHorizontal.length; j++) {
        endNode = sortedShapesOnCurrentPageHorizontal[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxX < endNode.pageBounds.minX && // and they overlap in the y axis
          rangesOverlap(
            startNode.pageBounds.minY,
            startNode.pageBounds.maxY,
            endNode.pageBounds.minY,
            endNode.pageBounds.maxY
          )
        ) {
          horizontal.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.minY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.maxY)
            ],
            length: endNode.pageBounds.minX - startNode.pageBounds.maxX,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minY,
              startNode.pageBounds.maxY,
              endNode.pageBounds.minY,
              endNode.pageBounds.maxY
            )
          });
        }
      }
    }
    const sortedShapesOnCurrentPageVertical = sortedShapesOnCurrentPageHorizontal.sort((a2, b) => {
      return a2.pageBounds.minY - b.pageBounds.minY;
    });
    for (let i = 0; i < sortedShapesOnCurrentPageVertical.length; i++) {
      startNode = sortedShapesOnCurrentPageVertical[i];
      for (let j = i + 1; j < sortedShapesOnCurrentPageVertical.length; j++) {
        endNode = sortedShapesOnCurrentPageVertical[j];
        if (
          // is there space between the boxes
          startNode.pageBounds.maxY < endNode.pageBounds.minY && // do they overlap in the x axis
          rangesOverlap(
            startNode.pageBounds.minX,
            startNode.pageBounds.maxX,
            endNode.pageBounds.minX,
            endNode.pageBounds.maxX
          )
        ) {
          vertical.push({
            startNode,
            endNode,
            startEdge: [
              new Vec(startNode.pageBounds.minX, startNode.pageBounds.maxY),
              new Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
            ],
            endEdge: [
              new Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),
              new Vec(endNode.pageBounds.maxX, endNode.pageBounds.minY)
            ],
            length: endNode.pageBounds.minY - startNode.pageBounds.maxY,
            breadthIntersection: rangeIntersection(
              startNode.pageBounds.minX,
              startNode.pageBounds.maxX,
              endNode.pageBounds.minX,
              endNode.pageBounds.maxX
            )
          });
        }
      }
    }
    return { horizontal, vertical };
  }
  snapTranslateShapes({
    lockedAxis,
    initialSelectionPageBounds,
    initialSelectionSnapPoints,
    dragDelta
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    const visibleSnapPointsNotInSelection = this.getSnappablePoints();
    const selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta);
    const selectionSnapPoints = initialSelectionSnapPoints.map(
      ({ x, y: y2 }, i) => ({
        id: "selection:" + i,
        x: x + dragDelta.x,
        y: y2 + dragDelta.y
      })
    );
    const otherNodeSnapPoints = visibleSnapPointsNotInSelection;
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const nudge = new Vec(
      lockedAxis === "x" ? 0 : nearestSnapsX[0]?.nudge ?? 0,
      lockedAxis === "y" ? 0 : nearestSnapsY[0]?.nudge ?? 0
    );
    minOffset.x = 0;
    minOffset.y = 0;
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    selectionSnapPoints.forEach((s2) => {
      s2.x += nudge.x;
      s2.y += nudge.y;
    });
    selectionPageBounds.translate(nudge);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    this.collectGapSnaps({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY,
      minOffset
    });
    const pointSnapsLines = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    const gapSnapLines = this.getGapSnapLines({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...gapSnapLines, ...pointSnapsLines]);
    return { nudge };
  }
  snapResizeShapes({
    initialSelectionPageBounds,
    dragDelta,
    handle: originalHandle,
    isAspectRatioLocked,
    isResizingFromCenter
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    const {
      box: unsnappedResizedPageBounds,
      scaleX,
      scaleY
    } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,
      isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,
      isAspectRatioLocked
    );
    let handle = originalHandle;
    if (scaleX < 0) {
      handle = flipSelectionHandleX(handle);
    }
    if (scaleY < 0) {
      handle = flipSelectionHandleY(handle);
    }
    if (isResizingFromCenter) {
      unsnappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const isXLocked = handle === "top" || handle === "bottom";
    const isYLocked = handle === "left" || handle === "right";
    const selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds);
    const otherNodeSnapPoints = this.getSnappablePoints();
    const nearestSnapsX = [];
    const nearestSnapsY = [];
    const minOffset = new Vec(snapThreshold, snapThreshold);
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints
    });
    const nudge = new Vec(
      isXLocked ? 0 : nearestSnapsX[0]?.nudge ?? 0,
      isYLocked ? 0 : nearestSnapsY[0]?.nudge ?? 0
    );
    if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {
      const primaryNudgeAxis = nearestSnapsX.length && nearestSnapsY.length ? Math.abs(nudge.x) < Math.abs(nudge.y) ? "x" : "y" : nearestSnapsX.length ? "x" : "y";
      const ratio = initialSelectionPageBounds.aspectRatio;
      if (primaryNudgeAxis === "x") {
        nearestSnapsY.length = 0;
        nudge.y = nudge.x / ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.y = -nudge.y;
        }
      } else {
        nearestSnapsX.length = 0;
        nudge.x = nudge.y * ratio;
        if (handle === "bottom_left" || handle === "top_right") {
          nudge.x = -nudge.x;
        }
      }
    }
    const snappedDelta = Vec.Add(dragDelta, nudge);
    const { box: snappedResizedPageBounds } = Box.Resize(
      initialSelectionPageBounds,
      originalHandle,
      isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,
      isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,
      isAspectRatioLocked
    );
    if (isResizingFromCenter) {
      snappedResizedPageBounds.center = initialSelectionPageBounds.center;
    }
    const snappedSelectionPoints = getResizeSnapPointsForHandle("any", snappedResizedPageBounds);
    nearestSnapsX.length = 0;
    nearestSnapsY.length = 0;
    minOffset.x = 0;
    minOffset.y = 0;
    this.collectPointSnaps({
      minOffset,
      nearestSnapsX,
      nearestSnapsY,
      otherNodeSnapPoints,
      selectionSnapPoints: snappedSelectionPoints
    });
    const pointSnaps = this.getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    });
    this.manager.setIndicators([...pointSnaps]);
    return { nudge };
  }
  collectPointSnaps({
    selectionSnapPoints,
    otherNodeSnapPoints,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    for (const thisSnapPoint of selectionSnapPoints) {
      for (const otherSnapPoint of otherNodeSnapPoints) {
        const offset2 = Vec.Sub(thisSnapPoint, otherSnapPoint);
        const offsetX = Math.abs(offset2.x);
        const offsetY = Math.abs(offset2.y);
        if (round$1(offsetX) <= round$1(minOffset.x)) {
          if (round$1(offsetX) < round$1(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          nearestSnapsX.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.x - thisSnapPoint.x
          });
          minOffset.x = offsetX;
        }
        if (round$1(offsetY) <= round$1(minOffset.y)) {
          if (round$1(offsetY) < round$1(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          nearestSnapsY.push({
            type: "points",
            points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
            nudge: otherSnapPoint.y - thisSnapPoint.y
          });
          minOffset.y = offsetY;
        }
      }
    }
  }
  collectGapSnaps({
    selectionPageBounds,
    minOffset,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { horizontal, vertical } = this.getVisibleGaps();
    for (const gap of horizontal) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minY,
        selectionPageBounds.maxY
      )) {
        continue;
      }
      const gapMidX = gap.startEdge[0].x + gap.length / 2;
      const centerNudge = gapMidX - selectionPageBounds.center.x;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.width;
      if (gapIsLargerThanSelection && round$1(Math.abs(centerNudge)) <= round$1(minOffset.x)) {
        if (round$1(Math.abs(centerNudge)) < round$1(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsX.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangeIntersection(
          gap.breadthIntersection[0],
          gap.breadthIntersection[1],
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsX.push(snap);
        }
      }
      const duplicationLeftX = gap.startNode.pageBounds.minX - gap.length;
      const selectionRightX = selectionPageBounds.maxX;
      const duplicationLeftNudge = duplicationLeftX - selectionRightX;
      if (round$1(Math.abs(duplicationLeftNudge)) <= round$1(minOffset.x)) {
        if (round$1(Math.abs(duplicationLeftNudge)) < round$1(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationLeftNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "left",
          nudge: duplicationLeftNudge
        });
      }
      const duplicationRightX = gap.endNode.pageBounds.maxX + gap.length;
      const selectionLeftX = selectionPageBounds.minX;
      const duplicationRightNudge = duplicationRightX - selectionLeftX;
      if (round$1(Math.abs(duplicationRightNudge)) <= round$1(minOffset.x)) {
        if (round$1(Math.abs(duplicationRightNudge)) < round$1(minOffset.x)) {
          nearestSnapsX.length = 0;
        }
        minOffset.x = Math.abs(duplicationRightNudge);
        nearestSnapsX.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "right",
          nudge: duplicationRightNudge
        });
      }
    }
    for (const gap of vertical) {
      if (!rangesOverlap(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        selectionPageBounds.minX,
        selectionPageBounds.maxX
      )) {
        continue;
      }
      const gapMidY = gap.startEdge[0].y + gap.length / 2;
      const centerNudge = gapMidY - selectionPageBounds.center.y;
      const gapIsLargerThanSelection = gap.length > selectionPageBounds.height;
      if (gapIsLargerThanSelection && round$1(Math.abs(centerNudge)) <= round$1(minOffset.y)) {
        if (round$1(Math.abs(centerNudge)) < round$1(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(centerNudge);
        const snap = {
          type: "gap_center",
          gap,
          nudge: centerNudge
        };
        const otherCenterSnap = nearestSnapsY.find(({ type }) => type === "gap_center");
        const gapBreadthsOverlap = otherCenterSnap && rangesOverlap(
          otherCenterSnap.gap.breadthIntersection[0],
          otherCenterSnap.gap.breadthIntersection[1],
          gap.breadthIntersection[0],
          gap.breadthIntersection[1]
        );
        if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
          nearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap;
        } else if (!otherCenterSnap || !gapBreadthsOverlap) {
          nearestSnapsY.push(snap);
        }
        continue;
      }
      const duplicationTopY = gap.startNode.pageBounds.minY - gap.length;
      const selectionBottomY = selectionPageBounds.maxY;
      const duplicationTopNudge = duplicationTopY - selectionBottomY;
      if (round$1(Math.abs(duplicationTopNudge)) <= round$1(minOffset.y)) {
        if (round$1(Math.abs(duplicationTopNudge)) < round$1(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationTopNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "top",
          nudge: duplicationTopNudge
        });
      }
      const duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length;
      const selectionTopY = selectionPageBounds.minY;
      const duplicationBottomNudge = duplicationBottomY - selectionTopY;
      if (round$1(Math.abs(duplicationBottomNudge)) <= round$1(minOffset.y)) {
        if (round$1(Math.abs(duplicationBottomNudge)) < round$1(minOffset.y)) {
          nearestSnapsY.length = 0;
        }
        minOffset.y = Math.abs(duplicationBottomNudge);
        nearestSnapsY.push({
          type: "gap_duplicate",
          gap,
          protrusionDirection: "bottom",
          nudge: duplicationBottomNudge
        });
      }
    }
  }
  getPointSnapLines({
    nearestSnapsX,
    nearestSnapsY
  }) {
    const snapGroupsX = {};
    const snapGroupsY = {};
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") {
          const key = round$1(snap.points.otherPoint.x);
          if (!snapGroupsX[key]) {
            snapGroupsX[key] = [];
          }
          snapGroupsX[key].push(snap.points);
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") {
          const key = round$1(snap.points.otherPoint.y);
          if (!snapGroupsY[key]) {
            snapGroupsY[key] = [];
          }
          snapGroupsY[key].push(snap.points);
        }
      }
    }
    return Object.values(snapGroupsX).concat(Object.values(snapGroupsY)).map((snapGroup) => ({
      id: uniqueId(),
      type: "points",
      points: dedupe(
        snapGroup.map((snap) => Vec.From(snap.otherPoint)).concat(snapGroup.map((snap) => Vec.From(snap.thisPoint))),
        (a2, b) => a2.equals(b)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds,
    nearestSnapsX,
    nearestSnapsY
  }) {
    const { vertical, horizontal } = this.getVisibleGaps();
    const selectionSides = {
      top: selectionPageBounds.sides[0],
      right: selectionPageBounds.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],
      left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]]
    };
    const result = [];
    if (nearestSnapsX.length > 0) {
      for (const snap of nearestSnapsX) {
        if (snap.type === "points") continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.width) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.left
                },
                {
                  startEdge: selectionSides.right,
                  endEdge
                },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: snap.protrusionDirection === "left" ? [
                {
                  startEdge: selectionSides.right,
                  endEdge: startEdge.map(
                    (v) => v.clone().addXY(-startNode.pageBounds.width, 0)
                  )
                },
                { startEdge, endEdge },
                ...findAdjacentGaps(
                  horizontal,
                  endNode.id,
                  length,
                  "forward",
                  gapBreadthIntersection
                )
              ] : [
                ...findAdjacentGaps(
                  horizontal,
                  startNode.id,
                  length,
                  "backward",
                  gapBreadthIntersection
                ),
                { startEdge, endEdge },
                {
                  startEdge: endEdge.map(
                    (v) => v.clone().addXY(snap.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: selectionSides.left
                }
              ]
            });
            break;
          }
        }
      }
    }
    if (nearestSnapsY.length > 0) {
      for (const snap of nearestSnapsY) {
        if (snap.type === "points") continue;
        const {
          gap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge }
        } = snap;
        switch (snap.type) {
          case "gap_center": {
            const newGapsLength = (length - selectionPageBounds.height) / 2;
            const gapBreadthIntersection = rangeIntersection(
              breadthIntersection[0],
              breadthIntersection[1],
              selectionPageBounds.minX,
              selectionPageBounds.maxX
            );
            result.push({
              type: "gaps",
              direction: "vertical",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  vertical,
                  startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge,
                  endEdge: selectionSides.top
                },
                {
                  startEdge: selectionSides.bottom,
                  endEdge
                },
                ...findAdjacentGaps(
                  vertical,
                  snap.gap.endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const gapBreadthIntersection = rangeIntersection(
                breadthIntersection[0],
                breadthIntersection[1],
                selectionPageBounds.minX,
                selectionPageBounds.maxX
              );
              result.push({
                type: "gaps",
                direction: "vertical",
                id: uniqueId(),
                gaps: snap.protrusionDirection === "top" ? [
                  {
                    startEdge: selectionSides.bottom,
                    endEdge: startEdge.map(
                      (v) => v.clone().addXY(0, -startNode.pageBounds.height)
                    )
                  },
                  { startEdge, endEdge },
                  ...findAdjacentGaps(
                    vertical,
                    endNode.id,
                    length,
                    "forward",
                    gapBreadthIntersection
                  )
                ] : [
                  ...findAdjacentGaps(
                    vertical,
                    startNode.id,
                    length,
                    "backward",
                    gapBreadthIntersection
                  ),
                  { startEdge, endEdge },
                  {
                    startEdge: endEdge.map(
                      (v) => v.clone().addXY(0, endNode.pageBounds.height)
                    ),
                    endEdge: selectionSides.top
                  }
                ]
              });
            }
            break;
        }
      }
    }
    dedupeGapSnaps(result);
    return result;
  }
}
_init$8 = __decoratorStart$8();
__decorateElement$8(_init$8, 1, "getSnapPointsCache", _getSnapPointsCache_dec, BoundsSnaps);
__decorateElement$8(_init$8, 1, "getSnappablePoints", _getSnappablePoints_dec, BoundsSnaps);
__decorateElement$8(_init$8, 1, "getSnappableGapNodes", _getSnappableGapNodes_dec, BoundsSnaps);
__decorateElement$8(_init$8, 1, "getVisibleGaps", _getVisibleGaps_dec, BoundsSnaps);
__decoratorMetadata$8(_init$8, BoundsSnaps);
function getResizeSnapPointsForHandle(handle, selectionPageBounds) {
  const { minX, maxX, minY, maxY } = selectionPageBounds;
  const result = [];
  switch (handle) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      result.push({
        id: "top_left",
        handle: "top_left",
        x: minX,
        y: minY
      });
  }
  switch (handle) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      result.push({
        id: "top_right",
        handle: "top_right",
        x: maxX,
        y: minY
      });
  }
  switch (handle) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      result.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: maxX,
        y: maxY
      });
  }
  switch (handle) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      result.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: minX,
        y: maxY
      });
  }
  return result;
}
var __create$7 = Object.create;
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __knownSymbol$7 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$7 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$7 = (base2) => [, , , __create$7(null)];
var __decoratorStrings$7 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$7 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$7("Function expected") : fn;
var __decoratorContext$7 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$7[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$7("Already initialized") : fns.push(__expectFn$7(fn || null)) });
var __decoratorMetadata$7 = (array2, target) => __defNormalProp$7(target, __knownSymbol$7("metadata"), array2[3]);
var __runInitializers$7 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$7 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$7[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$7(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$7(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$7(it) && (desc[key] = it);
  }
  return desc && __defProp$7(target, name, desc), target;
};
var __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, key + "", value);
var _getSnapGeometryCache_dec, _init$7;
const defaultGetSelfSnapOutline = () => null;
const defaultGetSelfSnapPoints = () => [];
_getSnapGeometryCache_dec = [computed];
class HandleSnaps {
  constructor(manager) {
    this.manager = manager;
    __runInitializers$7(_init$7, 5, this);
    __publicField$7(this, "editor");
    this.editor = manager.editor;
  }
  getSnapGeometryCache() {
    const { editor } = this;
    return editor.store.createComputedCache("handle snap geometry", (shape) => {
      const snapGeometry = editor.getShapeUtil(shape).getHandleSnapGeometry(shape);
      const getSelfSnapOutline = snapGeometry.getSelfSnapOutline ? snapGeometry.getSelfSnapOutline.bind(snapGeometry) : defaultGetSelfSnapOutline;
      const getSelfSnapPoints = snapGeometry.getSelfSnapPoints ? snapGeometry.getSelfSnapPoints.bind(snapGeometry) : defaultGetSelfSnapPoints;
      return {
        outline: snapGeometry.outline === void 0 ? editor.getShapeGeometry(shape) : snapGeometry.outline,
        points: snapGeometry.points ?? [],
        getSelfSnapOutline,
        getSelfSnapPoints
      };
    });
  }
  *iterateSnapPointsInPageSpace(currentShapeId, currentHandle) {
    const selfSnapPoints = this.getSnapGeometryCache().get(currentShapeId)?.getSelfSnapPoints(currentHandle);
    if (selfSnapPoints && selfSnapPoints.length) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
      for (const point of selfSnapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId) continue;
      const snapPoints = this.getSnapGeometryCache().get(shapeId)?.points;
      if (!snapPoints || !snapPoints.length) continue;
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      for (const point of snapPoints) {
        yield shapePageTransform.applyToPoint(point);
      }
    }
  }
  *iterateSnapOutlines(currentShapeId, currentHandle) {
    const selfSnapOutline = this.getSnapGeometryCache().get(currentShapeId)?.getSelfSnapOutline(currentHandle);
    if (selfSnapOutline) {
      yield { shapeId: currentShapeId, outline: selfSnapOutline };
    }
    for (const shapeId of this.manager.getSnappableShapes()) {
      if (shapeId === currentShapeId) continue;
      const snapOutline = this.getSnapGeometryCache().get(shapeId)?.outline;
      if (!snapOutline) continue;
      yield { shapeId, outline: snapOutline };
    }
  }
  getHandleSnapPosition({
    currentShapeId,
    handle,
    handleInPageSpace
  }) {
    const snapThreshold = this.manager.getSnapThreshold();
    let minDistanceForSnapPoint = snapThreshold;
    let nearestSnapPoint = null;
    for (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {
      if (Vec.DistMin(handleInPageSpace, snapPoint, minDistanceForSnapPoint)) {
        minDistanceForSnapPoint = Vec.Dist(handleInPageSpace, snapPoint);
        nearestSnapPoint = snapPoint;
      }
    }
    if (nearestSnapPoint) return nearestSnapPoint;
    let minDistanceForOutline = snapThreshold;
    let nearestPointOnOutline = null;
    for (const { shapeId, outline } of this.iterateSnapOutlines(currentShapeId, handle)) {
      const shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId));
      const pointInShapeSpace = this.editor.getPointInShapeSpace(shapeId, handleInPageSpace);
      const nearestShapePointInShapeSpace = outline.nearestPoint(pointInShapeSpace);
      const nearestInPageSpace = shapePageTransform.applyToPoint(nearestShapePointInShapeSpace);
      if (Vec.DistMin(handleInPageSpace, nearestInPageSpace, minDistanceForOutline)) {
        minDistanceForOutline = Vec.Dist(handleInPageSpace, nearestInPageSpace);
        nearestPointOnOutline = nearestInPageSpace;
      }
    }
    if (nearestPointOnOutline) return nearestPointOnOutline;
    return null;
  }
  snapHandle({
    currentShapeId,
    handle
  }) {
    const currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId));
    const handleInPageSpace = currentShapeTransform.applyToPoint(handle);
    const snapPosition = this.getHandleSnapPosition({ currentShapeId, handle, handleInPageSpace });
    if (snapPosition) {
      this.manager.setIndicators([
        {
          id: uniqueId(),
          type: "points",
          points: [snapPosition]
        }
      ]);
      return { nudge: Vec.Sub(snapPosition, handleInPageSpace) };
    }
    return null;
  }
}
_init$7 = __decoratorStart$7();
__decorateElement$7(_init$7, 1, "getSnapGeometryCache", _getSnapGeometryCache_dec, HandleSnaps);
__decoratorMetadata$7(_init$7, HandleSnaps);
var __create$6 = Object.create;
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __knownSymbol$6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$6 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$6 = (base2) => [, , , __create$6(null)];
var __decoratorStrings$6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$6 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$6("Function expected") : fn;
var __decoratorContext$6 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$6[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$6("Already initialized") : fns.push(__expectFn$6(fn || null)) });
var __decoratorMetadata$6 = (array2, target) => __defNormalProp$6(target, __knownSymbol$6("metadata"), array2[3]);
var __runInitializers$6 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$6 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$6[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$6(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$6(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$6(it) && (desc[key] = it);
  }
  return desc && __defProp$6(target, name, desc), target;
};
var __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
var _getCurrentCommonAncestor_dec, _getSnappableShapes_dec, _getSnapThreshold_dec, _init$6;
_getSnapThreshold_dec = [computed], _getSnappableShapes_dec = [computed], _getCurrentCommonAncestor_dec = [computed];
class SnapManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$6(_init$6, 5, this);
    __publicField$6(this, "shapeBounds");
    __publicField$6(this, "handles");
    __publicField$6(this, "_snapIndicators", atom("snapLines", void 0));
    this.shapeBounds = new BoundsSnaps(this);
    this.handles = new HandleSnaps(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? EMPTY_ARRAY;
  }
  clearIndicators() {
    if (this.getIndicators().length) {
      this._snapIndicators.set(void 0);
    }
  }
  setIndicators(indicators) {
    this._snapIndicators.set(indicators);
  }
  getSnapThreshold() {
    return 8 / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor } = this;
    const renderingBounds = editor.getViewportPageBounds();
    const selectedShapeIds = editor.getSelectedShapeIds();
    const snappableShapes = /* @__PURE__ */ new Set();
    const collectSnappableShapesFromParent = (parentId) => {
      if (isShapeId(parentId)) {
        const parent = editor.getShape(parentId);
        if (parent && editor.isShapeOfType(parent, "frame")) {
          snappableShapes.add(parentId);
        }
      }
      const sortedChildIds = editor.getSortedChildIdsForParent(parentId);
      for (const childId of sortedChildIds) {
        if (selectedShapeIds.includes(childId)) continue;
        const childShape = editor.getShape(childId);
        if (!childShape) continue;
        const util2 = editor.getShapeUtil(childShape);
        if (!util2.canSnap(childShape)) continue;
        const pageBounds = editor.getShapePageBounds(childId);
        if (!(pageBounds && renderingBounds.includes(pageBounds))) continue;
        if (editor.isShapeOfType(childShape, "group")) {
          collectSnappableShapesFromParent(childId);
          continue;
        }
        snappableShapes.add(childId);
      }
    };
    collectSnappableShapesFromParent(this.getCurrentCommonAncestor() ?? editor.getCurrentPageId());
    return snappableShapes;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
}
_init$6 = __decoratorStart$6();
__decorateElement$6(_init$6, 1, "getSnapThreshold", _getSnapThreshold_dec, SnapManager);
__decorateElement$6(_init$6, 1, "getSnappableShapes", _getSnappableShapes_dec, SnapManager);
__decorateElement$6(_init$6, 1, "getCurrentCommonAncestor", _getCurrentCommonAncestor_dec, SnapManager);
__decoratorMetadata$6(_init$6, SnapManager);
const fixNewLines = /\r?\n|\r/g;
function normalizeTextForDom(text) {
  return text.replace(fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
}
const textAlignmentsForLtr = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
};
const spaceCharacterRegex = /\s/;
class TextManager {
  constructor(editor) {
    this.editor = editor;
    this.baseElem = document.createElement("div");
    this.baseElem.classList.add("tl-text");
    this.baseElem.classList.add("tl-text-measure");
    this.baseElem.tabIndex = -1;
  }
  baseElem;
  measureText(textToMeasure, opts) {
    const div = document.createElement("div");
    div.textContent = normalizeTextForDom(textToMeasure);
    return this.measureHtml(div.innerHTML, opts);
  }
  measureHtml(html2, opts) {
    const wrapperElm = this.baseElem.cloneNode();
    this.editor.getContainer().appendChild(wrapperElm);
    wrapperElm.innerHTML = html2;
    this.baseElem.insertAdjacentElement("afterend", wrapperElm);
    wrapperElm.setAttribute("dir", "auto");
    wrapperElm.style.setProperty("unicode-bidi", "plaintext");
    wrapperElm.style.setProperty("font-family", opts.fontFamily);
    wrapperElm.style.setProperty("font-style", opts.fontStyle);
    wrapperElm.style.setProperty("font-weight", opts.fontWeight);
    wrapperElm.style.setProperty("font-size", opts.fontSize + "px");
    wrapperElm.style.setProperty("line-height", opts.lineHeight * opts.fontSize + "px");
    wrapperElm.style.setProperty("max-width", opts.maxWidth === null ? null : opts.maxWidth + "px");
    wrapperElm.style.setProperty("min-width", opts.minWidth === null ? null : opts.minWidth + "px");
    wrapperElm.style.setProperty("padding", opts.padding);
    wrapperElm.style.setProperty(
      "overflow-wrap",
      opts.disableOverflowWrapBreaking ? "normal" : "break-word"
    );
    if (opts.otherStyles) {
      for (const [key, value] of Object.entries(opts.otherStyles)) {
        wrapperElm.style.setProperty(key, value);
      }
    }
    const scrollWidth = wrapperElm.scrollWidth;
    const rect = wrapperElm.getBoundingClientRect();
    wrapperElm.remove();
    return {
      x: 0,
      y: 0,
      w: rect.width,
      h: rect.height,
      scrollWidth
    };
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(element, { shouldTruncateToFirstLine = false } = {}) {
    const spans = [];
    const elmBounds = element.getBoundingClientRect();
    const offsetX = -elmBounds.left;
    const offsetY = -elmBounds.top;
    const range = new Range();
    const textNode = element.childNodes[0];
    let idx = 0;
    let currentSpan = null;
    let prevCharWasSpaceCharacter = null;
    let prevCharTop = 0;
    let prevCharLeftForRTLTest = 0;
    let didTruncate = false;
    for (const childNode of element.childNodes) {
      if (childNode.nodeType !== Node.TEXT_NODE) continue;
      for (const char of childNode.textContent ?? "") {
        range.setStart(textNode, idx);
        range.setEnd(textNode, idx + char.length);
        const rects = range.getClientRects();
        const rect = rects[rects.length - 1];
        const top = rect.top + offsetY;
        const left = rect.left + offsetX;
        const right = rect.right + offsetX;
        const isRTL2 = left < prevCharLeftForRTLTest;
        const isSpaceCharacter = spaceCharacterRegex.test(char);
        if (
          // If we're at a word boundary...
          isSpaceCharacter !== prevCharWasSpaceCharacter || // ...or we're on a different line...
          top !== prevCharTop || // ...or we're at the start of the text and haven't created a span yet...
          !currentSpan
        ) {
          if (currentSpan) {
            if (shouldTruncateToFirstLine && top !== prevCharTop) {
              didTruncate = true;
              break;
            }
            spans.push(currentSpan);
          }
          currentSpan = {
            box: { x: left, y: top, w: rect.width, h: rect.height },
            text: char
          };
          prevCharLeftForRTLTest = left;
        } else {
          if (isRTL2) {
            currentSpan.box.x = left;
          }
          currentSpan.box.w = isRTL2 ? currentSpan.box.w + rect.width : right - currentSpan.box.x;
          currentSpan.text += char;
        }
        if (char === "\n") {
          prevCharLeftForRTLTest = 0;
        }
        prevCharWasSpaceCharacter = isSpaceCharacter;
        prevCharTop = top;
        idx += char.length;
      }
    }
    if (currentSpan) {
      spans.push(currentSpan);
    }
    return { spans, didTruncate };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(textToMeasure, opts) {
    if (textToMeasure === "") return [];
    const elm = this.baseElem.cloneNode();
    this.editor.getContainer().appendChild(elm);
    const elementWidth = Math.ceil(opts.width - opts.padding * 2);
    elm.setAttribute("dir", "auto");
    elm.style.setProperty("unicode-bidi", "plaintext");
    elm.style.setProperty("width", `${elementWidth}px`);
    elm.style.setProperty("height", "min-content");
    elm.style.setProperty("font-size", `${opts.fontSize}px`);
    elm.style.setProperty("font-family", opts.fontFamily);
    elm.style.setProperty("font-weight", opts.fontWeight);
    elm.style.setProperty("line-height", `${opts.lineHeight * opts.fontSize}px`);
    elm.style.setProperty("text-align", textAlignmentsForLtr[opts.textAlign]);
    elm.style.setProperty("font-style", opts.fontStyle);
    if (opts.otherStyles) {
      for (const [key, value] of Object.entries(opts.otherStyles)) {
        elm.style.setProperty(key, value);
      }
    }
    const shouldTruncateToFirstLine = opts.overflow === "truncate-ellipsis" || opts.overflow === "truncate-clip";
    if (shouldTruncateToFirstLine) {
      elm.style.setProperty("overflow-wrap", "anywhere");
      elm.style.setProperty("word-break", "break-all");
    }
    const normalizedText = normalizeTextForDom(textToMeasure);
    elm.textContent = normalizedText;
    const { spans, didTruncate } = this.measureElementTextNodeSpans(elm, {
      shouldTruncateToFirstLine
    });
    if (opts.overflow === "truncate-ellipsis" && didTruncate) {
      elm.textContent = "…";
      const ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(elm).spans[0].box.w);
      elm.style.setProperty("width", `${elementWidth - ellipsisWidth}px`);
      elm.textContent = normalizedText;
      const truncatedSpans = this.measureElementTextNodeSpans(elm, {
        shouldTruncateToFirstLine: true
      }).spans;
      const lastSpan = truncatedSpans[truncatedSpans.length - 1];
      truncatedSpans.push({
        text: "…",
        box: {
          x: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),
          y: lastSpan.box.y,
          w: ellipsisWidth,
          h: lastSpan.box.h
        }
      });
      return truncatedSpans;
    }
    elm.remove();
    return spans;
  }
}
var __create$5 = Object.create;
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __knownSymbol$5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$5 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$5 = (base2) => [, , , __create$5(null)];
var __decoratorStrings$5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$5 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$5("Function expected") : fn;
var __decoratorContext$5 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$5[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$5("Already initialized") : fns.push(__expectFn$5(fn || null)) });
var __decoratorMetadata$5 = (array2, target) => __defNormalProp$5(target, __knownSymbol$5("metadata"), array2[3]);
var __runInitializers$5 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$5 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$5[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$5(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$5(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$5(it) && (desc[key] = it);
  }
  return desc && __defProp$5(target, name, desc), target;
};
var __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
var _dispose_dec$1, _tick_dec, _init$5;
const throttleToNextFrame = throttleToNextFrame$1;
_tick_dec = [bind$1], _dispose_dec$1 = [bind$1];
class TickManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$5(_init$5, 5, this);
    __publicField$5(this, "cancelRaf");
    __publicField$5(this, "isPaused", true);
    __publicField$5(this, "now", 0);
    __publicField$5(this, "prevPoint", new Vec());
    this.editor.disposables.add(this.dispose);
    this.start();
  }
  start() {
    this.isPaused = false;
    this.cancelRaf?.();
    this.cancelRaf = throttleToNextFrame(this.tick);
    this.now = Date.now();
  }
  tick() {
    if (this.isPaused) {
      return;
    }
    const now = Date.now();
    const elapsed = now - this.now;
    this.now = now;
    this.updatePointerVelocity(elapsed);
    this.editor.emit("frame", elapsed);
    this.editor.emit("tick", elapsed);
    this.cancelRaf = throttleToNextFrame(this.tick);
  }
  dispose() {
    this.isPaused = true;
    this.cancelRaf?.();
  }
  updatePointerVelocity(elapsed) {
    const {
      prevPoint,
      editor: {
        inputs: { currentScreenPoint, pointerVelocity }
      }
    } = this;
    if (elapsed === 0) return;
    const delta = Vec.Sub(currentScreenPoint, prevPoint);
    this.prevPoint = currentScreenPoint.clone();
    const length = delta.len();
    const direction = length ? delta.div(length) : new Vec(0, 0);
    const next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5);
    if (Math.abs(next.x) < 0.01) next.x = 0;
    if (Math.abs(next.y) < 0.01) next.y = 0;
    if (!pointerVelocity.equals(next)) {
      this.editor.inputs.pointerVelocity = next;
    }
  }
}
_init$5 = __decoratorStart$5();
__decorateElement$5(_init$5, 1, "tick", _tick_dec, TickManager);
__decorateElement$5(_init$5, 1, "dispose", _dispose_dec$1, TickManager);
__decoratorMetadata$5(_init$5, TickManager);
var __create$4 = Object.create;
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __knownSymbol$4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$4 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$4 = (base2) => [, , , __create$4(null)];
var __decoratorStrings$4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$4("Function expected") : fn;
var __decoratorContext$4 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$4[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$4("Already initialized") : fns.push(__expectFn$4(fn || null)) });
var __decoratorMetadata$4 = (array2, target) => __defNormalProp$4(target, __knownSymbol$4("metadata"), array2[3]);
var __runInitializers$4 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$4 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$4[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$4(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$4(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$4(it) && (desc[key] = it);
  }
  return desc && __defProp$4(target, name, desc), target;
};
var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
var _getIsPasteAtCursorMode_dec, _getIsDynamicResizeMode_dec, _getIsWrapMode_dec, _getIsSnapMode_dec, _getColor_dec, _getLocale_dec, _getName_dec, _getId_dec, _getAnimationSpeed_dec, _getEdgeScrollSpeed_dec, _getIsDarkMode_dec, _getUserPreferences_dec, _init$4;
_getUserPreferences_dec = [computed], _getIsDarkMode_dec = [computed], _getEdgeScrollSpeed_dec = [computed], _getAnimationSpeed_dec = [computed], _getId_dec = [computed], _getName_dec = [computed], _getLocale_dec = [computed], _getColor_dec = [computed], _getIsSnapMode_dec = [computed], _getIsWrapMode_dec = [computed], _getIsDynamicResizeMode_dec = [computed], _getIsPasteAtCursorMode_dec = [computed];
class UserPreferencesManager {
  constructor(user, inferDarkMode) {
    this.user = user;
    this.inferDarkMode = inferDarkMode;
    __runInitializers$4(_init$4, 5, this);
    __publicField$4(this, "systemColorScheme", atom("systemColorScheme", "light"));
    __publicField$4(this, "disposables", /* @__PURE__ */ new Set());
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    const darkModeMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    if (darkModeMediaQuery?.matches) {
      this.systemColorScheme.set("dark");
    }
    const handleChange = (e) => {
      if (e.matches) {
        this.systemColorScheme.set("dark");
      } else {
        this.systemColorScheme.set("light");
      }
    };
    darkModeMediaQuery?.addEventListener("change", handleChange);
    this.disposables.add(() => darkModeMediaQuery?.removeEventListener("change", handleChange));
  }
  dispose() {
    this.disposables.forEach((d) => d());
  }
  updateUserPreferences(userPreferences) {
    this.user.setUserPreferences({
      ...this.user.userPreferences.get(),
      ...userPreferences
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return true;
      case "light":
        return false;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : false;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? defaultUserPreferences.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? defaultUserPreferences.animationSpeed;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    return this.user.userPreferences.get().name?.trim() ?? defaultUserPreferences.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? defaultUserPreferences.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? defaultUserPreferences.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? defaultUserPreferences.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? defaultUserPreferences.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? defaultUserPreferences.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? defaultUserPreferences.isPasteAtCursorMode;
  }
}
_init$4 = __decoratorStart$4();
__decorateElement$4(_init$4, 1, "getUserPreferences", _getUserPreferences_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsDarkMode", _getIsDarkMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getEdgeScrollSpeed", _getEdgeScrollSpeed_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getAnimationSpeed", _getAnimationSpeed_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getId", _getId_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getName", _getName_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getLocale", _getLocale_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getColor", _getColor_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsSnapMode", _getIsSnapMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsWrapMode", _getIsWrapMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsDynamicResizeMode", _getIsDynamicResizeMode_dec, UserPreferencesManager);
__decorateElement$4(_init$4, 1, "getIsPasteAtCursorMode", _getIsPasteAtCursorMode_dec, UserPreferencesManager);
__decoratorMetadata$4(_init$4, UserPreferencesManager);
const EVENT_NAME_MAP = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
};
const STATE_NODES_TO_MEASURE = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
class StateNode {
  constructor(editor, parent) {
    this.editor = editor;
    const { id, children, initial, isLockable, useCoalescedEvents } = this.constructor;
    this.id = id;
    this._isActive = atom("toolIsActive" + this.id, false);
    this._current = atom("toolState" + this.id, void 0);
    this._path = computed("toolPath" + this.id, () => {
      const current = this.getCurrent();
      return this.id + (current ? `.${current.getPath()}` : "");
    });
    this.parent = parent ?? {};
    if (this.parent) {
      if (children && initial) {
        this.type = "branch";
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      } else {
        this.type = "leaf";
      }
    } else {
      this.type = "root";
      if (children && initial) {
        this.initial = initial;
        this.children = Object.fromEntries(
          children().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])
        );
        this._current.set(this.children[this.initial]);
      }
    }
    this.isLockable = isLockable;
    this.useCoalescedEvents = useCoalescedEvents;
    this.performanceTracker = new PerformanceTracker();
  }
  performanceTracker;
  static id;
  static initial;
  static children;
  static isLockable = true;
  static useCoalescedEvents = false;
  id;
  type;
  shapeType;
  initial;
  children;
  isLockable;
  useCoalescedEvents;
  parent;
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  _path;
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  _current;
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  _isActive;
  /**
   * Transition to a new active child state node.
   *
   * @example
   * ```ts
   * parentState.transition('childStateA')
   * parentState.transition('childStateB', { myData: 4 })
   *```
   *
   * @param id - The id of the child state node to transition to.
   * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
   *
   * @public
   */
  transition(id, info = {}) {
    const path = id.split(".");
    let currState = this;
    for (let i = 0; i < path.length; i++) {
      const id2 = path[i];
      const prevChildState = currState.getCurrent();
      const nextChildState = currState.children?.[id2];
      if (!nextChildState) {
        throw Error(`${currState.id} - no child state exists with the id ${id2}.`);
      }
      if (prevChildState?.id !== nextChildState.id) {
        prevChildState?.exit(info, id2);
        currState._current.set(nextChildState);
        nextChildState.enter(info, prevChildState?.id || "initial");
        if (!nextChildState.getIsActive()) break;
      }
      currState = nextChildState;
    }
    return this;
  }
  handleEvent(info) {
    const cbName = EVENT_NAME_MAP[info.name];
    const currentActiveChild = this._current.__unsafe__getWithoutCapture();
    this[cbName]?.(info);
    if (this._isActive.__unsafe__getWithoutCapture() && currentActiveChild && currentActiveChild === this._current.__unsafe__getWithoutCapture()) {
      currentActiveChild.handleEvent(info);
    }
  }
  // todo: move this logic into transition
  enter(info, from2) {
    if (debugFlags.measurePerformance.get() && STATE_NODES_TO_MEASURE.includes(this.id)) {
      this.performanceTracker.start(this.id);
    }
    this._isActive.set(true);
    this.onEnter?.(info, from2);
    if (this.children && this.initial && this.getIsActive()) {
      const initial = this.children[this.initial];
      this._current.set(initial);
      initial.enter(info, from2);
    }
  }
  // todo: move this logic into transition
  exit(info, from2) {
    if (debugFlags.measurePerformance.get() && this.performanceTracker.isStarted()) {
      this.performanceTracker.stop();
    }
    this._isActive.set(false);
    this.onExit?.(info, from2);
    if (!this.getIsActive()) {
      this.getCurrent()?.exit(info, from2);
    }
  }
  /**
   * This is a hack / escape hatch that will tell the editor to
   * report a different state as active (in `getCurrentToolId()`) when
   * this state is active. This is usually used when a tool transitions
   * to a child of a different state for a certain interaction and then
   * returns to the original tool when that interaction completes; and
   * where we would want to show the original tool as active in the UI.
   *
   * @public
   */
  _currentToolIdMask = atom("curent tool id mask", void 0);
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(id) {
    this._currentToolIdMask.set(id);
  }
}
class RootState extends StateNode {
  static id = "root";
  static initial = "";
  static children() {
    return [];
  }
  onKeyDown(info) {
    switch (info.code) {
      case "KeyZ": {
        if (!(info.shiftKey || info.ctrlKey)) {
          const currentTool = this.getCurrent();
          if (currentTool && currentTool.getCurrent()?.id === "idle" && this.children["zoom"]) {
            this.editor.setCurrentTool("zoom", { ...info, onInteractionEnd: currentTool.id });
          }
        }
        break;
      }
    }
  }
}
var __create$3 = Object.create;
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __knownSymbol$3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$3 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$3 = (base2) => [, , , __create$3(base2?.[__knownSymbol$3("metadata")] ?? null)];
var __decoratorStrings$3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$3("Function expected") : fn;
var __decoratorContext$3 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$3[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$3("Already initialized") : fns.push(__expectFn$3(fn || null)) });
var __decoratorMetadata$3 = (array2, target) => __defNormalProp$3(target, __knownSymbol$3("metadata"), array2[3]);
var __runInitializers$3 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$3 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$3[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$3(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$3(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$3(it) && (desc[key] = it);
  }
  return desc && __defProp$3(target, name, desc), target;
};
var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
var __setMetaKeyTimeout_dec, __setCtrlKeyTimeout_dec, __setAltKeyTimeout_dec, __setShiftKeyTimeout_dec, _getIsReadonly_dec, _getIsFocused_dec, _getSharedOpacity_dec, _getSharedStyles_dec, __getSelectionSharedStyles_dec, __getBindingsIndexCache_dec, _getCurrentPageRenderingShapesSorted_dec, _getCurrentPageShapesSorted_dec, _getCurrentPageShapes_dec, _getCurrentPageBounds_dec, _getCulledShapes_dec, __notVisibleShapes_dec, __getShapeMaskedPageBoundsCache_dec, __getShapeMaskCache_dec, __getShapeClipPathCache_dec, __getShapePageBoundsCache_dec, __getShapePageTransformCache_dec, __getShapeHandlesCache_dec, __getAllAssetsQuery_dec, _getCurrentPageShapeIdsSorted_dec, _getCurrentPageId_dec, _getPages_dec, __getAllPagesQuery_dec, _getRenderingShapes_dec, _getCollaboratorsOnCurrentPage_dec, _getCollaborators_dec, __getCollaboratorsQuery_dec, _getViewportPageBounds_dec, _getViewportScreenCenter_dec, _getViewportScreenBounds_dec, _getZoomLevel_dec, _getCameraForFollowing_dec, _getViewportPageBoundsForFollowing_dec, _getCamera_dec, __unsafe_getCameraId_dec, _getErasingShapes_dec, _getErasingShapeIds_dec, _getHintingShape_dec, _getHintingShapeIds_dec, _getHoveredShape_dec, _getHoveredShapeId_dec, _getRichTextEditor_dec, _getEditingShape_dec, _getEditingShapeId_dec, _getFocusedGroup_dec, _getFocusedGroupId_dec, _getSelectionRotatedScreenBounds_dec, _getSelectionRotatedPageBounds_dec, _getSelectionRotation_dec, _getSelectionPageBounds_dec, _getOnlySelectedShape_dec, _getOnlySelectedShapeId_dec, _getCurrentPageShapesInReadingOrder_dec, _getSelectedShapes_dec, _getSelectedShapeIds_dec, __getCurrentPageStateId_dec, _getCurrentPageState_dec, __getPageStatesQuery_dec, _getPageStates_dec, _getIsMenuOpen_dec, _getOpenMenus_dec, _getInstanceState_dec, _getDocumentSettings_dec, _getCurrentToolId_dec, _getCurrentTool_dec, _getPath_dec, _getCanRedo_dec, _getCanUndo_dec, _getIsShapeHiddenCache_dec, _a$1, _init$3;
let Editor$1 = class Editor extends (_a$1 = EventEmitter$1, _getIsShapeHiddenCache_dec = [computed], _getCanUndo_dec = [computed], _getCanRedo_dec = [computed], _getPath_dec = [computed], _getCurrentTool_dec = [computed], _getCurrentToolId_dec = [computed], _getDocumentSettings_dec = [computed], _getInstanceState_dec = [computed], _getOpenMenus_dec = [computed], _getIsMenuOpen_dec = [computed], _getPageStates_dec = [computed], __getPageStatesQuery_dec = [computed], _getCurrentPageState_dec = [computed], __getCurrentPageStateId_dec = [computed], _getSelectedShapeIds_dec = [computed], _getSelectedShapes_dec = [computed], _getCurrentPageShapesInReadingOrder_dec = [computed], _getOnlySelectedShapeId_dec = [computed], _getOnlySelectedShape_dec = [computed], _getSelectionPageBounds_dec = [computed], _getSelectionRotation_dec = [computed], _getSelectionRotatedPageBounds_dec = [computed], _getSelectionRotatedScreenBounds_dec = [computed], _getFocusedGroupId_dec = [computed], _getFocusedGroup_dec = [computed], _getEditingShapeId_dec = [computed], _getEditingShape_dec = [computed], _getRichTextEditor_dec = [computed], _getHoveredShapeId_dec = [computed], _getHoveredShape_dec = [computed], _getHintingShapeIds_dec = [computed], _getHintingShape_dec = [computed], _getErasingShapeIds_dec = [computed], _getErasingShapes_dec = [computed], __unsafe_getCameraId_dec = [computed], _getCamera_dec = [computed], _getViewportPageBoundsForFollowing_dec = [computed], _getCameraForFollowing_dec = [computed], _getZoomLevel_dec = [computed], _getViewportScreenBounds_dec = [computed], _getViewportScreenCenter_dec = [computed], _getViewportPageBounds_dec = [computed], __getCollaboratorsQuery_dec = [computed], _getCollaborators_dec = [computed], _getCollaboratorsOnCurrentPage_dec = [computed], _getRenderingShapes_dec = [computed], __getAllPagesQuery_dec = [computed], _getPages_dec = [computed], _getCurrentPageId_dec = [computed], _getCurrentPageShapeIdsSorted_dec = [computed], __getAllAssetsQuery_dec = [computed], __getShapeHandlesCache_dec = [computed], __getShapePageTransformCache_dec = [computed], __getShapePageBoundsCache_dec = [computed], __getShapeClipPathCache_dec = [computed], __getShapeMaskCache_dec = [computed], __getShapeMaskedPageBoundsCache_dec = [computed], __notVisibleShapes_dec = [computed], _getCulledShapes_dec = [computed], _getCurrentPageBounds_dec = [computed], _getCurrentPageShapes_dec = [computed], _getCurrentPageShapesSorted_dec = [computed], _getCurrentPageRenderingShapesSorted_dec = [computed], __getBindingsIndexCache_dec = [computed], __getSelectionSharedStyles_dec = [computed], _getSharedStyles_dec = [computed({ isEqual: (a2, b) => a2.equals(b) })], _getSharedOpacity_dec = [computed], _getIsFocused_dec = [computed], _getIsReadonly_dec = [computed], __setShiftKeyTimeout_dec = [bind$1], __setAltKeyTimeout_dec = [bind$1], __setCtrlKeyTimeout_dec = [bind$1], __setMetaKeyTimeout_dec = [bind$1], _a$1) {
  constructor({
    store,
    user,
    shapeUtils,
    bindingUtils,
    tools,
    getContainer,
    cameraOptions,
    textOptions,
    initialState: initialState2,
    autoFocus,
    inferDarkMode,
    options,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isShapeHidden,
    getShapeVisibility,
    fontAssetUrls
  }) {
    super();
    __runInitializers$3(_init$3, 5, this);
    __publicField$3(this, "id", uniqueId());
    __publicField$3(this, "_getShapeVisibility");
    __publicField$3(this, "options");
    __publicField$3(this, "contextId", uniqueId());
    __publicField$3(this, "store");
    __publicField$3(this, "root");
    __publicField$3(this, "disposables", /* @__PURE__ */ new Set());
    __publicField$3(this, "isDisposed", false);
    __publicField$3(this, "_tickManager");
    __publicField$3(this, "snaps");
    __publicField$3(this, "timers", tltime.forContext(this.contextId));
    __publicField$3(this, "user");
    __publicField$3(this, "textMeasure");
    __publicField$3(this, "fonts");
    __publicField$3(this, "environment", tlenv);
    __publicField$3(this, "scribbles");
    __publicField$3(this, "sideEffects");
    __publicField$3(this, "edgeScrollManager");
    __publicField$3(this, "focusManager");
    __publicField$3(this, "getContainer");
    __publicField$3(this, "shapeUtils");
    __publicField$3(this, "styleProps");
    __publicField$3(this, "bindingUtils");
    __publicField$3(this, "history");
    __publicField$3(this, "_shouldIgnoreShapeLock", false);
    __publicField$3(this, "_crashingError", null);
    __publicField$3(this, "_isChangingStyleTimeout", -1);
    __publicField$3(this, "menus", tlmenus.forContext(this.contextId));
    __publicField$3(this, "_currentRichTextEditor", atom("rich text editor", null));
    __publicField$3(this, "_textOptions");
    __publicField$3(this, "_cameraOptions", atom("camera options", DEFAULT_CAMERA_OPTIONS));
    __publicField$3(this, "_viewportAnimation", null);
    __publicField$3(this, "_willSetInitialBounds", true);
    __publicField$3(this, "_isLockedOnFollowingUser", atom("isLockedOnFollowingUser", false));
    __publicField$3(this, "_cameraState", atom("camera state", "idle"));
    __publicField$3(this, "_cameraStateTimeoutRemaining", 0);
    __publicField$3(this, "_currentPageShapeIds");
    __publicField$3(this, "_shapeGeometryCaches", {});
    __publicField$3(this, "_shapePageGeometryCaches", {});
    __publicField$3(this, "_parentIdsToChildIds");
    __publicField$3(this, "animatingShapes", /* @__PURE__ */ new Map());
    __publicField$3(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    });
    __publicField$3(this, "temporaryAssetPreview", /* @__PURE__ */ new Map());
    __publicField$3(this, "externalContentHandlers", {
      text: null,
      files: null,
      embed: null,
      "svg-text": null,
      url: null,
      tldraw: null,
      excalidraw: null
    });
    __publicField$3(this, "inputs", {
      /** The most recent pointer down's position in the current page space. */
      originPagePoint: new Vec(),
      /** The most recent pointer down's position in screen space. */
      originScreenPoint: new Vec(),
      /** The previous pointer position in the current page space. */
      previousPagePoint: new Vec(),
      /** The previous pointer position in screen space. */
      previousScreenPoint: new Vec(),
      /** The most recent pointer position in the current page space. */
      currentPagePoint: new Vec(),
      /** The most recent pointer position in screen space. */
      currentScreenPoint: new Vec(),
      /** A set containing the currently pressed keys. */
      keys: /* @__PURE__ */ new Set(),
      /** A set containing the currently pressed buttons. */
      buttons: /* @__PURE__ */ new Set(),
      /** Whether the input is from a pe. */
      isPen: false,
      /** Whether the shift key is currently pressed. */
      shiftKey: false,
      /** Whether the meta key is currently pressed. */
      metaKey: false,
      /** Whether the control or command key is currently pressed. */
      ctrlKey: false,
      /** Whether the alt or option key is currently pressed. */
      altKey: false,
      /** Whether the user is dragging. */
      isDragging: false,
      /** Whether the user is pointing. */
      isPointing: false,
      /** Whether the user is pinching. */
      isPinching: false,
      /** Whether the user is editing. */
      isEditing: false,
      /** Whether the user is panning. */
      isPanning: false,
      /** Whether the user is spacebar panning. */
      isSpacebarPanning: false,
      /** Velocity of mouse pointer, in pixels per millisecond */
      pointerVelocity: new Vec()
    });
    __publicField$3(this, "_clickManager", new ClickManager(this));
    __publicField$3(this, "_prevCursor", "default");
    __publicField$3(this, "_shiftKeyTimeout", -1);
    __publicField$3(this, "_altKeyTimeout", -1);
    __publicField$3(this, "_ctrlKeyTimeout", -1);
    __publicField$3(this, "_metaKeyTimeout", -1);
    __publicField$3(this, "_restoreToolId", "select");
    __publicField$3(this, "_pinchStart", 1);
    __publicField$3(this, "_didPinch", false);
    __publicField$3(this, "_selectedShapeIdsAtPointerDown", []);
    __publicField$3(this, "_longPressTimeout", -1);
    __publicField$3(this, "capturedPointerId", null);
    __publicField$3(this, "performanceTracker");
    __publicField$3(this, "performanceTrackerTimeout", -1);
    __publicField$3(this, "_pendingEventsForNextTick", []);
    assert(
      !(isShapeHidden && getShapeVisibility),
      "Cannot use both isShapeHidden and getShapeVisibility"
    );
    this._getShapeVisibility = isShapeHidden ? (
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      (shape, editor) => isShapeHidden(shape, editor) ? "hidden" : "inherit"
    ) : getShapeVisibility;
    this.options = { ...defaultTldrawOptions, ...options };
    this.store = store;
    this.history = new HistoryManager({
      store,
      annotateError: (error) => {
        this.annotateError(error, { origin: "history.batch", willCrashApp: true });
        this.crash(error);
      }
    });
    this.snaps = new SnapManager(this);
    this.disposables.add(this.timers.dispose);
    this._cameraOptions.set({ ...DEFAULT_CAMERA_OPTIONS, ...cameraOptions });
    this._textOptions = atom("text options", textOptions ?? null);
    this.user = new UserPreferencesManager(user ?? createTLUser(), inferDarkMode ?? false);
    this.disposables.add(() => this.user.dispose());
    this.getContainer = getContainer;
    this.textMeasure = new TextManager(this);
    this.fonts = new FontManager(this, fontAssetUrls);
    this._tickManager = new TickManager(this);
    class NewRoot extends RootState {
      static initial = initialState2 ?? "";
    }
    this.root = new NewRoot(this);
    this.root.children = {};
    const allShapeUtils = checkShapesAndAddCore(shapeUtils);
    const _shapeUtils = {};
    const _styleProps = {};
    const allStylesById = /* @__PURE__ */ new Map();
    for (const Util of allShapeUtils) {
      const util2 = new Util(this);
      _shapeUtils[Util.type] = util2;
      const propKeysByStyle = getShapePropKeysByStyle(Util.props ?? {});
      _styleProps[Util.type] = propKeysByStyle;
      for (const style2 of propKeysByStyle.keys()) {
        if (!allStylesById.has(style2.id)) {
          allStylesById.set(style2.id, style2);
        } else if (allStylesById.get(style2.id) !== style2) {
          throw Error(
            `Multiple style props with id "${style2.id}" in use. Style prop IDs must be unique.`
          );
        }
      }
    }
    this.shapeUtils = _shapeUtils;
    this.styleProps = _styleProps;
    const allBindingUtils = checkBindings(bindingUtils);
    const _bindingUtils = {};
    for (const Util of allBindingUtils) {
      const util2 = new Util(this);
      _bindingUtils[Util.type] = util2;
    }
    this.bindingUtils = _bindingUtils;
    for (const Tool of [...tools]) {
      if (hasOwnProperty(this.root.children, Tool.id)) {
        throw Error(`Can't override tool with id "${Tool.id}"`);
      }
      this.root.children[Tool.id] = new Tool(this, this.root);
    }
    this.scribbles = new ScribbleManager(this);
    const cleanupInstancePageState = (prevPageState, shapesNoLongerInPage) => {
      let nextPageState = null;
      const selectedShapeIds = prevPageState.selectedShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (selectedShapeIds.length !== prevPageState.selectedShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.selectedShapeIds = selectedShapeIds;
      }
      const erasingShapeIds = prevPageState.erasingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (erasingShapeIds.length !== prevPageState.erasingShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.erasingShapeIds = erasingShapeIds;
      }
      if (prevPageState.hoveredShapeId && shapesNoLongerInPage.has(prevPageState.hoveredShapeId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.hoveredShapeId = null;
      }
      if (prevPageState.editingShapeId && shapesNoLongerInPage.has(prevPageState.editingShapeId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.editingShapeId = null;
      }
      const hintingShapeIds = prevPageState.hintingShapeIds.filter(
        (id) => !shapesNoLongerInPage.has(id)
      );
      if (hintingShapeIds.length !== prevPageState.hintingShapeIds.length) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.hintingShapeIds = hintingShapeIds;
      }
      if (prevPageState.focusedGroupId && shapesNoLongerInPage.has(prevPageState.focusedGroupId)) {
        if (!nextPageState) nextPageState = { ...prevPageState };
        nextPageState.focusedGroupId = null;
      }
      return nextPageState;
    };
    this.sideEffects = this.store.sideEffects;
    let deletedBindings = /* @__PURE__ */ new Map();
    const deletedShapeIds = /* @__PURE__ */ new Set();
    const invalidParents = /* @__PURE__ */ new Set();
    let invalidBindingTypes = /* @__PURE__ */ new Set();
    this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        deletedShapeIds.clear();
        for (const parentId of invalidParents) {
          invalidParents.delete(parentId);
          const parent = this.getShape(parentId);
          if (!parent) continue;
          const util2 = this.getShapeUtil(parent);
          const changes = util2.onChildrenChange?.(parent);
          if (changes?.length) {
            this.updateShapes(changes);
          }
        }
        if (invalidBindingTypes.size) {
          const t2 = invalidBindingTypes;
          invalidBindingTypes = /* @__PURE__ */ new Set();
          for (const type of t2) {
            const util2 = this.getBindingUtil(type);
            util2.onOperationComplete?.();
          }
        }
        if (deletedBindings.size) {
          const t2 = deletedBindings;
          deletedBindings = /* @__PURE__ */ new Map();
          for (const opts of t2.values()) {
            this.getBindingUtil(opts.binding).onAfterDelete?.(opts);
          }
        }
        this.emit("update");
      })
    );
    this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (shapeBefore, shapeAfter) => {
            for (const binding of this.getBindingsInvolvingShape(shapeAfter)) {
              invalidBindingTypes.add(binding.type);
              if (binding.fromId === shapeAfter.id) {
                this.getBindingUtil(binding).onAfterChangeFromShape?.({
                  binding,
                  shapeBefore,
                  shapeAfter
                });
              }
              if (binding.toId === shapeAfter.id) {
                this.getBindingUtil(binding).onAfterChangeToShape?.({
                  binding,
                  shapeBefore,
                  shapeAfter
                });
              }
            }
            if (shapeBefore.parentId !== shapeAfter.parentId) {
              const notifyBindingAncestryChange = (id) => {
                const descendantShape = this.getShape(id);
                if (!descendantShape) return;
                for (const binding of this.getBindingsInvolvingShape(descendantShape)) {
                  invalidBindingTypes.add(binding.type);
                  if (binding.fromId === descendantShape.id) {
                    this.getBindingUtil(binding).onAfterChangeFromShape?.({
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape
                    });
                  }
                  if (binding.toId === descendantShape.id) {
                    this.getBindingUtil(binding).onAfterChangeToShape?.({
                      binding,
                      shapeBefore: descendantShape,
                      shapeAfter: descendantShape
                    });
                  }
                }
              };
              notifyBindingAncestryChange(shapeAfter.id);
              this.visitDescendants(shapeAfter.id, notifyBindingAncestryChange);
            }
            if (shapeBefore.parentId !== shapeAfter.parentId && isPageId(shapeAfter.parentId)) {
              const allMovingIds = /* @__PURE__ */ new Set([shapeBefore.id]);
              this.visitDescendants(shapeBefore.id, (id) => {
                allMovingIds.add(id);
              });
              for (const instancePageState of this.getPageStates()) {
                if (instancePageState.pageId === shapeAfter.parentId) continue;
                const nextPageState = cleanupInstancePageState(instancePageState, allMovingIds);
                if (nextPageState) {
                  this.store.put([nextPageState]);
                }
              }
            }
            if (shapeBefore.parentId && isShapeId(shapeBefore.parentId)) {
              invalidParents.add(shapeBefore.parentId);
            }
            if (shapeAfter.parentId !== shapeBefore.parentId && isShapeId(shapeAfter.parentId)) {
              invalidParents.add(shapeAfter.parentId);
            }
          },
          beforeDelete: (shape) => {
            if (deletedShapeIds.has(shape.id)) return;
            if (shape.parentId && isShapeId(shape.parentId)) {
              invalidParents.add(shape.parentId);
            }
            deletedShapeIds.add(shape.id);
            const deleteBindingIds = [];
            for (const binding of this.getBindingsInvolvingShape(shape)) {
              invalidBindingTypes.add(binding.type);
              deleteBindingIds.push(binding.id);
              const util2 = this.getBindingUtil(binding);
              if (binding.fromId === shape.id) {
                util2.onBeforeIsolateToShape?.({ binding, removedShape: shape });
                util2.onBeforeDeleteFromShape?.({ binding, shape });
              } else {
                util2.onBeforeIsolateFromShape?.({ binding, removedShape: shape });
                util2.onBeforeDeleteToShape?.({ binding, shape });
              }
            }
            if (deleteBindingIds.length) {
              this.deleteBindings(deleteBindingIds);
            }
            const deletedIds = /* @__PURE__ */ new Set([shape.id]);
            const updates = compact$1(
              this.getPageStates().map((pageState) => {
                return cleanupInstancePageState(pageState, deletedIds);
              })
            );
            if (updates.length) {
              this.store.put(updates);
            }
          }
        },
        binding: {
          beforeCreate: (binding) => {
            const next = this.getBindingUtil(binding).onBeforeCreate?.({ binding });
            if (next) return next;
            return binding;
          },
          afterCreate: (binding) => {
            invalidBindingTypes.add(binding.type);
            this.getBindingUtil(binding).onAfterCreate?.({ binding });
          },
          beforeChange: (bindingBefore, bindingAfter) => {
            const updated = this.getBindingUtil(bindingAfter).onBeforeChange?.({
              bindingBefore,
              bindingAfter
            });
            if (updated) return updated;
            return bindingAfter;
          },
          afterChange: (bindingBefore, bindingAfter) => {
            invalidBindingTypes.add(bindingAfter.type);
            this.getBindingUtil(bindingAfter).onAfterChange?.({ bindingBefore, bindingAfter });
          },
          beforeDelete: (binding) => {
            this.getBindingUtil(binding).onBeforeDelete?.({ binding });
          },
          afterDelete: (binding) => {
            this.getBindingUtil(binding).onAfterDelete?.({ binding });
            invalidBindingTypes.add(binding.type);
          }
        },
        page: {
          afterCreate: (record) => {
            const cameraId = CameraRecordType.createId(record.id);
            const _pageStateId = InstancePageStateRecordType.createId(record.id);
            if (!this.store.has(cameraId)) {
              this.store.put([CameraRecordType.create({ id: cameraId })]);
            }
            if (!this.store.has(_pageStateId)) {
              this.store.put([
                InstancePageStateRecordType.create({ id: _pageStateId, pageId: record.id })
              ]);
            }
          },
          afterDelete: (record, source) => {
            if (this.getInstanceState()?.currentPageId === record.id) {
              const backupPageId = this.getPages().find((p) => p.id !== record.id)?.id;
              if (backupPageId) {
                this.store.put([{ ...this.getInstanceState(), currentPageId: backupPageId }]);
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
            const cameraId = CameraRecordType.createId(record.id);
            const instance_PageStateId = InstancePageStateRecordType.createId(record.id);
            this.store.remove([cameraId, instance_PageStateId]);
          }
        },
        instance: {
          afterChange: (prev, next, source) => {
            if (!this.store.has(next.currentPageId)) {
              const backupPageId = this.store.has(prev.currentPageId) ? prev.currentPageId : this.getPages()[0]?.id;
              if (backupPageId) {
                this.store.update(next.id, (instance) => ({
                  ...instance,
                  currentPageId: backupPageId
                }));
              } else if (source === "user") {
                this.store.ensureStoreIsUsable();
              }
            }
          }
        },
        instance_page_state: {
          afterChange: (prev, next) => {
            if (prev?.selectedShapeIds !== next?.selectedShapeIds) {
              const filtered = next.selectedShapeIds.filter((id) => {
                let parentId = this.getShape(id)?.parentId;
                while (isShapeId(parentId)) {
                  if (next.selectedShapeIds.includes(parentId)) {
                    return false;
                  }
                  parentId = this.getShape(parentId)?.parentId;
                }
                return true;
              });
              let nextFocusedGroupId = null;
              if (filtered.length > 0) {
                const commonGroupAncestor = this.findCommonAncestor(
                  compact$1(filtered.map((id) => this.getShape(id))),
                  (shape) => this.isShapeOfType(shape, "group")
                );
                if (commonGroupAncestor) {
                  nextFocusedGroupId = commonGroupAncestor;
                }
              } else {
                if (next?.focusedGroupId) {
                  nextFocusedGroupId = next.focusedGroupId;
                }
              }
              if (filtered.length !== next.selectedShapeIds.length || nextFocusedGroupId !== next.focusedGroupId) {
                this.store.put([
                  {
                    ...next,
                    selectedShapeIds: filtered,
                    focusedGroupId: nextFocusedGroupId ?? null
                  }
                ]);
              }
            }
          }
        }
      })
    );
    this._currentPageShapeIds = deriveShapeIdsInCurrentPage(
      this.store,
      () => this.getCurrentPageId()
    );
    this._parentIdsToChildIds = parentsToChildren(this.store);
    this.disposables.add(
      this.store.listen((changes) => {
        this.emit("change", changes);
      })
    );
    this.disposables.add(this.history.dispose);
    this.run(
      () => {
        this.store.ensureStoreIsUsable();
        this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    );
    if (initialState2 && this.root.children[initialState2] === void 0) {
      throw Error(`No state found for initialState "${initialState2}".`);
    }
    this.root.enter(void 0, "initial");
    this.edgeScrollManager = new EdgeScrollManager(this);
    this.focusManager = new FocusManager(this, autoFocus);
    this.disposables.add(this.focusManager.dispose.bind(this.focusManager));
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    this.on("tick", this._flushEventsForTick);
    this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    });
    this.performanceTracker = new PerformanceTracker();
    if (this.store.props.collaboration?.mode) {
      const mode = this.store.props.collaboration.mode;
      this.disposables.add(
        react$1("update collaboration mode", () => {
          this.store.put([{ ...this.getInstanceState(), isReadonly: mode.get() === "readonly" }]);
        })
      );
    }
  }
  getIsShapeHiddenCache() {
    if (!this._getShapeVisibility) return null;
    return this.store.createComputedCache("isShapeHidden", (shape) => {
      const visibility = this._getShapeVisibility(shape, this);
      const isParentHidden = PageRecordType.isId(shape.parentId) ? false : this.isShapeHidden(shape.parentId);
      if (isParentHidden) return visibility !== "visible";
      return visibility === "hidden";
    });
  }
  isShapeHidden(shapeOrId) {
    if (!this._getShapeVisibility) return false;
    return !!this.getIsShapeHiddenCache().get(
      typeof shapeOrId === "string" ? shapeOrId : shapeOrId.id
    );
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((dispose) => dispose());
    this.disposables.clear();
    this.store.dispose();
    this.isDisposed = true;
  }
  getShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const shapeUtil = getOwnProperty(this.shapeUtils, type);
    assert(shapeUtil, `No shape util found for type "${type}"`);
    return shapeUtil;
  }
  hasShapeUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    return hasOwnProperty(this.shapeUtils, type);
  }
  getBindingUtil(arg) {
    const type = typeof arg === "string" ? arg : arg.type;
    const bindingUtil = getOwnProperty(this.bindingUtils, type);
    assert(bindingUtil, `No binding util found for type "${type}"`);
    return bindingUtil;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.undo();
    return this;
  }
  getCanUndo() {
    return this.history.getNumUndos() > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    this._flushEventsForTick(0);
    this.complete();
    this.history.redo();
    return this;
  }
  clearHistory() {
    this.history.clear();
    return this;
  }
  getCanRedo() {
    return this.history.getNumRedos() > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * editor.mark()
   * editor.mark('flip shapes')
   * ```
   *
   * @param markId - The mark's id, usually the reason for adding the mark.
   *
   * @public
   * @deprecated use {@link Editor.markHistoryStoppingPoint} instead
   */
  mark(markId) {
    if (typeof markId === "string") {
      console.warn(
        `[tldraw] \`editor.history.mark("${markId}")\` is deprecated. Please use \`const myMarkId = editor.markHistoryStoppingPoint()\` instead.`
      );
    } else {
      console.warn(
        "[tldraw] `editor.mark()` is deprecated. Use `editor.markHistoryStoppingPoint()` instead."
      );
    }
    this.history._mark(markId ?? uniqueId());
    return this;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos. You typically want to do this just before a user interaction begins or is handled.
   *
   * @example
   * ```ts
   * editor.markHistoryStoppingPoint()
   * editor.flipShapes(editor.getSelectedShapes())
   * ```
   * @example
   * ```ts
   * const beginRotateMark = editor.markHistoryStoppingPoint()
   * // if the use cancels the rotation, you can bail back to this mark
   * editor.bailToMark(beginRotateMark)
   * ```
   *
   * @public
   * @param name - The name of the mark, useful for debugging the undo/redo stacks
   * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.
   */
  markHistoryStoppingPoint(name) {
    const id = `[${name ?? "stop"}]_${uniqueId()}`;
    this.history._mark(id);
    return id;
  }
  /**
   * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.
   */
  getMarkIdMatching(idSubstring) {
    return this.history.getMarkIdMatching(idSubstring);
  }
  /**
   * Coalesces all changes since the given mark into a single change, removing any intermediate marks.
   *
   * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.
   *
   * @example
   * ```ts
   * const bumpShapesMark = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.squashToMark(bumpShapesMark)
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(markId) {
    this.history.squashToMark(markId);
    return this;
  }
  /**
   * Undo to the closest mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    this.history.bail();
    return this;
  }
  /**
   * Undo to the given mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * const beginDrag = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.bailToMark(beginDrag)
   * ```
   *
   * @public
   */
  bailToMark(id) {
    this.history.bailToMark(id);
    return this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(fn, opts) {
    const previousIgnoreShapeLock = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = opts?.ignoreShapeLock ?? previousIgnoreShapeLock;
    try {
      this.history.batch(fn, opts);
    } finally {
      this._shouldIgnoreShapeLock = previousIgnoreShapeLock;
    }
    return this;
  }
  /**
   * @deprecated Use `Editor.run` instead.
   */
  batch(fn, opts) {
    return this.run(fn, opts);
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(error, {
    origin,
    willCrashApp,
    tags,
    extras
  }) {
    const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);
    annotateError(error, {
      tags: { ...defaultAnnotations.tags, ...tags },
      extras: { ...defaultAnnotations.extras, ...extras }
    });
    if (willCrashApp) {
      this.store.markAsPossiblyCorrupted();
    }
    return this;
  }
  /** @internal */
  createErrorAnnotations(origin, willCrashApp) {
    try {
      const editingShapeId = this.getEditingShapeId();
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes().map((s2) => {
            const { props, ...rest } = s2;
            const { text: _text, richText: _richText, ...restProps } = props;
            return {
              ...rest,
              props: restProps
            };
          }),
          selectionCount: this.getSelectedShapes().length,
          editingShape: editingShapeId ? this.getShape(editingShapeId) : void 0,
          inputs: this.inputs,
          pageState: this.getCurrentPageState(),
          instanceState: this.getInstanceState(),
          collaboratorCount: this.getCollaboratorsOnCurrentPage().length
        }
      };
    } catch {
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(error) {
    this._crashingError = error;
    this.store.markAsPossiblyCorrupted();
    this.emit("crash", { error });
    return this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id) return true;
      const current = state.getCurrent();
      if (current?.id === id) {
        if (ids.length === 0) return true;
        state = current;
        continue;
      } else return false;
    }
    return false;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...paths) {
    return paths.some((path) => this.isIn(path));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(id, info = {}) {
    this.root.transition(id, info);
    return this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const currentTool = this.getCurrentTool();
    if (!currentTool) return "";
    return currentTool.getCurrentToolIdMask() ?? currentTool.id;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * editor.getStateDescendant('select')
   * editor.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id) return state;
      const childState = state.children?.[id];
      if (!childState) return void 0;
      state = childState;
    }
    return state;
  }
  getDocumentSettings() {
    return this.store.get(TLDOCUMENT_ID);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(settings) {
    this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...settings }]);
      },
      { history: "ignore" }
    );
    return this;
  }
  getInstanceState() {
    return this.store.get(TLINSTANCE_ID);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param historyOptions - History batch options.
   *
   * @public
   */
  updateInstanceState(partial, historyOptions) {
    this._updateInstanceState(partial, { history: "ignore", ...historyOptions });
    if (partial.isChangingStyle !== void 0) {
      clearTimeout(this._isChangingStyleTimeout);
      if (partial.isChangingStyle === true) {
        this._isChangingStyleTimeout = this.timers.setTimeout(() => {
          this._updateInstanceState({ isChangingStyle: false }, { history: "ignore" });
        }, 1e3);
      }
    }
    return this;
  }
  /** @internal */
  _updateInstanceState(partial, opts) {
    this.run(() => {
      this.store.put([
        {
          ...this.getInstanceState(),
          ...partial
        }
      ]);
    }, opts);
  }
  getOpenMenus() {
    return this.menus.getOpenMenus();
  }
  /**
   * @deprecated Use `editor.menus.addOpenMenu` instead.
   *
   * @public
   */
  addOpenMenu(id) {
    this.menus.addOpenMenu(id);
    return this;
  }
  /**
   * @deprecated Use `editor.menus.deleteOpenMenu` instead.
   *
   * @public
   */
  deleteOpenMenu(id) {
    this.menus.deleteOpenMenu(id);
    return this;
  }
  /**
   * @deprecated Use `editor.menus.clearOpenMenus` instead.
   *
   * @public
   */
  clearOpenMenus() {
    this.menus.clearOpenMenus();
    return this;
  }
  getIsMenuOpen() {
    return this.menus.hasAnyOpenMenus();
  }
  /* --------------------- Cursor --------------------- */
  /**
   * Set the cursor.
   *
   * @param cursor - The cursor to set.
   * @public
   */
  setCursor(cursor) {
    this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...cursor } });
    return this;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return InstancePageStateRecordType.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(partial) {
    this._updateCurrentPageState(partial);
    return this;
  }
  _updateCurrentPageState(partial) {
    this.store.update(partial.id ?? this.getCurrentPageState().id, (state) => ({
      ...state,
      ...partial
    }));
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    return compact$1(this.getSelectedShapeIds().map((id) => this.store.get(id)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param shapes - The shape (or shape ids) to select.
   *
   * @public
   */
  setSelectedShapes(shapes) {
    return this.run(
      () => {
        const ids = shapes.map((shape) => typeof shape === "string" ? shape : shape.id);
        const { selectedShapeIds: prevSelectedShapeIds } = this.getCurrentPageState();
        const prevSet = new Set(prevSelectedShapeIds);
        if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: ids }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param shape - The shape (or shape id) of the shape to check.
   *
   * @public
   */
  isAncestorSelected(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    const _shape = this.getShape(id);
    if (!_shape) return false;
    const selectedShapeIds = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(_shape, (parent) => selectedShapeIds.includes(parent.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param shapes - The shape (or the shape ids) to select.
   *
   * @public
   */
  select(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.setSelectedShapes(ids);
    return this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    const selectedShapeIds = this.getSelectedShapeIds();
    if (selectedShapeIds.length > 0 && ids.length > 0) {
      this.setSelectedShapes(selectedShapeIds.filter((id) => !ids.includes(id)));
    }
    return this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const ids = this.getSortedChildIdsForParent(this.getCurrentPageId());
    if (ids.length <= 0) return this;
    this.setSelectedShapes(this._getUnlockedShapeIds(ids));
    return this;
  }
  /**
   * Select the next shape in the reading order or in cardinal order.
   *
   * @example
   * ```ts
   * editor.selectAdjacentShape('next')
   * ```
   *
   * @public
   */
  selectAdjacentShape(direction) {
    const selectedShapeIds = this.getSelectedShapeIds();
    const firstParentId = selectedShapeIds[0] ? this.getShape(selectedShapeIds[0])?.parentId : null;
    const isSelectedWithinContainer = firstParentId && selectedShapeIds.every((shapeId) => this.getShape(shapeId)?.parentId === firstParentId) && !isPageId(firstParentId);
    const readingOrderShapes = isSelectedWithinContainer ? this._getShapesInReadingOrder(
      this.getCurrentPageShapes().filter((shape2) => shape2.parentId === firstParentId)
    ) : this.getCurrentPageShapesInReadingOrder();
    const currentShapeId = selectedShapeIds.length === 1 ? selectedShapeIds[0] : readingOrderShapes.find((shape2) => selectedShapeIds.includes(shape2.id))?.id;
    let adjacentShapeId;
    if (direction === "next" || direction === "prev") {
      const shapeIds = readingOrderShapes.map((shape2) => shape2.id);
      const currentIndex = currentShapeId ? shapeIds.indexOf(currentShapeId) : -1;
      const adjacentIndex = (currentIndex + (direction === "next" ? 1 : -1) + shapeIds.length) % shapeIds.length;
      adjacentShapeId = shapeIds[adjacentIndex];
    } else {
      if (!currentShapeId) return;
      adjacentShapeId = this.getNearestAdjacentShape(currentShapeId, direction);
    }
    const shape = this.getShape(adjacentShapeId);
    if (!shape) return;
    this._selectShapesAndZoom([shape.id]);
  }
  getCurrentPageShapesInReadingOrder() {
    const shapes = this.getCurrentPageShapes().filter((shape) => isPageId(shape.parentId));
    return this._getShapesInReadingOrder(shapes);
  }
  _getShapesInReadingOrder(shapes) {
    const SHALLOW_ANGLE = 20;
    const ROW_THRESHOLD = 100;
    const tabbableShapes = shapes.filter((shape) => this.getShapeUtil(shape).canTabTo(shape));
    if (tabbableShapes.length <= 1) return tabbableShapes;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    shapesWithCenters.sort((a2, b) => a2.center.y - b.center.y);
    const rows = [];
    for (const shapeWithCenter of shapesWithCenters) {
      let rowIndex = -1;
      for (let i = rows.length - 1; i >= 0; i--) {
        const row = rows[i];
        const lastShapeInRow = row[row.length - 1];
        if (Math.abs(shapeWithCenter.center.y - lastShapeInRow.center.y) < ROW_THRESHOLD) {
          rowIndex = i;
          break;
        }
      }
      if (rowIndex === -1) {
        rows.push([shapeWithCenter]);
      } else {
        rows[rowIndex].push(shapeWithCenter);
      }
    }
    for (const row of rows) {
      row.sort((a2, b) => a2.center.x - b.center.x);
    }
    for (const row of rows) {
      if (row.length <= 2) continue;
      for (let i = 0; i < row.length - 2; i++) {
        const currentShape = row[i];
        const nextShape = row[i + 1];
        const nextNextShape = row[i + 2];
        const dist1 = Vec.Dist2(currentShape.center, nextShape.center);
        const dist2 = Vec.Dist2(currentShape.center, nextNextShape.center);
        if (dist2 < dist1 * 0.9) {
          const angle = Math.abs(
            Vec.Angle(currentShape.center, nextNextShape.center) * (180 / Math.PI)
          );
          if (angle <= SHALLOW_ANGLE) {
            [row[i + 1], row[i + 2]] = [row[i + 2], row[i + 1]];
          }
        }
      }
    }
    return rows.flat().map((item) => item.shape);
  }
  /**
   * Find the nearest adjacent shape in a specific direction.
   *
   * @public
   */
  getNearestAdjacentShape(currentShapeId, direction) {
    const directionToAngle = { right: 0, left: 180, down: 90, up: 270 };
    const currentShape = this.getShape(currentShapeId);
    if (!currentShape) return currentShapeId;
    const shapes = this.getCurrentPageShapes();
    const tabbableShapes = shapes.filter(
      (shape) => this.getShapeUtil(shape).canTabTo(shape) && shape.id !== currentShapeId
    );
    if (!tabbableShapes.length) return currentShapeId;
    const currentCenter = this.getShapePageBounds(currentShape).center;
    const shapesWithCenters = tabbableShapes.map((shape) => ({
      shape,
      center: this.getShapePageBounds(shape).center
    }));
    const shapesInDirection = shapesWithCenters.filter(({ center }) => {
      const isRight = center.x > currentCenter.x;
      const isDown = center.y > currentCenter.y;
      const xDist = center.x - currentCenter.x;
      const yDist = center.y - currentCenter.y;
      const isInXDirection = Math.abs(yDist) < Math.abs(xDist) * 2;
      const isInYDirection = Math.abs(xDist) < Math.abs(yDist) * 2;
      if (direction === "left" || direction === "right") {
        return isInXDirection && (direction === "right" ? isRight : !isRight);
      }
      if (direction === "up" || direction === "down") {
        return isInYDirection && (direction === "down" ? isDown : !isDown);
      }
    });
    if (shapesInDirection.length === 0) return currentShapeId;
    const lowestScoringShape = minBy(shapesInDirection, ({ center }) => {
      const distance = Vec.Dist2(currentCenter, center);
      const dirProp = ["left", "right"].includes(direction) ? "x" : "y";
      const directionalDistance = Math.abs(center[dirProp] - currentCenter[dirProp]);
      const offProp = ["left", "right"].includes(direction) ? "y" : "x";
      const offAxisDeviation = Math.abs(center[offProp] - currentCenter[offProp]);
      const angle = Math.abs(Vec.Angle(currentCenter, center) * (180 / Math.PI));
      const angleDeviation = Math.abs(angle - directionToAngle[direction]);
      return distance * 1 + // Base distance
      offAxisDeviation * 2 + // Heavy penalty for off-axis deviation
      (distance - directionalDistance) * 1.5 + // Penalty for diagonal distance
      angleDeviation * 0.5;
    });
    return lowestScoringShape.shape.id;
  }
  selectParentShape() {
    const selectedShape = this.getOnlySelectedShape();
    if (!selectedShape) return;
    const parentShape = this.getShape(selectedShape.parentId);
    if (!parentShape) return;
    this._selectShapesAndZoom([parentShape.id]);
  }
  selectFirstChildShape() {
    const selectedShapes = this.getSelectedShapes();
    if (!selectedShapes.length) return;
    const selectedShape = selectedShapes[0];
    const children = this.getSortedChildIdsForParent(selectedShape.id).map((id) => this.getShape(id)).filter((i) => i);
    const sortedChildren = this._getShapesInReadingOrder(children);
    if (sortedChildren.length === 0) return;
    this._selectShapesAndZoom([sortedChildren[0].id]);
  }
  _selectShapesAndZoom(ids) {
    this.setSelectedShapes(ids);
    this.zoomToSelectionIfOffscreen(256, {
      animation: {
        duration: this.options.animationMediumMs
      },
      inset: 0
    });
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    if (this.getSelectedShapeIds().length > 0) {
      this.setSelectedShapes([]);
    }
    return this;
  }
  getOnlySelectedShapeId() {
    return this.getOnlySelectedShape()?.id ?? null;
  }
  getOnlySelectedShape() {
    const selectedShapes = this.getSelectedShapes();
    return selectedShapes.length === 1 ? selectedShapes[0] : null;
  }
  /**
   * @internal
   */
  getShapesPageBounds(shapeIds) {
    const bounds = compact$1(shapeIds.map((id) => this.getShapePageBounds(id)));
    if (bounds.length === 0) return null;
    return Box.Common(bounds);
  }
  getSelectionPageBounds() {
    return this.getShapesPageBounds(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesSharedRotation(shapeIds) {
    let foundFirst = false;
    let rotation = 0;
    for (let i = 0, n2 = shapeIds.length; i < n2; i++) {
      const pageTransform = this.getShapePageTransform(shapeIds[i]);
      if (!pageTransform) continue;
      if (foundFirst) {
        if (pageTransform.rotation() !== rotation) {
          return 0;
        }
      } else {
        foundFirst = true;
        rotation = pageTransform.rotation();
      }
    }
    return rotation;
  }
  getSelectionRotation() {
    return this.getShapesSharedRotation(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesRotatedPageBounds(shapeIds) {
    if (shapeIds.length === 0) {
      return void 0;
    }
    const selectionRotation = this.getShapesSharedRotation(shapeIds);
    if (selectionRotation === 0) {
      return this.getShapesPageBounds(shapeIds) ?? void 0;
    }
    if (shapeIds.length === 1) {
      const bounds = this.getShapeGeometry(shapeIds[0]).bounds.clone();
      const pageTransform = this.getShapePageTransform(shapeIds[0]);
      bounds.point = pageTransform.applyToPoint(bounds.point);
      return bounds;
    }
    const boxFromRotatedVertices = Box.FromPoints(
      shapeIds.flatMap((id) => {
        const pageTransform = this.getShapePageTransform(id);
        if (!pageTransform) return [];
        return pageTransform.applyToPoints(this.getShapeGeometry(id).bounds.corners);
      }).map((p) => p.rot(-selectionRotation))
    );
    boxFromRotatedVertices.point = boxFromRotatedVertices.point.rot(selectionRotation);
    return boxFromRotatedVertices;
  }
  getSelectionRotatedPageBounds() {
    return this.getShapesRotatedPageBounds(this.getSelectedShapeIds());
  }
  getSelectionRotatedScreenBounds() {
    const bounds = this.getSelectionRotatedPageBounds();
    if (!bounds) return void 0;
    const { x, y: y2 } = this.pageToScreen(bounds.point);
    const zoom = this.getZoomLevel();
    return new Box(x, y2, bounds.width * zoom, bounds.height * zoom);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const focusedGroupId = this.getFocusedGroupId();
    return focusedGroupId ? this.getShape(focusedGroupId) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    if (id !== null) {
      const shape2 = this.getShape(id);
      if (!shape2) {
        throw Error(`Editor.setFocusedGroup: Shape with id ${id} does not exist`);
      }
      if (!this.isShapeOfType(shape2, "group")) {
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${shape2.type}`
        );
      }
    }
    if (id === this.getFocusedGroupId()) return this;
    return this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (s2) => ({ ...s2, focusedGroupId: id }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const focusedGroup = this.getFocusedGroup();
    if (focusedGroup) {
      const match = this.findShapeAncestor(
        focusedGroup,
        (shape) => this.isShapeOfType(shape, "group")
      );
      this.setFocusedGroup(match?.id ?? null);
      this.select(focusedGroup.id);
    } else {
      this.setFocusedGroup(null);
      this.selectNone();
    }
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const editingShapeId = this.getEditingShapeId();
    return editingShapeId ? this.getShape(editingShapeId) : void 0;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    this.setRichTextEditor(null);
    const prevEditingShapeId = this.getEditingShapeId();
    if (id !== prevEditingShapeId) {
      if (id) {
        const shape2 = this.getShape(id);
        if (shape2 && this.getShapeUtil(shape2).canEdit(shape2)) {
          this.run(
            () => {
              this._updateCurrentPageState({ editingShapeId: id });
              if (prevEditingShapeId) {
                const prevEditingShape = this.getShape(prevEditingShapeId);
                if (prevEditingShape) {
                  this.getShapeUtil(prevEditingShape).onEditEnd?.(prevEditingShape);
                }
              }
              this.getShapeUtil(shape2).onEditStart?.(shape2);
            },
            { history: "ignore" }
          );
          return this;
        }
      }
      this.run(
        () => {
          this._updateCurrentPageState({ editingShapeId: null });
          this._currentRichTextEditor.set(null);
          if (prevEditingShapeId) {
            const prevEditingShape = this.getShape(prevEditingShapeId);
            if (prevEditingShape) {
              this.getShapeUtil(prevEditingShape).onEditEnd?.(prevEditingShape);
            }
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  getRichTextEditor() {
    return this._currentRichTextEditor.get();
  }
  /**
   * Set the current editing shape's rich text editor.
   *
   * @example
   * ```ts
   * editor.setRichTextEditor(richTextEditorView)
   * ```
   *
   * @param textEditor - The text editor to set as the current editing shape's text editor.
   *
   * @public
   */
  setRichTextEditor(textEditor) {
    this._currentRichTextEditor.set(textEditor);
    return this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const hoveredShapeId = this.getHoveredShapeId();
    return hoveredShapeId ? this.getShape(hoveredShapeId) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    if (id === this.getHoveredShapeId()) return this;
    this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: id });
      },
      { history: "ignore" }
    );
    return this;
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const hintingShapeIds = this.getHintingShapeIds();
    return compact$1(hintingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: dedupe(ids) });
      },
      { history: "ignore" }
    );
    return this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const erasingShapeIds = this.getErasingShapeIds();
    return compact$1(erasingShapeIds.map((id) => this.getShape(id)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((shape) => shape.id);
    ids.sort();
    const erasingShapeIds = this.getErasingShapeIds();
    this.run(
      () => {
        if (ids.length === erasingShapeIds.length) {
          for (let i = 0; i < ids.length; i++) {
            if (ids[i] !== erasingShapeIds[i]) {
              this._updateCurrentPageState({ erasingShapeIds: ids });
              break;
            }
          }
        } else {
          this._updateCurrentPageState({ erasingShapeIds: ids });
        }
      },
      { history: "ignore" }
    );
    return this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(shape) {
    const id = typeof shape === "string" ? shape : shape?.id ?? null;
    if (id !== this.getCroppingShapeId()) {
      this.run(
        () => {
          if (!id) {
            this.updateCurrentPageState({ croppingShapeId: null });
          } else {
            const shape2 = this.getShape(id);
            const util2 = this.getShapeUtil(shape2);
            if (shape2 && util2.canCrop(shape2)) {
              this.updateCurrentPageState({ croppingShapeId: id });
            }
          }
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  /**
   * Get the current text options.
   *
   * @example
   * ```ts
   * editor.getTextOptions()
   * ```
   *
   *  @public */
  getTextOptions() {
    return assertExists(this._textOptions.get(), "Cannot use text without setting textOptions");
  }
  _unsafe_getCameraId() {
    return CameraRecordType.createId(this.getCurrentPageId());
  }
  getCamera() {
    const baseCamera = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const followingCamera = this.getCameraForFollowing();
      if (followingCamera) {
        return { ...baseCamera, ...followingCamera };
      }
    }
    return baseCamera;
  }
  _getFollowingPresence(targetUserId) {
    const visited = [this.user.getId()];
    const collaborators = this.getCollaborators();
    let leaderPresence = null;
    while (targetUserId && !visited.includes(targetUserId)) {
      leaderPresence = collaborators.find((c2) => c2.userId === targetUserId) ?? null;
      targetUserId = leaderPresence?.followingUserId ?? null;
      if (leaderPresence) {
        visited.push(leaderPresence.userId);
      }
    }
    return leaderPresence;
  }
  getViewportPageBoundsForFollowing() {
    const leaderPresence = this._getFollowingPresence(this.getInstanceState().followingUserId);
    if (!leaderPresence?.camera || !leaderPresence?.screenBounds) return null;
    const { w: lw, h: lh } = leaderPresence.screenBounds;
    const { x: lx, y: ly, z: lz2 } = leaderPresence.camera;
    const theirViewport = new Box(-lx, -ly, lw / lz2, lh / lz2);
    const ourViewport = this.getViewportScreenBounds().clone();
    const ourAspectRatio = ourViewport.width / ourViewport.height;
    ourViewport.width = theirViewport.width;
    ourViewport.height = ourViewport.width / ourAspectRatio;
    if (ourViewport.height < theirViewport.height) {
      ourViewport.height = theirViewport.height;
      ourViewport.width = ourViewport.height * ourAspectRatio;
    }
    ourViewport.center = theirViewport.center;
    return ourViewport;
  }
  getCameraForFollowing() {
    const viewport = this.getViewportPageBoundsForFollowing();
    if (!viewport) return null;
    return {
      x: -viewport.x,
      y: -viewport.y,
      z: this.getViewportScreenBounds().w / viewport.width
    };
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints) return 1;
    if (cameraOptions.constraints.initialZoom === "default") return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.initialZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError$1(cameraOptions.constraints.initialZoom);
      }
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const cameraOptions = this.getCameraOptions();
    if (!cameraOptions.constraints) return 1;
    if (cameraOptions.constraints.baseZoom === "default") return 1;
    const { zx, zy } = getCameraFitXFitY(this, cameraOptions);
    switch (cameraOptions.constraints.baseZoom) {
      case "fit-min": {
        return Math.max(zx, zy);
      }
      case "fit-max": {
        return Math.min(zx, zy);
      }
      case "fit-x": {
        return zx;
      }
      case "fit-y": {
        return zy;
      }
      case "fit-min-100": {
        return Math.min(1, Math.max(zx, zy));
      }
      case "fit-max-100": {
        return Math.min(1, Math.min(zx, zy));
      }
      case "fit-x-100": {
        return Math.min(1, zx);
      }
      case "fit-y-100": {
        return Math.min(1, zy);
      }
      default: {
        throw exhaustiveSwitchError$1(cameraOptions.constraints.baseZoom);
      }
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param opts - The camera options to set.
   *
   * @public */
  setCameraOptions(opts) {
    const next = structuredClone({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...opts
    });
    if (next.zoomSteps?.length < 1) next.zoomSteps = [1];
    this._cameraOptions.set(next);
    this.setCamera(this.getCamera());
    return this;
  }
  /** @internal */
  getConstrainedCamera(point, opts) {
    const currentCamera = this.getCamera();
    let { x, y: y2, z = currentCamera.z } = point;
    if (!opts?.force) {
      const cameraOptions = this.getCameraOptions();
      const zoomMin = cameraOptions.zoomSteps[0];
      const zoomMax = last$1(cameraOptions.zoomSteps);
      const vsb = this.getViewportScreenBounds();
      if (cameraOptions.constraints) {
        const { constraints } = cameraOptions;
        const py = Math.min(constraints.padding.y, vsb.w / 2);
        const px = Math.min(constraints.padding.x, vsb.h / 2);
        const bounds = Box.From(cameraOptions.constraints.bounds);
        const zx = (vsb.w - px * 2) / bounds.w;
        const zy = (vsb.h - py * 2) / bounds.h;
        const baseZoom = this.getBaseZoom();
        const maxZ = zoomMax * baseZoom;
        const minZ = zoomMin * baseZoom;
        if (opts?.reset) {
          z = this.getInitialZoom();
        }
        if (z < minZ || z > maxZ) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          const cxA = -cx + vsb.w / cz / 2;
          const cyA = -cy + vsb.h / cz / 2;
          z = clamp$3(z, minZ, maxZ);
          const cxB = -cx + vsb.w / z / 2;
          const cyB = -cy + vsb.h / z / 2;
          x = cx + cxB - cxA;
          y2 = cy + cyB - cyA;
        }
        const minX = px / z - bounds.x;
        const minY = py / z - bounds.y;
        const freeW = (vsb.w - px * 2) / z - bounds.w;
        const freeH = (vsb.h - py * 2) / z - bounds.h;
        const originX = minX + freeW * constraints.origin.x;
        const originY = minY + freeH * constraints.origin.y;
        const behaviorX = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.x;
        const behaviorY = typeof constraints.behavior === "string" ? constraints.behavior : constraints.behavior.y;
        if (opts?.reset) {
          x = originX;
          y2 = originY;
        } else {
          switch (behaviorX) {
            case "fixed": {
              x = originX;
              break;
            }
            case "contain": {
              if (z < zx) x = originX;
              else x = clamp$3(x, minX + freeW, minX);
              break;
            }
            case "inside": {
              if (z < zx) x = clamp$3(x, minX, (vsb.w - px) / z - bounds.w);
              else x = clamp$3(x, minX + freeW, minX);
              break;
            }
            case "outside": {
              x = clamp$3(x, px / z - bounds.w, (vsb.w - px) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError$1(behaviorX);
            }
          }
          switch (behaviorY) {
            case "fixed": {
              y2 = originY;
              break;
            }
            case "contain": {
              if (z < zy) y2 = originY;
              else y2 = clamp$3(y2, minY + freeH, minY);
              break;
            }
            case "inside": {
              if (z < zy) y2 = clamp$3(y2, minY, (vsb.h - py) / z - bounds.h);
              else y2 = clamp$3(y2, minY + freeH, minY);
              break;
            }
            case "outside": {
              y2 = clamp$3(y2, py / z - bounds.h, (vsb.h - py) / z);
              break;
            }
            case "free": {
              break;
            }
            default: {
              throw exhaustiveSwitchError$1(behaviorY);
            }
          }
        }
      } else {
        if (z > zoomMax || z < zoomMin) {
          const { x: cx, y: cy, z: cz } = currentCamera;
          z = clamp$3(z, zoomMin, zoomMax);
          x = cx + (-cx + vsb.w / z / 2) - (-cx + vsb.w / cz / 2);
          y2 = cy + (-cy + vsb.h / z / 2) - (-cy + vsb.h / cz / 2);
        }
      }
    }
    return { x, y: y2, z };
  }
  /** @internal */
  _setCamera(point, opts) {
    const currentCamera = this.getCamera();
    const { x, y: y2, z } = this.getConstrainedCamera(point, opts);
    if (currentCamera.x === x && currentCamera.y === y2 && currentCamera.z === z) {
      return this;
    }
    transact(() => {
      const camera = { ...currentCamera, x, y: y2, z };
      this.run(
        () => {
          this.store.put([camera]);
        },
        { history: "ignore" }
      );
      const { currentScreenPoint, currentPagePoint } = this.inputs;
      const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
      if (currentScreenPoint.x / z - x !== currentPagePoint.x || currentScreenPoint.y / z - y2 !== currentPagePoint.y) {
        const event = {
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          // weird but true: we need to put the screen point back into client space
          point: Vec.AddXY(currentScreenPoint, screenBounds.x, screenBounds.y),
          pointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          shiftKey: this.inputs.shiftKey,
          metaKey: this.inputs.metaKey,
          accelKey: isAccelKey(this.inputs),
          button: 0,
          isPen: this.getInstanceState().isPenMode ?? false
        };
        if (opts?.immediate) {
          this._flushEventForTick(event);
        } else {
          this.dispatch(event);
        }
      }
      this._tickCameraState();
    });
    return this;
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(point, opts) {
    const { isLocked } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (isLocked && !opts?.force) return this;
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    const _point = Vec.Cast(point);
    if (!Number.isFinite(_point.x)) _point.x = 0;
    if (!Number.isFinite(_point.y)) _point.y = 0;
    if (_point.z === void 0 || !Number.isFinite(_point.z)) point.z = this.getZoomLevel();
    const camera = this.getConstrainedCamera(_point, opts);
    if (opts?.animation) {
      const { width, height } = this.getViewportScreenBounds();
      this._animateToViewport(
        new Box(-camera.x, -camera.y, width / camera.z, height / camera.z),
        opts
      );
    } else {
      this._setCamera(camera, {
        ...opts,
        // we already did the constraining, so we don't need to do it again
        force: true
      });
    }
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param opts - The camera move options.
   *
   * @public
   */
  centerOnPoint(point, opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const { width: pw, height: ph } = this.getViewportPageBounds();
    this.setCamera(new Vec(-(point.x - pw / 2), -(point.y - ph / 2), this.getCamera().z), opts);
    return this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(opts) {
    const ids = [...this.getCurrentPageShapeIds()];
    if (ids.length <= 0) return this;
    const pageBounds = Box.Common(compact$1(ids.map((id) => this.getShapePageBounds(id))));
    this.zoomToBounds(pageBounds, opts);
    return this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(point = this.getViewportScreenCenter(), opts) {
    const { isLocked, constraints } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const currentCamera = this.getCamera();
    const { x: cx, y: cy, z: cz } = currentCamera;
    const { x, y: y2 } = point;
    let z = 1;
    if (constraints) {
      const initialZoom = this.getInitialZoom();
      if (cz !== initialZoom) {
        z = initialZoom;
      }
    }
    this.setCamera(
      new Vec(cx + (x / z - x) - (x / cz - x), cy + (y2 / z - y2) - (y2 / cz - y2), z),
      opts
    );
    return this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const { x: cx, y: cy, z: cz } = this.getCamera();
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      let zoom = last$1(zoomSteps) * baseZoom;
      for (let i = 1; i < zoomSteps.length; i++) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz <= (z2 - z1) / 2) continue;
        zoom = z2;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(point = this.getViewportScreenCenter(), opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const { zoomSteps } = this.getCameraOptions();
    if (zoomSteps !== null && zoomSteps.length > 1) {
      const baseZoom = this.getBaseZoom();
      const { x: cx, y: cy, z: cz } = this.getCamera();
      let zoom = zoomSteps[0] * baseZoom;
      for (let i = zoomSteps.length - 1; i > 0; i--) {
        const z1 = zoomSteps[i - 1] * baseZoom;
        const z2 = zoomSteps[i] * baseZoom;
        if (z2 - cz >= (z2 - z1) / 2) continue;
        zoom = z1;
        break;
      }
      this.setCamera(
        new Vec(
          cx + (point.x / zoom - point.x) - (point.x / cz - point.x),
          cy + (point.y / zoom - point.y) - (point.y / cz - point.y),
          zoom
        ),
        opts
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToSelection(opts) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const selectionPageBounds = this.getSelectionPageBounds();
    if (selectionPageBounds) {
      this.zoomToBounds(selectionPageBounds, {
        targetZoom: Math.max(1, this.getZoomLevel()),
        ...opts
      });
    }
    return this;
  }
  /**
   * Zoom the camera to the current selection if offscreen.
   *
   * @public
   */
  zoomToSelectionIfOffscreen(padding = 16, opts) {
    const selectionPageBounds = this.getSelectionPageBounds();
    const viewportPageBounds = this.getViewportPageBounds();
    if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
      const eb = selectionPageBounds.clone().expandBy(padding / this.getZoomLevel()).expand(viewportPageBounds);
      const nextBounds = viewportPageBounds.clone().translate({
        x: (eb.center.x - viewportPageBounds.center.x) * 2,
        y: (eb.center.y - viewportPageBounds.center.y) * 2
      });
      this.zoomToBounds(nextBounds, opts);
    }
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(bounds, opts) {
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    if (cameraOptions.isLocked && !opts?.force) return this;
    const viewportScreenBounds = this.getViewportScreenBounds();
    const inset = opts?.inset ?? Math.min(ZOOM_TO_FIT_PADDING, viewportScreenBounds.width * 0.28);
    const baseZoom = this.getBaseZoom();
    const zoomMin = cameraOptions.zoomSteps[0];
    const zoomMax = last$1(cameraOptions.zoomSteps);
    let zoom = clamp$3(
      Math.min(
        (viewportScreenBounds.width - inset) / bounds.w,
        (viewportScreenBounds.height - inset) / bounds.h
      ),
      zoomMin * baseZoom,
      zoomMax * baseZoom
    );
    if (opts?.targetZoom !== void 0) {
      zoom = Math.min(opts.targetZoom, zoom);
    }
    this.setCamera(
      new Vec(
        -bounds.x + (viewportScreenBounds.width - bounds.w * zoom) / 2 / zoom,
        -bounds.y + (viewportScreenBounds.height - bounds.h * zoom) / 2 / zoom,
        zoom
      ),
      opts
    );
    return this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    this.emit("stop-camera-animation");
    return this;
  }
  /** @internal */
  _animateViewport(ms) {
    if (!this._viewportAnimation) return;
    this._viewportAnimation.elapsed += ms;
    const { elapsed, easing, duration, start, end } = this._viewportAnimation;
    if (elapsed > duration) {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
      this._setCamera(new Vec(-end.x, -end.y, this.getViewportScreenBounds().width / end.width));
      return;
    }
    const remaining = duration - elapsed;
    const t2 = easing(1 - remaining / duration);
    const left = start.minX + (end.minX - start.minX) * t2;
    const top = start.minY + (end.minY - start.minY) * t2;
    const right = start.maxX + (end.maxX - start.maxX) * t2;
    this._setCamera(new Vec(-left, -top, this.getViewportScreenBounds().width / (right - left)), {
      force: true
    });
  }
  /** @internal */
  _animateToViewport(targetViewportPage, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    const { animation, ...rest } = opts;
    if (!animation) return;
    const { duration = 0, easing = EASINGS.easeInOutCubic } = animation;
    const animationSpeed = this.user.getAnimationSpeed();
    const viewportPageBounds = this.getViewportPageBounds();
    this.stopCameraAnimation();
    if (this.getInstanceState().followingUserId) {
      this.stopFollowingUser();
    }
    if (duration === 0 || animationSpeed === 0) {
      return this._setCamera(
        new Vec(
          -targetViewportPage.x,
          -targetViewportPage.y,
          this.getViewportScreenBounds().width / targetViewportPage.width
        ),
        { ...rest }
      );
    }
    this._viewportAnimation = {
      elapsed: 0,
      duration: duration / animationSpeed,
      easing,
      start: viewportPageBounds.clone(),
      end: targetViewportPage.clone()
    };
    this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport);
      this._viewportAnimation = null;
    });
    this.on("tick", this._animateViewport);
    return this;
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(opts = {}) {
    const { isLocked } = this.getCameraOptions();
    if (isLocked && !opts?.force) return this;
    const animationSpeed = this.user.getAnimationSpeed();
    if (animationSpeed === 0) return this;
    this.stopCameraAnimation();
    const {
      speed,
      friction = this.options.cameraSlideFriction,
      direction,
      speedThreshold = 0.01
    } = opts;
    let currentSpeed = Math.min(speed, 1);
    const cancel = () => {
      this.off("tick", moveCamera);
      this.off("stop-camera-animation", cancel);
    };
    this.once("stop-camera-animation", cancel);
    const moveCamera = (elapsed) => {
      const { x: cx, y: cy, z: cz } = this.getCamera();
      const movementVec = Vec.Mul(direction, currentSpeed * elapsed / cz);
      currentSpeed *= 1 - friction;
      if (currentSpeed < speedThreshold) {
        cancel();
      } else {
        this._setCamera(new Vec(cx + movementVec.x, cy + movementVec.y, cz));
      }
    };
    this.on("tick", moveCamera);
    return this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(userId, opts = { animation: { duration: 500 } }) {
    const presence = this.getCollaborators().find((c2) => c2.userId === userId);
    if (!presence) return this;
    const cursor = presence.cursor;
    if (!cursor) return this;
    this.run(() => {
      if (this.getInstanceState().followingUserId !== null) {
        this.stopFollowingUser();
      }
      const isOnSamePage = presence.currentPageId === this.getCurrentPageId();
      if (!isOnSamePage) {
        this.setCurrentPage(presence.currentPageId);
      }
      if (opts && opts.animation && !isOnSamePage) {
        opts.animation = void 0;
      }
      this.centerOnPoint(cursor, opts);
      const { highlightedUserIds } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] });
      this.timers.setTimeout(() => {
        const highlightedUserIds2 = [...this.getInstanceState().highlightedUserIds];
        const index2 = highlightedUserIds2.indexOf(userId);
        if (index2 < 0) return;
        highlightedUserIds2.splice(index2, 1);
        this.updateInstanceState({ highlightedUserIds: highlightedUserIds2 });
      }, this.options.collaboratorIdleTimeoutMs);
    });
    return this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param screenBounds - The new screen bounds of the viewport.
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(screenBounds, center = false) {
    if (screenBounds instanceof HTMLElement) {
      const rect = screenBounds.getBoundingClientRect();
      screenBounds = new Box(
        rect.left || rect.x,
        rect.top || rect.y,
        Math.max(rect.width, 1),
        Math.max(rect.height, 1)
      );
    } else {
      screenBounds.width = Math.max(screenBounds.width, 1);
      screenBounds.height = Math.max(screenBounds.height, 1);
    }
    const insets = [
      // top
      screenBounds.minY !== 0,
      // right
      !approximately(document.body.scrollWidth, screenBounds.maxX, 1),
      // bottom
      !approximately(document.body.scrollHeight, screenBounds.maxY, 1),
      // left
      screenBounds.minX !== 0
    ];
    const { _willSetInitialBounds } = this;
    this._willSetInitialBounds = false;
    const { screenBounds: prevScreenBounds, insets: prevInsets } = this.getInstanceState();
    if (screenBounds.equals(prevScreenBounds) && insets.every((v, i) => v === prevInsets[i])) {
      return this;
    }
    if (_willSetInitialBounds) {
      this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
      this.setCamera(this.getCamera());
    } else {
      if (center && !this.getInstanceState().followingUserId) {
        const before = this.getViewportPageBounds().center;
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this.centerOnPoint(before);
      } else {
        this.updateInstanceState({ screenBounds: screenBounds.toJson(), insets });
        this._setCamera(Vec.From({ ...this.getCamera() }));
      }
    }
    this._tickCameraState();
    return this;
  }
  getViewportScreenBounds() {
    const { x, y: y2, w, h } = this.getInstanceState().screenBounds;
    return new Box(x, y2, w, h);
  }
  getViewportScreenCenter() {
    const viewportScreenBounds = this.getViewportScreenBounds();
    return new Vec(
      viewportScreenBounds.midX - viewportScreenBounds.minX,
      viewportScreenBounds.midY - viewportScreenBounds.minY
    );
  }
  getViewportPageBounds() {
    const { w, h } = this.getViewportScreenBounds();
    const { x: cx, y: cy, z: cz } = this.getCamera();
    return new Box(-cx, -cy, w / cz, h / cz);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x - screenBounds.x) / cz - cx,
      (point.y - screenBounds.y) / cz - cy,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(point) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec(
      (point.x + cx) * cz + screenBounds.x,
      (point.y + cy) * cz + screenBounds.y,
      point.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(point) {
    const { x: cx, y: cy, z: cz = 1 } = this.getCamera();
    return new Vec((point.x + cx) * cz, (point.y + cy) * cz, point.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const allPresenceRecords = this._getCollaboratorsQuery().get();
    if (!allPresenceRecords.length) return EMPTY_ARRAY;
    const userIds = [...new Set(allPresenceRecords.map((c2) => c2.userId))].sort();
    return userIds.map((id) => {
      const latestPresence = maxBy(
        allPresenceRecords.filter((c2) => c2.userId === id),
        (p) => p.lastActivityTimestamp ?? 0
      );
      return latestPresence;
    });
  }
  getCollaboratorsOnCurrentPage() {
    const currentPageId = this.getCurrentPageId();
    return this.getCollaborators().filter((c2) => c2.currentPageId === currentPageId);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(userId) {
    this.stopFollowingUser();
    const thisUserId = this.user.getId();
    if (!thisUserId) {
      console.warn("You should set the userId for the current instance before following a user");
    }
    const leaderPresence = this._getFollowingPresence(userId);
    if (!leaderPresence) {
      return this;
    }
    const latestLeaderPresence = computed("latestLeaderPresence", () => {
      return this._getFollowingPresence(userId);
    });
    transact(() => {
      this.updateInstanceState({ followingUserId: userId }, { history: "ignore" });
      const dispose = react$1("update current page", () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (leaderPresence2.currentPageId !== this.getCurrentPageId() && this.getPage(leaderPresence2.currentPageId)) {
          this.run(
            () => {
              this.store.put([
                { ...this.getInstanceState(), currentPageId: leaderPresence2.currentPageId }
              ]);
              this._isLockedOnFollowingUser.set(true);
            },
            { history: "ignore" }
          );
        }
      });
      const cancel = () => {
        dispose();
        this._isLockedOnFollowingUser.set(false);
        this.off("frame", moveTowardsUser);
        this.off("stop-following", cancel);
      };
      const moveTowardsUser = () => {
        const leaderPresence2 = latestLeaderPresence.get();
        if (!leaderPresence2) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get()) return;
        const animationSpeed = this.user.getAnimationSpeed();
        if (animationSpeed === 0) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const targetViewport = this.getViewportPageBoundsForFollowing();
        if (!targetViewport) {
          this.stopFollowingUser();
          return;
        }
        const currentViewport = this.getViewportPageBounds();
        const diffX = Math.abs(targetViewport.minX - currentViewport.minX) + Math.abs(targetViewport.maxX - currentViewport.maxX);
        const diffY = Math.abs(targetViewport.minY - currentViewport.minY) + Math.abs(targetViewport.maxY - currentViewport.maxY);
        if (diffX < this.options.followChaseViewportSnap && diffY < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(true);
          return;
        }
        const t2 = clamp$3(animationSpeed * 0.5, 0.1, 0.8);
        const nextViewport = new Box(
          lerp(currentViewport.minX, targetViewport.minX, t2),
          lerp(currentViewport.minY, targetViewport.minY, t2),
          lerp(currentViewport.width, targetViewport.width, t2),
          lerp(currentViewport.height, targetViewport.height, t2)
        );
        const nextCamera = new Vec(
          -nextViewport.x,
          -nextViewport.y,
          this.getViewportScreenBounds().width / nextViewport.width
        );
        this.stopCameraAnimation();
        this._setCamera(nextCamera);
      };
      this.once("stop-following", cancel);
      this.addListener("frame", moveTowardsUser);
      moveTowardsUser();
    });
    return this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    this.run(
      () => {
        this.store.put([this.getCamera()]);
        this._isLockedOnFollowingUser.set(false);
        this.updateInstanceState({ followingUserId: null });
        this.emit("stop-following");
      },
      { history: "ignore" }
    );
    return this;
  }
  /** @internal */
  getUnorderedRenderingShapes(useEditorState) {
    const renderingShapes = [];
    let nextIndex = this.options.maxShapesPerPage * 2;
    let nextBackgroundIndex = this.options.maxShapesPerPage;
    const erasingShapeIds = this.getErasingShapeIds();
    const addShapeById = (id, opacity, isAncestorErasing) => {
      const shape = this.getShape(id);
      if (!shape) return;
      if (this.isShapeHidden(shape)) {
        const isErasing = isAncestorErasing || erasingShapeIds.includes(id);
        for (const childId of this.getSortedChildIdsForParent(id)) {
          addShapeById(childId, opacity, isErasing);
        }
        return;
      }
      opacity *= shape.opacity;
      let isShapeErasing = false;
      const util2 = this.getShapeUtil(shape);
      if (useEditorState) {
        isShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id);
        if (isShapeErasing) {
          opacity *= 0.32;
        }
      }
      renderingShapes.push({
        id,
        shape,
        util: util2,
        index: nextIndex,
        backgroundIndex: nextBackgroundIndex,
        opacity
      });
      nextIndex += 1;
      nextBackgroundIndex += 1;
      const childIds = this.getSortedChildIdsForParent(id);
      if (!childIds.length) return;
      let backgroundIndexToRestore = null;
      if (util2.providesBackgroundForChildren(shape)) {
        backgroundIndexToRestore = nextBackgroundIndex;
        nextBackgroundIndex = nextIndex;
        nextIndex += this.options.maxShapesPerPage;
      }
      for (const childId of childIds) {
        addShapeById(childId, opacity, isAncestorErasing || isShapeErasing);
      }
      if (backgroundIndexToRestore !== null) {
        nextBackgroundIndex = backgroundIndexToRestore;
      }
    };
    const pages = useEditorState ? [this.getCurrentPage()] : this.getPages();
    for (const page of pages) {
      for (const childId of this.getSortedChildIdsForParent(page.id)) {
        addShapeById(childId, 1, false);
      }
    }
    return renderingShapes;
  }
  _decayCameraStateTimeout(elapsed) {
    this._cameraStateTimeoutRemaining -= elapsed;
    if (this._cameraStateTimeoutRemaining > 0) return;
    this.off("tick", this._decayCameraStateTimeout);
    this._cameraState.set("idle");
  }
  _tickCameraState() {
    this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs;
    if (this._cameraState.__unsafe__getWithoutCapture() !== "idle") return;
    this._cameraState.set("moving");
    this.on("tick", this._decayCameraStateTimeout);
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    const renderingShapes = this.getUnorderedRenderingShapes(true);
    return renderingShapes.sort(sortById);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return Array.from(this._getAllPagesQuery().get()).sort(sortByIndex$1);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or the page id) to get.
   *
   * @public
   */
  getPage(page) {
    return this.store.get(typeof page === "string" ? page : page.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or the page id) to get the shape ids for.
   *
   * @public
   **/
  getPageShapeIds(page) {
    const pageId = typeof page === "string" ? page : page.id;
    const result = this.store.query.exec("shape", { parentId: { eq: pageId } });
    return this.getShapeAndDescendantIds(result.map((s2) => s2.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or the page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(page) {
    const pageId = typeof page === "string" ? page : page.id;
    if (!this.store.has(pageId)) {
      console.error("Tried to set the current page id to a page that doesn't exist.");
      return this;
    }
    this.stopFollowingUser();
    this.complete();
    return this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: pageId }]);
        this.setCamera(this.getCamera());
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(partial) {
    if (this.getIsReadonly()) return this;
    const prev = this.getPage(partial.id);
    if (!prev) return this;
    return this.run(() => this.store.update(partial.id, (page) => ({ ...page, ...partial })));
  }
  /**
   * Create a page whilst ensuring that the page name is unique.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(page) {
    this.run(() => {
      if (this.getIsReadonly()) return;
      if (this.getPages().length >= this.options.maxPages) return;
      const pages = this.getPages();
      const name = getIncrementedName(
        page.name ?? "Page 1",
        pages.map((p) => p.name)
      );
      let index2 = page.index;
      if (!index2 || pages.some((p) => p.index === index2)) {
        index2 = getIndexAbove(pages[pages.length - 1].index);
      }
      const newPage = PageRecordType.create({
        meta: {},
        ...page,
        name,
        index: index2
      });
      this.store.put([newPage]);
    });
    return this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param page - The page (or the page id) to delete.
   *
   * @public
   */
  deletePage(page) {
    const id = typeof page === "string" ? page : page.id;
    this.run(() => {
      if (this.getIsReadonly()) return;
      const pages = this.getPages();
      if (pages.length === 1) return;
      const deletedPage = this.getPage(id);
      if (!deletedPage) return;
      if (id === this.getCurrentPageId()) {
        const index2 = pages.findIndex((page2) => page2.id === id);
        const next = pages[index2 - 1] ?? pages[index2 + 1];
        this.setCurrentPage(next.id);
      }
      this.store.remove([deletedPage.id]);
    });
    return this;
  }
  /**
   * Duplicate a page.
   *
   * @param page - The page (or the page id) to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(page, createId = PageRecordType.createId()) {
    if (this.getPages().length >= this.options.maxPages) return this;
    const id = typeof page === "string" ? page : page.id;
    const freshPage = this.getPage(id);
    if (!freshPage) return this;
    const prevCamera = { ...this.getCamera() };
    const content = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(freshPage.id));
    this.run(() => {
      const pages = this.getPages();
      const index2 = getIndexBetween(freshPage.index, pages[pages.indexOf(freshPage) + 1]?.index);
      this.createPage({ name: freshPage.name + " Copy", id: createId, index: index2 });
      this.setCurrentPage(createId);
      this.setCamera(prevCamera);
      if (content) {
        return this.putContentOntoCurrentPage(content);
      }
    });
    return this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param page - The page (or the page id) to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(page, name) {
    const id = typeof page === "string" ? page : page.id;
    if (this.getIsReadonly()) return this;
    this.updatePage({ id, name });
    return this;
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(assets) {
    if (this.getIsReadonly()) return this;
    if (assets.length <= 0) return this;
    this.run(() => this.store.put(assets), { history: "ignore" });
    return this;
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(assets) {
    if (this.getIsReadonly()) return this;
    if (assets.length <= 0) return this;
    this.run(
      () => {
        this.store.put(
          assets.map((partial) => ({
            ...this.store.get(partial.id),
            ...partial
          }))
        );
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param assets - The assets (or asset ids) to delete.
   *
   * @public
   */
  deleteAssets(assets) {
    if (this.getIsReadonly()) return this;
    const ids = typeof assets[0] === "string" ? assets : assets.map((a2) => a2.id);
    if (ids.length <= 0) return this;
    this.run(
      () => {
        this.store.props.assets.remove?.(ids);
        this.store.remove(ids);
      },
      { history: "ignore" }
    );
    return this;
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(asset) {
    return this.store.get(typeof asset === "string" ? asset : asset.id);
  }
  async resolveAssetUrl(assetId, context) {
    if (!assetId) return null;
    const asset = this.getAsset(assetId);
    if (!asset) return null;
    const {
      screenScale = 1,
      shouldResolveToOriginal = false,
      dpr = this.getInstanceState().devicePixelRatio
    } = context;
    const zoomStepFunction = (zoom) => Math.pow(2, Math.ceil(Math.log2(zoom)));
    const steppedScreenScale = zoomStepFunction(screenScale);
    const networkEffectiveType = "connection" in navigator ? navigator.connection.effectiveType : null;
    return await this.store.props.assets.resolve(asset, {
      screenScale: screenScale || 1,
      steppedScreenScale,
      dpr,
      networkEffectiveType,
      shouldResolveToOriginal
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(asset, file, abortSignal) {
    return await this.store.props.assets.upload(asset, file, abortSignal);
  }
  /**
   * Get the geometry of a shape in shape-space.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * editor.getShapeGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapeGeometry(shape, opts) {
    const context = opts?.context ?? "none";
    if (!this._shapeGeometryCaches[context]) {
      this._shapeGeometryCaches[context] = this.store.createComputedCache(
        "bounds",
        (shape2) => {
          this.fonts.trackFontsForShape(shape2);
          return this.getShapeUtil(shape2).getGeometry(shape2, opts);
        },
        { areRecordsEqual: areShapesContentEqual }
      );
    }
    return this._shapeGeometryCaches[context].get(
      typeof shape === "string" ? shape : shape.id
    );
  }
  /**
   * Get the geometry of a shape in page-space.
   *
   * @example
   * ```ts
   * editor.getShapePageGeometry(myShape)
   * editor.getShapePageGeometry(myShapeId)
   * editor.getShapePageGeometry(myShapeId, { context: "arrow" })
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.
   *
   * @public
   */
  getShapePageGeometry(shape, opts) {
    const context = opts?.context ?? "none";
    if (!this._shapePageGeometryCaches[context]) {
      this._shapePageGeometryCaches[context] = this.store.createComputedCache(
        "bounds",
        (shape2) => {
          const geometry = this.getShapeGeometry(shape2.id, opts);
          const pageTransform = this.getShapePageTransform(shape2.id);
          return geometry.transform(pageTransform);
        },
        {
          // we only depend directly on the shape id, and changing geometry/transform will update us anyway
          areRecordsEqual: () => true
        }
      );
    }
    return this._shapePageGeometryCaches[context].get(
      typeof shape === "string" ? shape : shape.id
    );
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache(
      "handles",
      (shape) => {
        return this.getShapeUtil(shape).getHandles?.(shape);
      },
      {
        areRecordsEqual: areShapesContentEqual
      }
    );
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(shape) {
    return this._getShapeHandlesCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) throw Error("Editor.getTransform: shape not found");
    return Mat.Identity().translate(freshShape.x, freshShape.y).rotate(freshShape.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (shape) => {
      if (isPageId(shape.parentId)) {
        return this.getShapeLocalTransform(shape);
      }
      const parentTransform = this._getShapePageTransformCache().get(shape.parentId) ?? Mat.Identity();
      return Mat.Compose(parentTransform, this.getShapeLocalTransform(shape));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape || isPageId(freshShape.parentId)) return Mat.Identity();
    return this._getShapePageTransformCache().get(freshShape.parentId) ?? Mat.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id) ?? Mat.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (shape) => {
      return this.getShapePageGeometry(shape).bounds;
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(shape) {
    return this._getShapePageBoundsCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (shape) => {
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (!pageMask) return void 0;
      if (pageMask.length === 0) {
        return `polygon(0px 0px, 0px 0px, 0px 0px)`;
      }
      const pageTransform = this._getShapePageTransformCache().get(shape.id);
      if (!pageTransform) return void 0;
      const localMask = Mat.applyToPoints(Mat.Inverse(pageTransform), pageMask);
      return `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(",")})`;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(shape) {
    return this._getShapeClipPathCache().get(typeof shape === "string" ? shape : shape.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (shape) => {
      if (isPageId(shape.parentId)) return void 0;
      const frameAncestors = this.getShapeAncestors(shape.id).filter(
        (shape2) => this.isShapeOfType(shape2, "frame")
      );
      if (frameAncestors.length === 0) return void 0;
      const pageMask = frameAncestors.map(
        (s2) => (
          // Apply the frame transform to the frame outline to get the frame outline in the current page space
          this.getShapePageGeometry(s2.id).vertices
        )
      ).reduce((acc, b) => {
        if (!(b && acc)) return void 0;
        const intersection = intersectPolygonPolygon(acc, b);
        if (intersection) {
          return intersection.map(Vec.Cast);
        }
        return [];
      });
      return pageMask;
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param shape - The shape (or the shape id) of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(shape) {
    return this._getShapeMaskCache().get(typeof shape === "string" ? shape : shape.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(shape) {
    if (typeof shape !== "string") shape = shape.id;
    return this._getShapeMaskedPageBoundsCache().get(shape);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (shape) => {
      const pageBounds = this._getShapePageBoundsCache().get(shape.id);
      if (!pageBounds) return;
      const pageMask = this._getShapeMaskCache().get(shape.id);
      if (pageMask) {
        if (pageMask.length === 0) return void 0;
        const { corners } = pageBounds;
        if (corners.every((p, i) => p && Vec.Equals(p, pageMask[i]))) return pageBounds.clone();
        const intersection = intersectPolygonPolygon(pageMask, corners);
        if (!intersection) return;
        return Box.FromPoints(intersection);
      }
      return pageBounds;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   * @param acc - The accumulator.
   *
   * @public
   */
  getShapeAncestors(shape, acc = []) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return acc;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) {
      acc.reverse();
      return acc;
    }
    const parent = this.store.get(parentId);
    if (!parent) return acc;
    acc.push(parent);
    return this.getShapeAncestors(parent, acc);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @param predicate - The predicate to match.
   *
   * @public
   */
  findShapeAncestor(shape, predicate) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return;
    const parentId = freshShape.parentId;
    if (isPageId(parentId)) return;
    const parent = this.getShape(parentId);
    if (!parent) return;
    return predicate(parent) ? parent : this.findShapeAncestor(parent, predicate);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(shape, ancestorId) {
    const id = typeof shape === "string" ? shape : shape?.id;
    const freshShape = id && this.getShape(id);
    if (!freshShape) return false;
    if (freshShape.parentId === ancestorId) return true;
    return this.hasAncestor(this.getShapeParent(freshShape), ancestorId);
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(shapes, predicate) {
    if (shapes.length === 0) {
      return;
    }
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const freshShapes = compact$1(ids.map((id) => this.getShape(id)));
    if (freshShapes.length === 1) {
      const parentId = freshShapes[0].parentId;
      if (isPageId(parentId)) {
        return;
      }
      return predicate ? this.findShapeAncestor(freshShapes[0], predicate)?.id : parentId;
    }
    const [nodeA, ...others] = freshShapes;
    let ancestor = this.getShapeParent(nodeA);
    while (ancestor) {
      if (predicate && !predicate(ancestor)) {
        ancestor = this.getShapeParent(ancestor);
        continue;
      }
      if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
        return ancestor.id;
      }
      ancestor = this.getShapeParent(ancestor);
    }
    return void 0;
  }
  isShapeOrAncestorLocked(arg) {
    const shape = typeof arg === "string" ? this.getShape(arg) : arg;
    if (shape === void 0) return false;
    if (shape.isLocked) return true;
    return this.isShapeOrAncestorLocked(this.getShapeParent(shape));
  }
  _notVisibleShapes() {
    return notVisibleShapes(this);
  }
  getCulledShapes() {
    const notVisibleShapes2 = this._notVisibleShapes().get();
    const selectedShapeIds = this.getSelectedShapeIds();
    const editingId = this.getEditingShapeId();
    const culledShapes = new Set(notVisibleShapes2);
    if (editingId) {
      culledShapes.delete(editingId);
    }
    selectedShapeIds.forEach((id) => {
      culledShapes.delete(id);
    });
    return culledShapes;
  }
  getCurrentPageBounds() {
    let commonBounds;
    this.getCurrentPageShapeIdsSorted().forEach((shapeId) => {
      const bounds = this.getShapeMaskedPageBounds(shapeId);
      if (!bounds) return;
      if (!commonBounds) {
        commonBounds = bounds.clone();
      } else {
        commonBounds = commonBounds.expand(bounds);
      }
    });
    return commonBounds;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(point) {
    const selectedShapeIds = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((shape) => shape.type !== "group" && selectedShapeIds.includes(shape.id)).reverse().find((shape) => this.isPointInShape(shape, point, { hitInside: true, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(point, opts = {}) {
    const zoomLevel = this.getZoomLevel();
    const viewportPageBounds = this.getViewportPageBounds();
    const {
      filter: filter2,
      margin = 0,
      hitLocked = false,
      hitLabels = false,
      hitInside = false,
      hitFrameInside = false
    } = opts;
    let inHollowSmallestArea = Infinity;
    let inHollowSmallestAreaHit = null;
    let inMarginClosestToEdgeDistance = Infinity;
    let inMarginClosestToEdgeHit = null;
    const shapesToCheck = (opts.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((shape) => {
      if (shape.isLocked && !hitLocked || this.isShapeHidden(shape) || this.isShapeOfType(shape, "group"))
        return false;
      const pageMask = this.getShapeMask(shape);
      if (pageMask && !pointInPolygon(point, pageMask)) return false;
      if (filter2) return filter2(shape);
      return true;
    });
    for (let i = shapesToCheck.length - 1; i >= 0; i--) {
      const shape = shapesToCheck[i];
      const geometry = this.getShapeGeometry(shape);
      const isGroup = geometry instanceof Group2d;
      const pointInShapeSpace = this.getPointInShapeSpace(shape, point);
      if (this.isShapeOfType(shape, "frame") || this.isShapeOfType(shape, "arrow") && shape.props.text.trim() || (this.isShapeOfType(shape, "note") || this.isShapeOfType(shape, "geo") && shape.props.fill === "none") && this.getShapeUtil(shape).getText(shape)?.trim()) {
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && childGeometry.isPointInBounds(pointInShapeSpace)) {
            return shape;
          }
        }
      }
      if (this.isShapeOfType(shape, "frame")) {
        const distance2 = geometry.distanceToPoint(pointInShapeSpace, hitInside);
        if (Math.abs(distance2) <= margin) {
          return inMarginClosestToEdgeHit || shape;
        }
        if (geometry.hitTestPoint(pointInShapeSpace, 0, true)) {
          return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || (hitFrameInside ? shape : void 0);
        }
        continue;
      }
      let distance;
      if (isGroup) {
        let minDistance = Infinity;
        for (const childGeometry of geometry.children) {
          if (childGeometry.isLabel && !hitLabels) continue;
          const tDistance = childGeometry.distanceToPoint(pointInShapeSpace, hitInside);
          if (tDistance < minDistance) {
            minDistance = tDistance;
          }
        }
        distance = minDistance;
      } else {
        if (margin === 0 && (geometry.bounds.w < 1 || geometry.bounds.h < 1)) {
          distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
        } else {
          if (geometry.bounds.containsPoint(pointInShapeSpace, margin)) {
            distance = geometry.distanceToPoint(pointInShapeSpace, hitInside);
          } else {
            distance = Infinity;
          }
        }
      }
      if (geometry.isClosed) {
        if (distance <= margin) {
          if (geometry.isFilled || isGroup && geometry.children[0].isFilled) {
            return inMarginClosestToEdgeHit || shape;
          } else {
            if (this.getShapePageBounds(shape).contains(viewportPageBounds)) continue;
            if (Math.abs(distance) < margin) {
              if (Math.abs(distance) < inMarginClosestToEdgeDistance) {
                inMarginClosestToEdgeDistance = Math.abs(distance);
                inMarginClosestToEdgeHit = shape;
              }
            } else if (!inMarginClosestToEdgeHit) {
              const { area } = geometry;
              if (area < inHollowSmallestArea) {
                inHollowSmallestArea = area;
                inHollowSmallestAreaHit = shape;
              }
            }
          }
        }
      } else {
        if (distance < this.options.hitTestMargin / zoomLevel) {
          return shape;
        }
      }
    }
    return inMarginClosestToEdgeHit || inHollowSmallestAreaHit || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, exact: true })
   * ```
   *
   * @param point - The page point to test.
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  getShapesAtPoint(point, opts = {}) {
    return this.getCurrentPageShapes().filter(
      (shape) => !this.isShapeHidden(shape) && this.isPointInShape(shape, point, opts)
    );
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  isPointInShape(shape, point, opts = {}) {
    const { hitInside = false, margin = 0 } = opts;
    const id = typeof shape === "string" ? shape : shape.id;
    const pageMask = this.getShapeMask(id);
    if (pageMask && !pointInPolygon(point, pageMask)) return false;
    return this.getShapeGeometry(id).hitTestPoint(
      this.getPointInShapeSpace(shape, point),
      margin,
      hitInside
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this._getShapePageTransformCache().get(id).clone().invert().applyToPoint(point);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(shape, point) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    if (!freshShape) return new Vec(0, 0);
    if (isPageId(freshShape.parentId)) return Vec.From(point);
    const parentTransform = this.getShapePageTransform(freshShape.parentId);
    if (!parentTransform) return Vec.From(point);
    return parentTransform.clone().invert().applyToPoint(point);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (id) => this.store.get(id));
  }
  getCurrentPageShapesSorted() {
    const result = [];
    const topLevelShapes = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let i = 0, n2 = topLevelShapes.length; i < n2; i++) {
      pushShapeWithDescendants(this, topLevelShapes[i], result);
    }
    return result;
  }
  getCurrentPageRenderingShapesSorted() {
    const culledShapes = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(
      ({ id }) => !culledShapes.has(id) && !this.isShapeHidden(id)
    );
  }
  isShapeOfType(arg, type) {
    const shape = typeof arg === "string" ? this.getShape(arg) : arg;
    if (!shape) return false;
    return shape.type === type;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param shape - The shape (or the id of the shape) to get.
   *
   * @public
   */
  getShape(shape) {
    const id = typeof shape === "string" ? shape : shape.id;
    if (!isShapeId(id)) return void 0;
    return this.store.get(id);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(shape) {
    const id = typeof shape === "string" ? shape : shape?.id;
    if (!id) return void 0;
    const freshShape = this.getShape(id);
    if (freshShape === void 0 || !isShapeId(freshShape.parentId)) return void 0;
    return this.store.get(freshShape.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(siblingShape, targetShape) {
    if (!targetShape) {
      return void 0;
    }
    if (targetShape.parentId === siblingShape.parentId) {
      return targetShape;
    }
    const ancestor = this.findShapeAncestor(
      targetShape,
      (ancestor2) => ancestor2.parentId === siblingShape.parentId
    );
    return ancestor;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(shape, pageId = this.getCurrentPageId()) {
    const id = typeof shape === "string" ? shape : shape.id;
    const shapeToCheck = this.getShape(id);
    if (!shapeToCheck) return false;
    let shapeIsInPage = false;
    if (shapeToCheck.parentId === pageId) {
      shapeIsInPage = true;
    } else {
      let parent = this.getShape(shapeToCheck.parentId);
      isInPageSearch: while (parent) {
        if (parent.parentId === pageId) {
          shapeIsInPage = true;
          break isInPageSearch;
        }
        parent = this.getShape(parent.parentId);
      }
    }
    return shapeIsInPage;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(shape) {
    const id = typeof shape === "string" ? shape : shape?.id;
    const _shape = id && this.getShape(id);
    if (!_shape) return void 0;
    if (isPageId(_shape.parentId)) {
      return _shape.parentId;
    } else {
      return this.getAncestorPageId(this.getShape(_shape.parentId));
    }
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(shapes, parentId, insertIndex) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (ids.length === 0) return this;
    const changes = [];
    const parentTransform = isPageId(parentId) ? Mat.Identity() : this.getShapePageTransform(parentId);
    const parentPageRotation = parentTransform.rotation();
    let indices = [];
    const sibs = compact$1(this.getSortedChildIdsForParent(parentId).map((id) => this.getShape(id)));
    if (insertIndex) {
      const sibWithInsertIndex = sibs.find((s2) => s2.index === insertIndex);
      if (sibWithInsertIndex) {
        const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      } else {
        const sibAbove = sibs.sort(sortByIndex$1).find((s2) => s2.index > insertIndex);
        if (sibAbove) {
          indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = getIndicesAbove(insertIndex, ids.length);
        }
      }
    } else {
      const sib = sibs.length && sibs[sibs.length - 1];
      indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length);
    }
    const invertedParentTransform = parentTransform.clone().invert();
    const shapesToReparent = compact$1(ids.map((id) => this.getShape(id))).sort(sortByIndex$1);
    this.run(
      () => {
        for (let i = 0; i < shapesToReparent.length; i++) {
          const shape = shapesToReparent[i];
          const pageTransform = this.getShapePageTransform(shape);
          if (!pageTransform) continue;
          const pagePoint = pageTransform.point();
          if (!pagePoint) continue;
          const newPoint = invertedParentTransform.applyToPoint(pagePoint);
          const newRotation = pageTransform.rotation() - parentPageRotation;
          changes.push({
            id: shape.id,
            type: shape.type,
            parentId,
            x: newPoint.x,
            y: newPoint.y,
            rotation: newRotation,
            index: indices[i]
          });
        }
        this.updateShapes(changes);
      },
      { ignoreShapeLock: true }
    );
    return this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parent - The parent (or the id) of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const children = this._parentIdsToChildIds.get()[parentId];
    if (!children || children.length === 0) {
      return "a1";
    }
    const shape = this.getShape(children[children.length - 1]);
    return getIndexAbove(shape.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(parent) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const ids = this._parentIdsToChildIds.get()[parentId];
    if (!ids) return EMPTY_ARRAY;
    return ids;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(parent, visitor) {
    const parentId = typeof parent === "string" ? parent : parent.id;
    const children = this.getSortedChildIdsForParent(parentId);
    for (const id of children) {
      if (visitor(id) === false) continue;
      this.visitDescendants(id, visitor);
    }
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(ids) {
    const shapeIds = /* @__PURE__ */ new Set();
    for (const shape of ids.map((id) => this.getShape(id)).sort(sortByIndex$1)) {
      shapeIds.add(shape.id);
      this.visitDescendants(shape, (descendantId) => {
        shapeIds.add(descendantId);
      });
    }
    return shapeIds;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDroppingOverShape(point, droppingShapes = []) {
    const currentPageShapesSorted = this.getCurrentPageShapesSorted();
    for (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {
      const shape = currentPageShapesSorted[i];
      if (
        // ignore hidden shapes
        this.isShapeHidden(shape) || // don't allow dropping on selected shapes
        this.getSelectedShapeIds().includes(shape.id) || // only allow shapes that can receive children
        !this.getShapeUtil(shape).canDropShapes(shape, droppingShapes) || // don't allow dropping a shape on itself or one of it's children
        droppingShapes.find((s2) => s2.id === shape.id || this.hasAncestor(shape, s2.id))
      ) {
        continue;
      }
      const maskedPageBounds = this.getShapeMaskedPageBounds(shape.id);
      if (maskedPageBounds && maskedPageBounds.containsPoint(point) && this.getShapeGeometry(shape).hitTestPoint(this.getPointInShapeSpace(shape, point), 0, true)) {
        return shape;
      }
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(shape, filter2) {
    const id = typeof shape === "string" ? shape : shape.id;
    const freshShape = this.getShape(id);
    let match = freshShape;
    let node = freshShape;
    const focusedGroup = this.getFocusedGroup();
    while (node) {
      if (this.isShapeOfType(node, "group") && focusedGroup?.id !== node.id && !this.hasAncestor(focusedGroup, node.id) && (filter2?.(node) ?? true)) {
        match = node;
      } else if (focusedGroup?.id === node.id) {
        break;
      }
      node = this.getShapeParent(node);
    }
    return match;
  }
  _getBindingsIndexCache() {
    const index2 = bindingsIndex(this);
    return this.store.createComputedCache(
      "bindingsIndex",
      (shape) => {
        return index2.get().get(shape.id);
      },
      // we can ignore the shape equality check here because the index is
      // computed incrementally based on what bindings are in the store
      { areRecordsEqual: () => true }
    );
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(id) {
    return this.store.get(id);
  }
  /**
   * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose
   * `fromId` matched the shape's ID.
   */
  getBindingsFromShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.fromId === id && b.type === type
    );
  }
  /**
   * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose
   * `toId` matches the shape's ID.
   */
  getBindingsToShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    return this.getBindingsInvolvingShape(id).filter(
      (b) => b.toId === id && b.type === type
    );
  }
  /**
   * Get all bindings involving a particular shape. This includes bindings where the shape is the
   * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.
   */
  getBindingsInvolvingShape(shape, type) {
    const id = typeof shape === "string" ? shape : shape.id;
    const result = this._getBindingsIndexCache().get(id) ?? EMPTY_ARRAY;
    if (!type) return result;
    return result.filter((b) => b.type === type);
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(partials) {
    const bindings = [];
    for (const partial of partials) {
      const fromShape = this.getShape(partial.fromId);
      const toShape = this.getShape(partial.toId);
      if (!fromShape || !toShape) continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: partial })) continue;
      const util2 = this.getBindingUtil(partial.type);
      const defaultProps = util2.getDefaultProps();
      const binding = this.store.schema.types.binding.create({
        ...partial,
        id: partial.id ?? createBindingId(),
        props: {
          ...defaultProps,
          ...partial.props
        }
      });
      bindings.push(binding);
    }
    this.store.put(bindings);
    return this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(partial) {
    return this.createBindings([partial]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(partials) {
    const updated = [];
    for (const partial of partials) {
      if (!partial) continue;
      const current = this.getBinding(partial.id);
      if (!current) continue;
      const updatedBinding = applyPartialToRecordWithProps(current, partial);
      if (updatedBinding === current) continue;
      const fromShape = this.getShape(updatedBinding.fromId);
      const toShape = this.getShape(updatedBinding.toId);
      if (!fromShape || !toShape) continue;
      if (!this.canBindShapes({ fromShape, toShape, binding: updatedBinding })) continue;
      updated.push(updatedBinding);
    }
    this.store.put(updated);
    return this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(partial) {
    return this.updateBindings([partial]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(bindings, { isolateShapes = false } = {}) {
    const ids = bindings.map((binding) => typeof binding === "string" ? binding : binding.id);
    if (isolateShapes) {
      this.store.atomic(() => {
        for (const id of ids) {
          const binding = this.getBinding(id);
          if (!binding) continue;
          const util2 = this.getBindingUtil(binding);
          util2.onBeforeIsolateFromShape?.({ binding, removedShape: this.getShape(binding.toId) });
          util2.onBeforeIsolateToShape?.({ binding, removedShape: this.getShape(binding.fromId) });
          this.store.remove([id]);
        }
      });
    } else {
      this.store.remove(ids);
    }
    return this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(binding, opts) {
    return this.deleteBindings([binding], opts);
  }
  canBindShapes({
    fromShape,
    toShape,
    binding
  }) {
    const fromShapeType = typeof fromShape === "string" ? fromShape : fromShape.type;
    const toShapeType = typeof toShape === "string" ? toShape : toShape.type;
    const bindingType = typeof binding === "string" ? binding : binding.type;
    const canBindOpts = { fromShapeType, toShapeType, bindingType };
    if (fromShapeType === toShapeType) {
      return this.getShapeUtil(fromShapeType).canBind(canBindOpts);
    }
    return this.getShapeUtil(fromShapeType).canBind(canBindOpts) && this.getShapeUtil(toShapeType).canBind(canBindOpts);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   * @param opts - The options for the rotation.
   */
  rotateShapesBy(shapes, delta, opts) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (ids.length <= 0) return this;
    const snapshot = getRotationSnapshot({ editor: this, ids });
    if (!snapshot) return this;
    applyRotationToSnapshotShapes({
      delta,
      snapshot,
      editor: this,
      stage: "one-off",
      centerOverride: opts?.center
    });
    return this;
  }
  // Gets a shape partial that includes life cycle changes: on translate start, on translate, on translate end
  getChangesToTranslateShape(initialShape, newShapeCoords) {
    let workingShape = initialShape;
    const util2 = this.getShapeUtil(initialShape);
    const afterTranslateStart = util2.onTranslateStart?.(workingShape);
    if (afterTranslateStart) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateStart);
    }
    workingShape = applyPartialToRecordWithProps(workingShape, {
      id: initialShape.id,
      type: initialShape.type,
      x: newShapeCoords.x,
      y: newShapeCoords.y
    });
    const afterTranslate = util2.onTranslate?.(initialShape, workingShape);
    if (afterTranslate) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslate);
    }
    const afterTranslateEnd = util2.onTranslateEnd?.(initialShape, workingShape);
    if (afterTranslateEnd) {
      workingShape = applyPartialToRecordWithProps(workingShape, afterTranslateEnd);
    }
    return workingShape;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param offset - The offset to apply to the shapes.
   */
  nudgeShapes(shapes, offset2) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (ids.length <= 0) return this;
    const changes = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      const localDelta = Vec.From(offset2);
      const parentTransform = this.getShapeParentTransform(shape);
      if (parentTransform) localDelta.rot(-parentTransform.rotation());
      changes.push(this.getChangesToTranslateShape(shape, localDelta.add(shape)));
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(shapes, offset2) {
    this.run(() => {
      const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
      if (ids.length <= 0) return this;
      const initialIds = new Set(ids);
      const shapeIdSet = this.getShapeAndDescendantIds(ids);
      const orderedShapeIds = [...shapeIdSet].reverse();
      const shapeIds = /* @__PURE__ */ new Map();
      for (const shapeId of shapeIdSet) {
        shapeIds.set(shapeId, createShapeId());
      }
      const { shapesToCreateWithOriginals, bindingsToCreate } = withIsolatedShapes(
        this,
        shapeIdSet,
        (bindingIdsToMaintain) => {
          const bindingsToCreate2 = [];
          for (const originalId of bindingIdsToMaintain) {
            const originalBinding = this.getBinding(originalId);
            if (!originalBinding) continue;
            const duplicatedId = createBindingId();
            bindingsToCreate2.push({
              ...originalBinding,
              id: duplicatedId,
              fromId: assertExists(shapeIds.get(originalBinding.fromId)),
              toId: assertExists(shapeIds.get(originalBinding.toId))
            });
          }
          const shapesToCreateWithOriginals2 = [];
          for (const originalId of orderedShapeIds) {
            const duplicatedId = assertExists(shapeIds.get(originalId));
            const originalShape = this.getShape(originalId);
            if (!originalShape) continue;
            let ox = 0;
            let oy = 0;
            if (offset2 && initialIds.has(originalId)) {
              const parentTransform = this.getShapeParentTransform(originalShape);
              const vec = new Vec(offset2.x, offset2.y).rot(-parentTransform.rotation());
              ox = vec.x;
              oy = vec.y;
            }
            shapesToCreateWithOriginals2.push({
              shape: {
                ...originalShape,
                id: duplicatedId,
                x: originalShape.x + ox,
                y: originalShape.y + oy,
                // Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`
                index: "a1",
                parentId: shapeIds.get(originalShape.parentId) ?? originalShape.parentId
              },
              originalShape
            });
          }
          return { shapesToCreateWithOriginals: shapesToCreateWithOriginals2, bindingsToCreate: bindingsToCreate2 };
        }
      );
      shapesToCreateWithOriginals.forEach(({ shape, originalShape }) => {
        const parentId = originalShape.parentId;
        const siblings = this.getSortedChildIdsForParent(parentId);
        const currentIndex = siblings.indexOf(originalShape.id);
        const siblingAboveId = siblings[currentIndex + 1];
        const siblingAbove = siblingAboveId ? this.getShape(siblingAboveId) : void 0;
        const index2 = getIndexBetween(originalShape.index, siblingAbove?.index);
        shape.index = index2;
      });
      const shapesToCreate = shapesToCreateWithOriginals.map(({ shape }) => shape);
      const maxShapesReached = shapesToCreate.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage;
      if (maxShapesReached) {
        alertMaxShapes(this);
        return;
      }
      this.createShapes(shapesToCreate);
      this.createBindings(bindingsToCreate);
      this.setSelectedShapes(compact$1(ids.map((id) => shapeIds.get(id))));
      if (offset2 !== void 0) {
        const selectionPageBounds = this.getSelectionPageBounds();
        const viewportPageBounds = this.getViewportPageBounds();
        if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
          this.centerOnPoint(selectionPageBounds.center, {
            animation: { duration: this.options.animationMediumMs }
          });
        }
      }
    });
    return this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(shapes, pageId) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (ids.length === 0) return this;
    if (this.getIsReadonly()) return this;
    const currentPageId = this.getCurrentPageId();
    if (pageId === currentPageId) return this;
    if (!this.store.has(pageId)) return this;
    const content = this.getContentFromCurrentPage(ids);
    if (!content) return this;
    if (this.getPageShapeIds(pageId).size + content.shapes.length > this.options.maxShapesPerPage) {
      alertMaxShapes(this, pageId);
      return this;
    }
    const fromPageZ = this.getCamera().z;
    this.run(() => {
      this.deleteShapes(ids);
      this.setCurrentPage(pageId);
      this.setFocusedGroup(null);
      this.selectNone();
      this.putContentOntoCurrentPage(content, {
        select: true,
        preserveIds: true,
        preservePosition: true
      });
      this.setCamera({ ...this.getCamera(), z: fromPageZ });
      this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    });
    return this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (this.getIsReadonly() || ids.length === 0) return this;
    let allLocked = true, allUnlocked = true;
    const shapesToToggle = [];
    for (const id of ids) {
      const shape = this.getShape(id);
      if (shape) {
        shapesToToggle.push(shape);
        if (shape.isLocked) {
          allUnlocked = false;
        } else {
          allLocked = false;
        }
      }
    }
    this.run(() => {
      if (allUnlocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
        this.setSelectedShapes([]);
      } else if (allLocked) {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))
        );
      } else {
        this.updateShapes(
          shapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))
        );
      }
    });
    return this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const changes = getReorderingShapesChanges(this, "toBack", ids, {
      considerAllShapes: true
    });
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the backward operation.
   *
   * @public
   */
  sendBackward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const changes = getReorderingShapesChanges(this, "backward", ids, opts);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the forward operation.
   *
   * @public
   */
  bringForward(shapes, opts = {}) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const changes = getReorderingShapesChanges(this, "forward", ids, opts);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const changes = getReorderingShapesChanges(this, "toFront", ids);
    if (changes) this.updateShapes(changes);
    return this;
  }
  /**
   * @internal
   */
  collectShapesViaArrowBindings(info) {
    const { initialShapes, resultShapes, resultBounds, bindings, visited } = info;
    for (const binding of bindings) {
      for (const id of [binding.fromId, binding.toId]) {
        if (!visited.has(id)) {
          const aligningShape = initialShapes.find((s2) => s2.id === id);
          if (aligningShape && !visited.has(aligningShape.id)) {
            visited.add(aligningShape.id);
            const shapePageBounds = this.getShapePageBounds(aligningShape);
            if (!shapePageBounds) continue;
            resultShapes.push(aligningShape);
            resultBounds.push(shapePageBounds);
            this.collectShapesViaArrowBindings({
              ...info,
              bindings: this.getBindingsInvolvingShape(aligningShape, "arrow")
            });
          }
        }
      }
    }
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const shapesToFlipFirstPass = compact$1(ids.map((id) => this.getShape(id)));
    for (const shape of shapesToFlipFirstPass) {
      if (this.isShapeOfType(shape, "group")) {
        const childrenOfGroups = compact$1(
          this.getSortedChildIdsForParent(shape.id).map((id) => this.getShape(id))
        );
        shapesToFlipFirstPass.push(...childrenOfGroups);
      }
    }
    const shapesToFlip = [];
    const allBounds = [];
    for (const shape of shapesToFlipFirstPass) {
      const util2 = this.getShapeUtil(shape);
      if (!util2.canBeLaidOut(shape, {
        type: "flip",
        shapes: shapesToFlipFirstPass
      })) {
        continue;
      }
      const pageBounds = this.getShapePageBounds(shape);
      const localBounds = this.getShapeGeometry(shape).bounds;
      const pageTransform = this.getShapePageTransform(shape.id);
      if (!(pageBounds && localBounds && pageTransform)) continue;
      shapesToFlip.push({
        shape,
        localBounds,
        pageTransform,
        isAspectRatioLocked: util2.isAspectRatioLocked(shape)
      });
      allBounds.push(pageBounds);
    }
    if (!shapesToFlip.length) return this;
    const scaleOriginPage = Box.Common(allBounds).center;
    this.run(() => {
      for (const { shape, localBounds, pageTransform, isAspectRatioLocked } of shapesToFlip) {
        this.resizeShape(
          shape.id,
          { x: operation === "horizontal" ? -1 : 1, y: operation === "vertical" ? -1 : 1 },
          {
            initialBounds: localBounds,
            initialPageTransform: pageTransform,
            initialShape: shape,
            isAspectRatioLocked,
            mode: "scale_shape",
            scaleOrigin: scaleOriginPage,
            scaleAxisRotation: 0
          }
        );
      }
    });
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal')
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes. By default, uses the editor's `adjacentShapeMargin` option.
   *
   * @public
   */
  stackShapes(shapes, operation, gap) {
    const _gap = gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (this.getIsReadonly()) return this;
    const shapesToStackFirstPass = compact$1(ids.map((id) => this.getShape(id)));
    const shapeClustersToStack = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStackFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "stack",
        shapes: shapesToStackFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToStack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
    }
    const len = shapeClustersToStack.length;
    if (_gap === 0 && len < 3 || len < 2) return this;
    let val;
    let min2;
    let max2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min2 = "minX";
      max2 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min2 = "minY";
      max2 = "maxY";
      dim = "height";
    }
    let shapeGap = 0;
    if (_gap === 0) {
      const gaps = {};
      shapeClustersToStack.sort((a2, b) => a2.pageBounds[min2] - b.pageBounds[min2]);
      for (let i = 0; i < len - 1; i++) {
        const currCluster = shapeClustersToStack[i];
        const nextCluster = shapeClustersToStack[i + 1];
        const gap2 = nextCluster.pageBounds[min2] - currCluster.pageBounds[max2];
        if (!gaps[gap2]) {
          gaps[gap2] = 0;
        }
        gaps[gap2]++;
      }
      let maxCount = 1;
      for (const [gap2, count2] of Object.entries(gaps)) {
        if (count2 > maxCount) {
          maxCount = count2;
          shapeGap = parseFloat(gap2);
        }
      }
      if (maxCount === 1) {
        let totalCount = 0;
        for (const [gap2, count2] of Object.entries(gaps)) {
          shapeGap += parseFloat(gap2) * count2;
          totalCount += count2;
        }
        shapeGap /= totalCount;
      }
    } else {
      shapeGap = _gap;
    }
    const changes = [];
    let v = shapeClustersToStack[0].pageBounds[max2];
    for (let i = 1; i < shapeClustersToStack.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToStack[i];
      const delta = new Vec();
      delta[val] = v + shapeGap - pageBounds[val];
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + shapeGap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2])
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to the editor's `adjacentShapeMargin` option.
   */
  packShapes(shapes, _gap) {
    if (this.getIsReadonly()) return this;
    const gap = _gap ?? this.options.adjacentShapeMargin;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const shapesToPackFirstPass = compact$1(ids.map((id) => this.getShape(id)));
    const shapeClustersToPack = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToPackFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "pack",
        shapes: shapesToPackFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToPackFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToPack.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds,
        nextPageBounds: commonPageBounds.clone()
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToPack.length < 2) return this;
    let area = 0;
    for (const { pageBounds } of shapeClustersToPack) {
      area += pageBounds.width * pageBounds.height;
    }
    const commonBounds = Box.Common(allBounds);
    const maxWidth = commonBounds.width;
    shapeClustersToPack.sort((a2, b) => a2.pageBounds.width - b.pageBounds.width).sort((a2, b) => a2.pageBounds.height - b.pageBounds.height);
    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
    const spaces = [new Box(commonBounds.x, commonBounds.y, startWidth, Infinity)];
    let width = 0;
    let height = 0;
    let space;
    let last2;
    for (const { nextPageBounds } of shapeClustersToPack) {
      for (let i = spaces.length - 1; i >= 0; i--) {
        space = spaces[i];
        if (nextPageBounds.width > space.width || nextPageBounds.height > space.height) continue;
        nextPageBounds.x = space.x;
        nextPageBounds.y = space.y;
        height = Math.max(height, nextPageBounds.maxY);
        width = Math.max(width, nextPageBounds.maxX);
        if (nextPageBounds.width === space.width && nextPageBounds.height === space.height) {
          last2 = spaces.pop();
          if (i < spaces.length) spaces[i] = last2;
        } else if (nextPageBounds.height === space.height) {
          space.x += nextPageBounds.width + gap;
          space.width -= nextPageBounds.width + gap;
        } else if (nextPageBounds.width === space.width) {
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        } else {
          spaces.push(
            new Box(
              space.x + (nextPageBounds.width + gap),
              space.y,
              space.width - (nextPageBounds.width + gap),
              nextPageBounds.height
            )
          );
          space.y += nextPageBounds.height + gap;
          space.height -= nextPageBounds.height + gap;
        }
        break;
      }
    }
    const commonAfter = Box.Common(shapeClustersToPack.map((s2) => s2.nextPageBounds));
    const centerDelta = Vec.Sub(commonBounds.center, commonAfter.center);
    const changes = [];
    for (const { shapes: shapes2, pageBounds, nextPageBounds } of shapeClustersToPack) {
      const delta = Vec.Sub(nextPageBounds.point, pageBounds.point).add(centerDelta);
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    }
    if (changes.length) {
      this.updateShapes(changes);
    }
    return this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const shapesToAlignFirstPass = compact$1(ids.map((id) => this.getShape(id)));
    const shapeClustersToAlign = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToAlignFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "align",
        shapes: shapesToAlignFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToAlignFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToAlign.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToAlign.length < 2) return this;
    const commonBounds = Box.Common(allBounds);
    const changes = [];
    shapeClustersToAlign.forEach(({ shapes: shapes2, pageBounds }) => {
      const delta = new Vec();
      switch (operation) {
        case "top": {
          delta.y = commonBounds.minY - pageBounds.minY;
          break;
        }
        case "center-vertical": {
          delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;
          break;
        }
        case "bottom": {
          delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;
          break;
        }
        case "left": {
          delta.x = commonBounds.minX - pageBounds.minX;
          break;
        }
        case "center-horizontal": {
          delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;
          break;
        }
        case "right": {
          delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;
          break;
        }
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
    });
    this.updateShapes(changes);
    return this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(shapes, operation) {
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const shapesToDistributeFirstPass = compact$1(ids.map((id) => this.getShape(id)));
    const shapeClustersToDistribute = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToDistributeFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "distribute",
        shapes: shapesToDistributeFirstPass
      })) {
        continue;
      }
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToDistributeFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToDistribute.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
    }
    if (shapeClustersToDistribute.length < 3) return this;
    let val;
    let min2;
    let max2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min2 = "minX";
      max2 = "maxX";
      dim = "width";
    } else {
      val = "y";
      min2 = "minY";
      max2 = "maxY";
      dim = "height";
    }
    const changes = [];
    const first2 = shapeClustersToDistribute.sort((a2, b) => a2.pageBounds[min2] - b.pageBounds[min2])[0];
    const last2 = shapeClustersToDistribute.sort((a2, b) => b.pageBounds[max2] - a2.pageBounds[max2])[0];
    if (first2 === last2) {
      const excludedShapeIds = new Set(first2.shapes.map((s2) => s2.id));
      return this.distributeShapes(
        ids.filter((id) => !excludedShapeIds.has(id)),
        operation
      );
    }
    const shapeClustersToMove = shapeClustersToDistribute.filter((shape) => shape !== first2 && shape !== last2).sort((a2, b) => {
      if (a2.pageBounds[min2] === b.pageBounds[min2]) {
        return a2.shapes[0].id < b.shapes[0].id ? -1 : 1;
      }
      return a2.pageBounds[min2] - b.pageBounds[min2];
    });
    const maxFirst = first2.pageBounds[max2];
    const range = last2.pageBounds[min2] - maxFirst;
    const summedShapeDimensions = shapeClustersToMove.reduce((acc, s2) => acc + s2.pageBounds[dim], 0);
    const gap = (range - summedShapeDimensions) / (shapeClustersToMove.length + 1);
    for (let v = maxFirst + gap, i = 0; i < shapeClustersToMove.length; i++) {
      const { shapes: shapes2, pageBounds } = shapeClustersToMove[i];
      const delta = new Vec();
      delta[val] = v - pageBounds[val];
      if (v + pageBounds[dim] > last2.pageBounds[max2] - 1) {
        delta[val] = last2.pageBounds[max2] - pageBounds[max2] - 1;
      }
      for (const shape of shapes2) {
        const shapeDelta = delta.clone();
        const parent = this.getShapeParent(shape);
        if (parent) {
          const parentTransform = this.getShapePageTransform(parent);
          if (parentTransform) shapeDelta.rot(-parentTransform.rotation());
        }
        shapeDelta.add(shape);
        changes.push(this.getChangesToTranslateShape(shape, shapeDelta));
      }
      v += pageBounds[dim] + gap;
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(shapes, operation) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (this.getIsReadonly()) return this;
    const shapesToStretchFirstPass = compact$1(ids.map((id) => this.getShape(id))).filter(
      (s2) => this.getShapePageTransform(s2)?.rotation() % (PI$1 / 2) === 0
    );
    const shapeClustersToStretch = [];
    const allBounds = [];
    const visited = /* @__PURE__ */ new Set();
    for (const shape of shapesToStretchFirstPass) {
      if (visited.has(shape.id)) continue;
      visited.add(shape.id);
      const shapePageBounds = this.getShapePageBounds(shape);
      if (!shapePageBounds) continue;
      const shapesMovingTogether = [shape];
      const boundsOfShapesMovingTogether = [shapePageBounds];
      if (!this.getShapeUtil(shape).canBeLaidOut?.(shape, {
        type: "stretch",
        shapes: shapesToStretchFirstPass
      })) {
        continue;
      }
      this.collectShapesViaArrowBindings({
        bindings: this.getBindingsToShape(shape.id, "arrow"),
        initialShapes: shapesToStretchFirstPass,
        resultShapes: shapesMovingTogether,
        resultBounds: boundsOfShapesMovingTogether,
        visited
      });
      const commonPageBounds = Box.Common(boundsOfShapesMovingTogether);
      if (!commonPageBounds) continue;
      shapeClustersToStretch.push({
        shapes: shapesMovingTogether,
        pageBounds: commonPageBounds
      });
      allBounds.push(commonPageBounds);
    }
    if (shapeClustersToStretch.length < 2) return this;
    const commonBounds = Box.Common(allBounds);
    let val;
    let min2;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min2 = "minX";
      dim = "width";
    } else {
      val = "y";
      min2 = "minY";
      dim = "height";
    }
    this.run(() => {
      shapeClustersToStretch.forEach(({ shapes: shapes2, pageBounds }) => {
        const localOffset = new Vec();
        localOffset[val] = commonBounds[min2] - pageBounds[min2];
        const scaleOrigin = pageBounds.center.clone();
        scaleOrigin[val] = commonBounds[min2];
        const scale = new Vec(1, 1);
        scale[val] = commonBounds[dim] / pageBounds[dim];
        for (const shape of shapes2) {
          const shapeLocalOffset = localOffset.clone();
          const parentTransform = this.getShapeParentTransform(shape);
          if (parentTransform) localOffset.rot(-parentTransform.rotation());
          shapeLocalOffset.add(shape);
          const changes = this.getChangesToTranslateShape(shape, shapeLocalOffset);
          this.updateShape(changes);
          this.resizeShape(shape.id, scale, {
            initialBounds: this.getShapeGeometry(shape).bounds,
            scaleOrigin,
            isAspectRatioLocked: this.getShapeUtil(shape).isAspectRatioLocked(shape),
            scaleAxisRotation: 0
          });
        }
      });
    });
    return this;
  }
  /**
   * Resize a shape.
   *
   * @param shape - The shape (or the shape id of the shape) to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param opts - Additional options.
   *
   * @public
   */
  resizeShape(shape, scale, opts = {}) {
    const id = typeof shape === "string" ? shape : shape.id;
    if (this.getIsReadonly()) return this;
    if (!Number.isFinite(scale.x)) scale = new Vec(1, scale.y);
    if (!Number.isFinite(scale.y)) scale = new Vec(scale.x, 1);
    const initialShape = opts.initialShape ?? this.getShape(id);
    if (!initialShape) return this;
    const scaleOrigin = opts.scaleOrigin ?? this.getShapePageBounds(id)?.center;
    if (!scaleOrigin) return this;
    const pageTransform = opts.initialPageTransform ? Mat.Cast(opts.initialPageTransform) : this.getShapePageTransform(id);
    if (!pageTransform) return this;
    const pageRotation = pageTransform.rotation();
    if (pageRotation == null) return this;
    const scaleAxisRotation = opts.scaleAxisRotation ?? pageRotation;
    const initialBounds = opts.initialBounds ?? this.getShapeGeometry(id).bounds;
    if (!initialBounds) return this;
    const isAspectRatioLocked = opts.isAspectRatioLocked ?? this.getShapeUtil(initialShape).isAspectRatioLocked(initialShape);
    if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {
      return this._resizeUnalignedShape(id, scale, {
        ...opts,
        initialBounds,
        scaleOrigin,
        scaleAxisRotation,
        initialPageTransform: pageTransform,
        isAspectRatioLocked,
        initialShape
      });
    }
    const util2 = this.getShapeUtil(initialShape);
    if (isAspectRatioLocked) {
      if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale = new Vec(scale.x, Math.sign(scale.y) * Math.abs(scale.x));
      } else {
        scale = new Vec(Math.sign(scale.x) * Math.abs(scale.y), scale.y);
      }
    }
    let didResize = false;
    if (util2.onResize && util2.canResize(initialShape)) {
      const newPagePoint = this._scalePagePoint(
        Mat.applyToPoint(pageTransform, new Vec(0, 0)),
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);
      const myScale = new Vec(scale.x, scale.y);
      const areWidthAndHeightAlignedWithCorrectAxis = approximately(
        (pageRotation - scaleAxisRotation) % Math.PI,
        0
      );
      myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;
      myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;
      const initialPagePoint = Mat.applyToPoint(pageTransform, new Vec());
      const { x, y: y2 } = this.getPointInParentSpace(initialShape.id, initialPagePoint);
      let workingShape = initialShape;
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          initialShape,
          util2.onResizeStart?.(initialShape) ?? void 0
        );
      }
      const resizedShape = util2.onResize(
        { ...initialShape, x, y: y2 },
        {
          newPoint: newLocalPoint,
          handle: opts.dragHandle ?? "bottom_right",
          // don't set isSingle to true for children
          mode: opts.mode ?? "scale_shape",
          scaleX: myScale.x,
          scaleY: myScale.y,
          initialBounds,
          initialShape
        }
      );
      if (resizedShape) {
        didResize = true;
      }
      workingShape = applyPartialToRecordWithProps(workingShape, {
        id,
        type: initialShape.type,
        x: newLocalPoint.x,
        y: newLocalPoint.y,
        ...resizedShape
      });
      if (!opts.skipStartAndEndCallbacks) {
        workingShape = applyPartialToRecordWithProps(
          workingShape,
          util2.onResizeEnd?.(initialShape, workingShape) ?? void 0
        );
      }
      this.updateShapes([workingShape]);
    }
    if (!didResize) {
      const initialPageCenter = Mat.applyToPoint(pageTransform, initialBounds.center);
      const newPageCenter = this._scalePagePoint(
        initialPageCenter,
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const initialPageCenterInParentSpace = this.getPointInParentSpace(
        initialShape.id,
        initialPageCenter
      );
      const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);
      const delta = Vec.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);
      this.updateShapes([
        {
          id,
          type: initialShape.type,
          x: initialShape.x + delta.x,
          y: initialShape.y + delta.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(point, scaleOrigin, scale, scaleAxisRotation) {
    const relativePoint = Vec.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);
    const newRelativePagePoint = Vec.MulV(relativePoint, scale);
    const destination = Vec.Add(newRelativePagePoint, scaleOrigin).rotWith(
      scaleOrigin,
      scaleAxisRotation
    );
    return destination;
  }
  /** @internal */
  _resizeUnalignedShape(id, scale, options) {
    const { type } = options.initialShape;
    const shapeScale = new Vec(scale.x, scale.y);
    if (Math.abs(scale.x) > Math.abs(scale.y)) {
      shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);
    } else {
      shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);
    }
    this.resizeShape(id, shapeScale, {
      initialShape: options.initialShape,
      initialBounds: options.initialBounds,
      isAspectRatioLocked: options.isAspectRatioLocked
    });
    if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
      let { rotation } = Mat.Decompose(options.initialPageTransform);
      rotation -= 2 * rotation;
      this.updateShapes([{ id, type, rotation }]);
    }
    const preScaleShapePageCenter = Mat.applyToPoint(
      options.initialPageTransform,
      options.initialBounds.center
    );
    const postScaleShapePageCenter = this._scalePagePoint(
      preScaleShapePageCenter,
      options.scaleOrigin,
      scale,
      options.scaleAxisRotation
    );
    const pageBounds = this.getShapePageBounds(id);
    const pageTransform = this.getShapePageTransform(id);
    const currentPageCenter = pageBounds.center;
    const shapePageTransformOrigin = pageTransform.point();
    if (!currentPageCenter || !shapePageTransformOrigin) return this;
    const pageDelta = Vec.Sub(postScaleShapePageCenter, currentPageCenter);
    const postScaleShapePagePoint = Vec.Add(shapePageTransformOrigin, pageDelta);
    const { x, y: y2 } = this.getPointInParentSpace(id, postScaleShapePagePoint);
    this.updateShapes([{ id, type, x, y: y2 }]);
    return this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(_shape) {
    return {};
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { richText: toRichText("ok") } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(shape) {
    this.createShapes([shape]);
    return this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { richText: toRichText("ok") } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   *
   * @public
   */
  createShapes(shapes) {
    if (!Array.isArray(shapes)) {
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    }
    if (this.getIsReadonly()) return this;
    if (shapes.length <= 0) return this;
    const currentPageShapeIds = this.getCurrentPageShapeIds();
    const maxShapesReached = shapes.length + currentPageShapeIds.size > this.options.maxShapesPerPage;
    if (maxShapesReached) {
      alertMaxShapes(this);
      return this;
    }
    const focusedGroupId = this.getFocusedGroupId();
    this.run(() => {
      const currentPageShapesSorted = this.getCurrentPageShapesSorted();
      const partials = shapes.map((partial) => {
        if (!partial.id) {
          partial = { id: createShapeId(), ...partial };
        }
        if (!partial.parentId || !(this.store.has(partial.parentId) || shapes.some((p) => p.id === partial.parentId))) {
          let parentId = this.getFocusedGroupId();
          for (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {
            const parent = currentPageShapesSorted[i];
            if (!this.isShapeHidden(parent) && this.getShapeUtil(parent).canReceiveNewChildrenOfType(parent, partial.type) && this.isPointInShape(
              parent,
              // If no parent is provided, then we can treat the
              // shape's provided x/y as being in the page's space.
              { x: partial.x ?? 0, y: partial.y ?? 0 },
              {
                margin: 0,
                hitInside: true
              }
            )) {
              parentId = parent.id;
              break;
            }
          }
          const prevParentId = partial.parentId;
          if (parentId === partial.id) {
            parentId = focusedGroupId;
          }
          if (parentId !== prevParentId) {
            partial = { ...partial };
            partial.parentId = parentId;
            if (isShapeId(parentId)) {
              const point = this.getPointInShapeSpace(this.getShape(parentId), {
                x: partial.x ?? 0,
                y: partial.y ?? 0
              });
              partial.x = point.x;
              partial.y = point.y;
              partial.rotation = -this.getShapePageTransform(parentId).rotation() + (partial.rotation ?? 0);
            }
          }
        }
        return partial;
      });
      const parentIndices = /* @__PURE__ */ new Map();
      const shapeRecordsToCreate = [];
      const { opacityForNextShape } = this.getInstanceState();
      for (const partial of partials) {
        const util2 = this.getShapeUtil(partial);
        let index2 = partial.index;
        if (!index2) {
          const parentId = partial.parentId ?? focusedGroupId;
          if (!parentIndices.has(parentId)) {
            parentIndices.set(parentId, this.getHighestIndexForParent(parentId));
          }
          index2 = parentIndices.get(parentId);
          parentIndices.set(parentId, getIndexAbove(index2));
        }
        const initialProps = util2.getDefaultProps();
        for (const [style2, propKey] of this.styleProps[partial.type]) {
          initialProps[propKey] = this.getStyleForNextShape(style2);
        }
        let shapeRecordToCreate = this.store.schema.types.shape.create({
          ...partial,
          index: index2,
          opacity: partial.opacity ?? opacityForNextShape,
          parentId: partial.parentId ?? focusedGroupId,
          props: "props" in partial ? { ...initialProps, ...partial.props } : initialProps
        });
        if (shapeRecordToCreate.index === void 0) {
          throw Error("no index!");
        }
        const next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate);
        if (next) {
          shapeRecordToCreate = next;
        }
        shapeRecordsToCreate.push(shapeRecordToCreate);
      }
      shapeRecordsToCreate.forEach((shape) => {
        shape.meta = {
          ...this.getInitialMetaForShape(shape),
          ...shape.meta
        };
      });
      this.store.put(shapeRecordsToCreate);
    });
    return this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShape(partial, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    return this.animateShapes([partial], opts);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShapes(partials, opts = { animation: DEFAULT_ANIMATION_OPTIONS }) {
    if (!opts.animation) return this;
    const { duration = 500, easing = EASINGS.linear } = opts.animation;
    const animationId = uniqueId();
    let remaining = duration;
    let t2;
    const animations = [];
    let partial, result;
    for (let i = 0, n2 = partials.length; i < n2; i++) {
      partial = partials[i];
      if (!partial) continue;
      const shape = this.getShape(partial.id);
      if (!shape) continue;
      result = {
        start: structuredClone(shape),
        end: applyPartialToRecordWithProps(structuredClone(shape), partial)
      };
      animations.push(result);
      this.animatingShapes.set(shape.id, animationId);
    }
    const handleTick = (elapsed) => {
      remaining -= elapsed;
      if (remaining < 0) {
        const { animatingShapes: animatingShapes2 } = this;
        const partialsToUpdate = partials.filter(
          (p) => p && animatingShapes2.get(p.id) === animationId
        );
        if (partialsToUpdate.length) {
          this.updateShapes(partialsToUpdate);
        }
        this.off("tick", handleTick);
        return;
      }
      t2 = easing(1 - remaining / duration);
      const { animatingShapes } = this;
      const updates = [];
      let animationIdForShape;
      for (let i = 0, n2 = animations.length; i < n2; i++) {
        const { start, end } = animations[i];
        animationIdForShape = animatingShapes.get(start.id);
        if (animationIdForShape !== animationId) continue;
        updates.push({
          ...end,
          x: start.x + (end.x - start.x) * t2,
          y: start.y + (end.y - start.y) * t2,
          opacity: start.opacity + (end.opacity - start.opacity) * t2,
          rotation: start.rotation + (end.rotation - start.rotation) * t2,
          props: this.getShapeUtil(end).getInterpolatedProps?.(start, end, t2) ?? end.props
        });
      }
      this._updateShapes(updates);
    };
    this.on("tick", handleTick);
    return this;
  }
  groupShapes(shapes, opts = {}) {
    const { groupId = createShapeId(), select = true } = opts;
    if (!Array.isArray(shapes)) {
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    }
    if (this.getIsReadonly()) return this;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (ids.length <= 1) return this;
    const shapesToGroup = compact$1(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    const sortedShapeIds = shapesToGroup.sort(sortByIndex$1).map((s2) => s2.id);
    const pageBounds = Box.Common(compact$1(shapesToGroup.map((id) => this.getShapePageBounds(id))));
    const { x, y: y2 } = pageBounds.point;
    const parentId = this.findCommonAncestor(shapesToGroup) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select") return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const shapesWithRootParent = shapesToGroup.filter((shape) => shape.parentId === parentId).sort(sortByIndex$1);
    const highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index;
    this.run(() => {
      this.createShapes([
        {
          id: groupId,
          type: "group",
          parentId,
          index: highestIndex,
          x,
          y: y2,
          opacity: 1,
          props: {}
        }
      ]);
      this.reparentShapes(sortedShapeIds, groupId);
      if (select) {
        this.select(groupId);
      }
    });
    return this;
  }
  ungroupShapes(shapes, opts = {}) {
    if (this.getIsReadonly()) return this;
    const { select = true } = opts;
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    const shapesToUngroup = compact$1(
      (this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map(
        (id) => this.getShape(id)
      )
    );
    if (shapesToUngroup.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const idsToSelect = /* @__PURE__ */ new Set();
    const groups = [];
    shapesToUngroup.forEach((shape) => {
      if (this.isShapeOfType(shape, "group")) {
        groups.push(shape);
      } else {
        idsToSelect.add(shape.id);
      }
    });
    if (groups.length === 0) return this;
    this.run(() => {
      let group;
      for (let i = 0, n2 = groups.length; i < n2; i++) {
        group = groups[i];
        const childIds = this.getSortedChildIdsForParent(group.id);
        for (let j = 0, n22 = childIds.length; j < n22; j++) {
          idsToSelect.add(childIds[j]);
        }
        this.reparentShapes(childIds, group.parentId, group.index);
      }
      this.deleteShapes(groups.map((group2) => group2.id));
      if (select) {
        this.select(...idsToSelect);
      }
    });
    return this;
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(partial) {
    this.updateShapes([partial]);
    return this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(partials) {
    const compactedPartials = Array(partials.length);
    for (let i = 0, n2 = partials.length; i < n2; i++) {
      const partial = partials[i];
      if (!partial) continue;
      const shape = this.getShape(partial.id);
      if (!shape) continue;
      if (!this._shouldIgnoreShapeLock) {
        if (shape.isLocked) {
          if (!(Object.hasOwn(partial, "isLocked") && !partial.isLocked)) {
            continue;
          }
        } else if (this.isShapeOrAncestorLocked(shape)) {
          continue;
        }
      }
      this.animatingShapes.delete(partial.id);
      compactedPartials.push(partial);
    }
    this._updateShapes(compactedPartials);
    return this;
  }
  /** @internal */
  _updateShapes(_partials) {
    if (this.getIsReadonly()) return;
    this.run(() => {
      const updates = [];
      let shape;
      let updated;
      for (let i = 0, n2 = _partials.length; i < n2; i++) {
        const partial = _partials[i];
        if (!partial) continue;
        shape = this.getShape(partial.id);
        if (!shape) continue;
        updated = applyPartialToRecordWithProps(shape, partial);
        if (updated === shape) continue;
        updated = this.getShapeUtil(shape).onBeforeUpdate?.(shape, updated) ?? updated;
        updates.push(updated);
      }
      this.store.put(updates);
    });
  }
  /** @internal */
  _getUnlockedShapeIds(ids) {
    return ids.filter((id) => !this.getShape(id)?.isLocked);
  }
  deleteShapes(_ids) {
    if (this.getIsReadonly()) return this;
    if (!Array.isArray(_ids)) {
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    }
    const shapeIds = typeof _ids[0] === "string" ? _ids : _ids.map((s2) => s2.id);
    const shapeIdsToDelete = this._shouldIgnoreShapeLock ? shapeIds : this._getUnlockedShapeIds(shapeIds);
    if (shapeIdsToDelete.length === 0) return this;
    const allShapeIdsToDelete = new Set(shapeIdsToDelete);
    for (const id of shapeIdsToDelete) {
      this.visitDescendants(id, (childId) => {
        allShapeIdsToDelete.add(childId);
      });
    }
    return this.run(() => this.store.remove([...allShapeIdsToDelete]));
  }
  deleteShape(_id) {
    this.deleteShapes([typeof _id === "string" ? _id : _id.id]);
    return this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(shape, sharedStyleMap) {
    if (this.isShapeOfType(shape, "group")) {
      const childIds = this._parentIdsToChildIds.get()[shape.id];
      if (!childIds) return;
      for (let i = 0, n2 = childIds.length; i < n2; i++) {
        this._extractSharedStyles(this.getShape(childIds[i]), sharedStyleMap);
      }
    } else {
      for (const [style2, propKey] of this.styleProps[shape.type]) {
        sharedStyleMap.applyValue(style2, getOwnProperty(shape.props, propKey));
      }
    }
  }
  _getSelectionSharedStyles() {
    const selectedShapes = this.getSelectedShapes();
    const sharedStyles = new SharedStyleMap();
    for (const selectedShape of selectedShapes) {
      this._extractSharedStyles(selectedShape, sharedStyles);
    }
    return sharedStyles;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(style2) {
    const value = this.getInstanceState().stylesForNextShape[style2.id];
    return value === void 0 ? style2.defaultValue : value;
  }
  getShapeStyleIfExists(shape, style2) {
    const styleKey = this.styleProps[shape.type].get(style2);
    if (styleKey === void 0) return void 0;
    return getOwnProperty(shape.props, styleKey);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      return this._getSelectionSharedStyles();
    }
    const currentTool = this.root.getCurrent();
    const styles = new SharedStyleMap();
    if (!currentTool) return styles;
    if (currentTool.shapeType) {
      if (currentTool.shapeType === "frame" && !this.getShapeUtil("frame").options.showColors) {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          if (style2.id === "tldraw:color") continue;
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      } else {
        for (const style2 of this.styleProps[currentTool.shapeType].keys()) {
          styles.applyValue(style2, this.getStyleForNextShape(style2));
        }
      }
    }
    return styles;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const shapesToCheck = [];
      const addShape = (shapeId) => {
        const shape = this.getShape(shapeId);
        if (!shape) return;
        if (this.isShapeOfType(shape, "group")) {
          for (const childId of this.getSortedChildIdsForParent(shape.id)) {
            addShape(childId);
          }
        } else {
          shapesToCheck.push(shape);
        }
      };
      for (const shapeId of this.getSelectedShapeIds()) {
        addShape(shapeId);
      }
      let opacity = null;
      for (const shape of shapesToCheck) {
        if (opacity === null) {
          opacity = shape.opacity;
        } else if (opacity !== shape.opacity) {
          return { type: "mixed" };
        }
      }
      if (opacity !== null) return { type: "shared", value: opacity };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(opacity, historyOptions) {
    this.updateInstanceState({ opacityForNextShape: opacity }, historyOptions);
    return this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(opacity) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const shapesToUpdate = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          shapesToUpdate.push(shape);
        }
      };
      for (const id of selectedShapes) {
        addShapeById(id);
      }
      this.updateShapes(
        shapesToUpdate.map((shape) => {
          return {
            id: shape.id,
            type: shape.type,
            opacity
          };
        })
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(style2, value, historyOptions) {
    const stylesForNextShape = this.getInstanceState().stylesForNextShape;
    this.updateInstanceState(
      { stylesForNextShape: { ...stylesForNextShape, [style2.id]: value } },
      historyOptions
    );
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   *
   * @public
   */
  setStyleForSelectedShapes(style2, value) {
    const selectedShapes = this.getSelectedShapes();
    if (selectedShapes.length > 0) {
      const updates = [];
      const addShapeById = (shape) => {
        if (this.isShapeOfType(shape, "group")) {
          const childIds = this.getSortedChildIdsForParent(shape.id);
          for (const childId of childIds) {
            addShapeById(this.getShape(childId));
          }
        } else {
          const util2 = this.getShapeUtil(shape);
          const stylePropKey = this.styleProps[shape.type].get(style2);
          if (stylePropKey) {
            const shapePartial = {
              id: shape.id,
              type: shape.type,
              props: { [stylePropKey]: value }
            };
            updates.push({
              util: util2,
              originalShape: shape,
              updatePartial: shapePartial
            });
          }
        }
      };
      for (const shape of selectedShapes) {
        addShapeById(shape);
      }
      this.updateShapes(updates.map(({ updatePartial }) => updatePartial));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(type, handler) {
    this.externalAssetContentHandlers[type] = handler;
    return this;
  }
  /**
   * Register a temporary preview of an asset. This is useful for showing a ghost image of
   * something that is being uploaded. Retrieve the placeholder with
   * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this
   * can be configured using
   *
   * @example
   * ```ts
   * editor.createTemporaryAssetPreview(assetId, file)
   * ```
   *
   * @param assetId - The asset's id.
   * @param file - The raw file.
   *
   * @public
   */
  createTemporaryAssetPreview(assetId, file) {
    if (this.temporaryAssetPreview.has(assetId)) {
      return this.temporaryAssetPreview.get(assetId);
    }
    const objectUrl = URL.createObjectURL(file);
    this.temporaryAssetPreview.set(assetId, objectUrl);
    setTimeout(() => {
      this.temporaryAssetPreview.delete(assetId);
      URL.revokeObjectURL(objectUrl);
    }, this.options.temporaryAssetPreviewLifetimeMs);
    return objectUrl;
  }
  /**
   * Get temporary preview of an asset. This is useful for showing a ghost
   * image of something that is being uploaded.
   *
   * @example
   * ```ts
   * editor.getTemporaryAssetPreview('someId')
   * ```
   *
   * @param assetId - The asset's id.
   *
   * @public
   */
  getTemporaryAssetPreview(assetId) {
    return this.temporaryAssetPreview.get(assetId);
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(info) {
    return await this.externalAssetContentHandlers[info.type]?.(info);
  }
  hasExternalAssetHandler(type) {
    return !!this.externalAssetContentHandlers[type];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   * @example
   * ```ts
   * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(type, handler) {
    this.externalContentHandlers[type] = handler;
    return this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   */
  async putExternalContent(info) {
    return this.externalContentHandlers[info.type]?.(info);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(shapes) {
    const ids = typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (!ids) return;
    if (ids.length === 0) return;
    const shapeIds = this.getShapeAndDescendantIds(ids);
    return withIsolatedShapes(this, shapeIds, (bindingIdsToKeep) => {
      const bindings = [];
      for (const id of bindingIdsToKeep) {
        const binding = this.getBinding(id);
        if (!binding) continue;
        bindings.push(binding);
      }
      const rootShapeIds = [];
      const shapes2 = [];
      for (const shapeId of shapeIds) {
        const shape = this.getShape(shapeId);
        if (!shape) continue;
        const isRootShape = !shapeIds.has(shape.parentId);
        if (isRootShape) {
          const pageTransform = this.getShapePageTransform(shape.id);
          const pagePoint = pageTransform.point();
          shapes2.push({
            ...shape,
            x: pagePoint.x,
            y: pagePoint.y,
            rotation: pageTransform.rotation(),
            parentId: this.getCurrentPageId()
          });
          rootShapeIds.push(shape.id);
        } else {
          shapes2.push(shape);
        }
      }
      const assets = [];
      const seenAssetIds = /* @__PURE__ */ new Set();
      for (const shape of shapes2) {
        if (!("assetId" in shape.props)) continue;
        const assetId = shape.props.assetId;
        if (!assetId || seenAssetIds.has(assetId)) continue;
        seenAssetIds.add(assetId);
        const asset = this.getAsset(assetId);
        if (!asset) continue;
        assets.push(asset);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: shapes2,
        rootShapeIds,
        bindings,
        assets
      };
    });
  }
  async resolveAssetsInContent(content) {
    if (!content) return void 0;
    const assets = [];
    await Promise.allSettled(
      content.assets.map(async (asset) => {
        if ((asset.type === "image" || asset.type === "video") && !asset.props.src?.startsWith("data:image") && !asset.props.src?.startsWith("data:video") && !asset.props.src?.startsWith("http")) {
          const assetWithDataUrl = structuredClone(asset);
          const objectUrl = await this.store.props.assets.resolve(asset, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: true
          });
          assetWithDataUrl.props.src = await FileHelpers.blobToDataUrl(
            await fetch$1(objectUrl).then((r2) => r2.blob())
          );
          assets.push(assetWithDataUrl);
        } else {
          assets.push(asset);
        }
      })
    );
    content.assets = assets;
    return content;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param opts - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(content, opts = {}) {
    if (this.getIsReadonly()) return this;
    if (!content.schema) {
      throw Error("Could not put content:\ncontent is missing a schema.");
    }
    const { select = false, preserveIds = false, preservePosition = false } = opts;
    let { point = void 0 } = opts;
    const currentPageId = this.getCurrentPageId();
    const { rootShapeIds } = content;
    const assets = [];
    const shapes = [];
    const bindings = [];
    const store = {
      store: {
        ...Object.fromEntries(content.assets.map((asset) => [asset.id, asset])),
        ...Object.fromEntries(content.shapes.map((shape) => [shape.id, shape])),
        ...Object.fromEntries(
          content.bindings?.map((bindings2) => [bindings2.id, bindings2]) ?? []
        )
      },
      schema: content.schema
    };
    const result = this.store.schema.migrateStoreSnapshot(store);
    if (result.type === "error") {
      throw Error("Could not put content: could not migrate content");
    }
    for (const record of Object.values(result.value)) {
      switch (record.typeName) {
        case "asset": {
          assets.push(record);
          break;
        }
        case "shape": {
          shapes.push(record);
          break;
        }
        case "binding": {
          bindings.push(record);
          break;
        }
      }
    }
    const shapeIdMap = new Map(
      preserveIds ? shapes.map((shape) => [shape.id, shape.id]) : shapes.map((shape) => [shape.id, createShapeId()])
    );
    const bindingIdMap = new Map(
      preserveIds ? bindings.map((binding) => [binding.id, binding.id]) : bindings.map((binding) => [binding.id, createBindingId()])
    );
    let pasteParentId = this.getCurrentPageId();
    let lowestDepth = Infinity;
    let lowestAncestors = [];
    for (const shape of this.getSelectedShapes()) {
      if (lowestDepth === 0) break;
      const isFrame = this.isShapeOfType(shape, "frame");
      const ancestors = this.getShapeAncestors(shape);
      if (isFrame) ancestors.push(shape);
      const depth = isFrame ? ancestors.length + 1 : ancestors.length;
      if (depth < lowestDepth) {
        lowestDepth = depth;
        lowestAncestors = ancestors;
        pasteParentId = isFrame ? shape.id : shape.parentId;
      } else if (depth === lowestDepth) {
        if (lowestAncestors.length !== ancestors.length) {
          throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`);
        }
        if (lowestAncestors.length === 0) {
          pasteParentId = currentPageId;
          break;
        } else {
          pasteParentId = currentPageId;
          for (let i = 0; i < lowestAncestors.length; i++) {
            if (ancestors[i] !== lowestAncestors[i]) break;
            pasteParentId = ancestors[i].id;
          }
        }
      }
    }
    let isDuplicating = false;
    if (!isPageId(pasteParentId)) {
      const parent = this.getShape(pasteParentId);
      if (parent) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(parent))) {
          pasteParentId = currentPageId;
        } else {
          if (rootShapeIds.length === 1) {
            const rootShape = shapes.find((s2) => s2.id === rootShapeIds[0]);
            if (this.isShapeOfType(parent, "frame") && this.isShapeOfType(rootShape, "frame") && rootShape.props.w === parent?.props.w && rootShape.props.h === parent?.props.h) {
              isDuplicating = true;
            }
          }
        }
      } else {
        pasteParentId = currentPageId;
      }
    }
    if (!isDuplicating) {
      isDuplicating = shapeIdMap.has(pasteParentId);
    }
    if (isDuplicating) {
      pasteParentId = this.getShape(pasteParentId).parentId;
    }
    let index2 = this.getHighestIndexForParent(pasteParentId);
    const rootShapes = [];
    const newShapes = shapes.map((oldShape) => {
      const newId = shapeIdMap.get(oldShape.id);
      const newShape = { ...oldShape, id: newId };
      if (rootShapeIds.includes(oldShape.id)) {
        newShape.parentId = currentPageId;
        rootShapes.push(newShape);
      }
      if (shapeIdMap.has(newShape.parentId)) {
        newShape.parentId = shapeIdMap.get(oldShape.parentId);
      } else {
        rootShapeIds.push(newShape.id);
        newShape.index = index2;
        index2 = getIndexAbove(index2);
      }
      return newShape;
    });
    if (newShapes.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {
      alertMaxShapes(this);
      return this;
    }
    const newBindings = bindings.map(
      (oldBinding) => ({
        ...oldBinding,
        id: assertExists(bindingIdMap.get(oldBinding.id)),
        fromId: assertExists(shapeIdMap.get(oldBinding.fromId)),
        toId: assertExists(shapeIdMap.get(oldBinding.toId))
      })
    );
    const assetsToCreate = [];
    const assetsToUpdate = [];
    for (const asset of assets) {
      if (this.store.has(asset.id)) {
        continue;
      }
      if (asset.type === "image" && asset.props.src?.startsWith("data:image") || asset.type === "video" && asset.props.src?.startsWith("data:video")) {
        assetsToUpdate.push(structuredClone(asset));
        asset.props.src = null;
      }
      assetsToCreate.push(asset);
    }
    Promise.allSettled(
      assetsToUpdate.map(async (asset) => {
        const file = await dataUrlToFile(
          asset.props.src,
          asset.props.name,
          asset.props.mimeType ?? "image/png"
        );
        const newAsset = await this.getAssetForExternalContent({
          type: "file",
          file,
          assetId: asset.id
        });
        if (!newAsset) {
          this.deleteAssets([asset.id]);
          return;
        }
        this.updateAssets([{ ...newAsset, id: asset.id }]);
      })
    );
    this.run(() => {
      if (assetsToCreate.length > 0) {
        this.createAssets(assetsToCreate);
      }
      this.createShapes(newShapes);
      this.createBindings(newBindings);
      if (select) {
        this.select(...rootShapes.map((s2) => s2.id));
      }
      if (pasteParentId !== currentPageId) {
        this.reparentShapes(
          rootShapes.map((s2) => s2.id),
          pasteParentId
        );
      }
      const newCreatedShapes = newShapes.map((s2) => this.getShape(s2.id));
      const bounds = Box.Common(newCreatedShapes.map((s2) => this.getShapePageBounds(s2)));
      if (point === void 0) {
        if (!isPageId(pasteParentId)) {
          const shape = this.getShape(pasteParentId);
          point = Mat.applyToPoint(
            this.getShapePageTransform(shape),
            this.getShapeGeometry(shape).bounds.center
          );
        } else {
          const viewportPageBounds = this.getViewportPageBounds();
          if (preservePosition || viewportPageBounds.includes(Box.From(bounds))) {
            point = bounds.center;
          } else {
            point = viewportPageBounds.center;
          }
        }
      }
      if (rootShapes.length === 1) {
        const onlyRoot = rootShapes[0];
        if (this.isShapeOfType(onlyRoot, "frame")) {
          while (this.getShapesAtPoint(point).some(
            (shape) => this.isShapeOfType(shape, "frame") && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h
          )) {
            point.x += bounds.w + 16;
          }
        }
      }
      const pageCenter = Box.Common(
        compact$1(rootShapes.map(({ id }) => this.getShapePageBounds(id)))
      ).center;
      const offset2 = Vec.Sub(point, pageCenter);
      this.updateShapes(
        rootShapes.map(({ id }) => {
          const s2 = this.getShape(id);
          const localRotation = this.getShapeParentTransform(id).decompose().rotation;
          const localDelta = Vec.Rot(offset2, -localRotation);
          return { id: s2.id, type: s2.type, x: s2.x + localDelta.x, y: s2.y + localDelta.y };
        })
      );
    });
    return this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(shapes, opts = {}) {
    const ids = shapes.length === 0 ? this.getCurrentPageShapeIdsSorted() : typeof shapes[0] === "string" ? shapes : shapes.map((s2) => s2.id);
    if (ids.length === 0) return void 0;
    return exportToSvg(this, ids, opts);
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(shapes, opts = {}) {
    const result = await this.getSvgElement(shapes, opts);
    if (!result) return void 0;
    const serializer = new XMLSerializer();
    return {
      svg: serializer.serializeToString(result.svg),
      width: result.width,
      height: result.height
    };
  }
  /** @deprecated Use {@link Editor.getSvgString} or {@link Editor.getSvgElement} instead. */
  async getSvg(shapes, opts = {}) {
    const result = await this.getSvgElement(shapes, opts);
    if (!result) return void 0;
    return result.svg;
  }
  /**
   * Get an exported image of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns A blob of the image.
   * @public
   */
  async toImage(shapes, opts = {}) {
    const withDefaults = {
      format: "png",
      scale: 1,
      pixelRatio: opts.format === "svg" ? void 0 : 2,
      ...opts
    };
    const result = await this.getSvgString(shapes, withDefaults);
    if (!result) throw new Error("Could not create SVG");
    switch (withDefaults.format) {
      case "svg":
        return {
          blob: new Blob([result.svg], { type: "image/svg+xml" }),
          width: result.width,
          height: result.height
        };
      case "jpeg":
      case "png":
      case "webp": {
        const blob = await getSvgAsImage(result.svg, {
          type: withDefaults.format,
          quality: withDefaults.quality,
          pixelRatio: withDefaults.pixelRatio,
          width: result.width,
          height: result.height
        });
        if (!blob) {
          throw new Error("Could not construct image.");
        }
        return {
          blob,
          width: result.width,
          height: result.height
        };
      }
      default: {
        exhaustiveSwitchError$1(withDefaults.format);
      }
    }
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(info) {
    const {
      pointerVelocity,
      previousScreenPoint,
      previousPagePoint,
      currentScreenPoint,
      currentPagePoint
    } = this.inputs;
    const { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
    const sx = info.point.x - screenBounds.x;
    const sy = info.point.y - screenBounds.y;
    const sz = info.point.z ?? 0.5;
    previousScreenPoint.setTo(currentScreenPoint);
    previousPagePoint.setTo(currentPagePoint);
    currentScreenPoint.set(sx, sy);
    const nx = sx / cz - cx;
    const ny = sy / cz - cy;
    if (isFinite(nx) && isFinite(ny)) {
      currentPagePoint.set(nx, ny, sz);
    }
    this.inputs.isPen = info.type === "pointer" && info.isPen;
    if (info.name === "pointer_down" || this.inputs.isPinching) {
      pointerVelocity.set(0, 0);
      this.inputs.originScreenPoint.setTo(currentScreenPoint);
      this.inputs.originPagePoint.setTo(currentPagePoint);
    }
    this.run(
      () => {
        this.store.put([
          {
            id: TLPOINTER_ID,
            typeName: "pointer",
            x: currentPagePoint.x,
            y: currentPagePoint.y,
            lastActivityTimestamp: (
              // If our pointer moved only because we're following some other user, then don't
              // update our last activity timestamp; otherwise, update it to the current timestamp.
              info.type === "pointer" && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE ? this.store.unsafeGetWithoutCapture(TLPOINTER_ID)?.lastActivityTimestamp ?? this._tickManager.now : this._tickManager.now
            ),
            meta: {}
          }
        ]);
      },
      { history: "ignore" }
    );
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.dispatch({ type: "misc", name: "cancel" });
    return this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    this.dispatch({ type: "misc", name: "interrupt" });
    return this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    this.dispatch({ type: "misc", name: "complete" });
    return this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer = true } = {}) {
    if (this.getIsFocused()) return this;
    if (focusContainer) this.focusManager.focus();
    this.updateInstanceState({ isFocused: true });
    return this;
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer = true } = {}) {
    if (!this.getIsFocused()) return this;
    if (blurContainer) {
      this.focusManager.blur();
    } else {
      this.complete();
    }
    this.updateInstanceState({ isFocused: false });
    return this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  getIsReadonly() {
    return this.getInstanceState().isReadonly;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return getSnapshot(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - The snapshot to load.
   * @param opts - The options for loading the snapshot.
   * @returns
   */
  loadSnapshot(snapshot, opts) {
    loadSnapshot(this.store, snapshot, opts);
    return this;
  }
  _zoomToFitPageContentAt100Percent() {
    const bounds = this.getCurrentPageBounds();
    if (bounds) {
      this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
    }
  }
  _navigateToDeepLink(deepLink) {
    this.run(() => {
      switch (deepLink.type) {
        case "page": {
          const page = this.getPage(deepLink.pageId);
          if (page) {
            this.setCurrentPage(page);
          }
          this._zoomToFitPageContentAt100Percent();
          return;
        }
        case "shapes": {
          const allShapes = compact$1(deepLink.shapeIds.map((id) => this.getShape(id)));
          const byPage = {};
          for (const shape of allShapes) {
            const pageId2 = this.getAncestorPageId(shape);
            if (!pageId2) continue;
            byPage[pageId2] ??= [];
            byPage[pageId2].push(shape);
          }
          const [pageId, shapes] = Object.entries(byPage).sort(
            ([_, a2], [__, b]) => b.length - a2.length
          )[0] ?? ["", []];
          if (!pageId || !shapes.length) {
            this._zoomToFitPageContentAt100Percent();
          } else {
            this.setCurrentPage(pageId);
            const bounds = Box.Common(shapes.map((s2) => this.getShapePageBounds(s2)));
            this.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() });
          }
          return;
        }
        case "viewport": {
          if (deepLink.pageId) {
            if (!this.getPage(deepLink.pageId)) {
              this._zoomToFitPageContentAt100Percent();
              return;
            }
            this.setCurrentPage(deepLink.pageId);
          }
          this.zoomToBounds(deepLink.bounds, { immediate: true, inset: 0 });
          return;
        }
        default:
          exhaustiveSwitchError$1(deepLink);
      }
    });
  }
  /**
   * Handles navigating to the content specified by the query param in the given URL.
   *
   * Use {@link Editor#createDeepLink} to create a URL with a deep link query param.
   *
   * If no URL is provided, it will look for the param in the current `window.location.href`.
   *
   * @example
   * ```ts
   * editor.navigateToDeepLink()
   * ```
   *
   * The default parameter name is 'd'. You can override this by providing the `param` option.
   *
   * @example
   * ```ts
   * // disable page parameter and change viewport parameter to 'c'
   * editor.navigateToDeepLink({
   *   param: 'x',
   *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',
   * })
   * ```
   *
   * @param opts - Options for loading the state from the URL.
   */
  navigateToDeepLink(opts) {
    if (opts && "type" in opts) {
      this._navigateToDeepLink(opts);
      return this;
    }
    const url = new URL(opts?.url ?? window.location.href);
    const deepLinkString = url.searchParams.get(opts?.param ?? "d");
    if (!deepLinkString) {
      this._zoomToFitPageContentAt100Percent();
      return this;
    }
    try {
      this._navigateToDeepLink(parseDeepLinkString(deepLinkString));
    } catch (e) {
      console.warn(e);
      this._zoomToFitPageContentAt100Percent();
    }
    return this;
  }
  /**
   * Turns the given URL into a deep link by adding a query parameter.
   *
   * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`
   *
   * If no URL is provided, it will use the current `window.location.href`.
   *
   * @example
   * ```ts
   * // create a deep link to the current page + viewport
   * navigator.clipboard.writeText(editor.createDeepLink())
   * ```
   *
   * You can link to a particular set of shapes by providing a `to` parameter.
   *
   * @example
   * ```ts
   * // create a deep link to the set of currently selected shapes
   * navigator.clipboard.writeText(editor.createDeepLink({
   *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }
   * }))
   * ```
   *
   * The default query param is 'd'. You can override this by providing a `param` parameter.
   *
   * @example
   * ```ts
   * // Use `x` as the param name instead
   * editor.createDeepLink({ param: 'x' })
   * ```
   *
   * @param opts - Options for adding the state to the URL.
   * @returns the updated URL
   */
  createDeepLink(opts) {
    const url = new URL(opts?.url ?? window.location.href);
    url.searchParams.set(
      opts?.param ?? "d",
      createDeepLinkString(
        opts?.to ?? {
          type: "viewport",
          pageId: this.options.maxPages === 1 ? void 0 : this.getCurrentPageId(),
          bounds: this.getViewportPageBounds()
        }
      )
    );
    return url;
  }
  /**
   * Register a listener for changes to a deep link for the current document.
   *
   * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.
   *
   * By default this will update `window.location` in place, but you can provide a custom callback
   * to handle state changes on your own.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   onChange(url) {
   *     window.history.replaceState({}, document.title, url.toString())
   *   }
   * })
   * ```
   *
   * You can also provide a custom URL to update, in which case you must also provide `onChange`.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   getUrl: () => `https://my-app.com/my-document`,
   *   onChange(url) {
   *     setShareUrl(url.toString())
   *   }
   * })
   * ```
   *
   * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ debounceMs: 1000 })
   * ```
   * The default parameter name is `d`. You can override this by providing a `param` option.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ param: 'x' })
   * ```
   * @param opts - Options for setting up the listener.
   * @returns a function that will stop the listener.
   */
  registerDeepLinkListener(opts) {
    if (opts?.getUrl && !opts?.onChange) {
      throw Error(
        "[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback."
      );
    }
    const url$ = computed("url with state", () => {
      const url = opts?.getUrl?.(this) ?? window.location.href;
      const urlWithState = this.createDeepLink({
        param: opts?.param,
        url,
        to: opts?.getTarget?.(this)
      });
      return urlWithState.toString();
    });
    const announceChange = opts?.onChange ?? (() => {
      const url = this.createDeepLink({
        param: opts?.param,
        to: opts?.getTarget?.(this)
      });
      window.history.replaceState({}, document.title, url.toString());
    });
    const scheduleEffect = debounce((execute) => execute(), opts?.debounceMs ?? 500);
    const unlisten = react$1(
      "update url on state change",
      () => announceChange(new URL(url$.get()), this),
      { scheduleEffect }
    );
    return () => {
      unlisten();
      scheduleEffect.cancel();
    };
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _setShiftKeyTimeout() {
    this.inputs.shiftKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "ShiftLeft"
    });
  }
  _setAltKeyTimeout() {
    this.inputs.altKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "AltLeft"
    });
  }
  _setCtrlKeyTimeout() {
    this.inputs.ctrlKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "ControlLeft"
    });
  }
  _setMetaKeyTimeout() {
    this.inputs.metaKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Meta",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: isAccelKey(this.inputs),
      code: "MetaLeft"
    });
  }
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(info) {
    this._pendingEventsForNextTick.push(info);
    if (!(info.type === "pointer" && info.name === "pointer_move" || info.type === "wheel" || info.type === "pinch")) {
      this._flushEventsForTick(0);
    }
    return this;
  }
  _flushEventsForTick(elapsed) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const events = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const info of events) {
          this._flushEventForTick(info);
        }
      }
      if (elapsed > 0) {
        this.root.handleEvent({ type: "misc", name: "tick", elapsed });
      }
      this.scribbles.tick(elapsed);
    });
  }
  _flushEventForTick(info) {
    if (this.getCrashingError()) return this;
    this.emit("before-event", info);
    const { inputs } = this;
    const { type } = info;
    if (info.type === "misc") {
      if (info.name === "cancel" || info.name === "complete") {
        this.inputs.isDragging = false;
        if (this.inputs.isPanning) {
          this.inputs.isPanning = false;
          this.inputs.isSpacebarPanning = false;
          this.setCursor({ type: this._prevCursor, rotation: 0 });
        }
      }
      this.root.handleEvent(info);
      return;
    }
    if (info.shiftKey) {
      clearTimeout(this._shiftKeyTimeout);
      this._shiftKeyTimeout = -1;
      inputs.shiftKey = true;
    } else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {
      this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150);
    }
    if (info.altKey) {
      clearTimeout(this._altKeyTimeout);
      this._altKeyTimeout = -1;
      inputs.altKey = true;
    } else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {
      this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150);
    }
    if (info.ctrlKey) {
      clearTimeout(this._ctrlKeyTimeout);
      this._ctrlKeyTimeout = -1;
      inputs.ctrlKey = true;
    } else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {
      this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150);
    }
    if (info.metaKey) {
      clearTimeout(this._metaKeyTimeout);
      this._metaKeyTimeout = -1;
      inputs.metaKey = true;
    } else if (!info.metaKey && inputs.metaKey && this._metaKeyTimeout === -1) {
      this._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150);
    }
    const { originPagePoint, currentPagePoint } = inputs;
    if (!inputs.isPointing) {
      inputs.isDragging = false;
    }
    const instanceState = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
    const pageState = this.store.get(this._getCurrentPageStateId());
    const cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture();
    switch (type) {
      case "pinch": {
        if (cameraOptions.isLocked) return;
        clearTimeout(this._longPressTimeout);
        this._updateInputsFromEvent(info);
        switch (info.name) {
          case "pinch_start": {
            if (inputs.isPinching) return;
            if (!inputs.isEditing) {
              this._pinchStart = this.getCamera().z;
              if (!this._selectedShapeIdsAtPointerDown.length) {
                this._selectedShapeIdsAtPointerDown = [...pageState.selectedShapeIds];
              }
              this._didPinch = true;
              inputs.isPinching = true;
              this.interrupt();
            }
            return;
          }
          case "pinch": {
            if (!inputs.isPinching) return;
            const {
              point: { z = 1 },
              delta: { x: dx, y: dy }
            } = info;
            const { x, y: y2 } = Vec.SubXY(
              info.point,
              instanceState.screenBounds.x,
              instanceState.screenBounds.y
            );
            this.stopCameraAnimation();
            if (instanceState.followingUserId) {
              this.stopFollowingUser();
            }
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            const { panSpeed } = cameraOptions;
            this._setCamera(
              new Vec(
                cx + dx * panSpeed / cz - x / cz + x / z,
                cy + dy * panSpeed / cz - y2 / cz + y2 / z,
                z
              ),
              { immediate: true }
            );
            return;
          }
          case "pinch_end": {
            if (!inputs.isPinching) return this;
            inputs.isPinching = false;
            const { _selectedShapeIdsAtPointerDown: shapesToReselect } = this;
            this.setSelectedShapes(this._selectedShapeIdsAtPointerDown);
            this._selectedShapeIdsAtPointerDown = [];
            if (this._didPinch) {
              this._didPinch = false;
              if (shapesToReselect.length > 0) {
                this.once("tick", () => {
                  if (!this._didPinch) {
                    this.setSelectedShapes(shapesToReselect);
                  }
                });
              }
            }
            return;
          }
        }
      }
      case "wheel": {
        if (cameraOptions.isLocked) return;
        this._updateInputsFromEvent(info);
        const { panSpeed, zoomSpeed, wheelBehavior } = cameraOptions;
        if (wheelBehavior !== "none") {
          this.stopCameraAnimation();
          if (instanceState.followingUserId) {
            this.stopFollowingUser();
          }
          const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
          const { x: dx, y: dy, z: dz = 0 } = info.delta;
          let behavior = wheelBehavior;
          if (info.ctrlKey) behavior = wheelBehavior === "pan" ? "zoom" : "pan";
          switch (behavior) {
            case "zoom": {
              const { x, y: y2 } = this.inputs.currentScreenPoint;
              let delta = dz;
              if (wheelBehavior === "zoom") {
                if (Math.abs(dy) > 10) {
                  delta = 10 * Math.sign(dy) / 100;
                } else {
                  delta = dy / 100;
                }
              }
              const zoom = cz + (delta ?? 0) * zoomSpeed * cz;
              this._setCamera(new Vec(cx + x / zoom - x / cz, cy + y2 / zoom - y2 / cz, zoom), {
                immediate: true
              });
              this.maybeTrackPerformance("Zooming");
              return;
            }
            case "pan": {
              this._setCamera(new Vec(cx + dx * panSpeed / cz, cy + dy * panSpeed / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
          }
        }
        break;
      }
      case "pointer": {
        if (inputs.isPinching) return;
        this._updateInputsFromEvent(info);
        const { isPen } = info;
        const { isPenMode } = instanceState;
        switch (info.name) {
          case "pointer_down": {
            if (isPenMode && !isPen) return;
            if (!this.inputs.isPanning) {
              this._longPressTimeout = this.timers.setTimeout(() => {
                const vsb = this.getViewportScreenBounds();
                this.dispatch({
                  ...info,
                  // important! non-obvious!! the screenpoint was adjusted using the
                  // viewport bounds, and will be again when this event is handled...
                  // so we need to counter-adjust from the stored value so that the
                  // new value is set correctly.
                  point: this.inputs.originScreenPoint.clone().addXY(vsb.x, vsb.y),
                  name: "long_press"
                });
              }, this.options.longPressDurationMs);
            }
            this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds();
            if (info.button === LEFT_MOUSE_BUTTON) this.capturedPointerId = info.pointerId;
            inputs.buttons.add(info.button);
            inputs.isPointing = true;
            inputs.isDragging = false;
            if (!isPenMode && isPen) this.updateInstanceState({ isPenMode: true });
            if (info.button === STYLUS_ERASER_BUTTON) {
              this._restoreToolId = this.getCurrentToolId();
              this.complete();
              this.setCurrentTool("eraser");
            } else if (info.button === MIDDLE_MOUSE_BUTTON) {
              if (!this.inputs.isPanning) {
                this._prevCursor = this.getInstanceState().cursor.type;
              }
              this.inputs.isPanning = true;
              clearTimeout(this._longPressTimeout);
            }
            if (this.inputs.isPanning) {
              this.stopCameraAnimation();
              this.setCursor({ type: "grabbing", rotation: 0 });
              return this;
            }
            break;
          }
          case "pointer_move": {
            if (!isPen && isPenMode) return;
            const { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera());
            if (this.inputs.isPanning && this.inputs.isPointing) {
              const { currentScreenPoint, previousScreenPoint } = this.inputs;
              const offset2 = Vec.Sub(currentScreenPoint, previousScreenPoint);
              this.setCamera(new Vec(cx + offset2.x / cz, cy + offset2.y / cz, cz), {
                immediate: true
              });
              this.maybeTrackPerformance("Panning");
              return;
            }
            if (inputs.isPointing && !inputs.isDragging && Vec.Dist2(originPagePoint, currentPagePoint) * this.getZoomLevel() > (instanceState.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / cz) {
              inputs.isDragging = true;
              clearTimeout(this._longPressTimeout);
            }
            break;
          }
          case "pointer_up": {
            inputs.isDragging = false;
            inputs.isPointing = false;
            clearTimeout(this._longPressTimeout);
            inputs.buttons.delete(info.button);
            if (instanceState.isPenMode && !isPen) return;
            if (this.capturedPointerId === info.pointerId) {
              this.capturedPointerId = null;
              info.button = 0;
            }
            if (inputs.isPanning) {
              if (!inputs.keys.has("Space")) {
                inputs.isPanning = false;
                inputs.isSpacebarPanning = false;
              }
              const slideDirection = this.inputs.pointerVelocity;
              const slideSpeed = Math.min(2, slideDirection.len());
              switch (info.button) {
                case LEFT_MOUSE_BUTTON: {
                  this.setCursor({ type: "grab", rotation: 0 });
                  break;
                }
                case MIDDLE_MOUSE_BUTTON: {
                  if (this.inputs.keys.has(" ")) {
                    this.setCursor({ type: "grab", rotation: 0 });
                  } else {
                    this.setCursor({ type: this._prevCursor, rotation: 0 });
                  }
                }
              }
              if (slideSpeed > 0) {
                this.slideCamera({ speed: slideSpeed, direction: slideDirection });
              }
            } else {
              if (info.button === STYLUS_ERASER_BUTTON) {
                this.complete();
                this.setCurrentTool(this._restoreToolId);
              }
            }
            break;
          }
        }
        break;
      }
      case "keyboard": {
        if (info.key === "ShiftRight") info.key = "ShiftLeft";
        if (info.key === "AltRight") info.key = "AltLeft";
        if (info.code === "ControlRight") info.code = "ControlLeft";
        if (info.code === "MetaRight") info.code = "MetaLeft";
        switch (info.name) {
          case "key_down": {
            inputs.keys.add(info.code);
            if (info.code === "Space" && !info.ctrlKey) {
              if (!this.inputs.isPanning) {
                this._prevCursor = instanceState.cursor.type;
              }
              this.inputs.isPanning = true;
              this.inputs.isSpacebarPanning = true;
              clearTimeout(this._longPressTimeout);
              this.setCursor({ type: this.inputs.isPointing ? "grabbing" : "grab", rotation: 0 });
            }
            if (this.inputs.isSpacebarPanning) {
              let offset2;
              switch (info.code) {
                case "ArrowUp": {
                  offset2 = new Vec(0, -1);
                  break;
                }
                case "ArrowRight": {
                  offset2 = new Vec(1, 0);
                  break;
                }
                case "ArrowDown": {
                  offset2 = new Vec(0, 1);
                  break;
                }
                case "ArrowLeft": {
                  offset2 = new Vec(-1, 0);
                  break;
                }
              }
              if (offset2) {
                const bounds = this.getViewportPageBounds();
                const next = bounds.clone().translate(offset2.mulV({ x: bounds.w, y: bounds.h }));
                this._animateToViewport(next, { animation: { duration: 320 } });
              }
            }
            break;
          }
          case "key_up": {
            inputs.keys.delete(info.code);
            if (info.code === "Space") {
              if (this.inputs.buttons.has(MIDDLE_MOUSE_BUTTON)) ;
              else {
                this.inputs.isPanning = false;
                this.inputs.isSpacebarPanning = false;
                this.setCursor({ type: this._prevCursor, rotation: 0 });
              }
            }
            break;
          }
        }
        break;
      }
    }
    if (info.type === "pointer") {
      if (info.button === MIDDLE_MOUSE_BUTTON) {
        info.name = "middle_click";
      } else if (info.button === RIGHT_MOUSE_BUTTON) {
        info.name = "right_click";
      }
      const { isPenMode } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID);
      if (info.isPen === isPenMode) {
        const clickInfo = this._clickManager.handlePointerEvent(info);
        if (info.name !== clickInfo.name) {
          this.root.handleEvent(info);
          this.emit("event", info);
          this.root.handleEvent(clickInfo);
          this.emit("event", clickInfo);
          return;
        }
      }
    }
    this.root.handleEvent(info);
    this.emit("event", info);
    if (info.type === "pointer" && info.name === "pointer_down") {
      this.menus.clearOpenMenus();
    }
    return this;
  }
  /** @internal */
  maybeTrackPerformance(name) {
    if (debugFlags.measurePerformance.get()) {
      if (this.performanceTracker.isStarted()) {
        clearTimeout(this.performanceTrackerTimeout);
      } else {
        this.performanceTracker.start(name);
      }
      this.performanceTrackerTimeout = this.timers.setTimeout(() => {
        this.performanceTracker.stop();
      }, 50);
    }
  }
};
_init$3 = __decoratorStart$3(_a$1);
__decorateElement$3(_init$3, 1, "getIsShapeHiddenCache", _getIsShapeHiddenCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCanUndo", _getCanUndo_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCanRedo", _getCanRedo_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getPath", _getPath_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentTool", _getCurrentTool_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentToolId", _getCurrentToolId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getDocumentSettings", _getDocumentSettings_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getInstanceState", _getInstanceState_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getOpenMenus", _getOpenMenus_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getIsMenuOpen", _getIsMenuOpen_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getPageStates", _getPageStates_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getPageStatesQuery", __getPageStatesQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageState", _getCurrentPageState_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getCurrentPageStateId", __getCurrentPageStateId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectedShapeIds", _getSelectedShapeIds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectedShapes", _getSelectedShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapesInReadingOrder", _getCurrentPageShapesInReadingOrder_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getOnlySelectedShapeId", _getOnlySelectedShapeId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getOnlySelectedShape", _getOnlySelectedShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionPageBounds", _getSelectionPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionRotation", _getSelectionRotation_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionRotatedPageBounds", _getSelectionRotatedPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSelectionRotatedScreenBounds", _getSelectionRotatedScreenBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getFocusedGroupId", _getFocusedGroupId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getFocusedGroup", _getFocusedGroup_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getEditingShapeId", _getEditingShapeId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getEditingShape", _getEditingShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getRichTextEditor", _getRichTextEditor_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHoveredShapeId", _getHoveredShapeId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHoveredShape", _getHoveredShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHintingShapeIds", _getHintingShapeIds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getHintingShape", _getHintingShape_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getErasingShapeIds", _getErasingShapeIds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getErasingShapes", _getErasingShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_unsafe_getCameraId", __unsafe_getCameraId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCamera", _getCamera_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportPageBoundsForFollowing", _getViewportPageBoundsForFollowing_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCameraForFollowing", _getCameraForFollowing_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getZoomLevel", _getZoomLevel_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportScreenBounds", _getViewportScreenBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportScreenCenter", _getViewportScreenCenter_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getViewportPageBounds", _getViewportPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getCollaboratorsQuery", __getCollaboratorsQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCollaborators", _getCollaborators_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCollaboratorsOnCurrentPage", _getCollaboratorsOnCurrentPage_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getRenderingShapes", _getRenderingShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getAllPagesQuery", __getAllPagesQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getPages", _getPages_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageId", _getCurrentPageId_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapeIdsSorted", _getCurrentPageShapeIdsSorted_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getAllAssetsQuery", __getAllAssetsQuery_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeHandlesCache", __getShapeHandlesCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapePageTransformCache", __getShapePageTransformCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapePageBoundsCache", __getShapePageBoundsCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeClipPathCache", __getShapeClipPathCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeMaskCache", __getShapeMaskCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getShapeMaskedPageBoundsCache", __getShapeMaskedPageBoundsCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_notVisibleShapes", __notVisibleShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCulledShapes", _getCulledShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageBounds", _getCurrentPageBounds_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapes", _getCurrentPageShapes_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageShapesSorted", _getCurrentPageShapesSorted_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getCurrentPageRenderingShapesSorted", _getCurrentPageRenderingShapesSorted_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getBindingsIndexCache", __getBindingsIndexCache_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_getSelectionSharedStyles", __getSelectionSharedStyles_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSharedStyles", _getSharedStyles_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getSharedOpacity", _getSharedOpacity_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getIsFocused", _getIsFocused_dec, Editor$1);
__decorateElement$3(_init$3, 1, "getIsReadonly", _getIsReadonly_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setShiftKeyTimeout", __setShiftKeyTimeout_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setAltKeyTimeout", __setAltKeyTimeout_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setCtrlKeyTimeout", __setCtrlKeyTimeout_dec, Editor$1);
__decorateElement$3(_init$3, 1, "_setMetaKeyTimeout", __setMetaKeyTimeout_dec, Editor$1);
__decoratorMetadata$3(_init$3, Editor$1);
function alertMaxShapes(editor, pageId = editor.getCurrentPageId()) {
  const name = editor.getPage(pageId).name;
  editor.emit("max-shapes", { name, pageId, count: editor.options.maxShapesPerPage });
}
function applyPartialToRecordWithProps(prev, partial) {
  if (!partial) return prev;
  let next = null;
  const entries = Object.entries(partial);
  for (let i = 0, n2 = entries.length; i < n2; i++) {
    const [k, v] = entries[i];
    if (v === void 0) continue;
    if (k === "id" || k === "type" || k === "typeName") continue;
    if (v === prev[k]) continue;
    if (!next) next = { ...prev };
    if (k === "props" || k === "meta") {
      next[k] = { ...prev[k] };
      for (const [nextKey, nextValue] of Object.entries(v)) {
        next[k][nextKey] = nextValue;
      }
      continue;
    }
    next[k] = v;
  }
  if (!next) return prev;
  return next;
}
function pushShapeWithDescendants(editor, id, result) {
  const shape = editor.getShape(id);
  if (!shape) return;
  result.push(shape);
  const childIds = editor.getSortedChildIdsForParent(id);
  for (let i = 0, n2 = childIds.length; i < n2; i++) {
    pushShapeWithDescendants(editor, childIds[i], result);
  }
}
function withIsolatedShapes(editor, shapeIds, callback) {
  let result;
  editor.run(
    () => {
      const changes = editor.store.extractingChanges(() => {
        const bindingsWithBoth = /* @__PURE__ */ new Set();
        const bindingsToRemove = /* @__PURE__ */ new Set();
        for (const shapeId of shapeIds) {
          const shape = editor.getShape(shapeId);
          if (!shape) continue;
          for (const binding of editor.getBindingsInvolvingShape(shapeId)) {
            const hasFrom = shapeIds.has(binding.fromId);
            const hasTo = shapeIds.has(binding.toId);
            if (hasFrom && hasTo) {
              bindingsWithBoth.add(binding.id);
              continue;
            }
            if (!hasFrom || !hasTo) {
              bindingsToRemove.add(binding.id);
            }
          }
        }
        editor.deleteBindings([...bindingsToRemove], { isolateShapes: true });
        try {
          result = Result.ok(callback(bindingsWithBoth));
        } catch (error) {
          result = Result.err(error);
        }
      });
      editor.store.applyDiff(reverseRecordsDiff(changes), { runCallbacks: false });
    },
    { history: "ignore" }
  );
  if (result.ok) {
    return result.value;
  } else {
    throw result.error;
  }
}
function getCameraFitXFitY(editor, cameraOptions) {
  if (!cameraOptions.constraints) throw Error("Should have constraints here");
  const {
    padding: { x: px, y: py }
  } = cameraOptions.constraints;
  const vsb = editor.getViewportScreenBounds();
  const bounds = Box.From(cameraOptions.constraints.bounds);
  const zx = (vsb.w - px * 2) / bounds.w;
  const zy = (vsb.h - py * 2) / bounds.h;
  return { zx, zy };
}
function useIsDarkMode() {
  const editor = useEditor();
  const exportContext = useSvgExportContext();
  return useValue("isDarkMode", () => exportContext?.isDarkMode ?? editor.user.getIsDarkMode(), [
    exportContext,
    editor
  ]);
}
const CORNER_SVG = `<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>`;
const EDGE_SVG = `<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>`;
const ROTATE_CORNER_SVG = `<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>`;
function getCursorCss(svg, r2, tr2, f, color, hotspotX = 16, hotspotY = 16) {
  const a2 = (-tr2 - r2) * (PI$1 / 180);
  const s2 = Math.sin(a2);
  const c2 = Math.cos(a2);
  const dx = 1 * c2 - 1 * s2;
  const dy = 1 * s2 + 1 * c2;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${color};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${dx}' dy='${dy}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${r2 + tr2} 16 16)${f ? ` scale(-1,-1) translate(0, -32)` : ""}' filter='url(%23shadow)'>` + svg.replaceAll(`"`, `'`) + `</g></svg>") ${hotspotX} ${hotspotY}, pointer`;
}
const STATIC_CURSORS = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
];
const CURSORS = {
  none: () => "none",
  "ew-resize": (r2, f, c2) => getCursorCss(EDGE_SVG, r2, 0, f, c2),
  "ns-resize": (r2, f, c2) => getCursorCss(EDGE_SVG, r2, 90, f, c2),
  "nesw-resize": (r2, f, c2) => getCursorCss(CORNER_SVG, r2, 0, f, c2),
  "nwse-resize": (r2, f, c2) => getCursorCss(CORNER_SVG, r2, 90, f, c2),
  "nwse-rotate": (r2, f, c2) => getCursorCss(ROTATE_CORNER_SVG, r2, 0, f, c2),
  "nesw-rotate": (r2, f, c2) => getCursorCss(ROTATE_CORNER_SVG, r2, 90, f, c2),
  "senw-rotate": (r2, f, c2) => getCursorCss(ROTATE_CORNER_SVG, r2, 180, f, c2),
  "swne-rotate": (r2, f, c2) => getCursorCss(ROTATE_CORNER_SVG, r2, 270, f, c2)
};
function getCursor(cursor, rotation = 0, color = "black") {
  return CURSORS[cursor](radiansToDegrees(rotation), false, color);
}
function useCursor() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  useQuickReactor(
    "useCursor",
    () => {
      const { type, rotation } = editor.getInstanceState().cursor;
      if (STATIC_CURSORS.includes(type)) {
        container.style.setProperty("--tl-cursor", `var(--tl-cursor-${type})`);
        return;
      }
      container.style.setProperty(
        "--tl-cursor",
        getCursor(type, rotation, isDarkMode ? "white" : "black")
      );
    },
    [editor, container, isDarkMode]
  );
}
function useDarkMode() {
  const editor = useEditor();
  const container = useContainer();
  const isDarkMode = useIsDarkMode();
  const forceSrgb = useValue(debugFlags.forceSrgb);
  React.useEffect(() => {
    if (isDarkMode) {
      container.setAttribute("data-color-mode", "dark");
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    } else {
      container.setAttribute("data-color-mode", "light");
      container.classList.remove("tl-theme__dark");
      container.classList.add("tl-theme__light");
    }
    if (forceSrgb) {
      container.classList.add("tl-theme__force-sRGB");
    } else {
      container.classList.remove("tl-theme__force-sRGB");
    }
  }, [editor, container, forceSrgb, isDarkMode]);
}
function useForceUpdate() {
  const [_, ss] = reactExports.useState(0);
  reactExports.useEffect(() => ss((s2) => s2 + 1), []);
}
const defaultAssetResolve = (asset) => asset.props.src;
const inlineBase64AssetStore = {
  upload: async (_, file) => {
    return { src: await FileHelpers.blobToDataUrl(file) };
  }
};
function createTLSchemaFromUtils(opts) {
  if ("schema" in opts && opts.schema) return opts.schema;
  return createTLSchema({
    shapes: "shapeUtils" in opts && opts.shapeUtils ? utilsToMap(checkShapesAndAddCore(opts.shapeUtils)) : void 0,
    bindings: "bindingUtils" in opts && opts.bindingUtils ? utilsToMap(checkBindings(opts.bindingUtils)) : void 0,
    migrations: "migrations" in opts ? opts.migrations : void 0
  });
}
function createTLStore({
  initialData,
  defaultName = "",
  id,
  assets = inlineBase64AssetStore,
  onMount,
  collaboration,
  ...rest
} = {}) {
  const schema = createTLSchemaFromUtils(rest);
  const store = new Store({
    id,
    schema,
    initialData,
    props: {
      defaultName,
      assets: {
        upload: assets.upload,
        resolve: assets.resolve ?? defaultAssetResolve,
        remove: assets.remove ?? (() => Promise.resolve())
      },
      onMount: (editor) => {
        assert(editor instanceof Editor$1);
        onMount?.(editor);
      },
      collaboration
    }
  });
  if (rest.snapshot) {
    if (initialData) throw new Error("Cannot provide both initialData and snapshot");
    loadSnapshot(store, rest.snapshot, { forceOverwriteSessionState: true });
  }
  return store;
}
function utilsToMap(utils) {
  return Object.fromEntries(
    utils.map((s2) => [
      s2.type,
      {
        props: s2.props,
        migrations: s2.migrations
      }
    ])
  );
}
const instanceOfAny = (object2, constructors) => constructors.some((c2) => object2 instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap$1(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap$1(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap$1(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap$1(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap$1(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap$1(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version2);
  const openPromise = wrap$1(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap$1(request.result), event.oldVersion, event.newVersion, wrap$1(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap$1(request).then(() => void 0);
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
const STORE_PREFIX = "TLDRAW_DOCUMENT_v2";
const LEGACY_ASSET_STORE_PREFIX = "TLDRAW_ASSET_STORE_v1";
const dbNameIndexKey = "TLDRAW_DB_NAME_INDEX_v2";
const Table = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function openLocalDb(persistenceKey) {
  const storeId = STORE_PREFIX + persistenceKey;
  addDbName(storeId);
  return await openDB(storeId, 4, {
    upgrade(database) {
      if (!database.objectStoreNames.contains(Table.Records)) {
        database.createObjectStore(Table.Records);
      }
      if (!database.objectStoreNames.contains(Table.Schema)) {
        database.createObjectStore(Table.Schema);
      }
      if (!database.objectStoreNames.contains(Table.SessionState)) {
        database.createObjectStore(Table.SessionState);
      }
      if (!database.objectStoreNames.contains(Table.Assets)) {
        database.createObjectStore(Table.Assets);
      }
    }
  });
}
async function migrateLegacyAssetDbIfNeeded(persistenceKey) {
  const databases = window.indexedDB.databases ? (await window.indexedDB.databases()).map((db) => db.name) : getAllIndexDbNames();
  const oldStoreId = LEGACY_ASSET_STORE_PREFIX + persistenceKey;
  const existing = databases.find((dbName) => dbName === oldStoreId);
  if (!existing) return;
  const oldAssetDb = await openDB(oldStoreId, 1, {
    upgrade(database) {
      if (!database.objectStoreNames.contains("assets")) {
        database.createObjectStore("assets");
      }
    }
  });
  if (!oldAssetDb.objectStoreNames.contains("assets")) return;
  const oldTx = oldAssetDb.transaction(["assets"], "readonly");
  const oldAssetStore = oldTx.objectStore("assets");
  const oldAssetsKeys = await oldAssetStore.getAllKeys();
  const oldAssets = await Promise.all(
    oldAssetsKeys.map(async (key) => [key, await oldAssetStore.get(key)])
  );
  await oldTx.done;
  const newDb = await openLocalDb(persistenceKey);
  const newTx = newDb.transaction([Table.Assets], "readwrite");
  const newAssetTable = newTx.objectStore(Table.Assets);
  for (const [key, value] of oldAssets) {
    newAssetTable.put(value, key);
  }
  await newTx.done;
  oldAssetDb.close();
  newDb.close();
  await deleteDB(oldStoreId);
}
class LocalIndexedDb {
  getDbPromise;
  isClosed = false;
  pendingTransactionSet = /* @__PURE__ */ new Set();
  /** @internal */
  static connectedInstances = /* @__PURE__ */ new Set();
  constructor(persistenceKey) {
    LocalIndexedDb.connectedInstances.add(this);
    this.getDbPromise = (async () => {
      await migrateLegacyAssetDbIfNeeded(persistenceKey);
      return await openLocalDb(persistenceKey);
    })();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then(noop$3);
  }
  async close() {
    if (this.isClosed) return;
    this.isClosed = true;
    await this.pending();
    (await this.getDb()).close();
    LocalIndexedDb.connectedInstances.delete(this);
  }
  tx(mode, names, cb) {
    const txPromise = (async () => {
      assert(!this.isClosed, "db is closed");
      const db = await this.getDb();
      const tx = db.transaction(names, mode);
      const done = tx.done.catch((e) => {
        if (!this.isClosed) {
          throw e;
        }
      });
      try {
        return await cb(tx);
      } finally {
        if (!this.isClosed) {
          await done;
        } else {
          tx.abort();
        }
      }
    })();
    this.pendingTransactionSet.add(txPromise);
    txPromise.finally(() => this.pendingTransactionSet.delete(txPromise));
    return txPromise;
  }
  async load({ sessionId } = {}) {
    return await this.tx(
      "readonly",
      [Table.Records, Table.Schema, Table.SessionState],
      async (tx) => {
        const recordsStore = tx.objectStore(Table.Records);
        const schemaStore = tx.objectStore(Table.Schema);
        const sessionStateStore = tx.objectStore(Table.SessionState);
        let sessionStateSnapshot = sessionId ? (await sessionStateStore.get(sessionId))?.snapshot : null;
        if (!sessionStateSnapshot) {
          const all = await sessionStateStore.getAll();
          sessionStateSnapshot = all.sort((a2, b) => a2.updatedAt - b.updatedAt).pop()?.snapshot;
        }
        const result = {
          records: await recordsStore.getAll(),
          schema: await schemaStore.get(Table.Schema),
          sessionStateSnapshot
        };
        return result;
      }
    );
  }
  async storeChanges({
    schema,
    changes,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      for (const [id, record] of Object.entries(changes.added)) {
        await recordsStore.put(record, id);
      }
      for (const [_prev, updated] of Object.values(changes.updated)) {
        await recordsStore.put(updated, updated.id);
      }
      for (const id of Object.keys(changes.removed)) {
        await recordsStore.delete(id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async storeSnapshot({
    schema,
    snapshot,
    sessionId,
    sessionStateSnapshot
  }) {
    await this.tx("readwrite", [Table.Records, Table.Schema, Table.SessionState], async (tx) => {
      const recordsStore = tx.objectStore(Table.Records);
      const schemaStore = tx.objectStore(Table.Schema);
      const sessionStateStore = tx.objectStore(Table.SessionState);
      await recordsStore.clear();
      for (const [id, record] of Object.entries(snapshot)) {
        await recordsStore.put(record, id);
      }
      schemaStore.put(schema.serialize(), Table.Schema);
      if (sessionStateSnapshot && sessionId) {
        sessionStateStore.put(
          {
            snapshot: sessionStateSnapshot,
            updatedAt: Date.now(),
            id: sessionId
          },
          sessionId
        );
      } else if (sessionStateSnapshot || sessionId) {
        console.error("sessionStateSnapshot and instanceId must be provided together");
      }
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [Table.SessionState], async (tx) => {
      const sessionStateStore = tx.objectStore(Table.SessionState);
      const all = (await sessionStateStore.getAll()).sort((a2, b) => a2.updatedAt - b.updatedAt);
      if (all.length < 10) {
        await tx.done;
        return;
      }
      const toDelete = all.slice(0, all.length - 10);
      for (const { id } of toDelete) {
        await sessionStateStore.delete(id);
      }
    });
  }
  async getAsset(assetId) {
    return await this.tx("readonly", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      return await assetsStore.get(assetId);
    });
  }
  async storeAsset(assetId, blob) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      await assetsStore.put(blob, assetId);
    });
  }
  async removeAssets(assetId) {
    await this.tx("readwrite", [Table.Assets], async (tx) => {
      const assetsStore = tx.objectStore(Table.Assets);
      for (const id of assetId) {
        await assetsStore.delete(id);
      }
    });
  }
}
function getAllIndexDbNames() {
  const result = JSON.parse(getFromLocalStorage(dbNameIndexKey) || "[]") ?? [];
  if (!Array.isArray(result)) {
    return [];
  }
  return result;
}
function addDbName(name) {
  const all = new Set(getAllIndexDbNames());
  all.add(name);
  setInLocalStorage(dbNameIndexKey, JSON.stringify([...all]));
}
function showCantWriteToIndexDbAlert() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
• If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function showCantReadFromIndexDbAlert() {
  window.alert(
    `Oops! We could not access your browser's storage—and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}
const PERSIST_THROTTLE_MS = 350;
const PERSIST_RETRY_THROTTLE_MS = 1e4;
const UPDATE_INSTANCE_STATE = Symbol("UPDATE_INSTANCE_STATE");
const msg = (msg2) => msg2;
class BroadcastChannelMock {
  onmessage;
  constructor(_name) {
  }
  postMessage(_msg) {
  }
  close() {
  }
}
const BC = typeof BroadcastChannel === "undefined" ? BroadcastChannelMock : BroadcastChannel;
class TLLocalSyncClient {
  constructor(store, {
    persistenceKey,
    sessionId = TAB_ID,
    onLoad,
    onLoadError
  }, channel2 = new BC(`tldraw-tab-sync-${persistenceKey}`)) {
    this.store = store;
    this.channel = channel2;
    if (typeof window !== "undefined") {
      window.tlsync = this;
    }
    this.persistenceKey = persistenceKey;
    this.sessionId = sessionId;
    this.db = new LocalIndexedDb(persistenceKey);
    this.disposables.add(() => this.db.close());
    this.serializedSchema = this.store.schema.serialize();
    this.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store);
    this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      store.listen(
        ({ changes }) => {
          this.diffQueue.push(changes);
          this.channel.postMessage(
            msg({
              type: "diff",
              storeId: this.store.id,
              changes,
              schema: this.serializedSchema
            })
          );
          this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    );
    this.disposables.add(
      store.listen(
        () => {
          this.diffQueue.push(UPDATE_INSTANCE_STATE);
          this.schedulePersist();
        },
        { scope: "session" }
      )
    );
    this.connect(onLoad, onLoadError);
    this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((t2) => t2.scope === "document").map((t2) => t2.typeName)
    );
  }
  disposables = /* @__PURE__ */ new Set();
  diffQueue = [];
  didDispose = false;
  shouldDoFullDBWrite = true;
  isReloading = false;
  persistenceKey;
  sessionId;
  serializedSchema;
  isDebugging = false;
  documentTypes;
  $sessionStateSnapshot;
  /** @internal */
  db;
  initTime = Date.now();
  debug(...args) {
    if (this.isDebugging) {
      console.debug(...args);
    }
  }
  async connect(onLoad, onLoadError) {
    this.debug("connecting");
    let data;
    try {
      data = await this.db.load({ sessionId: this.sessionId });
    } catch (error) {
      onLoadError(error);
      showCantReadFromIndexDbAlert();
      return;
    }
    this.debug("loaded data from store", data, "didDispose", this.didDispose);
    if (this.didDispose) return;
    try {
      if (data) {
        const documentSnapshot = Object.fromEntries(data.records.map((r2) => [r2.id, r2]));
        const sessionStateSnapshot = data.sessionStateSnapshot ?? extractSessionStateFromLegacySnapshot(documentSnapshot);
        const migrationResult = this.store.schema.migrateStoreSnapshot({
          store: documentSnapshot,
          // eslint-disable-next-line @typescript-eslint/no-deprecated
          schema: data.schema ?? this.store.schema.serializeEarliestVersion()
        });
        if (migrationResult.type === "error") {
          console.error("failed to migrate store", migrationResult);
          onLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`));
          return;
        }
        const records = Object.values(migrationResult.value).filter(
          (r2) => this.documentTypes.has(r2.typeName)
        );
        if (records.length > 0) {
          this.store.mergeRemoteChanges(() => {
            this.store.put(records, "initialize");
          });
        }
        if (sessionStateSnapshot) {
          loadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot, {
            forceOverwrite: true
          });
        }
      }
      this.channel.onmessage = ({ data: data2 }) => {
        this.debug("got message", data2);
        const msg2 = data2;
        const res = this.store.schema.getMigrationsSince(msg2.schema);
        if (!res.ok) {
          const timeSinceInit = Date.now() - this.initTime;
          if (timeSinceInit < 5e3) {
            onLoadError(new Error("Schema mismatch, please close other tabs and reload the page"));
            return;
          }
          this.debug("reloading");
          this.isReloading = true;
          window?.location?.reload?.();
          return;
        } else if (res.value.length > 0) {
          this.debug("telling them to reload");
          this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
          this.shouldDoFullDBWrite = true;
          this.persistIfNeeded();
          return;
        }
        if (msg2.type === "diff") {
          this.debug("applying diff");
          transact(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(msg2.changes);
            });
          });
        }
      };
      this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
      this.disposables.add(() => {
        this.channel.close();
      });
      onLoad(this);
    } catch (e) {
      this.debug("error loading data from store", e);
      if (this.didDispose) return;
      onLoadError(e);
      return;
    }
  }
  close() {
    this.debug("closing");
    this.didDispose = true;
    this.disposables.forEach((d) => d());
  }
  isPersisting = false;
  didLastWriteError = false;
  // eslint-disable-next-line no-restricted-globals
  scheduledPersistTimeout = null;
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout);
    if (this.scheduledPersistTimeout) return;
    this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null;
        this.persistIfNeeded();
      },
      this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS
    );
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    });
    if (this.scheduledPersistTimeout) {
      clearTimeout(this.scheduledPersistTimeout);
      this.scheduledPersistTimeout = null;
    }
    if (this.isPersisting) return;
    if (this.isReloading) return;
    if (this.store.isPossiblyCorrupted()) return;
    if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {
      this.doPersist();
    }
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    assert(!this.isPersisting, "persist already in progress");
    if (this.didDispose) return;
    this.isPersisting = true;
    this.debug("doPersist start");
    const diffQueue = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite) {
        this.shouldDoFullDBWrite = false;
        await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      } else {
        const diffs = squashRecordDiffs(
          diffQueue.filter((d) => d !== UPDATE_INSTANCE_STATE)
        );
        await this.db.storeChanges({
          changes: diffs,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = false;
    } catch (e) {
      this.shouldDoFullDBWrite = true;
      this.didLastWriteError = true;
      console.error("failed to store changes in indexed db", e);
      showCantWriteToIndexDbAlert();
      if (typeof window !== "undefined") {
        window.location.reload();
      }
    }
    this.isPersisting = false;
    this.debug("doPersist end");
    this.schedulePersist();
  }
}
function useRefState(initialValue) {
  const ref = reactExports.useRef(initialValue);
  const [state, setState] = reactExports.useState(initialValue);
  if (state !== ref.current) {
    setState(ref.current);
  }
  const update = reactExports.useCallback((value) => {
    if (typeof value === "function") {
      ref.current = value(ref.current);
    } else {
      ref.current = value;
    }
    setState(ref.current);
  }, []);
  return [state, update];
}
function useLocalStore(options) {
  const [state, setState] = useRefState({ status: "loading" });
  options = useShallowObjectIdentity(options);
  reactExports.useEffect(() => {
    const { persistenceKey, sessionId, ...rest } = options;
    if (!persistenceKey) {
      setState({
        status: "not-synced",
        store: createTLStore(rest)
      });
      return;
    }
    setState({ status: "loading" });
    const objectURLCache = new WeakCache();
    const assets = {
      upload: async (asset, file) => {
        await client2.db.storeAsset(asset.id, file);
        return { src: asset.id };
      },
      resolve: async (asset) => {
        if (!asset.props.src) return null;
        if (asset.props.src.startsWith("asset:")) {
          return await objectURLCache.get(asset, async () => {
            const blob = await client2.db.getAsset(asset.id);
            if (!blob) return null;
            return URL.createObjectURL(blob);
          });
        }
        return asset.props.src;
      },
      remove: async (assetIds) => {
        await client2.db.removeAssets(assetIds);
      },
      ...rest.assets
    };
    const store = createTLStore({ ...rest, assets });
    let isClosed = false;
    const client2 = new TLLocalSyncClient(store, {
      sessionId,
      persistenceKey,
      onLoad() {
        if (isClosed) return;
        setState({ store, status: "synced-local" });
      },
      onLoadError(err) {
        if (isClosed) return;
        setState({ status: "error", error: err });
      }
    });
    return () => {
      isClosed = true;
      client2.close();
    };
  }, [options, setState]);
  return state;
}
function useZoomCss() {
  const editor = useEditor();
  const container = useContainer();
  reactExports.useEffect(() => {
    const setScale = (s2) => container.style.setProperty("--tl-zoom", s2.toString());
    const setScaleDebounced = debounce(setScale, 100);
    const scheduler2 = new EffectScheduler("useZoomCss", () => {
      const numShapes = editor.getCurrentPageShapeIds().size;
      if (numShapes < 300) {
        setScale(editor.getZoomLevel());
      } else {
        setScaleDebounced(editor.getZoomLevel());
      }
    });
    scheduler2.attach();
    scheduler2.execute();
    return () => {
      scheduler2.detach();
      setScaleDebounced.cancel();
    };
  }, [editor, container]);
}
function str2ab(str2) {
  const buf = new ArrayBuffer(str2.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str2.length; i < strLen; i++) {
    bufView[i] = str2.charCodeAt(i);
  }
  return buf;
}
function importPublicKey(pemContents) {
  const binaryDerString = atob(pemContents);
  const binaryDer = str2ab(binaryDerString);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(binaryDer),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    true,
    ["verify"]
  );
}
const GRACE_PERIOD_DAYS = 5;
const FLAGS = {
  ANNUAL_LICENSE: 1,
  PERPETUAL_LICENSE: 2,
  INTERNAL_LICENSE: 4,
  WITH_WATERMARK: 8
};
const HIGHEST_FLAG = Math.max(...Object.values(FLAGS));
const PROPERTIES = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
};
const NUMBER_OF_KNOWN_PROPERTIES = Object.keys(PROPERTIES).length;
const LICENSE_EMAIL = "sales@tldraw.com";
const WATERMARK_TRACK_SRC = `${getDefaultCdnBaseUrl()}/watermarks/watermark-track.svg`;
class LicenseManager {
  publicKey = "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ";
  isDevelopment;
  isTest;
  isCryptoAvailable;
  state = atom(
    "license state",
    "pending"
  );
  verbose = true;
  constructor(licenseKey, testPublicKey, testEnvironment) {
    this.isTest = false;
    this.isDevelopment = this.getIsDevelopment(testEnvironment);
    this.publicKey = testPublicKey || this.publicKey;
    this.isCryptoAvailable = !!crypto.subtle;
    this.getLicenseFromKey(licenseKey).then((result) => {
      const isUnlicensed = isEditorUnlicensed(result);
      if (!this.isDevelopment && isUnlicensed) {
        fetch$1(WATERMARK_TRACK_SRC);
      }
      if (isUnlicensed) {
        this.state.set("unlicensed");
      } else if (result.isLicensedWithWatermark) {
        this.state.set("licensed-with-watermark");
      } else {
        this.state.set("licensed");
      }
    });
  }
  getIsDevelopment(testEnvironment) {
    if (testEnvironment === "development") return true;
    if (testEnvironment === "production") return false;
    return !["https:", "vscode-webview:"].includes(window.location.protocol) || window.location.hostname === "localhost";
  }
  async extractLicenseKey(licenseKey) {
    const [data, signature] = licenseKey.split(".");
    const [prefix, encodedData] = data.split("/");
    if (!prefix.startsWith("tldraw-")) {
      throw new Error(`Unsupported prefix '${prefix}'`);
    }
    const publicCryptoKey = await importPublicKey(this.publicKey);
    let isVerified;
    try {
      isVerified = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        publicCryptoKey,
        new Uint8Array(str2ab(atob(signature))),
        new Uint8Array(str2ab(atob(encodedData)))
      );
    } catch (e) {
      console.error(e);
      throw new Error("Could not perform signature validation");
    }
    if (!isVerified) {
      throw new Error("Invalid signature");
    }
    let decodedData;
    try {
      decodedData = JSON.parse(atob(encodedData));
    } catch {
      throw new Error("Could not parse object");
    }
    if (decodedData.length > NUMBER_OF_KNOWN_PROPERTIES) {
      this.outputMessages([
        "License key contains some unknown properties.",
        "You may want to update tldraw packages to a newer version to get access to new functionality."
      ]);
    }
    return {
      id: decodedData[PROPERTIES.ID],
      hosts: decodedData[PROPERTIES.HOSTS],
      flags: decodedData[PROPERTIES.FLAGS],
      expiryDate: decodedData[PROPERTIES.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(licenseKey) {
    if (!licenseKey) {
      if (!this.isDevelopment) {
        this.outputNoLicenseKeyProvided();
      }
      return { isLicenseParseable: false, reason: "no-key-provided" };
    }
    if (this.isDevelopment && !this.isCryptoAvailable) {
      if (this.verbose) {
        console.log(
          "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
        );
        console.log("You should check that this works in production separately.");
      }
      return { isLicenseParseable: false, reason: "has-key-development-mode" };
    }
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    try {
      const licenseInfo = await this.extractLicenseKey(cleanedLicenseKey);
      const expiryDate = new Date(licenseInfo.expiryDate);
      const isAnnualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.ANNUAL_LICENSE);
      const isPerpetualLicense = this.isFlagEnabled(licenseInfo.flags, FLAGS.PERPETUAL_LICENSE);
      const result = {
        license: licenseInfo,
        isLicenseParseable: true,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(licenseInfo),
        expiryDate,
        isAnnualLicense,
        isAnnualLicenseExpired: isAnnualLicense && this.isAnnualLicenseExpired(expiryDate),
        isPerpetualLicense,
        isPerpetualLicenseExpired: isPerpetualLicense && this.isPerpetualLicenseExpired(expiryDate),
        isInternalLicense: this.isFlagEnabled(licenseInfo.flags, FLAGS.INTERNAL_LICENSE),
        isLicensedWithWatermark: this.isFlagEnabled(licenseInfo.flags, FLAGS.WITH_WATERMARK)
      };
      this.outputLicenseInfoIfNeeded(result);
      return result;
    } catch (e) {
      this.outputInvalidLicenseKey(e.message);
      return { isLicenseParseable: false, reason: "invalid-license-key" };
    }
  }
  isDomainValid(licenseInfo) {
    const currentHostname = window.location.hostname.toLowerCase();
    return licenseInfo.hosts.some((host) => {
      const normalizedHost = host.toLowerCase().trim();
      if (normalizedHost === currentHostname || `www.${normalizedHost}` === currentHostname || normalizedHost === `www.${currentHostname}`) {
        return true;
      }
      if (host === "*") {
        return true;
      }
      if (host.includes("*")) {
        const globToRegex = new RegExp(host.replace(/\*/g, ".*?"));
        return globToRegex.test(currentHostname) || globToRegex.test(`www.${currentHostname}`);
      }
      if (window.location.protocol === "vscode-webview:") {
        const currentUrl = new URL(window.location.href);
        const extensionId = currentUrl.searchParams.get("extensionId");
        if (normalizedHost === extensionId) {
          return true;
        }
      }
      return false;
    });
  }
  getExpirationDateWithoutGracePeriod(expiryDate) {
    return new Date(expiryDate.getFullYear(), expiryDate.getMonth(), expiryDate.getDate());
  }
  getExpirationDateWithGracePeriod(expiryDate) {
    return new Date(
      expiryDate.getFullYear(),
      expiryDate.getMonth(),
      expiryDate.getDate() + GRACE_PERIOD_DAYS + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    const isExpired = /* @__PURE__ */ new Date() >= expiration;
    if (!isExpired && /* @__PURE__ */ new Date() >= this.getExpirationDateWithoutGracePeriod(expiryDate)) {
      this.outputMessages([
        "tldraw license is about to expire, you are in a grace period.",
        `Please reach out to ${LICENSE_EMAIL} if you would like to renew your license.`
      ]);
    }
    return isExpired;
  }
  isPerpetualLicenseExpired(expiryDate) {
    const expiration = this.getExpirationDateWithGracePeriod(expiryDate);
    const dates = {
      major: new Date(publishDates.major),
      minor: new Date(publishDates.minor)
    };
    return dates.major >= expiration || dates.minor >= expiration;
  }
  isFlagEnabled(flags, flag) {
    return (flags & flag) === flag;
  }
  outputNoLicenseKeyProvided() {
  }
  outputInvalidLicenseKey(msg2) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${msg2}`]);
  }
  outputLicenseInfoIfNeeded(result) {
    if (result.isAnnualLicenseExpired) {
      this.outputMessages([
        "Your tldraw license has expired!",
        `Please reach out to ${LICENSE_EMAIL} to renew.`
      ]);
    }
    if (!result.isDomainValid && !result.isDevelopment) {
      this.outputMessages([
        "This tldraw license key is not valid for this domain!",
        `Please reach out to ${LICENSE_EMAIL} if you would like to use tldraw on other domains.`
      ]);
    }
    if (result.license.flags >= HIGHEST_FLAG * 2) {
      this.outputMessages([
        "This tldraw license contains some unknown flags.",
        "You may want to update tldraw packages to a newer version to get access to new functionality."
      ]);
    }
  }
  outputMessages(messages) {
    if (this.isTest) return;
    if (this.verbose) {
      this.outputDelimiter();
      for (const message of messages) {
        console.log(
          `%c${message}`,
          `color: white; background: crimson; padding: 2px; border-radius: 3px;`
        );
      }
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      `color: white; background: crimson; padding: 2px; border-radius: 3px;`
    );
  }
  static className = "tl-watermark_SEE-LICENSE";
}
function isEditorUnlicensed(result) {
  if (!result.isLicenseParseable) return true;
  if (!result.isDomainValid && !result.isDevelopment) return true;
  if (result.isPerpetualLicenseExpired || result.isAnnualLicenseExpired) {
    if (result.isInternalLicense) {
      throw new Error("License: Internal license expired.");
    }
    return true;
  }
  return false;
}
const LicenseContext = reactExports.createContext({});
const useLicenseContext = () => reactExports.useContext(LicenseContext);
function LicenseProvider({
  licenseKey,
  children
}) {
  const [licenseManager] = reactExports.useState(() => new LicenseManager(licenseKey));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseContext.Provider, { value: licenseManager, children });
}
function usePassThroughWheelEvents(ref) {
  if (!ref) throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  reactExports.useEffect(() => {
    function onWheel(e) {
      if (e.isSpecialRedispatchedEvent) return;
      const elm2 = ref.current;
      if (elm2 && elm2.scrollHeight > elm2.clientHeight) {
        return;
      }
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new WheelEvent("wheel", e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm) return;
    elm.addEventListener("wheel", onWheel, { passive: false });
    return () => {
      elm.removeEventListener("wheel", onWheel);
    };
  }, [container, ref]);
}
const watermarkDesktopSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>';
const watermarkMobileSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="1601" fill="none"><path fill="#000" d="M72 1319.8c0-10.73 7.071-20.18 17.372-23.22l215.823-63.62c15.519-4.57 31.078 7.05 31.078 23.22v28.26c0 11.31-7.824 21.1-18.85 23.61l-109.636 24.94c-9.254 2.1-9.487 15.2-.313 17.63l110.784 29.37a24.21 24.21 0 0 1 18.015 23.4v25.64c0 11-7.423 20.62-18.071 23.41l-109.659 28.79c-9.162 2.41-8.986 15.47.236 17.63l108.792 25.46c10.955 2.56 18.702 12.33 18.702 23.57v28.39c0 16.17-15.559 27.79-31.078 23.22l-215.823-63.62c-10.3-3.04-17.372-12.49-17.372-23.22v-32.72c0-10.59 6.883-19.95 16.994-23.11l104.523-32.67c8.547-2.67 8.479-14.79-.096-17.36l-104.17-31.3C79.01 1372.42 72 1363 72 1352.31zM72 572.638V495.43c0-13.336 10.846-24.147 24.225-24.147h215.823c13.379 0 24.225 10.811 24.225 24.147v76.179q0 40.645-15.872 70.228-15.743 29.712-45.422 45.79-29.55 16.206-70.843 16.206-41.292 0-70.971-16.078-29.55-16.077-45.422-45.532Q72 612.767 72 572.638m85.132-29.84c-13.379 0-24.225 10.81-24.225 24.146v3.122q0 19.55 6.323 33.313 6.323 13.89 21.807 21.094 15.485 7.332 43.099 7.331t43.1-7.46q15.484-7.33 21.807-21.608 6.323-14.15 6.323-34.728v-1.064c0-13.336-10.846-24.146-24.225-24.146zM72 285.858c0-13.363 10.846-24.197 24.225-24.197h215.823c13.379 0 24.225 10.834 24.225 24.197v23.27c0 13.364-10.846 24.197-24.225 24.197H154.035c-13.379 0-24.225 10.834-24.225 24.197v58.328c0 13.364-10.846 24.197-24.225 24.197h-9.36C82.845 440.047 72 429.214 72 415.85zM278.463 24.72c0-13.374 10.846-24.216 24.225-24.216h9.36c13.379 0 24.225 10.842 24.225 24.216v181.174c0 13.374-10.846 24.216-24.225 24.216h-9.36c-13.379 0-24.225-10.842-24.225-24.216v-40.108c0-8.359-6.779-15.135-15.141-15.135H96.225c-13.38 0-24.225-10.842-24.225-24.216v-22.256c0-13.374 10.846-24.216 24.225-24.216h167.097c8.362 0 15.141-6.776 15.141-15.135z"/><path fill="#000" fill-rule="evenodd" d="M89.224 1062.13C78.997 1059.04 72 1049.63 72 1038.96v-25.9c0-16.486 16.145-28.147 31.818-22.979l215.823 71.169a24.19 24.19 0 0 1 16.632 22.98v62.97c0 10.45-6.706 19.71-16.632 22.98l-215.823 71.17C88.145 1246.51 72 1234.86 72 1218.37v-25.9c0-10.67 6.997-20.08 17.224-23.17l22.595-6.81a15.13 15.13 0 0 0 10.765-14.48v-64.59a15.13 15.13 0 0 0-10.765-14.48zm98.672 77.53 49.299-14.39c8.601-2.51 8.755-14.62.22-17.35l-49.299-15.75c-5.861-1.88-11.852 2.49-11.852 8.64v30.14c0 6.05 5.817 10.41 11.632 8.71" clip-rule="evenodd"/><path fill="#000" d="M72 773.439c0-13.367 10.846-24.203 24.225-24.203h215.823c13.379 0 24.225 10.836 24.225 24.203v89.762q0 29.395-10.711 51.439-10.71 22.046-30.84 34.293t-48.261 12.248q-28.388 0-47.873-12.635-18.187-11.672-28.056-32.218c-8.303-17.289-11.301-36.661-11.301-55.705v-43.867c0-77.976 138.26 4.16 86.215 4.16h-8.138c-12.334 0-22.332 9.989-22.332 22.311 0 8.269.351 16.6 3.097 24.487q3.225 9.024 10.194 13.794 6.968 4.899 18.194 4.899 11.356 0 18.453-4.899 7.226-4.77 10.581-13.794c2.815-7.188 3.484-14.944 3.484-22.596 0-13.366-10.846-24.202-24.225-24.202h-48.56c-12.036 0-16.288 11.345-21.122 20.272-6.79 12.539-25.841 7.72-25.841-6.536 0-7.586-6.156-13.736-13.749-13.736H96.225C82.845 820.916 72 810.08 72 796.714zm108.66 137.378-10.128 5.511-62.72 34.131C91.67 959.243 72 947.569 72 929.205V906.52a24.2 24.2 0 0 1 12.719-21.299l66.199-35.696a15.82 15.82 0 0 0 8.313-13.921c0-43.012 83.618 41.371 21.429 75.213"/></svg>';
function useLicenseManagerState(licenseManager) {
  return useValue("watermarkState", () => licenseManager.state.get(), [licenseManager]);
}
const WATERMARK_DESKTOP_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkDesktopSvg)}`;
const WATERMARK_MOBILE_LOCAL_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(watermarkMobileSvg)}`;
const Watermark = reactExports.memo(function Watermark2() {
  const licenseManager = useLicenseContext();
  const editor = useEditor();
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const licenseManagerState = useLicenseManagerState(licenseManager);
  if (!["licensed-with-watermark", "unlicensed"].includes(licenseManagerState)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseStyles, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WatermarkInner, { src: isMobile ? WATERMARK_MOBILE_LOCAL_SRC : WATERMARK_DESKTOP_LOCAL_SRC })
  ] });
});
const WatermarkInner = reactExports.memo(function WatermarkInner2({ src }) {
  const editor = useEditor();
  const isDebugMode = useValue("debug mode", () => editor.getInstanceState().isDebugMode, [editor]);
  const isMobile = useValue("is mobile", () => editor.getViewportScreenBounds().width < 700, [
    editor
  ]);
  const events = useCanvasEvents();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const maskCss = `url('${src}') center 100% / 100% no-repeat`;
  const url = "https://tldraw.dev/?utm_source=dotcom&utm_medium=organic&utm_campaign=watermark";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: LicenseManager.className,
      "data-debug": isDebugMode,
      "data-mobile": isMobile,
      draggable: false,
      ...events,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          draggable: false,
          role: "button",
          onPointerDown: (e) => {
            stopEventPropagation(e);
            preventDefault(e);
          },
          title: "made with tldraw",
          onClick: () => runtime.openWindow(url, "_blank"),
          style: { mask: maskCss, WebkitMask: maskCss }
        }
      )
    }
  );
});
const LicenseStyles = reactExports.memo(function LicenseStyles2() {
  const editor = useEditor();
  const className = LicenseManager.className;
  const CSS2 = `/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
or "licensed-with-watermark" users. By using this library, you agree to
preserve the watermark's behavior, keeping it visible, unobscured, and
available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

	.${className} {
		position: absolute;
		bottom: var(--space-2);
		right: var(--space-2);
		width: 96px;
		height: 32px;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: var(--layer-watermark) !important;
		background-color: color-mix(in srgb, var(--color-background) 62%, transparent);
		opacity: 1;
		border-radius: 5px;
		pointer-events: all;
		padding: 2px;
		box-sizing: content-box;
	}

	.${className} > button {
		position: absolute;
		width: 96px;
		height: 32px;
		pointer-events: all;
		cursor: inherit;
		color: var(--color-text);
		opacity: .38;
		border: 0;
		padding: 0;
		background-color: currentColor;
	}

	.${className}[data-debug='true'] {
		bottom: 46px;
	}

	.${className}[data-mobile='true'] {
		border-radius: 4px 0px 0px 4px;
		right: -2px;
		width: 8px;
		height: 48px;
	}

	.${className}[data-mobile='true'] > button {
		width: 8px;
		height: 32px;
	}

	@media (hover: hover) {
		.${className} > button {
			pointer-events: none;
		}

		.${className}:hover {
			background-color: var(--color-background);
			transition: background-color 0.2s ease-in-out;
			transition-delay: 0.32s;
		}

		.${className}:hover > button {
			animation: delayed_link 0.2s forwards ease-in-out;
			animation-delay: 0.32s;
		}

		.${className} > button:focus-visible {
			opacity: 1;
		}
	}


	@keyframes delayed_link {
		0% {
			cursor: inherit;
			opacity: .38;
			pointer-events: none;
		}
		100% {
			cursor: pointer;
			opacity: 1;
			pointer-events: all;
		}
	}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("style", { nonce: editor.options.nonce, children: CSS2 });
});
const EMPTY_SHAPE_UTILS_ARRAY = [];
const EMPTY_BINDING_UTILS_ARRAY = [];
const EMPTY_TOOLS_ARRAY = [];
const TL_CONTAINER_CLASS = "tl-container";
reactExports.memo(function TldrawEditor2({
  store,
  components,
  className,
  user: _user,
  options: _options,
  ...rest
}) {
  const [container, setContainer] = reactExports.useState(null);
  const user = reactExports.useMemo(() => _user ?? createTLUser(), [_user]);
  const ErrorFallback = components?.ErrorFallback === void 0 ? DefaultErrorFallback : components?.ErrorFallback;
  const withDefaults = {
    ...rest,
    shapeUtils: rest.shapeUtils ?? EMPTY_SHAPE_UTILS_ARRAY,
    bindingUtils: rest.bindingUtils ?? EMPTY_BINDING_UTILS_ARRAY,
    tools: rest.tools ?? EMPTY_TOOLS_ARRAY,
    components,
    options: useShallowObjectIdentity(_options)
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: setContainer,
      "data-tldraw": version,
      draggable: false,
      className: classNames(`${TL_CONTAINER_CLASS} tl-theme__light`, className),
      onPointerDown: stopEventPropagation,
      tabIndex: -1,
      role: "application",
      "aria-label": _options?.branding ?? "tldraw",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        OptionalErrorBoundary,
        {
          fallback: ErrorFallback,
          onError: (error) => annotateError(error, { tags: { origin: "react.tldraw-before-app" } }),
          children: container && /* @__PURE__ */ jsxRuntimeExports.jsx(LicenseProvider, { licenseKey: rest.licenseKey, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerProvider, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(EditorComponentsProvider, { overrides: components, children: store ? store instanceof Store ? (
            // Store is ready to go, whether externally synced or not
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithReadyStore, { ...withDefaults, store, user })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithLoadingStore, { ...withDefaults, store, user })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithOwnStore, { ...withDefaults, store, user })
          ) }) }) })
        }
      )
    }
  );
});
function TldrawEditorWithOwnStore(props) {
  const {
    defaultName,
    snapshot,
    initialData,
    shapeUtils,
    bindingUtils,
    persistenceKey,
    sessionId,
    user,
    assets,
    migrations
  } = props;
  const syncedStore = useLocalStore({
    shapeUtils,
    bindingUtils,
    initialData,
    persistenceKey,
    sessionId,
    defaultName,
    snapshot,
    assets,
    migrations
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithLoadingStore, { ...props, store: syncedStore, user });
}
const TldrawEditorWithLoadingStore = reactExports.memo(function TldrawEditorBeforeLoading({
  store,
  user,
  ...rest
}) {
  const container = useContainer();
  reactExports.useLayoutEffect(() => {
    if (user.userPreferences.get().colorScheme === "dark") {
      container.classList.remove("tl-theme__light");
      container.classList.add("tl-theme__dark");
    }
  }, [container, user]);
  const { LoadingScreen: LoadingScreen2 } = useEditorComponents();
  switch (store.status) {
    case "error": {
      throw store.error;
    }
    case "loading": {
      return LoadingScreen2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen2, {}) : null;
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawEditorWithReadyStore, { ...rest, store: store.store, user });
});
const noAutoFocus = () => document.location.search.includes("tldraw_preserve_focus");
function TldrawEditorWithReadyStore({
  onMount,
  children,
  store,
  tools,
  shapeUtils,
  bindingUtils,
  user,
  initialState: initialState2,
  autoFocus = true,
  inferDarkMode,
  cameraOptions,
  textOptions,
  options,
  licenseKey,
  deepLinks: _deepLinks,
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  isShapeHidden,
  getShapeVisibility,
  assetUrls
}) {
  const { ErrorFallback } = useEditorComponents();
  const container = useContainer();
  const [editor, setEditor] = useRefState(null);
  const canvasRef = reactExports.useRef(null);
  const deepLinks = useShallowObjectIdentity(_deepLinks === true ? {} : _deepLinks);
  const editorOptionsRef = reactExports.useRef({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: autoFocus && !noAutoFocus(),
    inferDarkMode,
    initialState: initialState2,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions,
    deepLinks
  });
  reactExports.useLayoutEffect(() => {
    editorOptionsRef.current = {
      autoFocus: autoFocus && !noAutoFocus(),
      inferDarkMode,
      initialState: initialState2,
      cameraOptions,
      deepLinks
    };
  }, [autoFocus, inferDarkMode, initialState2, cameraOptions, deepLinks]);
  reactExports.useLayoutEffect(
    () => {
      const { autoFocus: autoFocus2, inferDarkMode: inferDarkMode2, initialState: initialState22, cameraOptions: cameraOptions2, deepLinks: deepLinks2 } = editorOptionsRef.current;
      const editor2 = new Editor$1({
        store,
        shapeUtils,
        bindingUtils,
        tools,
        getContainer: () => container,
        user,
        initialState: initialState22,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: autoFocus2,
        inferDarkMode: inferDarkMode2,
        cameraOptions: cameraOptions2,
        textOptions,
        options,
        licenseKey,
        isShapeHidden,
        getShapeVisibility,
        fontAssetUrls: assetUrls?.fonts
      });
      editor2.updateViewportScreenBounds(canvasRef.current ?? container);
      if (deepLinks2) {
        if (!deepLinks2?.getUrl) {
          editor2.navigateToDeepLink(deepLinks2);
        } else {
          editor2.navigateToDeepLink({ ...deepLinks2, url: deepLinks2.getUrl(editor2) });
        }
      }
      setEditor(editor2);
      return () => {
        editor2.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [
      bindingUtils,
      container,
      options,
      shapeUtils,
      store,
      tools,
      user,
      setEditor,
      licenseKey,
      isShapeHidden,
      getShapeVisibility,
      textOptions,
      assetUrls
    ]
  );
  reactExports.useLayoutEffect(() => {
    if (!editor) return;
    if (deepLinks) {
      return editor.registerDeepLinkListener(deepLinks);
    }
  }, [editor, deepLinks]);
  reactExports.useLayoutEffect(() => {
    if (editor && cameraOptions) {
      editor.setCameraOptions(cameraOptions);
    }
  }, [editor, cameraOptions]);
  const crashingError = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        if (editor) {
          editor.on("crash", onStoreChange);
          return () => editor.off("crash", onStoreChange);
        }
        return () => {
        };
      },
      [editor]
    ),
    () => editor?.getCrashingError() ?? null
  );
  reactExports.useEffect(
    function handleFocusOnPointerDownForPreserveFocusMode() {
      if (!editor) return;
      function handleFocusOnPointerDown() {
        if (!editor) return;
        editor.focus();
      }
      function handleBlurOnPointerDown() {
        if (!editor) return;
        editor.blur();
      }
      if (autoFocus && noAutoFocus()) {
        editor.getContainer().addEventListener("pointerdown", handleFocusOnPointerDown);
        document.body.addEventListener("pointerdown", handleBlurOnPointerDown);
        return () => {
          editor.getContainer()?.removeEventListener("pointerdown", handleFocusOnPointerDown);
          document.body.removeEventListener("pointerdown", handleBlurOnPointerDown);
        };
      }
    },
    [editor, autoFocus]
  );
  const [_fontLoadingState, setFontLoadingState] = reactExports.useState(null);
  let fontLoadingState = _fontLoadingState;
  if (editor !== fontLoadingState?.editor) {
    fontLoadingState = null;
  }
  reactExports.useEffect(() => {
    if (!editor) return;
    let isCancelled = false;
    setFontLoadingState({ editor, isLoaded: false });
    editor.fonts.loadRequiredFontsForCurrentPage(editor.options.maxFontsToLoadBeforeRender).finally(() => {
      if (isCancelled) return;
      setFontLoadingState({ editor, isLoaded: true });
    });
    return () => {
      isCancelled = true;
    };
  }, [editor]);
  const { Canvas, LoadingScreen: LoadingScreen2 } = useEditorComponents();
  if (!editor || !fontLoadingState?.isLoaded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      LoadingScreen2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingScreen2, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-canvas", ref: canvasRef })
    ] });
  }
  return (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalErrorBoundary, {
      fallback: ErrorFallback,
      onError: (error) => editor.annotateError(error, { origin: "react.tldraw", willCrashApp: true }),
      children: crashingError ? /* @__PURE__ */ jsxRuntimeExports.jsx(Crash, { crashingError }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EditorProvider, { editor, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { onMount, children: [
        children ?? (Canvas ? /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}, editor.contextId) : null),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Watermark, {})
      ] }) })
    })
  );
}
function Layout({ children, onMount }) {
  useZoomCss();
  useCursor();
  useDarkMode();
  useForceUpdate();
  useOnMount((editor) => {
    const teardownStore = editor.store.props.onMount(editor);
    const teardownCallback = onMount?.(editor);
    return () => {
      teardownStore?.();
      teardownCallback?.();
    };
  });
  return children;
}
function Crash({ crashingError }) {
  throw crashingError;
}
function LoadingScreen({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-loading", "aria-busy": "true", tabIndex: 0, children });
}
function useOnMount(onMount) {
  const editor = useEditor();
  const onMountEvent = useEvent((editor2) => {
    let teardown = void 0;
    editor2.run(
      () => {
        teardown = onMount?.(editor2);
        editor2.emit("mount");
      },
      { history: "ignore" }
    );
    window.tldrawReady = true;
    return teardown;
  });
  React.useLayoutEffect(() => {
    if (editor) return onMountEvent?.(editor);
  }, [editor, onMountEvent]);
}
function HTMLContainer({ children, className = "", ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...rest, className: classNames("tl-html-container", className), children });
}
class BindingUtil {
  constructor(editor) {
    this.editor = editor;
  }
  static props;
  static migrations;
  /**
   * The type of the binding util, which should match the binding's type.
   *
   * @public
   */
  static type;
}
function resizeBox(shape, info, opts = {}) {
  const { newPoint, handle, scaleX, scaleY } = info;
  const { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts;
  let w = shape.props.w * scaleX;
  let h = shape.props.h * scaleY;
  const offset2 = new Vec(0, 0);
  if (w > 0) {
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset2.x = w - minWidth;
          break;
        }
        case "top":
        case "bottom": {
          offset2.x = (w - minWidth) / 2;
          break;
        }
        default: {
          offset2.x = 0;
        }
      }
      w = minWidth;
    }
  } else {
    offset2.x = w;
    w = -w;
    if (w < minWidth) {
      switch (handle) {
        case "top_left":
        case "left":
        case "bottom_left": {
          offset2.x = -w;
          break;
        }
        default: {
          offset2.x = -minWidth;
        }
      }
      w = minWidth;
    }
  }
  if (h > 0) {
    if (h < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset2.y = h - minHeight;
          break;
        }
        case "right":
        case "left": {
          offset2.y = (h - minHeight) / 2;
          break;
        }
        default: {
          offset2.y = 0;
        }
      }
      h = minHeight;
    }
  } else {
    offset2.y = h;
    h = -h;
    if (h < minHeight) {
      switch (handle) {
        case "top_left":
        case "top":
        case "top_right": {
          offset2.y = -h;
          break;
        }
        default: {
          offset2.y = -minHeight;
        }
      }
      h = minHeight;
    }
  }
  const { x, y: y2 } = offset2.rot(shape.rotation).add(newPoint);
  return {
    ...shape,
    x,
    y: y2,
    props: {
      w: Math.min(maxWidth, w),
      h: Math.min(maxHeight, h)
    }
  };
}
class BaseBoxShapeUtil extends ShapeUtil {
  getGeometry(shape) {
    return new Rectangle2d({
      width: shape.props.w,
      height: shape.props.h,
      isFilled: true
    });
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getHandleSnapGeometry(shape) {
    return {
      points: this.getGeometry(shape).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...endShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
}
function resizeScaled(shape, { initialBounds, scaleX, scaleY, newPoint, handle }) {
  let scaleDelta;
  switch (handle) {
    case "bottom_left":
    case "bottom_right":
    case "top_left":
    case "top_right": {
      scaleDelta = Math.max(0.01, Math.max(Math.abs(scaleX), Math.abs(scaleY)));
      break;
    }
    case "left":
    case "right": {
      scaleDelta = Math.max(0.01, Math.abs(scaleX));
      break;
    }
    case "bottom":
    case "top": {
      scaleDelta = Math.max(0.01, Math.abs(scaleY));
      break;
    }
    default: {
      throw exhaustiveSwitchError$1(handle);
    }
  }
  const offset2 = new Vec(0, 0);
  if (scaleX < 0) {
    offset2.x = -(initialBounds.width * scaleDelta);
  }
  if (scaleY < 0) {
    offset2.y = -(initialBounds.height * scaleDelta);
  }
  const { x, y: y2 } = Vec.Add(newPoint, offset2.rot(shape.rotation));
  return {
    x,
    y: y2,
    props: {
      scale: scaleDelta * shape.props.scale
    }
  };
}
function maybeSnapToGrid(point, editor) {
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  if (isGridMode) return point.clone().snapToGrid(gridSize);
  return point.clone();
}
function useGlobalMenuIsOpen(id, onChange, onEvent) {
  const rIsOpen = reactExports.useRef(false);
  const onOpenChange = reactExports.useCallback(
    (isOpen2) => {
      rIsOpen.current = isOpen2;
      if (isOpen2) {
        tlmenus.addOpenMenu(id);
      } else {
        tlmenus.deleteOpenMenu(id);
      }
      onChange?.(isOpen2);
    },
    [id, onChange]
  );
  const isOpen = useValue("is menu open", () => tlmenus.getOpenMenus().includes(id), [id]);
  reactExports.useEffect(() => {
    if (rIsOpen.current) {
      onEvent?.("open-menu");
      tlmenus.addOpenMenu(id);
    }
    return () => {
      if (rIsOpen.current) {
        tlmenus.deleteOpenMenu(id);
        tlmenus.getOpenMenus().forEach((menuId) => {
          if (menuId.startsWith(id)) {
            onEvent?.("close-menu");
            tlmenus.deleteOpenMenu(menuId);
          }
        });
        rIsOpen.current = false;
      }
    };
  }, [id, onEvent]);
  return [isOpen, onOpenChange];
}
function useIsEditing(shapeId) {
  const editor = useEditor();
  return useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor, shapeId]);
}
function usePassThroughMouseOverEvents(ref) {
  if (!ref) throw Error("usePassThroughWheelEvents must be passed a ref");
  const container = useContainer();
  reactExports.useEffect(() => {
    function onMouseOver(e) {
      if (e.isSpecialRedispatchedEvent) return;
      preventDefault(e);
      const cvs = container.querySelector(".tl-canvas");
      if (!cvs) return;
      const newEvent = new PointerEvent(e.type, e);
      newEvent.isSpecialRedispatchedEvent = true;
      cvs.dispatchEvent(newEvent);
    }
    const elm = ref.current;
    if (!elm) return;
    elm.addEventListener("mouseover", onMouseOver, { passive: false });
    return () => {
      elm.removeEventListener("mouseover", onMouseOver);
    };
  }, [container, ref]);
}
function useSelectionEvents(handle) {
  const editor = useEditor();
  const events = reactExports.useMemo(
    function selectionEvents() {
      const onPointerDown = (e) => {
        if (e.isKilled) return;
        if (e.button === RIGHT_MOUSE_BUTTON) {
          editor.dispatch({
            type: "pointer",
            target: "selection",
            handle,
            name: "right_click",
            ...getPointerInfo(e)
          });
          return;
        }
        if (e.button !== 0) return;
        const elm = loopToHtmlElement(e.currentTarget);
        function releaseCapture() {
          elm.removeEventListener("pointerup", releaseCapture);
          releasePointerCapture(elm, e);
        }
        setPointerCapture(elm, e);
        elm.addEventListener("pointerup", releaseCapture);
        editor.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(e)
        });
        stopEventPropagation(e);
      };
      let lastX, lastY;
      function onPointerMove(e) {
        if (e.isKilled) return;
        if (e.button !== 0) return;
        if (e.clientX === lastX && e.clientY === lastY) return;
        lastX = e.clientX;
        lastY = e.clientY;
        editor.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(e)
        });
      }
      const onPointerUp = (e) => {
        if (e.isKilled) return;
        if (e.button !== 0) return;
        editor.dispatch({
          name: "pointer_up",
          type: "pointer",
          target: "selection",
          handle,
          ...getPointerInfo(e)
        });
      };
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp
      };
    },
    [editor, handle]
  );
  return events;
}
function useTLStore(opts) {
  const [current, setCurrent] = reactExports.useState(() => ({ store: createTLStore(opts), opts }));
  if (!areObjectsShallowEqual(current.opts, opts)) {
    const next = { store: createTLStore(opts), opts };
    setCurrent(next);
    return next.store;
  }
  return current.store;
}
const SPACING = 20;
const MIN_COUNT = 8;
function getVerticesCountForLength$1(length, spacing = SPACING) {
  return Math.max(MIN_COUNT, Math.ceil(length / spacing));
}
class Arc2d extends Geometry2d {
  _center;
  radius;
  start;
  end;
  largeArcFlag;
  sweepFlag;
  measure;
  angleStart;
  angleEnd;
  constructor(config) {
    super({ ...config, isFilled: false, isClosed: false });
    const { center, sweepFlag, largeArcFlag, start, end } = config;
    if (start.equals(end)) throw Error(`Arc must have different start and end points.`);
    this.angleStart = Vec.Angle(center, start);
    this.angleEnd = Vec.Angle(center, end);
    this.radius = Vec.Dist(center, start);
    this.measure = getArcMeasure(this.angleStart, this.angleEnd, sweepFlag, largeArcFlag);
    this.start = start;
    this.end = end;
    this.sweepFlag = sweepFlag;
    this.largeArcFlag = largeArcFlag;
    this._center = center;
  }
  nearestPoint(point) {
    const { _center, measure, radius, angleEnd, angleStart, start: A, end: B } = this;
    const t2 = getPointInArcT(measure, angleStart, angleEnd, _center.angle(point));
    if (t2 <= 0) return A;
    if (t2 >= 1) return B;
    const P = Vec.Sub(point, _center).uni().mul(radius).add(_center);
    let nearest;
    let dist = Infinity;
    let d;
    for (const p of [A, B, P]) {
      d = Vec.Dist2(point, p);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const { _center, radius, measure, angleStart, angleEnd } = this;
    const intersection = intersectLineSegmentCircle(A, B, _center, radius);
    if (intersection === null) return false;
    return intersection.some((p) => {
      const result = getPointInArcT(measure, angleStart, angleEnd, _center.angle(p));
      return result >= 0 && result <= 1;
    });
  }
  getVertices() {
    const { _center, measure, length, radius, angleStart } = this;
    const vertices = [];
    for (let i = 0, n2 = getVerticesCountForLength$1(Math.abs(length)); i < n2 + 1; i++) {
      const t2 = i / n2 * measure;
      const angle = angleStart + t2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  getSvgPathData(first2 = true) {
    const { start, end, radius, largeArcFlag, sweepFlag } = this;
    return `${first2 ? `M${start.toFixed()}` : ``} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.toFixed()}`;
  }
  getLength() {
    return Math.abs(this.measure * this.radius);
  }
}
class Circle2d extends Geometry2d {
  constructor(config) {
    super({ isClosed: true, ...config });
    this.config = config;
    const { x = 0, y: y2 = 0, radius } = config;
    this.x = x;
    this.y = y2;
    this._center = new Vec(radius + x, radius + y2);
    this.radius = radius;
  }
  _center;
  radius;
  x;
  y;
  getBounds() {
    return new Box(this.x, this.y, this.radius * 2, this.radius * 2);
  }
  getVertices() {
    const { _center, radius } = this;
    const perimeter = PI2 * radius;
    const vertices = [];
    for (let i = 0, n2 = getVerticesCountForLength$1(perimeter); i < n2; i++) {
      const angle = i / n2 * PI2;
      vertices.push(getPointOnCircle(_center, radius, angle));
    }
    return vertices;
  }
  nearestPoint(point) {
    const { _center, radius } = this;
    if (_center.equals(point)) return Vec.AddXY(_center, radius, 0);
    return Vec.Sub(point, _center).uni().mul(radius).add(_center);
  }
  hitTestLineSegment(A, B, distance = 0) {
    const { _center, radius } = this;
    return intersectLineSegmentCircle(A, B, _center, radius + distance) !== null;
  }
  getSvgPathData() {
    const { _center, radius } = this;
    return `M${_center.x + radius},${_center.y} a${radius},${radius} 0 1,0 ${radius * 2},0a${radius},${radius} 0 1,0 -${radius * 2},0`;
  }
}
class CubicBezier2d extends Polyline2d {
  a;
  b;
  c;
  d;
  constructor(config) {
    const { start: a2, cp1: b, cp2: c2, end: d } = config;
    super({ ...config, points: [a2, d] });
    this.a = a2;
    this.b = b;
    this.c = c2;
    this.d = d;
  }
  getVertices() {
    const vertices = [];
    const { a: a2, b, c: c2, d } = this;
    for (let i = 0, n2 = 10; i <= n2; i++) {
      const t2 = i / n2;
      vertices.push(
        new Vec(
          (1 - t2) * (1 - t2) * (1 - t2) * a2.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c2.x + t2 * t2 * t2 * d.x,
          (1 - t2) * (1 - t2) * (1 - t2) * a2.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c2.y + t2 * t2 * t2 * d.y
        )
      );
    }
    return vertices;
  }
  midPoint() {
    return CubicBezier2d.GetAtT(this, 0.5);
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.segments) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  getSvgPathData(first2 = true) {
    const { a: a2, b, c: c2, d } = this;
    return `${first2 ? `M ${a2.toFixed()} ` : ``} C${b.toFixed()} ${c2.toFixed()} ${d.toFixed()}`;
  }
  static GetAtT(segment, t2) {
    const { a: a2, b, c: c2, d } = segment;
    return new Vec(
      (1 - t2) * (1 - t2) * (1 - t2) * a2.x + 3 * ((1 - t2) * (1 - t2)) * t2 * b.x + 3 * (1 - t2) * (t2 * t2) * c2.x + t2 * t2 * t2 * d.x,
      (1 - t2) * (1 - t2) * (1 - t2) * a2.y + 3 * ((1 - t2) * (1 - t2)) * t2 * b.y + 3 * (1 - t2) * (t2 * t2) * c2.y + t2 * t2 * t2 * d.y
    );
  }
  getLength(filters, precision = 32) {
    let n1, p1 = this.a, length = 0;
    for (let i = 1; i <= precision; i++) {
      n1 = CubicBezier2d.GetAtT(this, i / precision);
      length += Vec.Dist(p1, n1);
      p1 = n1;
    }
    return length;
  }
}
class CubicSpline2d extends Geometry2d {
  points;
  constructor(config) {
    super({ ...config, isClosed: false, isFilled: false });
    const { points } = config;
    this.points = points;
  }
  _segments;
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { points } = this;
      const len = points.length;
      const last2 = len - 2;
      const k = 1.25;
      for (let i = 0; i < len - 1; i++) {
        const p0 = i === 0 ? points[0] : points[i - 1];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = i === last2 ? p2 : points[i + 2];
        const start = p1, cp1 = i === 0 ? p0 : new Vec(p1.x + (p2.x - p0.x) / 6 * k, p1.y + (p2.y - p0.y) / 6 * k), cp2 = i === last2 ? p2 : new Vec(p2.x - (p3.x - p1.x) / 6 * k, p2.y - (p3.y - p1.y) / 6 * k), end = p2;
        this._segments.push(new CubicBezier2d({ start, cp1, cp2, end }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((acc, segment) => acc + segment.length, 0);
  }
  getVertices() {
    const vertices = this.segments.reduce((acc, segment) => {
      return acc.concat(segment.vertices);
    }, []);
    vertices.push(this.points[this.points.length - 1]);
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const segment of this.segments) {
      p = segment.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.segments.some((segment) => segment.hitTestLineSegment(A, B));
  }
  getSvgPathData() {
    let d = this.segments.reduce((d2, segment, i) => {
      return d2 + segment.getSvgPathData(i === 0);
    }, "");
    if (this.isClosed) {
      d += "Z";
    }
    return d;
  }
}
class Ellipse2d extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    this.config = config;
    const { width, height } = config;
    this.w = width;
    this.h = height;
  }
  w;
  h;
  _edges;
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices } = this;
      this._edges = [];
      for (let i = 0, n2 = vertices.length; i < n2; i++) {
        const start = vertices[i];
        const end = vertices[(i + 1) % n2];
        this._edges.push(new Edge2d({ start, end }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const w = Math.max(1, this.w);
    const h = Math.max(1, this.h);
    const cx = w / 2;
    const cy = h / 2;
    const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);
    const p = PI$1 * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));
    const len = getVerticesCountForLength$1(p);
    const step = PI2 / len;
    const a2 = Math.cos(step);
    const b = Math.sin(step);
    let sin = 0;
    let cos = 1;
    let ts2 = 0;
    let tc = 1;
    const vertices = Array(len);
    for (let i = 0; i < len; i++) {
      vertices[i] = new Vec(cx + cx * cos, cy + cy * sin);
      ts2 = b * cos + a2 * sin;
      tc = a2 * cos - b * sin;
      sin = ts2;
      cos = tc;
    }
    return vertices;
  }
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let d;
    let p;
    for (const edge of this.edges) {
      p = edge.nearestPoint(A);
      d = Vec.Dist2(p, A);
      if (d < dist) {
        nearest = p;
        dist = d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    return this.edges.some((edge) => edge.hitTestLineSegment(A, B));
  }
  getBounds() {
    return new Box(0, 0, this.w, this.h);
  }
  getLength() {
    const { w, h } = this;
    const cx = w / 2;
    const cy = h / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return perimeterOfEllipse(rx, ry);
  }
  getSvgPathData(first2 = false) {
    const { w, h } = this;
    const cx = w / 2;
    const cy = h / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    return `${first2 ? `M${cx - rx},${cy}` : ``} a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
  }
}
class Stadium2d extends Geometry2d {
  constructor(config) {
    super({ ...config, isClosed: true });
    this.config = config;
    const { width: w, height: h } = config;
    this.w = w;
    this.h = h;
    if (h > w) {
      const r2 = w / 2;
      this.a = new Arc2d({
        start: new Vec(0, r2),
        end: new Vec(w, r2),
        center: new Vec(w / 2, r2),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.b = new Edge2d({ start: new Vec(w, r2), end: new Vec(w, h - r2) });
      this.c = new Arc2d({
        start: new Vec(w, h - r2),
        end: new Vec(0, h - r2),
        center: new Vec(w / 2, h - r2),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.d = new Edge2d({ start: new Vec(0, h - r2), end: new Vec(0, r2) });
    } else {
      const r2 = h / 2;
      this.a = new Arc2d({
        start: new Vec(r2, h),
        end: new Vec(r2, 0),
        center: new Vec(r2, r2),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.b = new Edge2d({ start: new Vec(r2, 0), end: new Vec(w - r2, 0) });
      this.c = new Arc2d({
        start: new Vec(w - r2, 0),
        end: new Vec(w - r2, h),
        center: new Vec(w - r2, r2),
        sweepFlag: 1,
        largeArcFlag: 1
      });
      this.d = new Edge2d({ start: new Vec(w - r2, h), end: new Vec(r2, h) });
    }
  }
  w;
  h;
  a;
  b;
  c;
  d;
  nearestPoint(A) {
    let nearest;
    let dist = Infinity;
    let _d;
    let p;
    const { a: a2, b, c: c2, d } = this;
    for (const part of [a2, b, c2, d]) {
      p = part.nearestPoint(A);
      _d = Vec.Dist2(p, A);
      if (_d < dist) {
        nearest = p;
        dist = _d;
      }
    }
    if (!nearest) throw Error("nearest point not found");
    return nearest;
  }
  hitTestLineSegment(A, B) {
    const { a: a2, b, c: c2, d } = this;
    return [a2, b, c2, d].some((edge) => edge.hitTestLineSegment(A, B));
  }
  getVertices() {
    const { a: a2, b, c: c2, d } = this;
    return [a2, b, c2, d].reduce((a22, p) => {
      a22.push(...p.vertices);
      return a22;
    }, []);
  }
  getBounds() {
    return new Box(0, 0, this.w, this.h);
  }
  getLength() {
    const { h, w } = this;
    if (h > w) return (PI$1 * (w / 2) + (h - w)) * 2;
    else return (PI$1 * (h / 2) + (w - h)) * 2;
  }
  getSvgPathData() {
    const { a: a2, b, c: c2, d } = this;
    return [a2, b, c2, d].map((p, i) => p.getSvgPathData(i === 0)).join(" ") + " Z";
  }
}
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a2, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a2.childCount || i == b.childCount)
      return a2.childCount == b.childCount ? null : pos;
    let childA = a2.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a2, b, posA, posB) {
  for (let iA = a2.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a2.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last2 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last2.isText && last2.sameMarkup(first2)) {
      content[content.length - 1] = last2.withText(last2.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size2 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size2 += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result, size2);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new Fragment(copy2, size2);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round2 > 0)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n2) => n2.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array2) {
    if (!array2.length)
      return Fragment.empty;
    let joined, size2 = 0;
    for (let i = 0; i < array2.length; i++) {
      let node = array2[i];
      size2 += node.nodeSize;
      if (i && node.isText && array2[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array2.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array2, size2);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset2) {
  found.index = index2;
  found.offset = offset2;
  return found;
}
function compareDeep(a2, b) {
  if (a2 === b)
    return true;
  if (!(a2 && typeof a2 == "object") || !(b && typeof b == "object"))
    return false;
  let array2 = Array.isArray(a2);
  if (Array.isArray(b) != array2)
    return false;
  if (array2) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!compareDeep(a2[i], b[i]))
        return false;
  } else {
    for (let p in a2)
      if (!(p in b) || !compareDeep(a2[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a2))
        return false;
  }
  return true;
}
let Mark$1 = class Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a2, b) {
    if (a2 == b)
      return true;
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!a2[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a2, b) => a2.type.rank - b.type.rank);
    return copy2;
  }
};
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild)
      openStart++;
    for (let n2 = fragment.lastChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset2 == dist || child.isText) {
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$1($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last2 = target.length - 1;
  if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
    target[last2] = child.withText(target[last2].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str2 = "";
    for (let i = 1; i <= this.depth; i++)
      str2 += (str2 ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str2 + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc2; ; ) {
      let { index: index2, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index2, start + offset2);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset2 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache = resolveCache.get(doc2);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$2 = class Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark$1.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset2 };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset2 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from2).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark$1.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n2) => n2.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node$2.prototype.text = void 0;
class TextNode extends Node$2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str2) {
  for (let i = marks.length - 1; i >= 0; i--)
    str2 = marks[i].type.name + "(" + str2 + ")";
  return str2;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string2, nodeTypes) {
    let stream2 = new TokenStream(string2, nodeTypes);
    if (stream2.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream2);
    if (stream2.next)
      stream2.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream2);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed2 = this.computeWrapping(target);
    this.wrapCache.push(target, computed2);
    return computed2;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n2) {
    if (n2 >= this.next.length)
      throw new RangeError(`There's no ${n2}th edge in this content match`);
    return this.next[n2];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string2, nodeTypes) {
    this.string = string2;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string2.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str2) {
    throw new SyntaxError(str2 + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream2) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream2));
  } while (stream2.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream2) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream2));
  } while (stream2.next && stream2.next != ")" && stream2.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream2) {
  let expr = parseExprAtom(stream2);
  for (; ; ) {
    if (stream2.eat("+"))
      expr = { type: "plus", expr };
    else if (stream2.eat("*"))
      expr = { type: "star", expr };
    else if (stream2.eat("?"))
      expr = { type: "opt", expr };
    else if (stream2.eat("{"))
      expr = parseExprRange(stream2, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream2) {
  if (/\D/.test(stream2.next))
    stream2.err("Expected number, got '" + stream2.next + "'");
  let result = Number(stream2.next);
  stream2.pos++;
  return result;
}
function parseExprRange(stream2, expr) {
  let min2 = parseNum(stream2), max2 = min2;
  if (stream2.eat(",")) {
    if (stream2.next != "}")
      max2 = parseNum(stream2);
    else
      max2 = -1;
  }
  if (!stream2.eat("}"))
    stream2.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream2, name) {
  let types = stream2.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream2.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream2) {
  if (stream2.eat("(")) {
    let expr = parseExpr(stream2);
    if (!stream2.eat(")"))
      stream2.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream2.next)) {
    let exprs = resolveName(stream2, stream2.next).map((type) => {
      if (stream2.inline == null)
        stream2.inline = type.isInline;
      else if (stream2.inline != type.isInline)
        stream2.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream2.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream2.err("Unexpected token '" + stream2.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a2, b) {
  return b - a2;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream2) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream2.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
let NodeType$1 = class NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n2 in this.attrs)
      if (this.attrs[n2].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$2(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$2(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$2(this, attrs, content.append(after), Mark$1.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark$1.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node$2.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark$1.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
let DOMParser$1 = class DOMParser2 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node = schema.nodes[r2.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark$1.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark$1.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  }
};
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type, attrs, marks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last2 = this.content[this.content.length - 1], m;
      if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
        let text = last2;
        if (last2.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark$1.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark$1.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc$1(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc$1(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc$1(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$1(options) {
  return options.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset2) {
  return index2 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n2) {
    return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map2);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n2) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n2)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n2, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n2, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this._maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from2, to, slice2) {
    try {
      return StepResult.ok(doc2.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from2, to) {
  let $from = doc2.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s2) => tr2.step(s2));
  added.forEach((s2) => tr2.step(s2));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index2 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex))
      break;
  }
  return null;
}
function lift$2(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset2) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset2 + m.index);
        tr2.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset2) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset2);
      tr2.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index3 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a2, b) {
  if (!b.content.size)
    a2.type.compatibleContent(b.type);
  let match = a2.contentMatchAt(a2.childCount);
  let { linebreakReplacement } = a2.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a2.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a2.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable(a2, b) {
  return !!(a2 && b && !a2.isLeaf && canAppendWithSubstitutedLinebreaks(a2, b));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index2 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index2++;
      after = $pos.node(d).maybeChild(index2);
    } else {
      before = $pos.node(d).maybeChild(index2 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index2, index2 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index2 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d + 1);
      if (index2 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice2) {
  let $pos = doc2.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc2.resolve(from2), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type, match, dropInner);
      if (!fit)
        continue;
      for (let d = i - 1; d >= 0; d--) {
        let { match: match2, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
}
function dropFromFragment(fragment, depth, count2) {
  if (depth == 0)
    return fragment.cutByIndex(count2, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count2)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type, node.content, index2) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$1(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last2 = i == covered.length - 1;
    if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange$1(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift$2(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType$1(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark$1) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd$1(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd$1(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from2) {
    return new NodeSelection(doc2.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index2, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$1(tr2, startLen, bias) {
  let last2 = tr2.steps.length - 1;
  if (last2 < startLen)
    return;
  let step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last2], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction2 extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time2) {
    this.time = time2;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n2 = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction2(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a2;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a2 = child.pmViewDesc) === null || _a2 === void 0 ? void 0 : _a2.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2];
      offset2 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y2) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y2);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(x, y2);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows$1 = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide$1(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide$1(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide$1(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide$1(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide$1(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide$1(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide$1(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide$1(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide$1(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide$1(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    let dom = view.root.elementFromPoint(x, y2);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack2 = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom, top, left } = stack2[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom: atom2 } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom2 || 0));
  if (!$dom.parent.inlineContent) {
    if (atom2 == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom2 == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom2 == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom2 == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y2 = top ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (offset2 == pos && end != offset2) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
        to = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (from2 > offset2 && to < end)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
      offset2 = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (offset2 == end ? from2 <= end && to >= offset2 : from2 < end && to > offset2) {
        let startInside = offset2 + child.border, endInside = end - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n2 = this.nodeDOM; n2; n2 = n2.parentNode)
      if (n2 == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a2, b) {
  if (a2.length != b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!a2[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ViewTreeUpdater {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start; i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a2, b) {
  return a2.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str2 = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str2 += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str2.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str2.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str2.length >= to + text.length - childStart && str2.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from2) {
      result.push(child);
    } else {
      if (start < from2)
        result.push(child.slice(0, from2 - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows$1) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods$1(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code2 = event.keyCode, mods = getMods$1(event);
  if (code2 == 8 || mac$2 && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code2 == 46 && !event.shiftKey || mac$2 && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37 || mac$2 && code2 == 66 && mods == "c") {
    let dir = code2 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 39 || mac$2 && code2 == 70 && mods == "c") {
    let dir = code2 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code2 == 38 || mac$2 && code2 == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code2 == 40 || mac$2 && code2 == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html2, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html2 && !text)
    return null;
  let asText = text && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html2 = f(html2, view);
    });
    dom = readHTML(html2);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html2) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html2;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s2) => s2 });
  return _policy.createHTML(html2);
}
function readHTML(html2) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas)
    html2 = html2.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html2 = wrap2.map((n2) => "<" + n2 + ">").join("") + html2 + wrap2.map((n2) => "</" + n2 + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html2);
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == " " && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array2;
  try {
    array2 = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array2.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array2[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array2[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html2, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html2, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText$1(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText$1(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode2)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a2, b) {
  if (a2 == b)
    return true;
  for (let p in a2)
    if (a2[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a2))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start = offset2 + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array2) {
  let result = [];
  for (let i = 0; i < array2.length; i++)
    if (array2[i] != null)
      result.push(array2[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a2, b) {
  return a2.from - b.from || a2.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array2, i, deco) {
  while (i < array2.length && byPos(deco, array2[i]) > 0)
    i++;
  array2.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n2) => n2.nodeName == "BR");
      if (brs.length == 2) {
        let [a2, b] = brs;
        if (a2.parentNode && a2.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a2.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared2 = $before.sharedDepth(to);
  from2 = $before.before(shared2 + 1);
  to = view.state.doc.resolve(to).after(shared2 + 1);
  let sel = view.state.selection;
  let parse2 = parseBetween(view, from2, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse2.from, parse2.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n2) => n2.nodeType == 1 && !isInline.test(n2.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse2.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse2.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse2.doc.resolveNoCache(change.start - parse2.from);
  let $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P")) || !inlineChange && $from.pos < parse2.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse2.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse2.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr2 = base2 || view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
    if (parse2.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse2.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    return tr2.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr2 = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      if (marks)
        tr2.ensureMarks(marks);
      view.dispatch(tr2);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr2 = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr2);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a2, b, pos, preferredPos, preferredSide) {
  let start = a2.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a2.findDiffEnd(b, pos + a2.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a2.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a2.size && isSurrogatePair(a2.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str2) {
  if (str2.length != 2)
    return false;
  let a2 = str2.charCodeAt(0), b = str2.charCodeAt(1);
  return a2 >= 56320 && a2 <= 57343 && b >= 55296 && b <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a2;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html2, event) {
    return doPaste(this, "", html2, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr2) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr2);
  else
    this.updateState(this.state.apply(tr2));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a2, b) {
  let nA = 0, nB = 0;
  for (let prop in a2) {
    if (a2[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift$3 = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift$3[i] = String.fromCharCode(i);
}
for (var code$1 in base) if (!shift$3.hasOwnProperty(code$1)) shift$3[code$1] = base[code$1];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift$3 : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName$1(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName$1(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
const deleteSelection$1 = (state, dispatch2) => {
  if (state.selection.empty)
    return false;
  if (dispatch2)
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$1 = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch2, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch2) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch2(tr2.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
const joinTextblockBackward$1 = (state, dispatch2, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
const joinTextblockForward$1 = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch2) : false;
};
function joinTextblocksAround(state, $cut, dispatch2) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch2) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$1 = (state, dispatch2, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch2) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2)
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state, dispatch2, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$1 = (state, dispatch2) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch2) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
const joinDown$1 = (state, dispatch2) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch2)
    dispatch2(state.tr.join(point).scrollIntoView());
  return true;
};
const lift$1 = (state, dispatch2) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch2)
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt$1(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$1 = (state, dispatch2) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$1(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch2) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state, dispatch2) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch2) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch2(tr2.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state, dispatch2) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch2)
        dispatch2(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch2)
    dispatch2(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch2) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch2)
        dispatch2(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt$1($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        types.unshift(atEnd && deflt ? { type: deflt } : null);
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr2 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr2.deleteSelection();
    let splitPos = tr2.mapping.map($from.pos);
    let can = canSplit(tr2.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr2.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr2.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
const splitBlock$1 = splitBlockAs();
const selectParentNode$1 = (state, dispatch2) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch2)
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch2) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch2)
      dispatch2(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch2)
    dispatch2(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch2, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch2))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch2) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch2)
      dispatch2(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at2 = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at2);
      if (at2.isTextblock)
        break;
      at2 = at2.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch2) {
        let end = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end = Fragment.from(wrap2[i].copy(end));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch2(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch2) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function wrapIn$1(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch2)
      dispatch2(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs = null) {
  return function(state, dispatch2) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch2) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch2(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch2, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch2, view))
        return true;
    return false;
  };
}
chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
({
  "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock$1)
});
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$1(listType, attrs = null) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch2 ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs))
      return false;
    if (dispatch2)
      dispatch2(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc2 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc2.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc2.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap2)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem$1(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch2)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch2, itemType, range);
    else
      return liftOutOfList(state, dispatch2, range);
  };
}
function liftToOuterList(state, dispatch2, itemType, range) {
  let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let $after = tr2.doc.resolve(tr2.mapping.map(end, -1) - 1);
  if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr2.join($after.pos);
  dispatch2(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch2, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch2(tr2.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state, dispatch2) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch2) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch2(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
function createChainableState(config) {
  const { state, transaction: transaction2 } = config;
  let { selection } = transaction2;
  let { doc: doc2 } = transaction2;
  let { storedMarks } = transaction2;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction2.selection;
      doc2 = transaction2.doc;
      storedMarks = transaction2.storedMarks;
      return transaction2;
    }
  };
}
class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr2);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr2, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain2;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch2 = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch2);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch2)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
}
class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction$1(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction$1(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a2;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a2 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a2 === void 0 ? void 0 : _a2.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
      linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a3;
        return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a3;
        return [extensionAttribute.name, { default: (_a3 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a3 === void 0 ? void 0 : _a3.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index2) => {
    var _a2, _b;
    const chunk = ((_b = (_a2 = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a2, {
      node,
      pos,
      parent,
      index: index2
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
class InputRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1$1(config) {
  var _a2;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a2 = $from.nodeBefore || $from.nodeAfter) === null || _a2 === void 0 ? void 0 : _a2.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands: commands2, chain: chain2, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain: chain2,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev, state) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr2.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run$1$1({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run$1$1({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
class Mark2 {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark2(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark2(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
}
function isNumber(value) {
  return typeof value === "number";
}
class PasteRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run$2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain: chain2, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain: chain2,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
let tiptapDragFromOtherEditor = null;
const createClipboardPasteEvent = (text) => {
  var _a2;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({ state, from: from2, to, rule, pasteEvt }) => {
    const tr2 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr2
    });
    const handler = run$2({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr2.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr2;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a2;
          dragSourceElement = ((_a2 = view.dom.parentElement) === null || _a2 === void 0 ? void 0 : _a2.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a2;
            const html2 = (_a2 = event.clipboardData) === null || _a2 === void 0 ? void 0 : _a2.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html2 === null || html2 === void 0 ? void 0 : html2.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction2 = transactions[0];
        const isPaste = transaction2.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction2.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction2.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment.from(text), state.schema);
          }
          const { from: from3 } = simulatedPasteMeta;
          const to2 = from3 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from3,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index2) => items.indexOf(el) !== index2);
  return Array.from(new Set(filtered));
}
class ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(extensions) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a2, b) => {
      const priorityA = getExtensionField(a2, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations, innerDecorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          // pass-through
          node,
          view,
          getPos,
          decorations,
          innerDecorations,
          // tiptap-specific
          editor,
          extension,
          HTMLAttributes
        });
      };
      return [extension.name, nodeview];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a2;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a2 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a2 !== void 0 ? _a2 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
}
class Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index2) => {
    var _a2;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index2,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a2 = node === null || node === void 0 ? void 0 : node.text) === null || _a2 === void 0 ? void 0 : _a2.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
const ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc2, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a2;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a2 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a2 === void 0 ? void 0 : _a2.removeAllRanges();
    }
  });
  return true;
};
const clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
const clearNodes = () => ({ state, tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr2;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const command = (fn) => (props) => {
  return fn(props);
};
const createParagraphNear = () => ({ state, dispatch: dispatch2 }) => {
  return createParagraphNear$1(state, dispatch2);
};
const cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
const deleteCurrentNode = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch2) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteRange = (range) => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { from: from2, to } = range;
  if (dispatch2) {
    tr2.delete(from2, to);
  }
  return true;
};
const deleteSelection = () => ({ state, dispatch: dispatch2 }) => {
  return deleteSelection$1(state, dispatch2);
};
const enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
const exitCode = () => ({ state, dispatch: dispatch2 }) => {
  return exitCode$1(state, dispatch2);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a2;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a2 = start.node.marks[0]) === null || _a2 === void 0 ? void 0 : _a2.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
const extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch2) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc2, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
const first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc2, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const focus$1 = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch2 && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch2) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
const forEach = (items, fn) => (props) => {
  return items.every((item, index2) => fn(item, { ...props, index: index2 }));
};
const insertContent = (value, options) => ({ tr: tr2, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
const removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html2 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html2);
}
function createNodeFromContent(content, schema, options) {
  if (content instanceof Node$2 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  const last2 = tr2.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr2.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last2];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
const isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
const insertContentAt = (position, value, options) => ({ tr: tr2, dispatch: dispatch2, editor }) => {
  var _a2;
  if (dispatch2) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
const joinUp = () => ({ state, dispatch: dispatch2 }) => {
  return joinUp$1(state, dispatch2);
};
const joinDown = () => ({ state, dispatch: dispatch2 }) => {
  return joinDown$1(state, dispatch2);
};
const joinBackward = () => ({ state, dispatch: dispatch2 }) => {
  return joinBackward$1(state, dispatch2);
};
const joinForward = () => ({ state, dispatch: dispatch2 }) => {
  return joinForward$1(state, dispatch2);
};
const joinItemBackward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
const joinItemForward = () => ({ state, dispatch: dispatch2, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch2) {
      dispatch2(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
const joinTextblockBackward = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockBackward$1(state, dispatch2);
};
const joinTextblockForward = () => ({ state, dispatch: dispatch2 }) => {
  return joinTextblockForward$1(state, dispatch2);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
const keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch: dispatch2 }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch2) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
const lift = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$1(state, dispatch2);
};
const liftEmptyBlock = () => ({ state, dispatch: dispatch2 }) => {
  return liftEmptyBlock$1(state, dispatch2);
};
const liftListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$1(type)(state, dispatch2);
};
const newlineInCode = () => ({ state, dispatch: dispatch2 }) => {
  return newlineInCode$1(state, dispatch2);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
const resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
const scrollIntoView = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    tr2.scrollIntoView();
  }
  return true;
};
const selectAll = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
const selectNodeBackward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeBackward$1(state, dispatch2);
};
const selectNodeForward = () => ({ state, dispatch: dispatch2 }) => {
  return selectNodeForward$1(state, dispatch2);
};
const selectParentNode = () => ({ state, dispatch: dispatch2 }) => {
  return selectParentNode$1(state, dispatch2);
};
const selectTextblockEnd = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockEnd$1(state, dispatch2);
};
const selectTextblockStart = () => ({ state, dispatch: dispatch2 }) => {
  return selectTextblockStart$1(state, dispatch2);
};
function createDocument(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
const setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr: tr2, dispatch: dispatch2, commands: commands2 }) => {
  var _a2, _b;
  const { doc: doc2 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a2 = options.errorOnInvalidContent) !== null && _a2 !== void 0 ? _a2 : editor.options.enableContentCheck
    });
    if (dispatch2) {
      tr2.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch2) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands2.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction2) => {
    transaction2.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getSchema(extensions, editor) {
  const resolvedExtensions = ExtensionManager.resolve(extensions);
  return getSchemaByResolvedExtensions(resolvedExtensions, editor);
}
function generateHTML(doc2, extensions) {
  const schema = getSchema(extensions);
  const contentNode = Node$2.fromJSON(schema, doc2);
  return getHTMLFromFragment(contentNode.content, schema);
}
function getText(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function generateText(doc2, extensions, options) {
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  const schema = getSchema(extensions);
  const contentNode = Node$2.fromJSON(schema, doc2);
  return getText(contentNode, {
    blockSeparator,
    textSerializers: {
      ...getTextSerializersFromSchema(schema),
      ...textSerializers
    }
  });
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array2, by = JSON.stringify) {
  const seen = {};
  return array2.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_, i) => i !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index2];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index2).map(from2, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from2, to, doc2) {
  const marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach((mark) => {
      const $pos = doc2.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc2.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(...node.marks.map((mark) => ({
        from: pos,
        to: pos + node.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a2;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a2 = node.text) !== null && _a2 !== void 0 ? _a2 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function canSetMark(state, tr2, newMarkType) {
  var _a2;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a2 = state.storedMarks) !== null && _a2 !== void 0 ? _a2 : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch2) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
const setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
const setNode = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2, chain: chain2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch2);
  }).run();
};
const setNodeSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const from2 = minMax(position, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from2);
    tr2.setSelection(selection);
  }
  return true;
};
const setTextSelection = (position) => ({ tr: tr2, dispatch: dispatch2 }) => {
  if (dispatch2) {
    const { doc: doc2 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
const sinkListItem = (typeOrName) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$1(type)(state, dispatch2);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  const { selection, doc: doc2 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch2) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
const splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch: dispatch2, editor }) => {
  var _a2;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch2) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a2 = type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start, tr2.doc.content.size, (n2, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n2.isTextblock && n2.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch2) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch2) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
const joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
const joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
const toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch: dispatch2, chain: chain2, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch2) {
      return chain2().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch2) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands2.setNode(toggleType, attributesToCopy);
  }
  return commands2.setNode(type, { ...attributesToCopy, ...attributes });
};
const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
const undoInputRule = () => ({ state, dispatch: dispatch2 }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
const unsetAllMarks = () => ({ tr: tr2, dispatch: dispatch2 }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch2) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
const unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  var _a2;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch2) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a2 = $from.marks().find((mark) => mark.type === type)) === null || _a2 === void 0 ? void 0 : _a2.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
const updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch: dispatch2 }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch2) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn$1(type, attributes)(state, dispatch2);
};
const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch: dispatch2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$1(type, attributes)(state, dispatch2);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange,
  deleteSelection,
  enter,
  exitCode,
  extendMarkRange,
  first,
  focus: focus$1,
  forEach,
  insertContent,
  insertContentAt,
  joinBackward,
  joinDown,
  joinForward,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward,
  joinTextblockForward,
  joinUp,
  keyboardShortcut,
  lift,
  liftEmptyBlock,
  liftListItem,
  newlineInCode,
  resetAttributes,
  scrollIntoView,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectParentNode,
  selectTextblockEnd,
  selectTextblockStart,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem,
  splitBlock,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn,
  wrapInList
});
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
const Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
const Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
const focusEventsPluginKey = new PluginKey("focusEvents");
const FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction2 = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction2 = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction2);
              return false;
            }
          }
        }
      })
    ];
  }
});
const Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr: tr2 }) => {
        const { selection, doc: doc2 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr3) => tr3.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction2) => transaction2.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
const Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
const Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
class NodePos {
  get name() {
    return this.node.type.name;
  }
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a2;
    return (_a2 = this.actualDepth) !== null && _a2 !== void 0 ? _a2 : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset2) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset2 + (isNonTextAtom ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index2 = 0; index2 < attrKeys.length; index2 += 1) {
            const key = attrKeys[index2];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr2 } = this.editor.state;
    tr2.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr2);
  }
}
const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
class Editor2 extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction$1(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a2, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a2 = this.options.coreExtensionOptions) === null || _a2 === void 0 ? void 0 : _a2.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var _a2;
    let doc2;
    try {
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if (this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const selection = resolveFocusPosition(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a2 = this.options.editorProps) === null || _a2 === void 0 ? void 0 : _a2.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc2,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction2) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction2;
        return;
      }
      transaction2.steps.forEach((step) => {
        var _a2;
        return (_a2 = this.capturedTransaction) === null || _a2 === void 0 ? void 0 : _a2.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction2);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: transaction2,
      nextState: state
    });
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction: transaction2
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction: transaction2
      });
    }
    const focus2 = transaction2.getMeta("focus");
    const blur2 = transaction2.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction: transaction2
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction: transaction2
      });
    }
    if (!transaction2.docChanged || transaction2.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction: transaction2
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      const dom = this.view.dom;
      if (dom && dom.editor) {
        delete dom.editor;
      }
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a2;
    return !((_a2 = this.view) === null || _a2 === void 0 ? void 0 : _a2.docView);
  }
  $node(selector, attributes) {
    var _a2;
    return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a2;
    return ((_a2 = this.$doc) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
}
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start = range.from;
      let end = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset2;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start + match[0].length - 1);
        tr2.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain: chain2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain2().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
let Node$1 = class Node3 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node3(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node3(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function getFontsFromRichText(editor, richText, initialState2) {
  const { tipTapConfig, addFontsFromNode } = editor.getTextOptions();
  assert(tipTapConfig, "textOptions.tipTapConfig must be set to use rich text");
  assert(addFontsFromNode, "textOptions.addFontsFromNode must be set to use rich text");
  const schema = getSchema(tipTapConfig.extensions ?? []);
  const rootNode = Node$2.fromJSON(schema, richText);
  const fonts = /* @__PURE__ */ new Set();
  function addFont(font) {
    fonts.add(font);
  }
  function visit(node, state) {
    state = addFontsFromNode(node, state, addFont);
    for (const child of node.children) {
      visit(child, state);
    }
  }
  visit(rootNode, initialState2);
  return Array.from(fonts);
}
async function hardReset({ shouldReload = true } = {}) {
  clearSessionStorage();
  for (const instance of LocalIndexedDb.connectedInstances) {
    await instance.close();
  }
  await Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)));
  clearLocalStorage();
  if (shouldReload) {
    window.location.reload();
  }
}
if (typeof window !== "undefined") {
  window.__tldraw__hardReset = hardReset;
}
function openWindow(url, target = "_blank") {
  runtime.openWindow(url, target);
}
registerTldrawLibraryVersion(
  "@tldraw/editor",
  "3.13.1",
  "esm"
);
function usePrefersReducedMotion() {
  const [prefersReducedMotion, setPrefersReducedMotion] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (typeof window === "undefined" || !("matchMedia" in window)) return;
    const mql = window.matchMedia("(prefers-reduced-motion: reduce)");
    const handler = () => {
      setPrefersReducedMotion(mql.matches);
    };
    handler();
    mql.addEventListener("change", handler);
    return () => mql.removeEventListener("change", handler);
  }, []);
  return prefersReducedMotion;
}
const A11yContext = reactExports.createContext(null);
function TldrawUiA11yProvider({ children }) {
  const currentMsg = useAtom("a11y", { msg: "", priority: "assertive" });
  const ctx = reactExports.useContext(A11yContext);
  const current = reactExports.useMemo(
    () => ({
      currentMsg,
      announce(msg2) {
        if (!msg2) return;
        currentMsg.set(msg2);
      }
    }),
    [currentMsg]
  );
  if (ctx) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A11yContext.Provider, { value: current, children });
}
function useA11y() {
  const ctx = reactExports.useContext(A11yContext);
  if (!ctx) {
    throw new Error("useA11y must be used within a A11yContext.Provider");
  }
  return ctx;
}
const AssetUrlsContext = reactExports.createContext(null);
function AssetUrlsProvider({
  assetUrls,
  children
}) {
  reactExports.useEffect(() => {
    for (const src of Object.values(assetUrls.icons)) {
      if (!src) continue;
      const image = Image();
      image.src = src;
      image.decode();
    }
    for (const src of Object.values(assetUrls.embedIcons)) {
      if (!src) continue;
      const image = Image();
      image.src = src;
      image.decode();
    }
  }, [assetUrls]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AssetUrlsContext.Provider, { value: assetUrls, children });
}
function useAssetUrls() {
  const assetUrls = reactExports.useContext(AssetUrlsContext);
  if (!assetUrls) {
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  }
  return assetUrls;
}
const DEFAULT_TRANSLATION = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle Select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.files.amount-too-many": "Too many files",
  "assets.url.failed": "Couldn’t load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.cloud": "Cloud",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.heart": "Heart",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "arrow-kind-style.arc": "Arc",
  "arrow-kind-style.elbow": "Elbow",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.heart": "Heart",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.media": "Media",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "tool.pointer-down": "Pointer down",
  "tool.rich-text-bold": "Bold",
  "tool.rich-text-italic": "Italic",
  "tool.rich-text-code": "Code",
  "tool.rich-text-highlight": "Highlight",
  "tool.rich-text-strikethrough": "Strikethrough",
  "tool.rich-text-link": "Link",
  "tool.rich-text-link-visit": "Visit link",
  "tool.rich-text-link-remove": "Remove link",
  "tool.rich-text-header": "Header",
  "tool.rich-text-bulletList": "Bulleted list",
  "tool.rich-text-toolbar-title": "Text formatting",
  "tool.rich-text-orderedList": "Ordered list",
  "tool.bookmark": "Bookmark",
  "a11y.status": "Status",
  "a11y.skip-to-main-content": "Move focus to canvas",
  "a11y.shape-index": "{num} of {total}",
  "a11y.shape-image": "Image",
  "a11y.shape-video": "Video",
  "a11y.multiple-shapes": "{num} shapes selected",
  "a11y.select-shape": "Select next shape",
  "a11y.select-shape-direction": "Select shape in direction",
  "a11y.enter-leave-container": "Enter/leave container",
  "a11y.repeat-shape": "Repeat shape",
  "a11y.move-shape": "Move shape",
  "a11y.move-shape-faster": "Move shape faster",
  "a11y.enlarge-shape": "Enlarge shape",
  "a11y.shrink-shape": "Shrink shape",
  "a11y.pan-camera": "Pan camera",
  "a11y.adjust-shape-styles": "Adjust shape styles",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "context-menu.title": "Context menu",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project can’t be shared because it’s too large. We’re working on it!",
  "share-menu.upload-failed": "Sorry, we couldn’t upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project…",
  "share-menu.copied": "Copied link",
  "document-name-menu.copy-link": "Copy link",
  "status.offline": "Offline",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.avatar-color": "Avatar color",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following You",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "people-menu.anonymous-user": "New user",
  "help-menu.import-tldr-file": "Import file…",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About tldraw",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "help-menu.terms": "Terms of service",
  "help-menu.privacy": "Privacy policy",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "edit-link-dialog.external-link": "External link",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site’s URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "shortcuts-dialog.a11y": "Accessibility",
  "shortcuts-dialog.text-formatting": "Text formatting",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.label-align": "Label align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.arrow-kind": "Line",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "tool-panel.title": "Tools",
  "tool-panel.more": "More",
  "navigation-zone.title": "Navigation",
  "navigation-zone.minimap": "Minimap",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "toast.success": "Success",
  "toast.error": "Error",
  "toast.info": "Info",
  "toast.warning": "Warning",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn’t look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don’t ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Don’t ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Don’t ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We’ve updated this document to work with the current version of tldraw. If you’d like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don’t ask again",
  "cursor-chat.type-to-chat": "Type to chat…",
  "app.loading": "Loading tldraw…",
  "handle.resize-top": "Resize top",
  "handle.resize-bottom": "Resize bottom",
  "handle.resize-left": "Resize left",
  "handle.resize-right": "Resize right",
  "handle.resize-top-left": "Resize top left",
  "handle.resize-top-right": "Resize top right",
  "handle.resize-bottom-left": "Resize bottom left",
  "handle.resize-bottom-right": "Resize bottom right",
  "handle.rotate.top_left_rotate": "Rotate top left",
  "handle.rotate.top_right_rotate": "Rotate top right",
  "handle.rotate.bottom_left_rotate": "Rotate bottom left",
  "handle.rotate.bottom_right_rotate": "Rotate bottom right",
  "handle.rotate.mobile_rotate": "Rotate",
  "handle.crop.top": "Crop top",
  "handle.crop.bottom": "Crop bottom",
  "handle.crop.left": "Crop left",
  "handle.crop.right": "Crop right",
  "handle.crop.top-left": "Crop top left",
  "handle.crop.top-right": "Crop top right",
  "handle.crop.bottom-left": "Crop bottom left",
  "handle.crop.bottom-right": "Crop bottom right",
  "ui.close": "Close",
  "ui.checked": "Checked",
  "ui.unchecked": "Unchecked"
};
const RTL_LANGUAGES = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]);
const EN_TRANSLATION = {
  locale: "en",
  label: "English",
  messages: DEFAULT_TRANSLATION,
  dir: "ltr"
};
async function fetchTranslation(locale, assetUrls) {
  const mainRes = await fetch$1(assetUrls.translations.en);
  if (!mainRes.ok) {
    console.warn(`No main translations found.`);
    return EN_TRANSLATION;
  }
  if (locale === "en") {
    return EN_TRANSLATION;
  }
  const language = LANGUAGES.find((t2) => t2.locale === locale);
  if (!language) {
    console.warn(`No translation found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  const res = await fetch$1(assetUrls.translations[language.locale]);
  const messages = await res.json();
  if (!messages) {
    console.warn(`No messages found for locale ${locale}`);
    return EN_TRANSLATION;
  }
  for (const key in EN_TRANSLATION.messages) {
    if (!messages[key]) ;
  }
  return {
    locale,
    label: language.label,
    dir: RTL_LANGUAGES.has(language.locale) ? "rtl" : "ltr",
    messages: { ...EN_TRANSLATION.messages, ...messages }
  };
}
const TranslationsContext = reactExports.createContext(null);
function useCurrentTranslation() {
  const translations = reactExports.useContext(TranslationsContext);
  if (!translations) {
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  }
  return translations;
}
function TldrawUiTranslationProvider({
  overrides,
  locale,
  children
}) {
  const getAssetUrl = useAssetUrls();
  const [currentTranslation, setCurrentTranslation] = reactExports.useState(() => {
    if (overrides && overrides["en"]) {
      return {
        locale: "en",
        label: "English",
        dir: "ltr",
        messages: { ...DEFAULT_TRANSLATION, ...overrides["en"] }
      };
    }
    return {
      locale: "en",
      label: "English",
      dir: "ltr",
      messages: DEFAULT_TRANSLATION
    };
  });
  reactExports.useEffect(() => {
    let isCancelled = false;
    async function loadTranslation() {
      const translation = await fetchTranslation(locale, getAssetUrl);
      if (translation && !isCancelled) {
        if (overrides && overrides[locale]) {
          setCurrentTranslation({
            ...translation,
            messages: { ...translation.messages, ...overrides[locale] }
          });
        } else {
          setCurrentTranslation(translation);
        }
      }
    }
    loadTranslation();
    return () => {
      isCancelled = true;
    };
  }, [getAssetUrl, locale, overrides]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TranslationsContext.Provider, { value: currentTranslation, children });
}
function useTranslation() {
  const translation = useCurrentTranslation();
  return reactExports.useCallback(
    function msg2(id) {
      return translation.messages[id] ?? id;
    },
    [translation]
  );
}
function untranslated(string2) {
  return string2;
}
const TldrawUiButton = reactExports.forwardRef(
  function TldrawUiButton2({ children, type, isActive: isActive2, ...props }, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        ref,
        type: "button",
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        className: classNames("tlui-button", `tlui-button__${type}`, props.className),
        children
      }
    );
  }
);
function SkipToMainContent() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const button = reactExports.useRef(null);
  const handleNavigateToFirstShape = reactExports.useCallback(
    (e) => {
      stopEventPropagation(e);
      button.current?.blur();
      const shapes = editor.getCurrentPageShapesInReadingOrder();
      if (!shapes.length) return;
      editor.setSelectedShapes([shapes[0].id]);
      editor.zoomToSelectionIfOffscreen(256, {
        animation: {
          duration: editor.options.animationMediumMs
        },
        inset: 0
      });
      editor.timers.setTimeout(() => editor.getContainer().focus(), 100);
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiButton,
    {
      ref: button,
      type: "low",
      tabIndex: 0,
      className: "tl-skip-to-main-content",
      onClick: handleNavigateToFirstShape,
      children: msg2("a11y.skip-to-main-content")
    }
  );
}
const DefaultA11yAnnouncer = reactExports.memo(function TldrawUiA11yAnnouncer() {
  const a11y = useA11y();
  const translation = useTranslation();
  const msg2 = useValue("a11y-msg", () => a11y.currentMsg.get(), []);
  useA11yDebug(msg2.msg);
  useSelectedShapesAnnouncer();
  return msg2.msg && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "aria-label": translation("a11y.status"),
      "aria-live": msg2.priority || "assertive",
      role: "status",
      "aria-hidden": "false",
      style: {
        position: "absolute",
        top: "-10000px",
        left: "-10000px"
      },
      children: msg2.msg
    }
  );
});
function generateShapeAnnouncementMessage(args) {
  const { editor, selectedShapeIds, msg: msg2 } = args;
  let a11yLive = "";
  const numShapes = selectedShapeIds.length;
  if (numShapes > 1) {
    a11yLive = msg2("a11y.multiple-shapes").replace("{num}", numShapes.toString());
  } else if (numShapes === 1) {
    const shapeId = selectedShapeIds[0];
    const shape = editor.getShape(shapeId);
    if (!shape) return "";
    const shapeUtil = editor.getShapeUtil(shape.type);
    const isMedia = ["image", "video"].includes(shape.type);
    let shapeType = "";
    if (shape.type === "geo") {
      shapeType = msg2(`geo-style.${shape.props.geo}`);
    } else if (isMedia) {
      shapeType = msg2(`a11y.shape-${shape.type}`);
    } else {
      shapeType = msg2(`tool.${shape.type}`);
    }
    const readingOrderShapes = editor.getCurrentPageShapesInReadingOrder();
    const currentShapeIndex = (readingOrderShapes.findIndex((s2) => s2.id === shapeId) + 1).toString();
    const totalShapes = readingOrderShapes.length.toString();
    const shapeIndex = msg2("a11y.shape-index").replace("{num}", currentShapeIndex).replace("{total}", totalShapes);
    const describingText = shapeUtil.getAriaDescriptor(shape) || shapeUtil.getText(shape) || "";
    a11yLive = (describingText ? `${describingText}, ` : "") + `${shapeType}. ${shapeIndex}`;
  }
  return a11yLive;
}
const useSelectedShapesAnnouncer = () => {
  const editor = useMaybeEditor();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const rPrevSelectedShapeIds = reactExports.useRef([]);
  useReactor(
    "announce selection",
    () => {
      if (!editor) return;
      const isInSelecting = editor.isIn("select.idle");
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (isInSelecting && selectedShapeIds !== rPrevSelectedShapeIds.current) {
        rPrevSelectedShapeIds.current = selectedShapeIds;
        unsafe__withoutCapture(() => {
          const a11yLive = generateShapeAnnouncementMessage({
            editor,
            selectedShapeIds,
            msg: msg2
          });
          if (a11yLive) {
            a11y.announce({ msg: a11yLive });
          }
        });
      }
    },
    [editor, a11y, msg2]
  );
};
const useA11yDebug = (msg2) => {
  const container = useContainer();
  reactExports.useEffect(() => {
    if (debugFlags.a11y.get()) {
      const log = (msg22) => {
        console.debug(
          `%ca11y%c: ${msg22}`,
          `color: white; background: #40C057; padding: 2px;border-radius: 3px;`,
          "font-weight: normal"
        );
      };
      const handleKeyUp = (e) => {
        const el = document.activeElement;
        if (e.key === "Tab" && el && el !== document.body && !el.classList.contains("tl-container")) {
          const label = el.getAttribute("aria-label") || el.getAttribute("title") || el.textContent;
          if (label) {
            log(label);
          }
        }
      };
      if (msg2) {
        log(msg2);
      }
      document.addEventListener("keyup", handleKeyUp);
      return () => document.removeEventListener("keyup", handleKeyUp);
    }
  }, [container, msg2]);
};
const defaultEventHandler = () => void 0;
const EventsContext = reactExports.createContext(null);
function TldrawUiEventsProvider({ onEvent, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EventsContext.Provider, { value: onEvent ?? defaultEventHandler, children });
}
function useUiEvents() {
  const eventHandler2 = reactExports.useContext(EventsContext);
  return eventHandler2 ?? defaultEventHandler;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node4 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node4.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node4 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME$3 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$3;
function createContext2(rootComponentName, defaultContext) {
  const Context2 = reactExports.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context2);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = /* @__PURE__ */ createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = /* @__PURE__ */ createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
var useLayoutEffect2 = globalThis?.document ? reactExports.useLayoutEffect : () => {
};
var useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from2 = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from2} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
function useStateMachine(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode2] = reactExports.useState();
  const stylesRef = reactExports.useRef(null);
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode2(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var useReactId = React$1[" useId ".trim().toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown2, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode2] = reactExports.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$5 = DismissableLayer;
var Branch$1 = DismissableLayerBranch;
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$3(removeLinks(getTabbableCandidates$1(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown2 = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first2, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first2 && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop) focus(first2, { select: true });
          } else if (event.shiftKey && focusedElement === first2) {
            event.preventDefault();
            if (loop) focus(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown2 });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$3(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates$1(container);
  const first2 = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first2, last2];
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack2 = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack2[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack2 = arrayRemove(stack2, focusScope);
      stack2.unshift(focusScope);
    },
    remove(focusScope) {
      stack2 = arrayRemove(stack2, focusScope);
      stack2[0]?.resume();
    }
  };
}
function arrayRemove(array2, item) {
  const updatedArray = [...array2];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var PORTAL_NAME$5 = "Portal";
var Portal$3 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$5;
var count = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    return () => {
      if (count === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t2[p] = s2[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
    t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x) {
          return x !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x) {
          return cb(x);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x) {
          pendingQueue.push(x);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$1 = function(x) {
  return parseInt(x || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left), parse$1(top), parse$1(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b = _a2.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x, y2) {
  return x[0] === y2[0] && x[1] === y2[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e) {
      return e.name === event.type && (e.target === event.target || event.target === e.shadowParent) && deltaCompare(e.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e) {
        return e !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst2) {
        return inst2 !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode2, markerName, controlAttribute) {
  var targets = correctTargets(parentNode2, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode2);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode2, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger";
var DialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$1(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$4 = "DialogPortal";
var [PortalProvider$2, usePortalContext$2] = createDialogContext(PORTAL_NAME$4, {
  forceMount: void 0
});
var DialogPortal = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$4, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal.displayName = PORTAL_NAME$4;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay.displayName = OVERLAY_NAME;
var Slot$2 = /* @__PURE__ */ createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$2, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$1(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$5 = "DialogContent";
var DialogContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$5, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$5, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent.displayName = CONTENT_NAME$5;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$5, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$5, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$5, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$1(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$1 = "DialogTitle";
var DialogTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "DialogDescription";
var DialogDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription.displayName = DESCRIPTION_NAME$1;
var CLOSE_NAME$2 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$2, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$2;
function getState$1(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$5,
  titleName: TITLE_NAME$1,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$4 = Dialog;
var Portal$2 = DialogPortal;
var Overlay = DialogOverlay;
var Content$1 = DialogContent;
var Title$1 = DialogTitle;
function usePrevious(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry2 = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry2) {
          const borderSizeEntry = entry2["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
const sides = ["top", "right", "bottom", "left"];
const min$1 = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min$1(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$4 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min$1(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min$1(paddingObject[maxProp], largestPossiblePadding);
    const min$1$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1$1 ? center - min$1$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min$1(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min$1(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect2.top + element.clientTop;
  const left = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle$1(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult2 = cache.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a2, b) {
  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min$1(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$3 = arrow$4;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop$1 = function noop() {
};
var index = isClient ? reactExports.useLayoutEffect : noop$1;
function deepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (typeof a2 !== typeof b) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys2;
  if (a2 && b && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a2[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys2[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys2[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$3({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$3({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow$2 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$2 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$2;
var Root$3 = Arrow$1;
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$2 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$2, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$2;
var CONTENT_NAME$4 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$4);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$4, __scopePopper);
    const [content, setContent2] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent2(node));
    const [arrow2, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow2);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow2 && arrow$2({ element: arrow2, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$4;
var ARROW_NAME$4 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$4, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$3,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$4;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper;
var Anchor = PopperAnchor;
var Content2 = PopperContent;
var Arrow = PopperArrow;
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$3,
  [createCollectionScope$3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME$3
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems = useCollection$3(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$4 = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$4, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = useCollection$3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$1(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$4;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array2, startIndex) {
  return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
}
var Root$2 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope$2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$1 = createPopperScope();
var useRovingFocusGroupScope$2 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$1(__scopeMenu);
  const [content, setContent2] = reactExports.useState(null);
  const isUsingKeyboardRef = reactExports.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  reactExports.useEffect(() => {
    const handleKeyDown2 = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown2, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: reactExports.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME$1 = "MenuAnchor";
var MenuAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$1(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME$1;
var PORTAL_NAME$3 = "MenuPortal";
var [PortalProvider$1, usePortalContext$1] = createMenuContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME$3, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$1, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$3;
var CONTENT_NAME$3 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$3);
var MenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME$3, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$3, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$3, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = reactExports.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$3, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot$1 = /* @__PURE__ */ createSlot("MenuContent.ScrollLock");
var MenuContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME$3, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$3, __scopeMenu);
    const popperScope = usePopperScope$1(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const getItems = useCollection$2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = reactExports.useState(null);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = reactExports.useRef(0);
    const searchRef = reactExports.useRef("");
    const pointerGraceTimerRef = reactExports.useRef(0);
    const pointerGraceIntentRef = reactExports.useRef(null);
    const pointerDirRef = reactExports.useRef("right");
    const lastPointerXRef = reactExports.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : reactExports.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot$1, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      const search = searchRef.current + key;
      const items = getItems().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    reactExports.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) return;
            contentRef.current?.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: reactExports.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              event.preventDefault();
              contentRef.current?.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$2,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst$1(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$3;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$3 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = reactExports.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$3, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$3, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = reactExports.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          props.onPointerDown?.(event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          if (!isPointerDownRef.current) event.currentTarget?.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$3;
var MenuItemImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$3, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$2(__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const [textContent, setTextContent] = reactExports.useState("");
    reactExports.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$2 = "MenuCheckboxItem";
var MenuCheckboxItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$2;
var RADIO_GROUP_NAME$2 = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME$2,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$2;
var RADIO_ITEM_NAME$2 = "MenuRadioItem";
var MenuRadioItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME$2, props.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => context.onValueChange?.(value),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$2;
var ITEM_INDICATOR_NAME = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME,
  { checked: false }
);
var MenuItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SEPARATOR_NAME$3 = "MenuSeparator";
var MenuSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$3;
var ARROW_NAME$3 = "MenuArrow";
var MenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME$1 = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME$1);
var MenuSub = (props) => {
  const { __scopeMenu, children, open = false, onOpenChange } = props;
  const parentMenuContext = useMenuContext(SUB_NAME$1, __scopeMenu);
  const popperScope = usePopperScope$1(__scopeMenu);
  const [trigger2, setTrigger] = reactExports.useState(null);
  const [content, setContent2] = reactExports.useState(null);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  reactExports.useEffect(() => {
    if (parentMenuContext.open === false) handleOpenChange(false);
    return () => handleOpenChange(false);
  }, [parentMenuContext.open, handleOpenChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuSubProvider,
        {
          scope: __scopeMenu,
          contentId: useId(),
          triggerId: useId(),
          trigger: trigger2,
          onTriggerChange: setTrigger,
          children
        }
      )
    }
  ) });
};
MenuSub.displayName = SUB_NAME$1;
var SUB_TRIGGER_NAME$2 = "MenuSubTrigger";
var MenuSubTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$2, props.__scopeMenu);
    const openTimerRef = reactExports.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = reactExports.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    reactExports.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    reactExports.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          props.onClick?.(event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            clearOpenTimer();
            const contentRect = context.content?.getBoundingClientRect();
            if (contentRect) {
              const side = context.content?.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            context.content?.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$2;
var SUB_CONTENT_NAME$2 = "MenuSubContent";
var MenuSubContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$3, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME$3, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$3, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$2, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            subContext.trigger?.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$2;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$1(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray(array2, startIndex) {
  return array2.map((_, index2) => array2[(startIndex + index2) % array2.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon(point, polygon) {
  const { x, y: y2 } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y2 !== yj > y2 && x < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3 = Menu;
var Anchor2 = MenuAnchor;
var Portal$1 = MenuPortal;
var Content2$3 = MenuContent;
var Group = MenuGroup;
var Label = MenuLabel;
var Item2$3 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator = MenuItemIndicator;
var Separator$1 = MenuSeparator;
var Arrow2 = MenuArrow;
var Sub = MenuSub;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var CONTEXT_MENU_NAME = "ContextMenu";
var [createContextMenuContext, createContextMenuScope] = createContextScope(CONTEXT_MENU_NAME, [
  createMenuScope
]);
var useMenuScope$1 = createMenuScope();
var [ContextMenuProvider, useContextMenuContext] = createContextMenuContext(CONTEXT_MENU_NAME);
var ContextMenu = (props) => {
  const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
  const [open, setOpen] = reactExports.useState(false);
  const menuScope = useMenuScope$1(__scopeContextMenu);
  const handleOpenChangeProp = useCallbackRef$1(onOpenChange);
  const handleOpenChange = reactExports.useCallback(
    (open2) => {
      setOpen(open2);
      handleOpenChangeProp(open2);
    },
    [handleOpenChangeProp]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ContextMenuProvider,
    {
      scope: __scopeContextMenu,
      open,
      onOpenChange: handleOpenChange,
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Root3,
        {
          ...menuScope,
          dir,
          open,
          onOpenChange: handleOpenChange,
          modal,
          children
        }
      )
    }
  );
};
ContextMenu.displayName = CONTEXT_MENU_NAME;
var TRIGGER_NAME$2 = "ContextMenuTrigger";
var ContextMenuTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, disabled = false, ...triggerProps } = props;
    const context = useContextMenuContext(TRIGGER_NAME$2, __scopeContextMenu);
    const menuScope = useMenuScope$1(__scopeContextMenu);
    const pointRef = reactExports.useRef({ x: 0, y: 0 });
    const virtualRef = reactExports.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...pointRef.current })
    });
    const longPressTimerRef = reactExports.useRef(0);
    const clearLongPress = reactExports.useCallback(
      () => window.clearTimeout(longPressTimerRef.current),
      []
    );
    const handleOpen = (event) => {
      pointRef.current = { x: event.clientX, y: event.clientY };
      context.onOpenChange(true);
    };
    reactExports.useEffect(() => clearLongPress, [clearLongPress]);
    reactExports.useEffect(() => void (disabled && clearLongPress()), [disabled, clearLongPress]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { ...menuScope, virtualRef }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.span,
        {
          "data-state": context.open ? "open" : "closed",
          "data-disabled": disabled ? "" : void 0,
          ...triggerProps,
          ref: forwardedRef,
          style: { WebkitTouchCallout: "none", ...props.style },
          onContextMenu: disabled ? props.onContextMenu : composeEventHandlers(props.onContextMenu, (event) => {
            clearLongPress();
            handleOpen(event);
            event.preventDefault();
          }),
          onPointerDown: disabled ? props.onPointerDown : composeEventHandlers(
            props.onPointerDown,
            whenTouchOrPen((event) => {
              clearLongPress();
              longPressTimerRef.current = window.setTimeout(() => handleOpen(event), 700);
            })
          ),
          onPointerMove: disabled ? props.onPointerMove : composeEventHandlers(props.onPointerMove, whenTouchOrPen(clearLongPress)),
          onPointerCancel: disabled ? props.onPointerCancel : composeEventHandlers(props.onPointerCancel, whenTouchOrPen(clearLongPress)),
          onPointerUp: disabled ? props.onPointerUp : composeEventHandlers(props.onPointerUp, whenTouchOrPen(clearLongPress))
        }
      )
    ] });
  }
);
ContextMenuTrigger.displayName = TRIGGER_NAME$2;
var PORTAL_NAME$2 = "ContextMenuPortal";
var ContextMenuPortal = (props) => {
  const { __scopeContextMenu, ...portalProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { ...menuScope, ...portalProps });
};
ContextMenuPortal.displayName = PORTAL_NAME$2;
var CONTENT_NAME$2 = "ContextMenuContent";
var ContextMenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...contentProps } = props;
    const context = useContextMenuContext(CONTENT_NAME$2, __scopeContextMenu);
    const menuScope = useMenuScope$1(__scopeContextMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$3,
      {
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented && hasInteractedOutsideRef.current) {
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented && !context.modal) hasInteractedOutsideRef.current = true;
        },
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
ContextMenuContent.displayName = CONTENT_NAME$2;
var GROUP_NAME$1 = "ContextMenuGroup";
var ContextMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...groupProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
ContextMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "ContextMenuLabel";
var ContextMenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...labelProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
ContextMenuLabel.displayName = LABEL_NAME$1;
var ITEM_NAME$2 = "ContextMenuItem";
var ContextMenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...itemProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$3, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
ContextMenuItem.displayName = ITEM_NAME$2;
var CHECKBOX_ITEM_NAME$1 = "ContextMenuCheckboxItem";
var ContextMenuCheckboxItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
ContextMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$1 = "ContextMenuRadioGroup";
var ContextMenuRadioGroup = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
ContextMenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME$1 = "ContextMenuRadioItem";
var ContextMenuRadioItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
ContextMenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var INDICATOR_NAME$1 = "ContextMenuItemIndicator";
var ContextMenuItemIndicator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
ContextMenuItemIndicator.displayName = INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "ContextMenuSeparator";
var ContextMenuSeparator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...separatorProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$1, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
ContextMenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$2 = "ContextMenuArrow";
var ContextMenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeContextMenu, ...arrowProps } = props;
    const menuScope = useMenuScope$1(__scopeContextMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
ContextMenuArrow.displayName = ARROW_NAME$2;
var SUB_NAME = "ContextMenuSub";
var ContextMenuSub = (props) => {
  const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SUB_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
ContextMenuSub.displayName = SUB_NAME;
var SUB_TRIGGER_NAME$1 = "ContextMenuSubTrigger";
var ContextMenuSubTrigger = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...triggerItemProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...triggerItemProps, ref: forwardedRef });
});
ContextMenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "ContextMenuSubContent";
var ContextMenuSubContent = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeContextMenu, ...subContentProps } = props;
  const menuScope = useMenuScope$1(__scopeContextMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
ContextMenuSubContent.displayName = SUB_CONTENT_NAME$1;
function whenTouchOrPen(handler) {
  return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
}
var Root2$4 = ContextMenu;
var Trigger$2 = ContextMenuTrigger;
var Portal2$1 = ContextMenuPortal;
var Content2$2 = ContextMenuContent;
var Item2$2 = ContextMenuItem;
var CheckboxItem2$1 = ContextMenuCheckboxItem;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$1 = "DropdownMenuTrigger";
var DropdownMenuTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME$1, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger.displayName = TRIGGER_NAME$1;
var PORTAL_NAME$1 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "DropdownMenuContent";
var DropdownMenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME$1, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$3,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent.displayName = CONTENT_NAME$1;
var GROUP_NAME = "DropdownMenuGroup";
var DropdownMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME;
var LABEL_NAME = "DropdownMenuLabel";
var DropdownMenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel.displayName = LABEL_NAME;
var ITEM_NAME$1 = "DropdownMenuItem";
var DropdownMenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$3, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem.displayName = ITEM_NAME$1;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$1, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$1 = "DropdownMenuArrow";
var DropdownMenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME$1;
var DropdownMenuSub = (props) => {
  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub, { ...menuScope, open, onOpenChange: setOpen, children });
};
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent.displayName = SUB_CONTENT_NAME;
var Root2$3 = DropdownMenu;
var Trigger$1 = DropdownMenuTrigger;
var Portal2 = DropdownMenuPortal;
var Content2$1 = DropdownMenuContent;
var Item2$1 = DropdownMenuItem;
var CheckboxItem2 = DropdownMenuCheckboxItem;
var Sub2 = DropdownMenuSub;
var SubTrigger2 = DropdownMenuSubTrigger;
var SubContent2 = DropdownMenuSubContent;
function clamp(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
var POPOVER_NAME = "Popover";
var [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: POPOVER_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME = "PopoverTrigger";
var PopoverTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger2 = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger2 : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger2 });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "PopoverContent";
var PopoverContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME;
var Slot = /* @__PURE__ */ createSlot("PopoverContent.RemoveScroll");
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current) context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content2,
              {
                "data-state": getState(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME$1 = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME$1, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME$1;
var ARROW_NAME = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var Root2$2 = Popover;
var Trigger = PopoverTrigger;
var Portal = PopoverPortal;
var Content22 = PopoverContent;
var NAME$1 = "Separator";
var DEFAULT_ORIENTATION = "horizontal";
var ORIENTATIONS = ["horizontal", "vertical"];
var Separator = reactExports.forwardRef((props, forwardedRef) => {
  const { decorative, orientation: orientationProp = DEFAULT_ORIENTATION, ...domProps } = props;
  const orientation = isValidOrientation(orientationProp) ? orientationProp : DEFAULT_ORIENTATION;
  const ariaOrientation = orientation === "vertical" ? orientation : void 0;
  const semanticProps = decorative ? { role: "none" } : { "aria-orientation": ariaOrientation, role: "separator" };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-orientation": orientation,
      ...semanticProps,
      ...domProps,
      ref: forwardedRef
    }
  );
});
Separator.displayName = NAME$1;
function isValidOrientation(orientation) {
  return ORIENTATIONS.includes(orientation);
}
var Root$1 = Separator;
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
  createCollectionScope$1
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min2 = 0,
      max: max2 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min2],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = reactExports.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = reactExports.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        const thumbs = [...thumbRefs.current];
        thumbs[valueIndexToChangeRef.current]?.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = reactExports.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount);
      const nextValue = clamp(snapToStep, [min2, max2]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min2,
        max: max2,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values;
            }),
            min: min2,
            max: max2,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min2, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max2, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = reactExports.useRef(void 0);
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min2, max2] : [max2, min2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = reactExports.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = reactExports.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max2, min2] : [min2, max2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection$1(props.__scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index2 = reactExports.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
  }
);
var SliderThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index2, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size2 = useSize(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size2?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    reactExports.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            }
          ) }),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SliderBubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME;
var BUBBLE_INPUT_NAME = "RadioBubbleInput";
var SliderBubbleInput = reactExports.forwardRef(
  ({ __scopeSlider, value, ...props }, forwardedRef) => {
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("input", { bubbles: true });
        setValue.call(input, value);
        input.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.input,
      {
        style: { display: "none" },
        ...props,
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SliderBubbleInput.displayName = BUBBLE_INPUT_NAME;
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a2, b) => a2 - b);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset2(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root = Slider;
var Track = SliderTrack;
var Range$1 = SliderRange;
var Thumb = SliderThumb;
var PROVIDER_NAME = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = reactExports.useState(null);
  const [toastCount, setToastCount] = reactExports.useState(0);
  const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
  const isClosePausedRef = reactExports.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider.displayName = PROVIDER_NAME;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown2 = (event) => {
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) ref.current?.focus();
      };
      document.addEventListener("keydown", handleKeyDown2);
      return () => document.removeEventListener("keydown", handleKeyDown2);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    reactExports.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown2 = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.current?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown2);
        return () => viewport.removeEventListener("keydown", handleKeyDown2);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch$1,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode2] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode2(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef$1(() => {
      const isFocusInToast = node?.contains(document.activeElement);
      if (isFocusInToast) context.viewport?.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume?.();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause?.();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown?.(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x = event.clientX - pointerStartRef.current.x;
                  const y2 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose.displayName = CLOSE_NAME;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider = ToastProvider;
var Root2$1 = Toast;
var Title = ToastTitle;
var Description = ToastDescription;
var Action = ToastAction;
var Close = ToastClose;
var NAME = "Toggle";
var Toggle = reactExports.forwardRef((props, forwardedRef) => {
  const { pressed: pressedProp, defaultPressed, onPressedChange, ...buttonProps } = props;
  const [pressed, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed ?? false,
    caller: NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.button,
    {
      type: "button",
      "aria-pressed": pressed,
      "data-state": pressed ? "on" : "off",
      "data-disabled": props.disabled ? "" : void 0,
      ...buttonProps,
      ref: forwardedRef,
      onClick: composeEventHandlers(props.onClick, () => {
        if (!props.disabled) {
          setPressed(!pressed);
        }
      })
    }
  );
});
Toggle.displayName = NAME;
var TOGGLE_GROUP_NAME$1 = "ToggleGroup";
var [createToggleGroupContext, createToggleGroupScope] = createContextScope(TOGGLE_GROUP_NAME$1, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var ToggleGroup$1 = React.forwardRef((props, forwardedRef) => {
  const { type, ...toggleGroupProps } = props;
  if (type === "single") {
    const singleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplSingle, { ...singleProps, ref: forwardedRef });
  }
  if (type === "multiple") {
    const multipleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplMultiple, { ...multipleProps, ref: forwardedRef });
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME$1}\``);
});
ToggleGroup$1.displayName = TOGGLE_GROUP_NAME$1;
var [ToggleGroupValueProvider, useToggleGroupValueContext] = createToggleGroupContext(TOGGLE_GROUP_NAME$1);
var ToggleGroupImplSingle = React.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupSingleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? "",
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME$1
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "single",
      value: React.useMemo(() => value ? [value] : [], [value]),
      onItemActivate: setValue,
      onItemDeactivate: React.useCallback(() => setValue(""), [setValue]),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, { ...toggleGroupSingleProps, ref: forwardedRef })
    }
  );
});
var ToggleGroupImplMultiple = React.forwardRef((props, forwardedRef) => {
  const {
    value: valueProp,
    defaultValue,
    onValueChange = () => {
    },
    ...toggleGroupMultipleProps
  } = props;
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue ?? [],
    onChange: onValueChange,
    caller: TOGGLE_GROUP_NAME$1
  });
  const handleButtonActivate = React.useCallback(
    (itemValue) => setValue((prevValue = []) => [...prevValue, itemValue]),
    [setValue]
  );
  const handleButtonDeactivate = React.useCallback(
    (itemValue) => setValue((prevValue = []) => prevValue.filter((value2) => value2 !== itemValue)),
    [setValue]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroupValueProvider,
    {
      scope: props.__scopeToggleGroup,
      type: "multiple",
      value,
      onItemActivate: handleButtonActivate,
      onItemDeactivate: handleButtonDeactivate,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, { ...toggleGroupMultipleProps, ref: forwardedRef })
    }
  );
});
ToggleGroup$1.displayName = TOGGLE_GROUP_NAME$1;
var [ToggleGroupContext, useToggleGroupContext] = createToggleGroupContext(TOGGLE_GROUP_NAME$1);
var ToggleGroupImpl = React.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToggleGroup,
      disabled = false,
      rovingFocus = true,
      orientation,
      dir,
      loop = true,
      ...toggleGroupProps
    } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeToggleGroup);
    const direction = useDirection(dir);
    const commonProps = { role: "group", dir: direction, ...toggleGroupProps };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupContext, { scope: __scopeToggleGroup, rovingFocus, disabled, children: rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...commonProps, ref: forwardedRef })
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...commonProps, ref: forwardedRef }) });
  }
);
var ITEM_NAME = "ToggleGroupItem";
var ToggleGroupItem = React.forwardRef(
  (props, forwardedRef) => {
    const valueContext = useToggleGroupValueContext(ITEM_NAME, props.__scopeToggleGroup);
    const context = useToggleGroupContext(ITEM_NAME, props.__scopeToggleGroup);
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(props.__scopeToggleGroup);
    const pressed = valueContext.value.includes(props.value);
    const disabled = context.disabled || props.disabled;
    const commonProps = { ...props, pressed, disabled };
    const ref = React.useRef(null);
    return context.rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: pressed,
        ref,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef })
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemImpl, { ...commonProps, ref: forwardedRef });
  }
);
ToggleGroupItem.displayName = ITEM_NAME;
var ToggleGroupItemImpl = React.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToggleGroup, value, ...itemProps } = props;
    const valueContext = useToggleGroupValueContext(ITEM_NAME, __scopeToggleGroup);
    const singleProps = { role: "radio", "aria-checked": props.pressed, "aria-pressed": void 0 };
    const typeProps = valueContext.type === "single" ? singleProps : void 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        ...typeProps,
        ...itemProps,
        ref: forwardedRef,
        onPressedChange: (pressed) => {
          if (pressed) {
            valueContext.onItemActivate(value);
          } else {
            valueContext.onItemDeactivate(value);
          }
        }
      }
    );
  }
);
var Root2 = ToggleGroup$1;
var Item2 = ToggleGroupItem;
var TOOLBAR_NAME = "Toolbar";
var [createToolbarContext, createToolbarScope] = createContextScope(TOOLBAR_NAME, [
  createRovingFocusGroupScope,
  createToggleGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var useToggleGroupScope = createToggleGroupScope();
var [ToolbarProvider, useToolbarContext] = createToolbarContext(TOOLBAR_NAME);
var Toolbar = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, orientation = "horizontal", dir, loop = true, ...toolbarProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarProvider, { scope: __scopeToolbar, orientation, dir: direction, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$2,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation,
        dir: direction,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "toolbar",
            "aria-orientation": orientation,
            dir: direction,
            ...toolbarProps,
            ref: forwardedRef
          }
        )
      }
    ) });
  }
);
Toolbar.displayName = TOOLBAR_NAME;
var SEPARATOR_NAME = "ToolbarSeparator";
var ToolbarSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...separatorProps } = props;
    const context = useToolbarContext(SEPARATOR_NAME, __scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$1,
      {
        orientation: context.orientation === "horizontal" ? "vertical" : "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
ToolbarSeparator.displayName = SEPARATOR_NAME;
var BUTTON_NAME = "ToolbarButton";
var ToolbarButton = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...buttonProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !props.disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.button, { type: "button", ...buttonProps, ref: forwardedRef }) });
  }
);
ToolbarButton.displayName = BUTTON_NAME;
var LINK_NAME = "ToolbarLink";
var ToolbarLink = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...linkProps } = props;
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.a,
      {
        ...linkProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === " ") event.currentTarget.click();
        })
      }
    ) });
  }
);
ToolbarLink.displayName = LINK_NAME;
var TOGGLE_GROUP_NAME = "ToolbarToggleGroup";
var ToolbarToggleGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleGroupProps } = props;
    const context = useToolbarContext(TOGGLE_GROUP_NAME, __scopeToolbar);
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root2,
      {
        "data-orientation": context.orientation,
        dir: context.dir,
        ...toggleGroupScope,
        ...toggleGroupProps,
        ref: forwardedRef,
        rovingFocus: false
      }
    );
  }
);
ToolbarToggleGroup.displayName = TOGGLE_GROUP_NAME;
var TOGGLE_ITEM_NAME = "ToolbarToggleItem";
var ToolbarToggleItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToolbar, ...toggleItemProps } = props;
    const toggleGroupScope = useToggleGroupScope(__scopeToolbar);
    const scope = { __scopeToolbar: props.__scopeToolbar };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarButton, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item2, { ...toggleGroupScope, ...toggleItemProps, ref: forwardedRef }) });
  }
);
ToolbarToggleItem.displayName = TOGGLE_ITEM_NAME;
var Root4 = Toolbar;
var Button = ToolbarButton;
var ToggleGroup = ToolbarToggleGroup;
var ToggleItem = ToolbarToggleItem;
function kickoutOccludedShapes(editor, shapeIds) {
  const parentsToCheck = /* @__PURE__ */ new Set();
  for (const id of shapeIds) {
    const shape = editor.getShape(id);
    if (!shape) continue;
    if (editor.getShapeUtil(shape).onDragShapesOut) {
      parentsToCheck.add(shape);
    }
    const parent = editor.getShape(shape.parentId);
    if (!parent) continue;
    if (editor.getShapeUtil(parent).onDragShapesOut) {
      parentsToCheck.add(parent);
    }
  }
  const parentsWithKickedOutChildren = /* @__PURE__ */ new Map();
  for (const parent of parentsToCheck) {
    const occludedChildren = getOccludedChildren(editor, parent);
    if (occludedChildren.length) {
      parentsWithKickedOutChildren.set(parent, occludedChildren);
    }
  }
  for (const [parent, kickedOutChildrenIds] of parentsWithKickedOutChildren) {
    const shapeUtil = editor.getShapeUtil(parent);
    const kickedOutChildren = compact$1(kickedOutChildrenIds.map((id) => editor.getShape(id)));
    shapeUtil.onDragShapesOut?.(parent, kickedOutChildren);
  }
}
function getOccludedChildren(editor, parent) {
  const childIds = editor.getSortedChildIdsForParent(parent.id);
  if (childIds.length === 0) return [];
  const parentPageBounds = editor.getShapePageBounds(parent);
  if (!parentPageBounds) return [];
  let parentGeometry;
  let parentPageTransform;
  let parentPageCorners;
  const results = [];
  for (const childId of childIds) {
    const shapePageBounds = editor.getShapePageBounds(childId);
    if (!shapePageBounds) {
      continue;
    }
    if (!parentPageBounds.includes(shapePageBounds)) {
      results.push(childId);
      continue;
    }
    parentGeometry ??= editor.getShapeGeometry(parent);
    parentPageTransform ??= editor.getShapePageTransform(parent);
    parentPageCorners ??= parentPageTransform.applyToPoints(parentGeometry.vertices);
    const parentCornersInShapeSpace = editor.getShapePageTransform(childId).clone().invert().applyToPoints(parentPageCorners);
    const { vertices, isClosed } = editor.getShapeGeometry(childId);
    if (vertices.some((v) => pointInPolygon(v, parentCornersInShapeSpace))) {
      continue;
    }
    if (isClosed) {
      if (polygonsIntersect(parentCornersInShapeSpace, vertices)) {
        continue;
      }
    } else if (polygonIntersectsPolyline(parentCornersInShapeSpace, vertices)) {
      continue;
    }
    results.push(childId);
  }
  return results;
}
function startEditingShapeWithLabel(editor, shape, selectAll2 = false) {
  editor.select(shape);
  editor.setEditingShape(shape);
  editor.setCurrentTool("select.editing_shape", {
    target: "shape",
    shape
  });
  if (selectAll2) {
    editor.emit("select-all-text", { shapeId: shape.id });
  }
}
function removeFrame(editor, ids) {
  const frames = compact$1(
    ids.map((id) => editor.getShape(id)).filter((f) => f && editor.isShapeOfType(f, "frame"))
  );
  if (!frames.length) return;
  const allChildren = [];
  editor.run(() => {
    frames.map((frame2) => {
      const children = editor.getSortedChildIdsForParent(frame2.id);
      if (children.length) {
        editor.reparentShapes(children, frame2.parentId, frame2.index);
        allChildren.push(...children);
      }
    });
    editor.setSelectedShapes(allChildren);
    editor.deleteShapes(ids);
  });
}
const DEFAULT_FRAME_PADDING = 50;
function getFrameChildrenBounds(children, editor, opts = { padding: DEFAULT_FRAME_PADDING }) {
  const bounds = Box.FromPoints(
    children.flatMap((shape) => {
      if (!shape) return [];
      const geometry = editor.getShapeGeometry(shape.id);
      const transform = editor.getShapeLocalTransform(shape);
      return transform?.applyToPoints(geometry.vertices) ?? [];
    })
  );
  const padding = opts.padding ?? DEFAULT_FRAME_PADDING;
  const w = bounds.w + 2 * padding;
  const h = bounds.h + 2 * padding;
  const dx = padding - bounds.minX;
  const dy = padding - bounds.minY;
  return { w, h, dx, dy };
}
function fitFrameToContent(editor, id, opts = {}) {
  const frame2 = editor.getShape(id);
  if (!frame2) return;
  const childIds = editor.getSortedChildIdsForParent(frame2.id);
  const children = compact$1(childIds.map((id2) => editor.getShape(id2)));
  if (!children.length) return;
  const { w, h, dx, dy } = getFrameChildrenBounds(children, editor, opts);
  if (dx === 0 && dy === 0 && frame2.props.w === w && frame2.props.h === h) return;
  const diff = new Vec(dx, dy).rot(frame2.rotation);
  editor.run(() => {
    const changes = childIds.map((child) => {
      const shape = editor.getShape(child);
      return {
        id: shape.id,
        type: shape.type,
        x: shape.x + dx,
        y: shape.y + dy
      };
    });
    changes.push({
      id: frame2.id,
      type: frame2.type,
      x: frame2.x - diff.x,
      y: frame2.y - diff.y,
      props: {
        w,
        h
      }
    });
    editor.updateShapes(changes);
  });
}
function TldrawUiButtonLabel({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", children });
}
const TldrawUiIcon = reactExports.memo(function TldrawUiIcon2({
  label,
  small,
  invertIcon,
  icon,
  color,
  className,
  ...props
}) {
  const assetUrls = useAssetUrls();
  const asset = assetUrls.icons[icon] ?? assetUrls.icons["question-mark-circle"];
  const ref = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (!asset) {
      console.error(`Icon not found: ${icon}. Add it to the assetUrls.icons object.`);
    }
    if (ref?.current) {
      ref.current.style.webkitMask = `url(${asset}) center 100% / 100% no-repeat`;
    }
  }, [ref, asset, icon]);
  if (icon === "none") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames(
          "tlui-icon tlui-icon__placeholder",
          { "tlui-icon__small": small },
          className
        )
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ...props,
      ref,
      "aria-label": label,
      role: "img",
      className: classNames("tlui-icon", { "tlui-icon__small": small }, className),
      style: {
        color,
        mask: `url(${asset}) center 100% / 100% no-repeat`,
        transform: invertIcon ? "scale(-1, 1)" : void 0
      }
    }
  );
});
function TldrawUiButtonIcon({ icon, small, invertIcon }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiIcon,
    {
      "aria-hidden": "true",
      label: "",
      className: "tlui-button__icon",
      icon,
      small,
      invertIcon
    }
  );
}
function TldrawUiDialogHeader({ className, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-dialog__header", className), children });
}
function TldrawUiDialogTitle({ className, children, style: style2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Title$1,
    {
      dir: "ltr",
      className: classNames("tlui-dialog__header__title", className),
      style: style2,
      children
    }
  );
}
function TldrawUiDialogCloseButton() {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, { "data-testid": "dialog.close", dir: "ltr", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiButton,
    {
      type: "icon",
      "aria-label": msg2("ui.close"),
      onTouchEnd: (e) => e.target.click(),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "cross-2" })
    }
  ) }) });
}
function TldrawUiDialogBody({ className, children, style: style2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-dialog__body", className), style: style2, children });
}
function TldrawUiDialogFooter({ className, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames("tlui-dialog__footer", className), children });
}
const TldrawUiInput = reactExports.forwardRef(
  function TldrawUiInput2({
    className,
    label,
    icon,
    iconLeft,
    iconLabel,
    autoSelect = false,
    autoFocus = false,
    defaultValue,
    placeholder,
    onComplete,
    onValueChange,
    onCancel,
    onFocus,
    onBlur,
    shouldManuallyMaintainScrollPositionWhenFocused = false,
    children,
    value,
    "data-testid": dataTestId
  }, ref) {
    const editor = useMaybeEditor();
    const rInputRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref, () => rInputRef.current);
    const msg2 = useTranslation();
    const rInitialValue = reactExports.useRef(defaultValue ?? "");
    const rCurrentValue = reactExports.useRef(defaultValue ?? "");
    const isComposing = reactExports.useRef(false);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const handleFocus = reactExports.useCallback(
      (e) => {
        setIsFocused(true);
        const elm = e.currentTarget;
        rCurrentValue.current = elm.value;
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            if (autoSelect) {
              elm.select();
            }
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            if (autoSelect) {
              elm.select();
            }
          });
        }
        onFocus?.();
      },
      [autoSelect, editor, onFocus]
    );
    const handleChange = reactExports.useCallback(
      (e) => {
        const value2 = e.currentTarget.value;
        rCurrentValue.current = value2;
        onValueChange?.(value2);
      },
      [onValueChange]
    );
    const handleKeyDownCapture = reactExports.useCallback(
      (e) => {
        switch (e.key) {
          case "Enter": {
            if (isComposing.current) return;
            e.currentTarget.blur();
            stopEventPropagation(e);
            onComplete?.(e.currentTarget.value);
            break;
          }
          case "Escape": {
            e.currentTarget.value = rInitialValue.current;
            onCancel?.(e.currentTarget.value);
            e.currentTarget.blur();
            stopEventPropagation(e);
            break;
          }
        }
      },
      [onComplete, onCancel]
    );
    const handleBlur = reactExports.useCallback(
      (e) => {
        setIsFocused(false);
        const value2 = e.currentTarget.value;
        onBlur?.(value2);
      },
      [onBlur]
    );
    const handleCompositionStart = reactExports.useCallback(() => isComposing.current = true, []);
    const handleCompositionEnd = reactExports.useCallback(() => isComposing.current = false, []);
    reactExports.useEffect(() => {
      if (!tlenv.isIos) return;
      const visualViewport = window.visualViewport;
      if (isFocused && shouldManuallyMaintainScrollPositionWhenFocused && visualViewport) {
        const onViewportChange = () => {
          rInputRef.current?.scrollIntoView({ block: "center" });
        };
        visualViewport.addEventListener("resize", onViewportChange);
        visualViewport.addEventListener("scroll", onViewportChange);
        if (editor) {
          editor.timers.requestAnimationFrame(() => {
            rInputRef.current?.scrollIntoView({ block: "center" });
          });
        } else {
          tltime.requestAnimationFrame("anon", () => {
            rInputRef.current?.scrollIntoView({ block: "center" });
          });
        }
        return () => {
          visualViewport.removeEventListener("resize", onViewportChange);
          visualViewport.removeEventListener("scroll", onViewportChange);
        };
      }
    }, [isFocused, editor, shouldManuallyMaintainScrollPositionWhenFocused]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { draggable: false, className: "tlui-input__wrapper", children: [
      children,
      label && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: msg2(label) }),
      iconLeft && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiIcon,
        {
          label: iconLabel ? msg2(iconLabel) : "",
          icon: iconLeft,
          className: "tlui-icon-left",
          small: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: rInputRef,
          className: classNames("tlui-input", className),
          type: "text",
          defaultValue,
          onKeyDownCapture: handleKeyDownCapture,
          onChange: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onCompositionStart: handleCompositionStart,
          onCompositionEnd: handleCompositionEnd,
          autoFocus,
          placeholder,
          value,
          "data-testid": dataTestId
        }
      ),
      icon && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: iconLabel ? msg2(iconLabel) : "", icon, small: !!label })
    ] });
  }
);
function validateUrl(url) {
  if (linkUrl.isValid(url)) {
    return { isValid: true, hasProtocol: true };
  }
  if (linkUrl.isValid("https://" + url)) {
    return { isValid: true, hasProtocol: false };
  }
  return { isValid: false, hasProtocol: false };
}
const EditLinkDialog = track(function EditLinkDialog2({ onClose }) {
  const editor = useEditor();
  const selectedShape = editor.getOnlySelectedShape();
  if (!(selectedShape && "url" in selectedShape.props && typeof selectedShape.props.url === "string")) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkDialogInner, { onClose, selectedShape });
});
const EditLinkDialogInner = track(function EditLinkDialogInner2({
  onClose,
  selectedShape
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rInput = reactExports.useRef(null);
  reactExports.useEffect(() => {
    editor.timers.requestAnimationFrame(() => rInput.current?.focus());
  }, [editor]);
  const rInitialValue = reactExports.useRef(selectedShape.props.url);
  const [urlInputState, setUrlInputState] = reactExports.useState(() => {
    const urlValidResult = validateUrl(selectedShape.props.url);
    const initialValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? selectedShape.props.url : "https://" + selectedShape.props.url : "https://";
    return {
      actual: initialValue,
      safe: initialValue,
      valid: true
    };
  });
  const handleChange = reactExports.useCallback((rawValue) => {
    const fixedRawValue = rawValue.replace(/https?:\/\/(https?:\/\/)/, (_match, arg1) => {
      return arg1;
    });
    const urlValidResult = validateUrl(fixedRawValue);
    const safeValue = urlValidResult.isValid === true ? urlValidResult.hasProtocol ? fixedRawValue : "https://" + fixedRawValue : "https://";
    setUrlInputState({
      actual: fixedRawValue,
      safe: safeValue,
      valid: urlValidResult.isValid
    });
  }, []);
  const handleClear = reactExports.useCallback(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape) return;
    editor.updateShapes([
      { id: onlySelectedShape.id, type: onlySelectedShape.type, props: { url: "" } }
    ]);
    onClose();
  }, [editor, onClose]);
  const handleComplete = reactExports.useCallback(() => {
    const onlySelectedShape = editor.getOnlySelectedShape();
    if (!onlySelectedShape) return;
    if (onlySelectedShape && "url" in onlySelectedShape.props) {
      if (onlySelectedShape.props.url !== urlInputState.safe) {
        editor.updateShapes([
          {
            id: onlySelectedShape.id,
            type: onlySelectedShape.type,
            props: { url: urlInputState.safe }
          }
        ]);
      }
    }
    onClose();
  }, [editor, onClose, urlInputState]);
  const handleCancel = reactExports.useCallback(() => {
    onClose();
  }, [onClose]);
  if (!selectedShape) {
    onClose();
    return null;
  }
  const isRemoving = rInitialValue.current && !urlInputState.valid;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: msg2("edit-link-dialog.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiInput,
        {
          ref: rInput,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: true,
          autoSelect: true,
          placeholder: "https://example.com",
          value: urlInputState.actual,
          onValueChange: handleChange,
          onComplete: handleComplete,
          onCancel: handleCancel
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: urlInputState.valid ? msg2("edit-link-dialog.detail") : msg2("edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", onClick: handleCancel, onTouchEnd: handleCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.cancel") }) }),
      isRemoving ? /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "danger", onTouchEnd: handleClear, onClick: handleClear, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.clear") }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButton,
        {
          type: "primary",
          disabled: !urlInputState.valid,
          onTouchEnd: handleComplete,
          onClick: handleComplete,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
});
var define_process_env_default = {};
const TLDRAW_APP_RE = /(^\/[f|p|r|ro|s|v]\/[^/]+\/?$)/;
const DEFAULT_EMBED_DEFINITIONS = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-top-navigation": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
        urlObj.searchParams.append("embed", "true");
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
        urlObj.searchParams.delete("embed");
        return url;
      }
      return;
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      if (!!url.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto|design)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !url.includes("figma.com/embed")) {
        return `https://www.figma.com/embed?embed_host=share&url=${url}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
        const outUrl = urlObj.searchParams.get("url");
        if (outUrl) {
          return outUrl;
        }
      }
      return;
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true
    },
    toEmbedUrl: (url) => {
      if (url.includes("/maps/embed?")) {
        return url;
      } else if (url.includes("/maps/")) {
        const match = url.match(/@(.*?),(.*?),(.*?)(z|m)/);
        let result;
        if (match) {
          const [, lat, lng, zoomOrMeters, mapTypeSymbol] = match;
          const mapType = mapTypeSymbol === "z" ? "roadmap" : "satellite";
          const z = mapType === "roadmap" ? zoomOrMeters : -Math.log2(parseInt(zoomOrMeters) / 14772321) / 0.8;
          const host = new URL(url).host.replace("www.", "");
          result = `https://${host}/maps/embed/v1/view?key=${define_process_env_default.NEXT_PUBLIC_GC_API_KEY}&center=${lat},${lng}&zoom=${z}&maptype=${mapType}`;
        } else {
          result = "";
        }
        return result;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const matches2 = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
      if (matches2 && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
        const zoom = urlObj.searchParams.get("zoom") ?? "12";
        const mapType = urlObj.searchParams.get("maptype") ?? "roadmap";
        const zoomOrMeters = mapType === "roadmap" ? zoom : 14772321 * Math.pow(2, parseInt(zoom) * -0.8);
        const [lat, lon] = urlObj.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${lat},${lon},${zoomOrMeters}${mapType === "roadmap" ? "z" : "m"}`;
      }
      return;
    }
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/v\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/(.+)\/?/);
      if (matches2) {
        return `https://www.val.town/v/${matches2[1]}`;
      }
      return;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/s\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/embed/${matches2[1]}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const matches2 = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
      if (matches2) {
        return `https://codesandbox.io/s/${matches2[1]}`;
      }
      return;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: true,
    toEmbedUrl: (url) => {
      const CODEPEN_URL_REGEXP = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/;
      const matches2 = url.match(CODEPEN_URL_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
      const matches2 = url.match(CODEPEN_EMBED_REGEXP);
      if (matches2) {
        const [_, user, id] = matches2;
        return `https://codepen.io/${user}/pen/${id}`;
      }
      return;
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: false,
    toEmbedUrl: (url) => {
      const SCRATCH_URL_REGEXP = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/;
      const matches2 = url.match(SCRATCH_URL_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/embed/${id}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
      const matches2 = url.match(SCRATCH_EMBED_REGEXP);
      if (matches2) {
        const [_, id] = matches2;
        return `https://scratch.mit.edu/projects/${id}`;
      }
      return;
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: true,
    overridePermissions: {
      "allow-presentation": true,
      "allow-popups-to-escape-sandbox": true
    },
    isAspectRatioLocked: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtu.be") {
        const videoId = urlObj.pathname.split("/").filter(Boolean)[0];
        const searchParams = new URLSearchParams(urlObj.search);
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      } else if ((hostname === "youtube.com" || hostname === "m.youtube.com") && urlObj.pathname.match(/^\/watch/)) {
        const videoId = urlObj.searchParams.get("v");
        const searchParams = new URLSearchParams(urlObj.search);
        searchParams.delete("v");
        const timeStart = searchParams.get("t");
        if (timeStart) {
          searchParams.set("start", timeStart);
          searchParams.delete("t");
        }
        const search = searchParams.toString() ? "?" + searchParams.toString() : "";
        return `https://www.youtube.com/embed/${videoId}${search}`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (!urlObj) return;
      const hostname = urlObj.hostname.replace(/^www./, "");
      if (hostname === "youtube.com") {
        const matches2 = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (matches2) {
          const params = new URLSearchParams(urlObj.search);
          params.set("v", matches2?.[1] ?? "");
          const timeStart = params.get("start");
          if (timeStart) {
            params.set("t", timeStart);
            params.delete("start");
          }
          return `https://www.youtube.com/watch?${params.toString()}`;
        }
      }
      return;
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const cidQs = urlObj?.searchParams.get("cid");
      if (urlObj?.pathname.match(/\/calendar\/u\/0/) && cidQs) {
        urlObj.pathname = "/calendar/embed";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("src", cidQs);
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      const srcQs = urlObj?.searchParams.get("src");
      if (urlObj?.pathname.match(/\/calendar\/embed/) && srcQs) {
        urlObj.pathname = "/calendar/u/0";
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        urlObj.searchParams.set("cid", srcQs);
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: true,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": true
    },
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/pub\/?$/)) {
        urlObj.pathname = urlObj.pathname.replace(/\/pub$/, "/embed");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj?.pathname.match(/^\/presentation/) && urlObj?.pathname.match(/\/embed\/?$/)) {
        urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
        const keys2 = Array.from(urlObj.searchParams.keys());
        for (const key of keys2) {
          urlObj.searchParams.delete(key);
        }
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: true,
    // Security warning:
    // Gists allow adding .json extensions to the URL which return JSONP.
    // Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.
    // It _is_ sandboxed by the iframe but we still want to disable it nonetheless.
    // We restrict the id to only allow hexdecimal characters to prevent this.
    // Read more:
    //   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques
    //   https://github.com/renniepak/CSPBypass
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/)) {
        if (!url.split("/").pop()) return;
        return url;
      }
      return;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/)) {
        return `${url}?embed=true`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
        urlObj.searchParams.delete("embed");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/map\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
        urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
        return urlObj.href;
      }
      return;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/(artist|album)\//)) {
        return urlObj.origin + "/embed" + urlObj.pathname;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
        return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
      }
      return;
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: true,
    isAspectRatioLocked: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "vimeo.com") {
        if (urlObj.pathname.match(/^\/[0-9]+/)) {
          return "https://player.vimeo.com/video/" + urlObj.pathname.split("/")[1] + "?title=0&byline=0";
        }
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "player.vimeo.com") {
        const matches2 = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (matches2) {
          return "https://vimeo.com/" + matches2[1];
        }
      }
      return;
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: true,
    isAspectRatioLocked: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hash.match(/#room=/)) {
        return url;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hash.match(/#room=/)) {
        return url;
      }
      return;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: true,
    isAspectRatioLocked: false,
    backgroundColor: "#fff",
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}/embed${urlObj.pathname}?cell=*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const pathName = urlObj.pathname.replace(/^\/d/, "");
        return `${urlObj.origin}/embed${pathName}?cell=*`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
      }
      if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
        return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
      }
      return;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: true,
    toEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "" && urlObj.hash === "") {
        return `${url}?embed`;
      }
      return;
    },
    fromEmbedUrl: (url) => {
      const urlObj = safeParseUrl(url);
      if (urlObj && urlObj.hostname === "www.desmos.com" && urlObj.pathname.match(/^\/calculator\/([^/]+)\/?$/) && urlObj.search === "?embed" && urlObj.hash === "") {
        return url.replace("?embed", "");
      }
      return;
    }
  }
];
const embedShapePermissionDefaults = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": false,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": false,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": false,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": false,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": false,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": true,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": false,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": false,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": false,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": false,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": false,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": true,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": true,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": true
};
const DEFAULT_EMBED_DEFINITION_TYPES = DEFAULT_EMBED_DEFINITIONS.map(
  (def) => def.type
);
function isDefaultEmbedDefinitionType(type) {
  return DEFAULT_EMBED_DEFINITION_TYPES.includes(type);
}
function isCustomEmbedDefinition(def) {
  return "icon" in def;
}
function useGetEmbedShapeUtil() {
  const editor = useMaybeEditor();
  if (!editor) return void 0;
  if (editor.hasShapeUtil("embed")) {
    return editor.getShapeUtil("embed");
  }
  return void 0;
}
function useGetEmbedDefinition() {
  const embedUtil = useGetEmbedShapeUtil();
  return (url) => {
    return embedUtil ? embedUtil.getEmbedDefinition(url) : void 0;
  };
}
function useGetEmbedDefinitions() {
  const embedUtil = useGetEmbedShapeUtil();
  return embedUtil ? embedUtil.getEmbedDefinitions() : [];
}
const EmbedDialog = track(function EmbedDialog2({ onClose }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const assetUrls = useAssetUrls();
  const [embedDefinition, setEmbedDefinition] = reactExports.useState(null);
  const [url, setUrl] = reactExports.useState("");
  const [embedInfoForUrl, setEmbedInfoForUrl] = reactExports.useState(null);
  const [showError, setShowError] = reactExports.useState(false);
  const rShowErrorTimeout = reactExports.useRef(-1);
  const definitions = useGetEmbedDefinitions();
  const getEmbedDefinition = useGetEmbedDefinition();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: embedDefinition ? `${msg2("embed-dialog.title")} — ${embedDefinition.title}` : msg2("embed-dialog.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    embedDefinition ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogBody, { className: "tlui-embed-dialog__enter", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiInput,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "https://example.com",
            autoFocus: true,
            onValueChange: (value) => {
              setUrl(value);
              const embedInfo = getEmbedDefinition(value);
              setEmbedInfoForUrl(
                embedInfo && embedInfo.definition.type === embedDefinition.type ? embedInfo : null
              );
              setShowError(false);
              clearTimeout(rShowErrorTimeout.current);
              rShowErrorTimeout.current = editor.timers.setTimeout(
                () => setShowError(!embedInfo),
                320
              );
            }
          }
        ),
        url === "" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: msg2("embed-dialog.instruction") }),
          " ",
          embedDefinition.instructionLink && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                target: "_blank",
                rel: "noopener noreferrer",
                href: embedDefinition.instructionLink,
                className: "tlui-embed-dialog__instruction__link",
                children: "Learn more"
              }
            ),
            "."
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-embed-dialog__warning", children: showError ? msg2("embed-dialog.invalid-url") : " " })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "normal",
            onClick: () => {
              setEmbedDefinition(null);
              setEmbedInfoForUrl(null);
              setUrl("");
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("embed-dialog.back") })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-embed__spacer" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("embed-dialog.cancel") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "primary",
            disabled: !embedInfoForUrl,
            onClick: () => {
              if (!embedInfoForUrl) return;
              editor.putExternalContent({
                type: "embed",
                url,
                point: editor.getViewportPageBounds().center,
                embed: embedInfoForUrl.definition
              });
              onClose();
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: msg2("embed-dialog.create") })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogBody, { className: "tlui-embed-dialog__list", children: definitions.map((def) => {
      const url2 = isDefaultEmbedDefinitionType(def.type) ? assetUrls.embedIcons[def.type] : isCustomEmbedDefinition(def) ? def.icon : void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiButton, { type: "menu", onClick: () => setEmbedDefinition(def), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: untranslated(def.title) }),
        url2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "tlui-embed-dialog__item__image",
            style: { backgroundImage: `url(${url2})` }
          }
        )
      ] }, def.type);
    }) }) })
  ] });
});
function useShowCollaborationUi() {
  const editor = useMaybeEditor();
  return editor?.store.props.collaboration !== void 0;
}
function useCollaborationStatus() {
  const editor = useMaybeEditor();
  return useValue(
    "sync status",
    () => {
      if (!editor?.store.props.collaboration?.status) {
        return null;
      }
      return editor.store.props.collaboration.status.get();
    },
    [editor]
  );
}
async function flattenShapesToImages(editor, shapeIds, flattenImageBoundsExpand) {
  const shapes = compact$1(
    shapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const util2 = editor.getShapeUtil(shape.type);
      if (util2.toSvg === void 0) return;
      return shape;
    })
  );
  if (shapes.length === 0) return;
  if (shapes.length === 1) {
    const shape = shapes[0];
    if (!shape) return;
    if (editor.isShapeOfType(shape, "image")) return;
  }
  const groups = [];
  if (flattenImageBoundsExpand !== void 0) {
    const expandedBounds = shapes.map((shape) => {
      return {
        shape,
        bounds: editor.getShapeMaskedPageBounds(shape).clone().expandBy(flattenImageBoundsExpand)
      };
    });
    for (let i = 0; i < expandedBounds.length; i++) {
      const item = expandedBounds[i];
      if (i === 0) {
        groups[0] = {
          shapes: [item.shape],
          bounds: item.bounds
        };
        continue;
      }
      let didLand = false;
      for (const group of groups) {
        if (group.bounds.includes(item.bounds)) {
          group.shapes.push(item.shape);
          group.bounds.expand(item.bounds);
          didLand = true;
          break;
        }
      }
      if (!didLand) {
        groups.push({
          shapes: [item.shape],
          bounds: item.bounds
        });
      }
    }
  } else {
    const bounds = Box.Common(shapes.map((shape) => editor.getShapeMaskedPageBounds(shape)));
    groups.push({
      shapes,
      bounds
    });
  }
  const padding = editor.options.flattenImageBoundsPadding;
  for (const group of groups) {
    if (flattenImageBoundsExpand !== void 0) {
      group.bounds.expandBy(-flattenImageBoundsExpand);
    }
    const svgResult = await editor.getSvgString(group.shapes, {
      padding,
      background: false
    });
    if (!svgResult?.svg) continue;
    const asset = await editor.getAssetForExternalContent({
      type: "file",
      file: new File([svgResult.svg], "asset.svg", { type: "image/svg+xml" })
    });
    if (!asset) continue;
    group.asset = asset;
  }
  const createdShapeIds = [];
  transact(() => {
    for (const group of groups) {
      const { asset, bounds, shapes: shapes2 } = group;
      if (!asset) continue;
      const commonAncestorId = editor.findCommonAncestor(shapes2) ?? editor.getCurrentPageId();
      if (!commonAncestorId) continue;
      let index2 = "a1";
      for (const shape of shapes2) {
        if (shape.parentId === commonAncestorId) {
          if (shape.index > index2) {
            index2 = shape.index;
          }
          break;
        }
      }
      let x;
      let y2;
      let rotation;
      if (isShapeId(commonAncestorId)) {
        const commonAncestor = editor.getShape(commonAncestorId);
        if (!commonAncestor) continue;
        const point = editor.getPointInShapeSpace(commonAncestor, {
          x: bounds.x,
          y: bounds.y
        });
        rotation = editor.getShapePageTransform(commonAncestorId).rotation();
        point.sub(new Vec(padding, padding).rot(-rotation));
        x = point.x;
        y2 = point.y;
      } else {
        x = bounds.x - padding;
        y2 = bounds.y - padding;
        rotation = 0;
      }
      editor.deleteShapes(shapes2);
      editor.createAssets([{ ...asset, id: asset.id }]);
      const shapeId = createShapeId();
      editor.createShape({
        id: shapeId,
        type: "image",
        index: index2,
        parentId: commonAncestorId,
        x,
        y: y2,
        rotation: -rotation,
        props: {
          assetId: asset.id,
          w: bounds.w + padding * 2,
          h: bounds.h + padding * 2
        }
      });
      createdShapeIds.push(shapeId);
    }
  });
  return createdShapeIds;
}
const PORTRAIT_BREAKPOINTS = [0, 389, 436, 476, 580, 640, 840, 1023];
var PORTRAIT_BREAKPOINT = /* @__PURE__ */ ((PORTRAIT_BREAKPOINT2) => {
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["ZERO"] = 0] = "ZERO";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XXS"] = 1] = "MOBILE_XXS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_XS"] = 2] = "MOBILE_XS";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE_SM"] = 3] = "MOBILE_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["MOBILE"] = 4] = "MOBILE";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET_SM"] = 5] = "TABLET_SM";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["TABLET"] = 6] = "TABLET";
  PORTRAIT_BREAKPOINT2[PORTRAIT_BREAKPOINT2["DESKTOP"] = 7] = "DESKTOP";
  return PORTRAIT_BREAKPOINT2;
})(PORTRAIT_BREAKPOINT || {});
const BreakpointContext = React.createContext(null);
function BreakPointProvider({ forceMobile = false, children }) {
  const editor = useMaybeEditor();
  const breakpoint = useValue(
    "breakpoint",
    () => {
      const { width } = editor?.getViewportScreenBounds() ?? { width: window.innerWidth };
      const maxBreakpoint = forceMobile ? PORTRAIT_BREAKPOINT.MOBILE_SM : PORTRAIT_BREAKPOINTS.length - 1;
      for (let i = 0; i < maxBreakpoint; i++) {
        if (width > PORTRAIT_BREAKPOINTS[i] && width <= PORTRAIT_BREAKPOINTS[i + 1]) {
          return i;
        }
      }
      return maxBreakpoint;
    },
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BreakpointContext.Provider, { value: breakpoint, children });
}
function useBreakpoint() {
  const breakpoint = reactExports.useContext(BreakpointContext);
  if (breakpoint === null) {
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  }
  return breakpoint;
}
const DialogsContext = reactExports.createContext(null);
function TldrawUiDialogsProvider({ context, children }) {
  const ctx = reactExports.useContext(DialogsContext);
  const trackEvent = useUiEvents();
  const dialogs = useAtom("dialogs", []);
  const content = reactExports.useMemo(() => {
    return {
      dialogs,
      addDialog(dialog) {
        const id = dialog.id ?? uniqueId();
        dialogs.update((d) => {
          return [...d.filter((m) => m.id !== dialog.id), { ...dialog, id }];
        });
        trackEvent("open-menu", { source: "dialog", id });
        tlmenus.addOpenMenu(id, context);
        return id;
      },
      removeDialog(id) {
        const dialog = dialogs.get().find((d) => d.id === id);
        if (dialog) {
          dialog.onClose?.();
          trackEvent("close-menu", { source: "dialog", id });
          tlmenus.deleteOpenMenu(id, context);
          dialogs.update((d) => d.filter((m) => m !== dialog));
        }
        return id;
      },
      clearDialogs() {
        const current = dialogs.get();
        if (current.length === 0) return;
        current.forEach((d) => {
          d.onClose?.();
          trackEvent("close-menu", { source: "dialog", id: d.id });
          tlmenus.deleteOpenMenu(d.id, context);
        });
        dialogs.set([]);
      }
    };
  }, [trackEvent, dialogs, context]);
  if (ctx) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogsContext.Provider, { value: content, children });
}
function useDialogs() {
  const ctx = reactExports.useContext(DialogsContext);
  if (!ctx) {
    throw new Error("useDialogs must be used within a DialogsProvider");
  }
  return ctx;
}
const ToastsContext = reactExports.createContext(null);
function TldrawUiToastsProvider({ children }) {
  const toasts = useAtom("toasts", []);
  const ctx = reactExports.useContext(ToastsContext);
  const current = reactExports.useMemo(() => {
    return {
      toasts,
      addToast(toast) {
        const id = toast.id ?? uniqueId();
        toasts.update((d) => [...d.filter((m) => m.id !== toast.id), { ...toast, id }]);
        return id;
      },
      removeToast(id) {
        toasts.update((d) => d.filter((m) => m.id !== id));
        return id;
      },
      clearToasts() {
        toasts.set([]);
      }
    };
  }, [toasts]);
  if (ctx) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastsContext.Provider, { value: current, children }) });
}
function useToasts() {
  const ctx = reactExports.useContext(ToastsContext);
  if (!ctx) {
    throw new Error("useToasts must be used within a ToastsProvider");
  }
  return ctx;
}
var lzString = { exports: {} };
var hasRequiredLzString;
function requireLzString() {
  if (hasRequiredLzString) return lzString.exports;
  hasRequiredLzString = 1;
  (function(module) {
    var LZString = function() {
      var f = String.fromCharCode;
      var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
      var baseReverseDic = {};
      function getBaseValue(alphabet, character) {
        if (!baseReverseDic[alphabet]) {
          baseReverseDic[alphabet] = {};
          for (var i = 0; i < alphabet.length; i++) {
            baseReverseDic[alphabet][alphabet.charAt(i)] = i;
          }
        }
        return baseReverseDic[alphabet][character];
      }
      var LZString2 = {
        compressToBase64: function(input) {
          if (input == null) return "";
          var res = LZString2._compress(input, 6, function(a2) {
            return keyStrBase64.charAt(a2);
          });
          switch (res.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return res;
            case 1:
              return res + "===";
            case 2:
              return res + "==";
            case 3:
              return res + "=";
          }
        },
        decompressFromBase64: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          return LZString2._decompress(input.length, 32, function(index2) {
            return getBaseValue(keyStrBase64, input.charAt(index2));
          });
        },
        compressToUTF16: function(input) {
          if (input == null) return "";
          return LZString2._compress(input, 15, function(a2) {
            return f(a2 + 32);
          }) + " ";
        },
        decompressFromUTF16: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 16384, function(index2) {
            return compressed.charCodeAt(index2) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(uncompressed) {
          var compressed = LZString2.compress(uncompressed);
          var buf = new Uint8Array(compressed.length * 2);
          for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
            var current_value = compressed.charCodeAt(i);
            buf[i * 2] = current_value >>> 8;
            buf[i * 2 + 1] = current_value % 256;
          }
          return buf;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(compressed) {
          if (compressed === null || compressed === void 0) {
            return LZString2.decompress(compressed);
          } else {
            var buf = new Array(compressed.length / 2);
            for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
              buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
            }
            var result = [];
            buf.forEach(function(c2) {
              result.push(f(c2));
            });
            return LZString2.decompress(result.join(""));
          }
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(input) {
          if (input == null) return "";
          return LZString2._compress(input, 6, function(a2) {
            return keyStrUriSafe.charAt(a2);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(input) {
          if (input == null) return "";
          if (input == "") return null;
          input = input.replace(/ /g, "+");
          return LZString2._decompress(input.length, 32, function(index2) {
            return getBaseValue(keyStrUriSafe, input.charAt(index2));
          });
        },
        compress: function(uncompressed) {
          return LZString2._compress(uncompressed, 16, function(a2) {
            return f(a2);
          });
        },
        _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
          if (uncompressed == null) return "";
          var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
          for (ii = 0; ii < uncompressed.length; ii += 1) {
            context_c = uncompressed.charAt(ii);
            if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
              context_dictionary[context_c] = context_dictSize++;
              context_dictionaryToCreate[context_c] = true;
            }
            context_wc = context_w + context_c;
            if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
              context_w = context_wc;
            } else {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 8; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i = 0; i < 16; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              context_dictionary[context_wc] = context_dictSize++;
              context_w = String(context_c);
            }
          }
          if (context_w !== "") {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
          }
          value = 2;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
          while (true) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data.push(getCharFromInt(context_data_val));
              break;
            } else context_data_position++;
          }
          return context_data.join("");
        },
        decompress: function(compressed) {
          if (compressed == null) return "";
          if (compressed == "") return null;
          return LZString2._decompress(compressed.length, 32768, function(index2) {
            return compressed.charCodeAt(index2);
          });
        },
        _decompress: function(length, resetValue, getNextValue) {
          var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry2 = "", result = [], i, w, bits, resb, maxpower, power, c2, data = { val: getNextValue(0), position: resetValue, index: 1 };
          for (i = 0; i < 3; i += 1) {
            dictionary[i] = i;
          }
          bits = 0;
          maxpower = Math.pow(2, 2);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c2 = f(bits);
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              c2 = f(bits);
              break;
            case 2:
              return "";
          }
          dictionary[3] = c2;
          w = c2;
          result.push(c2);
          while (true) {
            if (data.index > length) {
              return "";
            }
            bits = 0;
            maxpower = Math.pow(2, numBits);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (c2 = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c2 = dictSize - 1;
                enlargeIn--;
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                dictionary[dictSize++] = f(bits);
                c2 = dictSize - 1;
                enlargeIn--;
                break;
              case 2:
                return result.join("");
            }
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
            if (dictionary[c2]) {
              entry2 = dictionary[c2];
            } else {
              if (c2 === dictSize) {
                entry2 = w + w.charAt(0);
              } else {
                return null;
              }
            }
            result.push(entry2);
            dictionary[dictSize++] = w + entry2.charAt(0);
            enlargeIn--;
            w = entry2;
            if (enlargeIn == 0) {
              enlargeIn = Math.pow(2, numBits);
              numBits++;
            }
          }
        }
      };
      return LZString2;
    }();
    if (module != null) {
      module.exports = LZString;
    } else if (typeof angular !== "undefined" && angular != null) {
      angular.module("LZString", []).factory("LZString", function() {
        return LZString;
      });
    }
  })(lzString);
  return lzString.exports;
}
var lzStringExports = requireLzString();
const lz = /* @__PURE__ */ getDefaultExportFromCjs(lzStringExports);
const TLDRAW_CUSTOM_PNG_MIME_TYPE = "web image/vnd.tldraw+png";
const additionalClipboardWriteTypes = {
  png: TLDRAW_CUSTOM_PNG_MIME_TYPE
};
const canonicalClipboardReadTypes = {
  [TLDRAW_CUSTOM_PNG_MIME_TYPE]: "image/png"
};
function getAdditionalClipboardWriteType(format2) {
  return getOwnProperty(additionalClipboardWriteTypes, format2) ?? null;
}
function getCanonicalClipboardReadType(mimeType) {
  return getOwnProperty(canonicalClipboardReadTypes, mimeType) ?? mimeType;
}
function doesClipboardSupportType(mimeType) {
  return typeof ClipboardItem !== "undefined" && "supports" in ClipboardItem && ClipboardItem.supports(mimeType);
}
function clipboardWrite(types) {
  const entries = Object.entries(types);
  for (const [_, promise] of entries) promise.catch((err) => console.error(err));
  return navigator.clipboard.write([new ClipboardItem(types)]).catch((err) => {
    console.error(err);
    return Promise.all(
      entries.map(async ([type, promise]) => {
        return [type, await promise];
      })
    ).then((entries2) => {
      const resolvedTypes = objectMapFromEntries(entries2);
      return navigator.clipboard.write([new ClipboardItem(resolvedTypes)]);
    });
  });
}
async function pasteFiles(editor, blobs, point, sources) {
  const files = blobs.map(
    (blob) => blob instanceof File ? blob : new File([blob], "tldrawFile", { type: blob.type })
  );
  editor.markHistoryStoppingPoint("paste");
  await editor.putExternalContent({
    type: "files",
    files,
    point,
    ignoreParent: false,
    sources
  });
}
async function pasteUrl(editor, url, point, sources) {
  editor.markHistoryStoppingPoint("paste");
  return await editor.putExternalContent({
    type: "url",
    point,
    url,
    sources
  });
}
const expectedPasteFileMimeTypes = [
  TLDRAW_CUSTOM_PNG_MIME_TYPE,
  "image/png",
  "image/jpeg",
  "image/webp",
  "image/svg+xml"
];
function stripHtml(html2) {
  const doc2 = document.implementation.createHTMLDocument("");
  doc2.documentElement.innerHTML = html2.trim();
  return doc2.body.textContent || doc2.body.innerText || "";
}
const isValidHttpURL = (url) => {
  try {
    const u = new URL(url);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch {
    return false;
  }
};
const getValidHttpURLList = (url) => {
  const urls = url.split(/[\n\s]/);
  for (const url2 of urls) {
    try {
      const u = new URL(url2);
      if (!(u.protocol === "http:" || u.protocol === "https:")) {
        return;
      }
    } catch {
      return;
    }
  }
  return uniq(urls);
};
const isSvgText = (text) => {
  return /^<svg/.test(text);
};
const INPUTS = ["input", "select", "textarea"];
function areShortcutsDisabled$1(editor) {
  const { activeElement } = document;
  return editor.menus.hasAnyOpenMenus() || activeElement && (activeElement.isContentEditable || INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1);
}
const handleText = (editor, data, point, sources) => {
  const validUrlList = getValidHttpURLList(data);
  if (validUrlList) {
    for (const url of validUrlList) {
      pasteUrl(editor, url, point);
    }
  } else if (isValidHttpURL(data)) {
    pasteUrl(editor, data, point);
  } else if (isSvgText(data)) {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "svg-text",
      text: data,
      point,
      sources
    });
  } else {
    editor.markHistoryStoppingPoint("paste");
    editor.putExternalContent({
      type: "text",
      text: data,
      point,
      sources
    });
  }
};
const handlePasteFromEventClipboardData = async (editor, clipboardData, point) => {
  if (editor.getEditingShapeId() !== null) return;
  if (!clipboardData) {
    throw Error("No clipboard data");
  }
  const things = [];
  for (const item of Object.values(clipboardData.items)) {
    switch (item.kind) {
      case "file": {
        things.push({
          type: "file",
          source: new Promise((r2) => r2(item.getAsFile()))
        });
        break;
      }
      case "string": {
        if (item.type === "text/html") {
          things.push({
            type: "html",
            source: new Promise((r2) => item.getAsString(r2))
          });
        } else if (item.type === "text/plain") {
          things.push({
            type: "text",
            source: new Promise((r2) => item.getAsString(r2))
          });
        } else {
          things.push({ type: item.type, source: new Promise((r2) => item.getAsString(r2)) });
        }
        break;
      }
    }
  }
  handleClipboardThings(editor, things, point);
};
const handlePasteFromClipboardApi = async ({
  editor,
  clipboardItems,
  point,
  fallbackFiles
}) => {
  const things = [];
  for (const item of clipboardItems) {
    for (const type of expectedPasteFileMimeTypes) {
      if (item.types.includes(type)) {
        const blobPromise = item.getType(type).then((blob) => FileHelpers.rewriteMimeType(blob, getCanonicalClipboardReadType(type)));
        things.push({
          type: "blob",
          source: blobPromise
        });
        break;
      }
    }
    if (item.types.includes("text/html")) {
      things.push({
        type: "html",
        source: (async () => {
          const blob = await item.getType("text/html");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/uri-list")) {
      things.push({
        type: "url",
        source: (async () => {
          const blob = await item.getType("text/uri-list");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
    if (item.types.includes("text/plain")) {
      things.push({
        type: "text",
        source: (async () => {
          const blob = await item.getType("text/plain");
          return await FileHelpers.blobToText(blob);
        })()
      });
    }
  }
  if (fallbackFiles?.length && things.length === 1 && things[0].type === "text") {
    things.pop();
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  } else if (fallbackFiles?.length && things.length === 0) {
    things.push(
      ...fallbackFiles.map((f) => ({ type: "file", source: Promise.resolve(f) }))
    );
  }
  return await handleClipboardThings(editor, things, point);
};
async function handleClipboardThings(editor, things, point) {
  const files = things.filter(
    (t2) => (t2.type === "file" || t2.type === "blob") && t2.source !== null
  );
  if (files.length) {
    if (files.length > editor.options.maxFilesAtOnce) {
      throw Error("Too many files");
    }
    const fileBlobs = compact$1(await Promise.all(files.map((t2) => t2.source)));
    return await pasteFiles(editor, fileBlobs, point);
  }
  const results = await Promise.all(
    things.filter((t2) => t2.type !== "file").map(
      (t2) => new Promise((r2) => {
        const thing = t2;
        if (thing.type === "file") {
          r2({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        thing.source.then((text) => {
          const tldrawHtmlComment = text.match(/<div data-tldraw[^>]*>(.*)<\/div>/)?.[1];
          if (tldrawHtmlComment) {
            try {
              const jsonComment = lz.decompressFromBase64(tldrawHtmlComment);
              if (jsonComment === null) {
                r2({
                  type: "error",
                  data: jsonComment,
                  reason: `found tldraw data comment but could not parse base64`
                });
                return;
              } else {
                const json = JSON.parse(jsonComment);
                if (json.type !== "application/tldraw") {
                  r2({
                    type: "error",
                    data: json,
                    reason: `found tldraw data comment but JSON was of a different type: ${json.type}`
                  });
                }
                if (typeof json.data === "string") {
                  r2({
                    type: "error",
                    data: json,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                r2({ type: "tldraw", data: json.data });
                return;
              }
            } catch {
              r2({
                type: "error",
                data: tldrawHtmlComment,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          } else {
            if (thing.type === "html") {
              r2({ type: "text", data: text, subtype: "html" });
              return;
            }
            if (thing.type === "url") {
              r2({ type: "text", data: text, subtype: "url" });
              return;
            }
            try {
              const json = JSON.parse(text);
              if (json.type === "excalidraw/clipboard") {
                r2({ type: "excalidraw", data: json });
                return;
              } else {
                r2({ type: "text", data: text, subtype: "json" });
                return;
              }
            } catch {
              r2({ type: "text", data: text, subtype: "text" });
              return;
            }
          }
          r2({ type: "error", data: text, reason: "unhandled case" });
        });
      })
    )
  );
  for (const result of results) {
    if (result.type === "tldraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "tldraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "excalidraw") {
      editor.markHistoryStoppingPoint("paste");
      editor.putExternalContent({ type: "excalidraw", content: result.data, point });
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "html") {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isHtmlSingleLink = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "A" && bodyNode.firstElementChild.hasAttribute("href") && bodyNode.firstElementChild.getAttribute("href") !== "";
      if (isHtmlSingleLink) {
        const href = bodyNode.firstElementChild.getAttribute("href");
        handleText(editor, href, point, results);
        return;
      }
      if (!results.some((r2) => r2.type === "text" && r2.subtype !== "html") && result.data.trim()) {
        const html2 = stripHtml(result.data) ?? "";
        if (html2) {
          handleText(editor, stripHtml(result.data), point, results);
          return;
        }
      }
      if (results.some((r2) => r2.type === "text" && r2.subtype !== "html")) {
        const html2 = stripHtml(result.data) ?? "";
        if (html2) {
          editor.markHistoryStoppingPoint("paste");
          editor.putExternalContent({
            type: "text",
            text: html2,
            html: result.data,
            point,
            sources: results
          });
          return;
        }
      }
    }
    if (result.type === "text" && result.subtype === "text" && result.data.startsWith("<iframe ")) {
      const rootNode = new DOMParser().parseFromString(result.data, "text/html");
      const bodyNode = rootNode.querySelector("body");
      const isSingleIframe = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "IFRAME" && bodyNode.firstElementChild.hasAttribute("src") && bodyNode.firstElementChild.getAttribute("src") !== "";
      if (isSingleIframe) {
        const src = bodyNode.firstElementChild.getAttribute("src");
        handleText(editor, src, point, results);
        return;
      }
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "url") {
      pasteUrl(editor, result.data, point, results);
      return;
    }
  }
  for (const result of results) {
    if (result.type === "text" && result.subtype === "text" && result.data.trim()) {
      handleText(editor, result.data, point, results);
      return;
    }
  }
}
const handleNativeOrMenuCopy = async (editor) => {
  const content = await editor.resolveAssetsInContent(
    editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
  );
  if (!content) {
    if (navigator && navigator.clipboard) {
      navigator.clipboard.writeText("");
    }
    return;
  }
  const stringifiedClipboard = lz.compressToBase64(
    JSON.stringify({
      type: "application/tldraw",
      kind: "content",
      data: content
    })
  );
  if (typeof navigator === "undefined") {
    return;
  } else {
    const textItems = content.shapes.map((shape) => {
      const util2 = editor.getShapeUtil(shape);
      return util2.getText(shape);
    }).filter(isDefined);
    if (navigator.clipboard?.write) {
      const htmlBlob = new Blob([`<div data-tldraw>${stringifiedClipboard}</div>`], {
        type: "text/html"
      });
      let textContent = textItems.join(" ");
      if (textContent === "") {
        textContent = " ";
      }
      navigator.clipboard.write([
        new ClipboardItem({
          "text/html": htmlBlob,
          // What is this second blob used for?
          "text/plain": new Blob([textContent], { type: "text/plain" })
        })
      ]);
    } else if (navigator.clipboard.writeText) {
      navigator.clipboard.writeText(`<div data-tldraw>${stringifiedClipboard}</div>`);
    }
  }
};
function useMenuClipboardEvents() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const copy2 = reactExports.useCallback(
    async function onCopy(source) {
      assert(editor, "editor is required for copy");
      if (editor.getSelectedShapeIds().length === 0) return;
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source });
    },
    [editor, trackEvent]
  );
  const cut2 = reactExports.useCallback(
    async function onCut(source) {
      if (!editor) return;
      if (editor.getSelectedShapeIds().length === 0) return;
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source });
    },
    [editor, trackEvent]
  );
  const paste = reactExports.useCallback(
    async function onPaste(data, source, point) {
      if (!editor) return;
      if (editor.getEditingShapeId() !== null) return;
      if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
        handlePasteFromClipboardApi({ editor, clipboardItems: data, point });
        trackEvent("paste", { source: "menu" });
      } else {
        navigator.clipboard.read().then((clipboardItems) => {
          paste(clipboardItems, source, point);
        });
      }
    },
    [editor, trackEvent]
  );
  return {
    copy: copy2,
    cut: cut2,
    paste
  };
}
function useNativeClipboardEvents() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const appIsFocused = useValue("editor.isFocused", () => editor.getInstanceState().isFocused, [
    editor
  ]);
  reactExports.useEffect(() => {
    if (!appIsFocused) return;
    const copy2 = async (e) => {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled$1(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      trackEvent("copy", { source: "kbd" });
    };
    async function cut2(e) {
      if (editor.getSelectedShapeIds().length === 0 || editor.getEditingShapeId() !== null || areShortcutsDisabled$1(editor)) {
        return;
      }
      preventDefault(e);
      await handleNativeOrMenuCopy(editor);
      editor.deleteShapes(editor.getSelectedShapeIds());
      trackEvent("cut", { source: "kbd" });
    }
    let disablingMiddleClickPaste = false;
    const pointerUpHandler = (e) => {
      if (e.button === 1) {
        disablingMiddleClickPaste = true;
        editor.timers.requestAnimationFrame(() => {
          disablingMiddleClickPaste = false;
        });
      }
    };
    const paste = (e) => {
      if (disablingMiddleClickPaste) {
        stopEventPropagation(e);
        return;
      }
      if (editor.getEditingShapeId() !== null || areShortcutsDisabled$1(editor)) return;
      let point = void 0;
      let pasteAtCursor = false;
      if (editor.inputs.shiftKey) pasteAtCursor = true;
      if (editor.user.getIsPasteAtCursorMode()) pasteAtCursor = !pasteAtCursor;
      if (pasteAtCursor) point = editor.inputs.currentPagePoint;
      const pasteFromEvent = () => {
        if (e.clipboardData) {
          handlePasteFromEventClipboardData(editor, e.clipboardData, point);
        }
      };
      if (navigator.clipboard?.read) {
        const fallbackFiles = Array.from(e.clipboardData?.files || []);
        navigator.clipboard.read().then(
          (clipboardItems) => {
            if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
              handlePasteFromClipboardApi({ editor, clipboardItems, point, fallbackFiles });
            }
          },
          () => {
            pasteFromEvent();
          }
        );
      } else {
        pasteFromEvent();
      }
      preventDefault(e);
      trackEvent("paste", { source: "kbd" });
    };
    document.addEventListener("copy", copy2);
    document.addEventListener("cut", cut2);
    document.addEventListener("paste", paste);
    document.addEventListener("pointerup", pointerUpHandler);
    return () => {
      document.removeEventListener("copy", copy2);
      document.removeEventListener("cut", cut2);
      document.removeEventListener("paste", paste);
      document.removeEventListener("pointerup", pointerUpHandler);
    };
  }, [editor, trackEvent, appIsFocused]);
}
const clipboardMimeTypesByFormat = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  svg: "text/plain"
};
function exportToImagePromiseForClipboard(editor, ids, opts = {}) {
  const idsToUse = ids?.length ? ids : [...editor.getCurrentPageShapeIds()];
  const format2 = opts.format ?? "png";
  return {
    blobPromise: editor.toImage(idsToUse, opts).then(
      (result) => FileHelpers.rewriteMimeType(result.blob, clipboardMimeTypesByFormat[format2])
    ),
    mimeType: clipboardMimeTypesByFormat[format2]
  };
}
function copyAs(...args) {
  const [editor, ids, opts] = typeof args[2] === "string" ? [args[0], args[1], { ...args[3], format: args[2] }] : args;
  if (!navigator.clipboard) return Promise.reject(new Error("Copy not supported"));
  if (navigator.clipboard.write) {
    const { blobPromise, mimeType } = exportToImagePromiseForClipboard(editor, ids, opts);
    const types = { [mimeType]: blobPromise };
    const additionalMimeType = getAdditionalClipboardWriteType(opts.format);
    if (additionalMimeType && doesClipboardSupportType(additionalMimeType)) {
      types[additionalMimeType] = blobPromise.then(
        (blob) => FileHelpers.rewriteMimeType(blob, additionalMimeType)
      );
    }
    return clipboardWrite(types);
  }
  switch (opts.format) {
    case "svg": {
      return fallbackWriteTextAsync(async () => {
        const result = await editor.getSvgString(ids, opts);
        if (!result) throw new Error("Failed to copy");
        return result.svg;
      });
    }
    case "png":
      throw new Error("Copy not supported");
    default:
      exhaustiveSwitchError$1(opts.format);
  }
}
async function fallbackWriteTextAsync(getText2) {
  await navigator.clipboard?.writeText?.(await getText2());
}
function useCopyAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return reactExports.useCallback(
    (ids, format2 = "svg") => {
      assert(editor, "useCopyAs: editor is required");
      copyAs(editor, ids, { format: format2 }).catch(() => {
        addToast({
          id: "copy-fail",
          severity: "warning",
          title: msg2("toast.error.copy-fail.title"),
          description: msg2("toast.error.copy-fail.desc")
        });
      });
    },
    [editor, addToast, msg2]
  );
}
async function exportAs(...args) {
  const [editor, ids, opts] = typeof args[2] === "object" ? args : [args[0], args[1], { ...args[4], format: args[2] ?? "png", name: args[3] }];
  let name = opts.name;
  if (!name) {
    name = `shapes at ${getTimestamp()}`;
    if (ids.length === 1) {
      const first2 = editor.getShape(ids[0]);
      if (editor.isShapeOfType(first2, "frame")) {
        name = first2.props.name || "frame";
      } else {
        name = `${sanitizeId(first2.id)} at ${getTimestamp()}`;
      }
    }
  }
  name += `.${opts.format}`;
  const { blob } = await editor.toImage(ids, opts);
  const file = new File([blob], name, { type: blob.type });
  downloadFile(file);
}
function getTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = String(now.getFullYear()).slice(2);
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}.${minutes}.${seconds}`;
}
function downloadFile(file) {
  const link = document.createElement("a");
  const url = URL.createObjectURL(file);
  link.href = url;
  link.download = file.name;
  link.click();
  URL.revokeObjectURL(url);
}
function useExportAs() {
  const editor = useMaybeEditor();
  const { addToast } = useToasts();
  const msg2 = useTranslation();
  return reactExports.useCallback(
    (ids, format2 = "png", name) => {
      assert(editor, "useExportAs: editor is required");
      exportAs(editor, ids, {
        format: format2,
        name,
        scale: 1
      }).catch((e) => {
        console.error(e.message);
        addToast({
          id: "export-fail",
          title: msg2("toast.error.export-fail.title"),
          description: msg2("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [editor, addToast, msg2]
  );
}
const MimeTypeContext = React.createContext([]);
function useInsertMedia() {
  const _editor = useMaybeEditor();
  const inputRef = reactExports.useRef();
  const mimeTypes = useShallowArrayIdentity(React.useContext(MimeTypeContext));
  reactExports.useEffect(() => {
    const editor = _editor;
    if (!editor) return;
    const input = window.document.createElement("input");
    input.type = "file";
    input.accept = mimeTypes?.join(",") ?? DEFAULT_SUPPORTED_MEDIA_TYPE_LIST;
    input.multiple = true;
    inputRef.current = input;
    async function onchange(e) {
      const fileList = e.target.files;
      if (!fileList || fileList.length === 0) return;
      editor.markHistoryStoppingPoint("insert media");
      await editor.putExternalContent({
        type: "files",
        files: Array.from(fileList),
        point: editor.getViewportPageBounds().center,
        ignoreParent: false
      });
      input.value = "";
    }
    input.addEventListener("change", onchange);
    return () => {
      inputRef.current = void 0;
      input.removeEventListener("change", onchange);
    };
  }, [_editor, mimeTypes]);
  return reactExports.useCallback(() => {
    inputRef.current?.click();
  }, [inputRef]);
}
function usePrint() {
  const editor = useMaybeEditor();
  const prevPrintEl = reactExports.useRef(null);
  const prevStyleEl = reactExports.useRef(null);
  return reactExports.useCallback(
    async function printSelectionOrPages() {
      assert(editor, "usePrint: editor is required");
      const el = document.createElement("div");
      const style2 = document.createElement("style");
      const clearElements = (printEl, styleEl) => {
        if (printEl) printEl.innerHTML = "";
        if (styleEl && document.head.contains(styleEl)) document.head.removeChild(styleEl);
        if (printEl && document.body.contains(printEl)) {
          document.body.removeChild(printEl);
        }
      };
      clearElements(prevPrintEl.current, prevStyleEl.current);
      prevPrintEl.current = el;
      prevStyleEl.current = style2;
      const className = `tl-print-surface-${uniqueId()}`;
      el.className = className;
      style2.innerHTML = `
			.${className} {
				display: none;
			}

			.${className} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${className} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${className}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${className}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${className}__item__header {
					display: none;
				}

				.${className}__item__footer {
					display: none;
					text-align: right;
				}

				.${className}__item__footer__hide {
					display: none;
				}

				${""}
			}

		`;
      const beforePrintHandler = () => {
        document.head.appendChild(style2);
        document.body.appendChild(el);
      };
      const afterPrintHandler = () => {
        editor.once("tick", () => {
          clearElements(el, style2);
        });
      };
      window.addEventListener("beforeprint", beforePrintHandler);
      window.addEventListener("afterprint", afterPrintHandler);
      function addPageToPrint(title, footer, svg) {
        try {
          el.innerHTML += `<div class="${className}__item">
        <div class="${className}__item__header">
          ${title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${className}__item__main">
          ${svg}
        </div>
        <div class="${className}__item__footer ${className}__item__footer__${footer ? "" : "hide"}">
          ${footer ?? ""}
        </div>
      </div>`;
        } catch (e) {
          console.error(e);
        }
      }
      function triggerPrint() {
        if (tlenv.isChromeForIos) {
          beforePrintHandler();
          window.print();
        } else if (tlenv.isSafari) {
          beforePrintHandler();
          document.execCommand("print", false);
        } else {
          window.print();
        }
      }
      const selectedShapeIds = editor.getSelectedShapeIds();
      const currentPageId = editor.getCurrentPageId();
      const pages = editor.getPages();
      const preserveAspectRatio = "xMidYMid meet";
      const svgOpts = {
        scale: 1,
        background: false,
        darkMode: false,
        preserveAspectRatio
      };
      if (editor.getSelectedShapeIds().length > 0) {
        const svgExport = await editor.getSvgString(selectedShapeIds, svgOpts);
        if (svgExport) {
          const page = pages.find((p) => p.id === currentPageId);
          addPageToPrint(`tldraw — ${page?.name}`, null, svgExport.svg);
          triggerPrint();
        }
      } else {
        {
          const page = editor.getCurrentPage();
          const svgExport = await editor.getSvgString(
            editor.getSortedChildIdsForParent(page.id),
            svgOpts
          );
          if (svgExport) {
            addPageToPrint(`tldraw — ${page.name}`, null, svgExport.svg);
            triggerPrint();
          }
        }
      }
      window.removeEventListener("beforeprint", beforePrintHandler);
      window.removeEventListener("afterprint", afterPrintHandler);
    },
    [editor]
  );
}
function useDefaultHelpers() {
  const { addToast, removeToast, clearToasts } = useToasts();
  const { addDialog, clearDialogs, removeDialog } = useDialogs();
  const msg2 = useTranslation();
  const insertMedia = useInsertMedia();
  const printSelectionOrPages = usePrint();
  const { cut: cut2, copy: copy2, paste } = useMenuClipboardEvents();
  const copyAs2 = useCopyAs();
  const exportAs2 = useExportAs();
  const getEmbedDefinition = useGetEmbedDefinition();
  const breakpoint = useBreakpoint();
  const isMobile = breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM;
  return reactExports.useMemo(
    () => ({
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg: msg2,
      isMobile,
      insertMedia,
      printSelectionOrPages,
      cut: cut2,
      copy: copy2,
      paste,
      copyAs: copyAs2,
      exportAs: exportAs2,
      getEmbedDefinition
    }),
    [
      addToast,
      removeToast,
      clearToasts,
      addDialog,
      removeDialog,
      clearDialogs,
      msg2,
      isMobile,
      insertMedia,
      printSelectionOrPages,
      cut2,
      copy2,
      paste,
      copyAs2,
      exportAs2,
      getEmbedDefinition
    ]
  );
}
function mergeOverrides(overrides, defaultHelpers) {
  const mergedTranslations = {};
  for (const override of overrides) {
    if (override.translations) {
      for (const [key, value] of objectMapEntries(override.translations)) {
        let strings = mergedTranslations[key];
        if (!strings) {
          strings = mergedTranslations[key] = {};
        }
        Object.assign(strings, value);
      }
    }
  }
  return {
    actions: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.actions) {
          schema = override.actions(editor, schema, helpers);
        }
      }
      return schema;
    },
    tools: (editor, schema, helpers) => {
      for (const override of overrides) {
        if (override.tools) {
          schema = override.tools(editor, schema, { ...defaultHelpers, ...helpers });
        }
      }
      return schema;
    },
    translations: mergedTranslations
  };
}
function useShallowArrayEquality(array2) {
  return reactExports.useMemo(() => array2, array2);
}
function useMergedTranslationOverrides(overrides) {
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return reactExports.useMemo(() => {
    const mergedTranslations = {};
    for (const override of overridesArray) {
      if (override.translations) {
        for (const [key, value] of objectMapEntries(override.translations)) {
          let strings = mergedTranslations[key];
          if (!strings) {
            strings = mergedTranslations[key] = {};
          }
          Object.assign(strings, value);
        }
      }
    }
    return mergedTranslations;
  }, [overridesArray]);
}
function useMergedOverrides(overrides) {
  const defaultHelpers = useDefaultHelpers();
  const overridesArray = useShallowArrayEquality(
    overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
  );
  return reactExports.useMemo(
    () => mergeOverrides(overridesArray, defaultHelpers),
    [overridesArray, defaultHelpers]
  );
}
const ActionsContext = reactExports.createContext(null);
function makeActions(actions) {
  return Object.fromEntries(actions.map((action) => [action.id, action]));
}
function getExportName(editor, defaultName) {
  const selectedShapes = editor.getSelectedShapes();
  if (selectedShapes.length === 0) {
    return editor.getDocumentSettings().name || defaultName;
  }
  return void 0;
}
function ActionsProvider({ overrides, children }) {
  const _editor = useMaybeEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const helpers = useDefaultHelpers();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const defaultDocumentName = helpers.msg("document.default-name");
  const actions = reactExports.useMemo(() => {
    const editor = _editor;
    if (!editor) return {};
    function mustGoBackToSelectToolFirst() {
      if (!editor.isIn("select")) {
        editor.complete();
        editor.setCurrentTool("select");
        return false;
      }
      return false;
    }
    function canApplySelectionAction() {
      return editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
    }
    function scaleShapes(scaleFactor) {
      if (!canApplySelectionAction()) return;
      if (mustGoBackToSelectToolFirst()) return;
      editor.markHistoryStoppingPoint("resize shapes");
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0) return;
      editor.run(() => {
        const shapes = selectedShapeIds.map((id) => editor.getShape(id)).filter(Boolean);
        shapes.forEach((shape) => {
          editor.resizeShape(shape.id, new Vec(scaleFactor, scaleFactor), {
            scaleOrigin: editor.getSelectionPageBounds()?.center
          });
        });
      });
    }
    const actionItems = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("edit-link", { source });
          editor.markHistoryStoppingPoint("edit-link");
          helpers.addDialog({ component: EditLinkDialog });
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "cmd+i,ctrl+i",
        onSelect(source) {
          trackEvent("insert-embed", { source });
          helpers.addDialog({ component: EmbedDialog });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          trackEvent("insert-media", { source });
          helpers.insertMedia();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "cmd+z,ctrl+z",
        onSelect(source) {
          trackEvent("undo", { source });
          editor.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "cmd+shift+z,ctrl+shift+z",
        onSelect(source) {
          trackEvent("redo", { source });
          editor.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          ["context-menu"]: "action.export-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-as", { format: "svg", source });
          helpers.exportAs(ids, "svg", getExportName(editor, defaultDocumentName));
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          ["context-menu"]: "action.export-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-as", { format: "png", source });
          helpers.exportAs(ids, "png", getExportName(editor, defaultDocumentName));
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          ["context-menu"]: "action.export-all-as-svg.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-all-as", { format: "svg", source });
          helpers.exportAs(
            Array.from(editor.getCurrentPageShapeIds()),
            "svg",
            getExportName(editor, defaultDocumentName)
          );
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          ["context-menu"]: "action.export-all-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          const ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("export-all-as", { format: "png", source });
          helpers.exportAs(ids, "png", getExportName(editor, defaultDocumentName));
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          ["context-menu"]: "action.copy-as-svg.short"
        },
        kbd: "cmd+shift+c,ctrl+shift+c",
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("copy-as", { format: "svg", source });
          helpers.copyAs(ids, "svg");
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          ["context-menu"]: "action.copy-as-png.short"
        },
        readonlyOk: true,
        onSelect(source) {
          let ids = editor.getSelectedShapeIds();
          if (ids.length === 0) ids = Array.from(editor.getCurrentPageShapeIds().values());
          if (ids.length === 0) return;
          trackEvent("copy-as", { format: "png", source });
          helpers.copyAs(ids, "png");
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("toggle-auto-size", { source });
          editor.markHistoryStoppingPoint("toggling auto size");
          editor.run(() => {
            const shapes = editor.getSelectedShapes().filter(
              (shape) => editor.isShapeOfType(shape, "text") && shape.props.autoSize === false
            );
            editor.updateShapes(
              shapes.map((shape) => {
                return {
                  id: shape.id,
                  type: shape.type,
                  props: {
                    ...shape.props,
                    w: 8,
                    autoSize: true
                  }
                };
              })
            );
            kickoutOccludedShapes(
              editor,
              shapes.map((shape) => shape.id)
            );
          });
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("open-embed-link", { source });
          const ids = editor.getSelectedShapeIds();
          const warnMsg = "No embed shapes selected";
          if (ids.length !== 1) {
            console.error(warnMsg);
            return;
          }
          const shape = editor.getShape(ids[0]);
          if (!shape || !editor.isShapeOfType(shape, "embed")) {
            console.error(warnMsg);
            return;
          }
          openWindow(shape.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: true,
        kbd: "z",
        onSelect(source) {
          if (editor.root.getCurrent()?.id === "zoom") return;
          trackEvent("zoom-tool", { source });
          if (!(editor.inputs.shiftKey || editor.inputs.ctrlKey)) {
            const currentTool = editor.root.getCurrent();
            if (currentTool && currentTool.getCurrent()?.id === "idle") {
              editor.setCurrentTool("zoom", { onInteractionEnd: currentTool.id, maskAs: "zoom" });
            }
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          editor.run(() => {
            trackEvent("convert-to-bookmark", { source });
            const shapes = editor.getSelectedShapes();
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!shape || !editor.isShapeOfType(shape, "embed") || !shape.props.url)
                continue;
              const newPos = new Vec(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec(shape.props.w / 2 - 300 / 2, shape.props.h / 2 - 320 / 2));
              newPos.rot(shape.rotation);
              const partial = {
                id: createShapeId(),
                type: "bookmark",
                rotation: shape.rotation,
                x: newPos.x,
                y: newPos.y,
                opacity: 1,
                props: {
                  url: shape.props.url
                }
              };
              createList.push(partial);
              deleteList.push(shape.id);
            }
            editor.markHistoryStoppingPoint("convert shapes to bookmark");
            editor.deleteShapes(deleteList);
            editor.createShapes(createList);
          });
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("convert-to-embed", { source });
          editor.run(() => {
            const ids = editor.getSelectedShapeIds();
            const shapes = compact$1(ids.map((id) => editor.getShape(id)));
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!editor.isShapeOfType(shape, "bookmark")) continue;
              const { url } = shape.props;
              const embedInfo = helpers.getEmbedDefinition(url);
              if (!embedInfo) continue;
              if (!embedInfo.definition) continue;
              const { width, height } = embedInfo.definition;
              const newPos = new Vec(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec(shape.props.w / 2 - width / 2, shape.props.h / 2 - height / 2));
              newPos.rot(shape.rotation);
              const shapeToCreate = {
                id: createShapeId(),
                type: "embed",
                x: newPos.x,
                y: newPos.y,
                rotation: shape.rotation,
                props: {
                  url,
                  w: width,
                  h: height
                }
              };
              createList.push(shapeToCreate);
              deleteList.push(shape.id);
            }
            editor.markHistoryStoppingPoint("convert shapes to embed");
            editor.deleteShapes(deleteList);
            editor.createShapes(createList);
          });
        }
      },
      {
        id: "duplicate",
        kbd: "cmd+d,ctrl+d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("duplicate-shapes", { source });
          const instanceState = editor.getInstanceState();
          let ids;
          let offset2;
          if (instanceState.duplicateProps) {
            ids = instanceState.duplicateProps.shapeIds;
            offset2 = instanceState.duplicateProps.offset;
          } else {
            ids = editor.getSelectedShapeIds();
            const commonBounds = Box.Common(compact$1(ids.map((id) => editor.getShapePageBounds(id))));
            offset2 = editor.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: editor.options.adjacentShapeMargin,
              y: editor.options.adjacentShapeMargin
            } : {
              x: commonBounds.width + editor.options.adjacentShapeMargin,
              y: 0
            };
          }
          editor.markHistoryStoppingPoint("duplicate shapes");
          editor.duplicateShapes(ids, offset2);
          if (instanceState.duplicateProps) {
            editor.updateInstanceState({
              duplicateProps: {
                ...instanceState.duplicateProps,
                shapeIds: editor.getSelectedShapeIds()
              }
            });
          }
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "cmd+shift+g,ctrl+shift+g",
        icon: "ungroup",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("ungroup-shapes", { source });
          editor.markHistoryStoppingPoint("ungroup");
          editor.ungroupShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "cmd+g,ctrl+g",
        icon: "group",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("group-shapes", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "group")) {
            editor.markHistoryStoppingPoint("ungroup");
            editor.ungroupShapes(editor.getSelectedShapeIds());
          } else {
            editor.markHistoryStoppingPoint("group");
            editor.groupShapes(editor.getSelectedShapeIds());
          }
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "cmd+shift+f,ctrl+shift+f",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          trackEvent("remove-frame", { source });
          const selectedShapes = editor.getSelectedShapes();
          if (selectedShapes.length > 0 && selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"))) {
            editor.markHistoryStoppingPoint("remove-frame");
            removeFrame(
              editor,
              selectedShapes.map((shape) => shape.id)
            );
          }
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          trackEvent("fit-frame-to-content", { source });
          const onlySelectedShape = editor.getOnlySelectedShape();
          if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "frame")) {
            editor.markHistoryStoppingPoint("fit-frame-to-content");
            fitFrameToContent(editor, onlySelectedShape.id);
          }
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "alt+A",
        icon: "align-left",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "left", source });
          editor.markHistoryStoppingPoint("align left");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "left");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          ["context-menu"]: "action.align-center-horizontal.short"
        },
        kbd: "alt+H",
        icon: "align-center-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "center-horizontal", source });
          editor.markHistoryStoppingPoint("align center horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "alt+D",
        icon: "align-right",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "right", source });
          editor.markHistoryStoppingPoint("align right");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "right");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          ["context-menu"]: "action.align-center-vertical.short"
        },
        kbd: "alt+V",
        icon: "align-center-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "center-vertical", source });
          editor.markHistoryStoppingPoint("align center vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "center-vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "alt+W",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "top", source });
          editor.markHistoryStoppingPoint("align top");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "top");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "alt+S",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("align-shapes", { operation: "bottom", source });
          editor.markHistoryStoppingPoint("align bottom");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.alignShapes(selectedShapeIds, "bottom");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          ["context-menu"]: "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "alt+shift+h",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("distribute-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("distribute horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          ["context-menu"]: "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "alt+shift+V",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("distribute-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("distribute vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.distributeShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          ["context-menu"]: "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stretch-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stretch horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          ["context-menu"]: "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stretch-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stretch vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stretchShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          ["context-menu"]: "action.flip-horizontal.short"
        },
        kbd: "shift+h",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("flip-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("flip horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "horizontal");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", ["context-menu"]: "action.flip-vertical.short" },
        kbd: "shift+v",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("flip-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("flip vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.flipShapes(selectedShapeIds, "vertical");
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("pack-shapes", { source });
          editor.markHistoryStoppingPoint("pack");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.packShapes(selectedShapeIds, editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          ["context-menu"]: "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stack-shapes", { operation: "vertical", source });
          editor.markHistoryStoppingPoint("stack-vertical");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "vertical", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          ["context-menu"]: "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("stack-shapes", { operation: "horizontal", source });
          editor.markHistoryStoppingPoint("stack-horizontal");
          editor.run(() => {
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.stackShapes(selectedShapeIds, "horizontal", editor.options.adjacentShapeMargin);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "toFront", source });
          editor.markHistoryStoppingPoint("bring to front");
          editor.bringToFront(editor.getSelectedShapeIds());
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "alt+]",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "forward", source });
          editor.markHistoryStoppingPoint("bring forward");
          editor.bringForward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "alt+[",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "backward", source });
          editor.markHistoryStoppingPoint("send backward");
          editor.sendBackward(editor.getSelectedShapeIds());
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("reorder-shapes", { operation: "toBack", source });
          editor.markHistoryStoppingPoint("send to back");
          editor.sendToBack(editor.getSelectedShapeIds());
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "cmd+x,ctrl+x",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          editor.markHistoryStoppingPoint("cut");
          helpers.cut(source);
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "cmd+c,ctrl+c",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          helpers.copy(source);
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "cmd+v,ctrl+v",
        onSelect(source) {
          navigator.clipboard?.read().then((clipboardItems) => {
            helpers.paste(
              clipboardItems,
              source,
              source === "context-menu" ? editor.inputs.currentPagePoint : void 0
            );
          }).catch(() => {
            helpers.addToast({
              title: helpers.msg("action.paste-error-title"),
              description: helpers.msg("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "cmd+a,ctrl+a",
        readonlyOk: true,
        onSelect(source) {
          editor.run(() => {
            if (mustGoBackToSelectToolFirst()) return;
            trackEvent("select-all-shapes", { source });
            editor.markHistoryStoppingPoint("select all kbd");
            editor.selectAll();
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("select-none-shapes", { source });
          editor.markHistoryStoppingPoint("select none");
          editor.selectNone();
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫,del",
        icon: "trash",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("delete-shapes", { source });
          editor.markHistoryStoppingPoint("delete");
          editor.deleteShapes(editor.getSelectedShapeIds());
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("rotate-cw", { source });
          editor.markHistoryStoppingPoint("rotate-cw");
          editor.run(() => {
            const offset2 = editor.getSelectionRotation() % (HALF_PI / 2);
            const dontUseOffset = approximately(offset2, 0) || approximately(offset2, HALF_PI / 2);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, HALF_PI / 2 - (dontUseOffset ? 0 : offset2));
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("rotate-ccw", { source });
          editor.markHistoryStoppingPoint("rotate-ccw");
          editor.run(() => {
            const offset2 = editor.getSelectionRotation() % (HALF_PI / 2);
            const offsetCloseToZero = approximately(offset2, 0);
            const selectedShapeIds = editor.getSelectedShapeIds();
            editor.rotateShapesBy(selectedShapeIds, offsetCloseToZero ? -(HALF_PI / 2) : -offset2);
            kickoutOccludedShapes(editor, selectedShapeIds);
          });
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "cmd+=,ctrl+=,=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: false });
          editor.zoomIn(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-in-on-cursor",
        label: "action.zoom-in",
        kbd: "shift+cmd+=,shift+ctrl+=,shift+=",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-in", { source, towardsCursor: true });
          editor.zoomIn(editor.inputs.currentScreenPoint, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "cmd+-,ctrl+-,-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: false });
          editor.zoomOut(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out-on-cursor",
        label: "action.zoom-out",
        kbd: "shift+cmd+-,shift+ctrl+-,shift+-",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-out", { source, towardsCursor: true });
          editor.zoomOut(editor.inputs.currentScreenPoint, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "shift+0",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("reset-zoom", { source });
          editor.resetZoom(void 0, {
            animation: { duration: editor.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "shift+1",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-fit", { source });
          editor.zoomToFit({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "shift+2",
        readonlyOk: true,
        onSelect(source) {
          if (!canApplySelectionAction()) return;
          if (mustGoBackToSelectToolFirst()) return;
          trackEvent("zoom-to-selection", { source });
          editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } });
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(source) {
          trackEvent("toggle-snap-mode", { source });
          editor.user.updateUserPreferences({ isSnapMode: !editor.user.getIsSnapMode() });
        },
        checkbox: true
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "cmd+/,ctrl+/",
        readonlyOk: true,
        onSelect(source) {
          const value = editor.user.getIsDarkMode() ? "light" : "dark";
          trackEvent("color-scheme", { source, value });
          editor.user.updateUserPreferences({
            colorScheme: value
          });
        },
        checkbox: true
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-wrap-mode", { source });
          editor.user.updateUserPreferences({
            isWrapMode: !editor.user.getIsWrapMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-dynamic-size-mode", { source });
          editor.user.updateUserPreferences({
            isDynamicSizeMode: !editor.user.getIsDynamicResizeMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: false,
        onSelect(source) {
          trackEvent("toggle-paste-at-cursor", { source });
          editor.user.updateUserPreferences({
            isPasteAtCursorMode: !editor.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: true
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-reduce-motion", { source });
          editor.user.updateUserPreferences({
            animationSpeed: editor.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-edge-scrolling", { source });
          editor.user.updateUserPreferences({
            edgeScrollSpeed: editor.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: true
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          ["context-menu"]: "action.toggle-transparent.context-menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-transparent", { source });
          editor.updateInstanceState({
            exportBackground: !editor.getInstanceState().exportBackground
          });
        },
        checkbox: true
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(source) {
          trackEvent("toggle-tool-lock", { source });
          editor.updateInstanceState({ isToolLocked: !editor.getInstanceState().isToolLocked });
        },
        checkbox: true
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(source) {
          trackEvent("unlock-all", { source });
          const updates = [];
          for (const shape of editor.getCurrentPageShapes()) {
            if (shape.isLocked) {
              updates.push({ id: shape.id, type: shape.type, isLocked: false });
            }
          }
          if (updates.length > 0) {
            editor.updateShapes(updates);
          }
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: true,
        kbd: "cmd+.,ctrl+.",
        checkbox: true,
        onSelect(source) {
          editor.timers.requestAnimationFrame(() => {
            editor.run(() => {
              trackEvent("toggle-focus-mode", { source });
              helpers.clearDialogs();
              helpers.clearToasts();
              editor.updateInstanceState({ isFocusMode: !editor.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: true,
        kbd: "cmd+',ctrl+'",
        onSelect(source) {
          trackEvent("toggle-grid-mode", { source });
          editor.updateInstanceState({ isGridMode: !editor.getInstanceState().isGridMode });
        },
        checkbox: true
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: true,
        onSelect(source) {
          trackEvent("toggle-debug-mode", { source });
          editor.updateInstanceState({
            isDebugMode: !editor.getInstanceState().isDebugMode
          });
        },
        checkbox: true
      },
      {
        id: "print",
        label: "action.print",
        kbd: "cmd+p,ctrl+p",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("print", { source });
          helpers.printSelectionOrPages();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("exit-pen-mode", { source });
          editor.updateInstanceState({ isPenMode: false });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("stop-following", { source });
          editor.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: true,
        onSelect(source) {
          trackEvent("zoom-to-content", { source });
          const bounds = editor.getSelectionPageBounds() ?? editor.getCurrentPageBounds();
          if (!bounds) return;
          editor.zoomToBounds(bounds, {
            targetZoom: Math.min(1, editor.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "shift+l",
        onSelect(source) {
          editor.markHistoryStoppingPoint("locking");
          trackEvent("toggle-lock", { source });
          editor.toggleLock(editor.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(source) {
          const newPageId = PageRecordType.createId();
          const ids = editor.getSelectedShapeIds();
          editor.run(() => {
            editor.markHistoryStoppingPoint("move_shapes_to_page");
            editor.createPage({
              name: helpers.msg("page-menu.new-page-initial-name"),
              id: newPageId
            });
            editor.moveShapesToPage(ids, newPageId);
          });
          trackEvent("move-to-new-page", { source });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "alt+t",
        onSelect(source) {
          const style2 = DefaultColorStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-color");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "white");
            }
            editor.setStyleForNextShapes(style2, "white");
          });
          trackEvent("set-style", { source, id: style2.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "alt+f",
        onSelect(source) {
          const style2 = DefaultFillStyle;
          editor.run(() => {
            editor.markHistoryStoppingPoint("change-fill");
            if (editor.isIn("select")) {
              editor.setStyleForSelectedShapes(style2, "fill");
            }
            editor.setStyleForNextShapes(style2, "fill");
          });
          trackEvent("set-style", { source, id: style2.id, value: "fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "shift+f",
        onSelect: async (source) => {
          const ids = editor.getSelectedShapeIds();
          if (ids.length === 0) return;
          editor.markHistoryStoppingPoint("flattening to image");
          trackEvent("flatten-to-image", { source });
          const newShapeIds = await flattenShapesToImages(
            editor,
            ids,
            editor.options.flattenImageBoundsExpand
          );
          if (newShapeIds?.length) {
            editor.setSelectedShapes(newShapeIds);
          }
        }
      },
      {
        id: "select-geo-tool",
        kbd: "g",
        onSelect: async (source) => {
          trackEvent("select-tool", { source, id: `geo-previous` });
          editor.setCurrentTool("geo");
        }
      },
      {
        id: "change-page-prev",
        kbd: "alt+left,alt+up",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex < 1) return;
          trackEvent("change-page", { source, direction: "prev" });
          editor.setCurrentPage(pages[currentPageIndex - 1].id);
        }
      },
      {
        id: "change-page-next",
        kbd: "alt+right,alt+down",
        readonlyOk: true,
        onSelect: async (source) => {
          const pages = editor.getPages();
          const currentPageIndex = pages.findIndex((page) => page.id === editor.getCurrentPageId());
          if (currentPageIndex === -1 || currentPageIndex >= pages.length - 1) {
            if (editor.getCurrentPageShapes().length <= 0 || editor.getIsReadonly()) {
              return;
            }
            trackEvent("new-page", { source });
            editor.run(() => {
              editor.markHistoryStoppingPoint("creating page");
              const newPageId = PageRecordType.createId();
              editor.createPage({
                name: helpers.msg("page-menu.new-page-initial-name"),
                id: newPageId
              });
              editor.setCurrentPage(newPageId);
            });
            return;
          }
          editor.setCurrentPage(pages[currentPageIndex + 1].id);
          trackEvent("change-page", { source, direction: "next" });
        }
      },
      {
        id: "adjust-shape-styles",
        label: "a11y.adjust-shape-styles",
        kbd: "cmd+Enter,ctrl+Enter",
        onSelect: async (source) => {
          if (!canApplySelectionAction()) return;
          const firstButton = editor.getContainer().querySelector(".tlui-style-panel button");
          firstButton?.focus();
          trackEvent("adjust-shape-styles", { source });
        }
      },
      {
        id: "enlarge-shapes",
        label: "a11y.enlarge-shape",
        kbd: "cmd+alt+shift+=,ctrl+alt+shift+=",
        onSelect: async (source) => {
          scaleShapes(1.1);
          trackEvent("enlarge-shapes", { source });
        }
      },
      {
        id: "shrink-shapes",
        label: "a11y.shrink-shape",
        kbd: "cmd+alt+shift+-,ctrl+alt+shift+-",
        onSelect: async (source) => {
          scaleShapes(1 / 1.1);
          trackEvent("shrink-shapes", { source });
        }
      },
      {
        id: "a11y-repeat-shape-announce",
        kbd: "alt+r",
        label: "a11y.repeat-shape",
        readonlyOk: true,
        onSelect: async (source) => {
          const selectedShapeIds = editor.getSelectedShapeIds();
          if (!selectedShapeIds.length) return;
          const a11yLive = generateShapeAnnouncementMessage({
            editor,
            selectedShapeIds,
            msg: msg2
          });
          if (a11yLive) {
            a11y.announce({ msg: "" });
            editor.timers.requestAnimationFrame(() => {
              a11y.announce({ msg: a11yLive });
            });
            trackEvent("a11y-repeat-shape-announce", { source });
          }
        }
      }
    ];
    if (showCollaborationUi) {
      actionItems.push({
        id: "open-cursor-chat",
        label: "action.open-cursor-chat",
        readonlyOk: true,
        kbd: "/",
        onSelect(source) {
          trackEvent("open-cursor-chat", { source });
          if (editor.getInstanceState().isCoarsePointer) {
            return;
          }
          editor.timers.requestAnimationFrame(() => {
            editor.updateInstanceState({ isChatting: true });
          });
        }
      });
    }
    const actions2 = makeActions(actionItems);
    if (overrides) {
      return overrides(editor, actions2, helpers);
    }
    return actions2;
  }, [helpers, _editor, trackEvent, overrides, defaultDocumentName, showCollaborationUi, msg2, a11y]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsContext.Provider, { value: asActions(actions), children });
}
function useActions() {
  const ctx = reactExports.useContext(ActionsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function asActions(actions) {
  return actions;
}
function unwrapLabel(label, menuType) {
  return label ? typeof label === "string" ? label : menuType ? label[menuType] ?? label["default"] : void 0 : void 0;
}
function useReadonly() {
  const editor = useMaybeEditor();
  return useValue("isReadonlyMode", () => !!editor?.getIsReadonly(), [editor]);
}
const cmdKey = tlenv.isDarwin ? "⌘" : "Ctrl";
const altKey = tlenv.isDarwin ? "⌥" : "Alt";
function kbd(str2) {
  if (str2 === ",") return [","];
  return str2.split(",")[0].split(/(\[\[[^\]]+\]\])/g).map(
    (s2) => s2.startsWith("[[") ? s2.replace(/[[\]]/g, "") : s2.replace(/cmd\+/g, cmdKey).replace(/ctrl\+/g, cmdKey).replace(/alt\+/g, altKey).replace(/shift\+/g, "⇧").replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, "⇧").split("")
  ).flat().map((sub) => {
    return sub[0].toUpperCase() + sub.slice(1);
  });
}
function kbdStr(str2) {
  return "— " + kbd(str2).join(" ");
}
function TldrawUiKbd({ children, visibleOnMobileLayout = false }) {
  const breakpoint = useBreakpoint();
  if (!visibleOnMobileLayout && breakpoint < PORTRAIT_BREAKPOINT.MOBILE) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("kbd", { className: "tlui-kbd", children: kbd(children).map((k, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: k }, i)) });
}
const menuContext = reactExports.createContext(null);
function useTldrawUiMenuContext() {
  const context = reactExports.useContext(menuContext);
  if (!context) {
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  }
  return context;
}
function TldrawUiMenuContextProvider({
  type,
  sourceId,
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(menuContext.Provider, { value: { type, sourceId }, children });
}
function TldrawUiMenuCheckboxItem({
  id,
  kbd: kbd2,
  label,
  readonlyOk,
  onSelect,
  toggle = false,
  disabled = false,
  checked = false
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const isReadonlyMode = useReadonly();
  const msg2 = useTranslation();
  if (isReadonlyMode && !readonlyOk) return null;
  const labelToUse = unwrapLabel(label, menuType);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CheckboxItem2,
        {
          dir: "ltr",
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: labelStr,
          onSelect: (e) => {
            onSelect?.(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 })
          ]
        }
      );
    }
    case "context-menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        CheckboxItem2$1,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          title: labelStr,
          onSelect: (e) => {
            onSelect(sourceId);
            preventDefault(e);
          },
          disabled,
          checked,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiIcon,
              {
                small: true,
                label: msg2(checked ? "ui.checked" : "ui.unchecked"),
                icon: toggle ? checked ? "toggle-on" : "toggle-off" : checked ? "check" : "none"
              }
            ),
            labelStr && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 })
          ]
        },
        id
      );
    }
    default: {
      return null;
    }
  }
}
function useMenuIsOpen(id, cb) {
  const editor = useMaybeEditor();
  const onChange = reactExports.useCallback(
    (isOpen) => {
      if (isOpen) {
        editor?.complete();
      }
      cb?.(isOpen);
    },
    [editor, cb]
  );
  const trackEvent = useUiEvents();
  const onEvent = reactExports.useCallback(
    (eventName) => {
      trackEvent(eventName, { source: "unknown", id });
    },
    [id, trackEvent]
  );
  return useGlobalMenuIsOpen(editor ? `${id}-${editor.contextId}` : id, onChange, onEvent);
}
function TldrawUiDropdownMenuRoot({
  id,
  children,
  modal = false,
  debugOpen = false
}) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2$3,
    {
      open: debugOpen || open,
      dir: "ltr",
      modal,
      onOpenChange,
      children
    }
  );
}
function TldrawUiDropdownMenuTrigger({ children, ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Trigger$1,
    {
      dir: "ltr",
      asChild: true,
      onTouchEnd: (e) => preventDefault(e),
      ...rest,
      children
    }
  );
}
function TldrawUiDropdownMenuContent({
  className,
  side = "bottom",
  align = "start",
  sideOffset = 8,
  alignOffset = 8,
  children
}) {
  const container = useContainer();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2$1,
    {
      className: classNames("tlui-menu", className),
      side,
      sideOffset,
      align,
      alignOffset,
      collisionPadding: 4,
      children
    }
  ) });
}
function TldrawUiDropdownMenuSub({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Sub2, { open, onOpenChange, children });
}
function TldrawUiDropdownMenuSubTrigger({
  id,
  label,
  title,
  disabled
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger2, { dir: "ltr", asChild: true, disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiButton,
    {
      "data-testid": id,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled,
      title,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
      ]
    }
  ) });
}
function TldrawUiDropdownMenuSubContent({
  id,
  alignOffset = -1,
  sideOffset = -6,
  size: size2 = "small",
  children
}) {
  const container = useContainer();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent2,
    {
      "data-testid": id,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset,
      sideOffset,
      collisionPadding: 4,
      "data-size": size2,
      children
    }
  ) });
}
function TldrawUiDropdownMenuGroup({ className, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dir: "ltr", className: classNames("tlui-menu__group", className), children });
}
function TldrawUiDropdownMenuItem({ noClose, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$1, { dir: "ltr", asChild: true, onClick: noClose ? preventDefault : void 0, children });
}
function TldrawUiMenuGroup({ id, label, className, children }) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const msg2 = useTranslation();
  const labelToUse = unwrapLabel(label, menuType);
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "panel": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: classNames("tlui-menu__group", className),
          "data-testid": `${sourceId}-group.${id}`,
          children
        }
      );
    }
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuGroup, { className, "data-testid": `${sourceId}-group.${id}`, children });
    }
    case "context-menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          dir: "ltr",
          className: classNames("tlui-menu__group", className),
          "data-testid": `${sourceId}-group.${id}`,
          children
        }
      );
    }
    case "keyboard-shortcuts": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${sourceId}-group.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: labelStr }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children })
      ] });
    }
    default: {
      return children;
    }
  }
}
function TldrawUiMenuSubmenu({
  id,
  disabled = false,
  label,
  size: size2 = "small",
  children
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const container = useContainer();
  const msg2 = useTranslation();
  const labelToUse = label ? typeof label === "string" ? label : label[menuType] ?? label["default"] : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  switch (menuType) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuSub, { id: `${sourceId}-sub.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiDropdownMenuSubTrigger,
          {
            id: `${sourceId}-sub.${id}-button`,
            disabled,
            label: labelStr,
            title: labelStr
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuSubContent, { id: `${sourceId}-sub.${id}-content`, size: size2, children })
      ] });
    }
    case "context-menu": {
      if (disabled) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ContextMenuSubWithMenu, { id: `${sourceId}-sub.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenuSubTrigger, { dir: "ltr", disabled, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TldrawUiButton,
          {
            "data-testid": `${sourceId}-sub.${id}-button`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-right", small: true })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenuPortal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ContextMenuSubContent,
          {
            "data-testid": `${sourceId}-sub.${id}-content`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": size2,
            children
          }
        ) })
      ] });
    }
    default: {
      return children;
    }
  }
}
function ContextMenuSubWithMenu({ id, children }) {
  const [open, onOpenChange] = useMenuIsOpen(id);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextMenuSub, { open, onOpenChange, children });
}
const COLOR_SCHEMES = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function ColorSchemeMenu() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const currentColorScheme = useValue(
    "colorScheme",
    () => editor.user.getUserPreferences().colorScheme ?? (editor.user.getIsDarkMode() ? "dark" : "light"),
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "help menu color-scheme", label: "menu.theme", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "theme", children: COLOR_SCHEMES.map(({ colorScheme, label }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: `color-scheme-${colorScheme}`,
      label,
      checked: colorScheme === currentColorScheme,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ colorScheme });
        trackEvent("color-scheme", { source: "menu", value: colorScheme });
      }
    },
    colorScheme
  )) }) });
}
const TldrawUiDialog = ({
  id,
  component: ModalContent,
  onClose,
  preventBackgroundClose
}) => {
  const { removeDialog } = useDialogs();
  const mouseDownInsideContentRef = reactExports.useRef(false);
  const container = useContainer();
  const handleOpenChange = reactExports.useCallback(
    (isOpen) => {
      if (!isOpen) {
        if (onClose) {
          try {
            onClose();
          } catch (err) {
            console.warn(err);
          }
        }
        removeDialog(id);
      }
    },
    [id, onClose, removeDialog]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root$4, { onOpenChange: handleOpenChange, defaultOpen: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Overlay,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (e) => {
        if (mouseDownInsideContentRef.current) return;
        if (!preventBackgroundClose && e.target === e.currentTarget) handleOpenChange(false);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Content$1,
        {
          dir: "ltr",
          className: "tlui-dialog__content",
          "aria-describedby": void 0,
          onMouseDown: () => mouseDownInsideContentRef.current = true,
          onMouseUp: () => mouseDownInsideContentRef.current = false,
          onInteractOutside: (e) => {
            mouseDownInsideContentRef.current = false;
            if (preventBackgroundClose) {
              e.preventDefault();
            }
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ModalContent,
            {
              onClose: () => {
                mouseDownInsideContentRef.current = false;
                handleOpenChange(false);
              }
            }
          )
        }
      )
    }
  ) }) });
};
const DefaultDialogs = reactExports.memo(function DefaultDialogs2() {
  const { dialogs } = useDialogs();
  const dialogsArray = useValue("dialogs", () => dialogs.get(), [dialogs]);
  return dialogsArray.map((dialog) => /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialog, { ...dialog }, dialog.id));
});
const DEFAULT_TOAST_DURATION = 4e3;
const SEVERITY_TO_ICON = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function TldrawUiToast({ toast }) {
  const { removeToast } = useToasts();
  const msg2 = useTranslation();
  const onOpenChange = (isOpen) => {
    if (!isOpen) {
      removeToast(toast.id);
    }
  };
  const hasActions = toast.actions && toast.actions.length > 0;
  const icon = toast.icon || toast.severity && SEVERITY_TO_ICON[toast.severity];
  const iconLabel = toast.iconLabel || (toast.severity ? msg2(`toast.${toast.severity}`) : "");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root2$1,
    {
      onOpenChange,
      className: "tlui-toast__container",
      duration: toast.keepOpen ? Infinity : DEFAULT_TOAST_DURATION,
      "data-severity": toast.severity,
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: iconLabel, icon }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "tlui-toast__main",
            "data-title": !!toast.title,
            "data-description": !!toast.description,
            "data-actions": !!toast.actions,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toast__content", children: [
                toast.title && /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { className: "tlui-toast__title", children: toast.title }),
                toast.description && /* @__PURE__ */ jsxRuntimeExports.jsx(Description, { className: "tlui-toast__description", children: toast.description })
              ] }),
              toast.actions && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toast__actions", children: [
                toast.actions.map((action, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(Action, { altText: action.label, asChild: true, onClick: action.onClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: action.type, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: action.label }) }) }, i)),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TldrawUiButton,
                  {
                    type: "normal",
                    className: "tlui-toast__close",
                    style: { marginLeft: "auto" },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") })
                  }
                ) })
              ] })
            ]
          }
        ),
        !hasActions && /* @__PURE__ */ jsxRuntimeExports.jsx(Close, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", className: "tlui-toast__close", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: toast.closeLabel ?? msg2("toast.close") }) }) })
      ]
    }
  );
}
const DefaultToasts = reactExports.memo(function TldrawUiToasts() {
  const { toasts } = useToasts();
  const toastsArray = useValue("toasts", () => toasts.get(), []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    toastsArray.map((toast) => /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToast, { toast }, toast.id)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, { className: "tlui-toast__viewport" })
  ] });
});
function TldrawUiMenuActionCheckboxItem({
  actionId = "",
  ...rest
}) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuCheckboxItem, { ...action, ...rest });
}
function Spinner(props) {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      width: 16,
      height: 16,
      viewBox: "0 0 16 16",
      ...props,
      "aria-label": msg2("app.loading"),
      "aria-hidden": "false",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "animateTransform",
          {
            attributeName: "transform",
            type: "rotate",
            from: "0 8 8",
            to: "360 8 8",
            dur: "1s",
            repeatCount: "indefinite"
          }
        ) })
      ] })
    }
  );
}
const TldrawUiToolbar = React.forwardRef(
  ({ children, className, label, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root4,
      {
        ref,
        ...props,
        className: classNames("tlui-toolbar-container", className),
        "aria-label": label,
        children
      }
    );
  }
);
const TldrawUiToolbarButton = React.forwardRef(
  ({ asChild, children, type, isActive: isActive2, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        ref,
        asChild,
        draggable: false,
        "data-isactive": isActive2,
        ...props,
        className: classNames("tlui-button", `tlui-button__${type}`, props.className),
        children
      }
    );
  }
);
const TldrawUiToolbarToggleGroup = ({
  children,
  className,
  type,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleGroup,
    {
      type,
      ...props,
      className: classNames("tlui-toolbar-toggle-group", className),
      children
    }
  );
};
const TldrawUiToolbarToggleItem = ({
  children,
  className,
  type,
  value,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToggleItem,
    {
      ...props,
      className: classNames(
        "tlui-button",
        `tlui-button__${type}`,
        "tlui-toolbar-toggle-group-item",
        className
      ),
      value,
      children
    }
  );
};
function TldrawUiMenuItem({
  disabled = false,
  spinner = false,
  readonlyOk = false,
  id,
  kbd: kbd2,
  label,
  icon,
  iconLeft,
  onSelect,
  noClose,
  isSelected
}) {
  const { type: menuType, sourceId } = useTldrawUiMenuContext();
  const msg2 = useTranslation();
  const [disableClicks, setDisableClicks] = reactExports.useState(false);
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode && !readonlyOk) return null;
  const labelToUse = unwrapLabel(label, menuType);
  const kbdToUse = kbd2 ? kbdStr(kbd2) : void 0;
  const labelStr = labelToUse ? msg2(labelToUse) : void 0;
  const titleStr = labelStr && kbdToUse ? `${labelStr} ${kbdToUse}` : labelStr;
  switch (menuType) {
    case "menu": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TldrawUiButton,
        {
          type: "menu",
          "data-testid": `${sourceId}.${id}`,
          disabled,
          title: titleStr,
          onClick: (e) => {
            if (noClose) {
              preventDefault(e);
            }
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            iconLeft && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 })
          ]
        }
      ) });
    }
    case "context-menu": {
      if (disabled) return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Item2$2,
        {
          dir: "ltr",
          title: titleStr,
          draggable: false,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${sourceId}.${id}`,
          onSelect: (e) => {
            if (noClose) preventDefault(e);
            if (disableClicks) {
              setDisableClicks(false);
            } else {
              onSelect(sourceId);
            }
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tlui-button__label", draggable: false, children: labelStr }),
            iconLeft && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconLeft, small: true }),
            kbd2 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { children: kbd2 }),
            spinner && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, {})
          ]
        }
      );
    }
    case "panel": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TldrawUiButton,
        {
          "data-testid": `${sourceId}.${id}`,
          type: "menu",
          title: titleStr,
          disabled,
          onClick: () => onSelect(sourceId),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
            spinner ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, {}) : icon && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
          ]
        }
      );
    }
    case "small-icons":
    case "icons": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          "data-testid": `${sourceId}.${id}`,
          type: "icon",
          title: titleStr,
          disabled,
          onClick: () => onSelect(sourceId),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon, small: true })
        }
      );
    }
    case "keyboard-shortcuts": {
      if (!kbd2) {
        console.warn(
          `Menu item '${label}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
        );
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${sourceId}.${id}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: labelStr }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiKbd, { visibleOnMobileLayout: true, children: kbd2 }) })
      ] });
    }
    case "helper-buttons": {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiButton, { type: "low", onClick: () => onSelect(sourceId), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr })
      ] });
    }
    case "toolbar": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          "data-testid": `tools.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          onTouchStart: (e) => {
            preventDefault(e);
            onSelect("toolbar");
          },
          role: "option",
          title: titleStr,
          type: "tool",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
        }
      );
    }
    case "toolbar-overflow": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          "aria-label": labelStr,
          "aria-pressed": isSelected ? "true" : "false",
          isActive: isSelected,
          className: "tlui-button-grid__button",
          "data-testid": `tools.more.${id}`,
          "data-value": id,
          disabled,
          onClick: () => onSelect("toolbar"),
          role: "option",
          title: titleStr,
          type: "icon",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon })
        }
      );
    }
    default: {
      throw exhaustiveSwitchError$1(menuType);
    }
  }
}
function TldrawUiMenuActionItem({ actionId = "", ...rest }) {
  const actions = useActions();
  const action = actions[actionId];
  if (!action) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { ...action, ...rest });
}
const ToolsContext = reactExports.createContext(null);
function ToolsProvider({ overrides, children }) {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const a11y = useA11y();
  const msg2 = useTranslation();
  const helpers = useDefaultHelpers();
  const onToolSelect = reactExports.useCallback(
    (source, tool, id) => {
      a11y.announce({ msg: msg2(tool.label) });
      trackEvent("select-tool", { source, id: id ?? tool.id });
    },
    [a11y, msg2, trackEvent]
  );
  const tools = reactExports.useMemo(() => {
    if (!editor) return {};
    const toolsArray = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: true,
        onSelect(source) {
          if (editor.isIn("select")) {
            const currentNode = editor.root.getCurrent();
            currentNode.exit({}, currentNode.id);
            currentNode.enter({}, currentNode.id);
          }
          editor.setCurrentTool("select");
          onToolSelect(source, this);
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: true,
        onSelect(source) {
          editor.setCurrentTool("hand");
          onToolSelect(source, this);
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(source) {
          editor.setCurrentTool("eraser");
          onToolSelect(source, this);
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(source) {
          editor.setCurrentTool("draw");
          onToolSelect(source, this);
        }
      },
      ...[...GeoShapeGeoStyle.values].map((id) => ({
        id,
        label: `tool.${id}`,
        meta: {
          geo: id
        },
        kbd: id === "rectangle" ? "r" : id === "ellipse" ? "o" : void 0,
        icon: "geo-" + id,
        onSelect(source) {
          editor.run(() => {
            editor.setStyleForNextShapes(GeoShapeGeoStyle, id);
            editor.setCurrentTool("geo");
            onToolSelect(source, this, `geo-${id}`);
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(source) {
          editor.setCurrentTool("arrow");
          onToolSelect(source, this);
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(source) {
          editor.setCurrentTool("line");
          onToolSelect(source, this);
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(source) {
          editor.setCurrentTool("frame");
          onToolSelect(source, this);
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(source) {
          editor.setCurrentTool("text");
          onToolSelect(source, this);
        }
      },
      {
        id: "asset",
        label: "tool.media",
        icon: "tool-media",
        kbd: "cmd+u,ctrl+u",
        onSelect(source) {
          helpers.insertMedia();
          onToolSelect(source, this, "media");
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(source) {
          editor.setCurrentTool("note");
          onToolSelect(source, this);
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: true,
        icon: "tool-laser",
        kbd: "k",
        onSelect(source) {
          editor.setCurrentTool("laser");
          onToolSelect(source, this);
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(source) {
          helpers.addDialog({ component: EmbedDialog });
          onToolSelect(source, this);
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "shift+d",
        onSelect(source) {
          editor.setCurrentTool("highlight");
          onToolSelect(source, this);
        }
      }
    ];
    toolsArray.forEach((t2) => t2.onSelect = t2.onSelect.bind(t2));
    const tools2 = Object.fromEntries(toolsArray.map((t2) => [t2.id, t2]));
    if (overrides) {
      return overrides(editor, tools2, helpers);
    }
    return tools2;
  }, [overrides, editor, helpers, onToolSelect]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolsContext.Provider, { value: tools, children });
}
function useTools() {
  const ctx = reactExports.useContext(ToolsContext);
  if (!ctx) {
    throw new Error("useTools must be used within a ToolProvider");
  }
  return ctx;
}
function TldrawUiMenuToolItem({ toolId = "", ...rest }) {
  const tools = useTools();
  const tool = tools[toolId];
  if (!tool) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { ...tool, ...rest });
}
const ElbowArrowSides = ["right", "bottom", "left", "top"];
const ElbowArrowSideDeltas = {
  top: { x: 0, y: -1 },
  right: { x: 1, y: 0 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 }
};
const ElbowArrowSideAxes = {
  left: "x",
  right: "x",
  top: "y",
  bottom: "y"
};
const ElbowArrowSideOpposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
const ElbowArrowAxes = {
  x: {
    v: (x, y2) => new Vec(x, y2),
    loEdge: "left",
    hiEdge: "right",
    crossMid: "midY",
    gap: "gapX",
    midRange: "midXRange",
    self: "x",
    cross: "y",
    size: "width"
  },
  y: {
    v: (y2, x) => new Vec(x, y2),
    loEdge: "top",
    hiEdge: "bottom",
    crossMid: "midX",
    gap: "gapY",
    midRange: "midYRange",
    self: "y",
    cross: "x",
    size: "height"
  }
};
const arrowTargetStore = new WeakCache();
function getArrowTargetAtom(editor) {
  return arrowTargetStore.get(editor, () => atom("arrowTarget", null));
}
function updateArrowTargetState({
  editor,
  pointInPageSpace,
  arrow: arrow2,
  isPrecise,
  isExact,
  currentBinding,
  oppositeBinding
}) {
  if (editor.inputs.ctrlKey) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const util2 = editor.getShapeUtil("arrow");
  const arrowKind = arrow2 ? arrow2.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle);
  const target = editor.getShapeAtPoint(pointInPageSpace, {
    hitInside: true,
    hitFrameInside: true,
    margin: arrowKind === "elbow" ? 8 : 0,
    filter: (targetShape) => {
      return !targetShape.isLocked && editor.canBindShapes({
        fromShape: arrow2 ?? targetFilterFallback,
        toShape: targetShape,
        binding: "arrow"
      });
    }
  });
  if (!target) {
    getArrowTargetAtom(editor).set(null);
    return null;
  }
  const targetGeometryInTargetSpace = editor.getShapeGeometry(target);
  const targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds);
  const targetCenterInTargetSpace = targetGeometryInTargetSpace.center;
  const targetTransform = editor.getShapePageTransform(target);
  const pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace);
  const castDistance = Math.max(
    targetGeometryInTargetSpace.bounds.width,
    targetGeometryInTargetSpace.bounds.height
  );
  const handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {
    const axis = ElbowArrowAxes[ElbowArrowSideAxes[side]];
    const farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace);
    let isEnabled = false;
    let handlePointInTargetSpace = axis.v(
      targetBoundsInTargetSpace[side],
      targetBoundsInTargetSpace[axis.crossMid]
    );
    let furthestDistance = 0;
    const intersections = targetGeometryInTargetSpace.intersectLineSegment(
      targetCenterInTargetSpace,
      farPoint,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    );
    for (const intersection of intersections) {
      const distance = Vec.Dist2(intersection, targetCenterInTargetSpace);
      if (distance > furthestDistance) {
        furthestDistance = distance;
        handlePointInTargetSpace = intersection;
        isEnabled = targetGeometryInTargetSpace.isClosed;
      }
    }
    const handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace);
    return { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) };
  });
  const zoomLevel = editor.getZoomLevel();
  const minDistScaled = util2.options.minElbowHandleDistance / zoomLevel;
  const targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace);
  for (const side of objectMapKeys(handlesInPageSpace)) {
    const handle = handlesInPageSpace[side];
    if (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {
      handle.isEnabled = false;
    }
  }
  let precise2 = isPrecise || isExact;
  if (!precise2) {
    if (!currentBinding || currentBinding && target.id !== currentBinding.toId) {
      precise2 = editor.inputs.pointerVelocity.len() < 0.5;
    }
  }
  if (!isPrecise) {
    if (!targetGeometryInTargetSpace.isClosed) {
      precise2 = true;
    }
    if (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {
      precise2 = true;
    }
  }
  const shouldSnapCenter = !isExact && precise2 && targetGeometryInTargetSpace.isClosed;
  const shouldSnapEdges = !isExact && (precise2 && arrowKind === "elbow" || !targetGeometryInTargetSpace.isClosed);
  const shouldSnapEdgePoints = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  const shouldSnapNone = precise2 && (targetGeometryInTargetSpace.isClosed || isExact);
  const shouldSnapCenterAxis = !isExact && precise2 && arrowKind === "elbow" && targetGeometryInTargetSpace.isClosed;
  let snap = "none";
  let anchorInPageSpace = pointInPageSpace;
  if (!shouldSnapNone) {
    snap = "center";
    anchorInPageSpace = targetCenterInPageSpace;
  }
  if (shouldSnapEdges) {
    const snapDistance = shouldSnapNone ? calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util2.options.elbowArrowEdgeSnapDistance
    ) : Infinity;
    const nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(
      pointInTargetSpace,
      {
        includeLabels: false,
        includeInternal: false
      }
    );
    const nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(
      nearestPointOnEdgeInTargetSpace
    );
    const distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace);
    if (distance < snapDistance) {
      snap = "edge";
      anchorInPageSpace = nearestPointOnEdgeInPageSpace;
    }
  }
  if (shouldSnapCenterAxis) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util2.options.elbowArrowAxisSnapDistance
    );
    const distanceFromXAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.left.far,
      handlesInPageSpace.right.far,
      pointInPageSpace
    );
    const distanceFromYAxis = Vec.DistanceToLineSegment(
      handlesInPageSpace.top.far,
      handlesInPageSpace.bottom.far,
      pointInPageSpace
    );
    const snapAxis = distanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance ? "x" : distanceFromYAxis < snapDistance ? "y" : null;
    if (snapAxis) {
      const axis = ElbowArrowAxes[snapAxis];
      const loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace);
      const hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace);
      const side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge;
      if (handlesInPageSpace[side].isEnabled) {
        snap = "edge-point";
        anchorInPageSpace = handlesInPageSpace[side].point;
      }
    }
  }
  if (shouldSnapEdgePoints) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      util2.options.elbowArrowPointSnapDistance
    );
    let closestSide = null;
    let closestDistance = Infinity;
    for (const [side, handle] of objectMapEntries(handlesInPageSpace)) {
      if (!handle.isEnabled) continue;
      const distance = Vec.Dist(handle.point, pointInPageSpace);
      if (distance < snapDistance && distance < closestDistance) {
        closestDistance = distance;
        closestSide = side;
      }
    }
    if (closestSide) {
      snap = "edge-point";
      anchorInPageSpace = handlesInPageSpace[closestSide].point;
    }
  }
  if (shouldSnapCenter) {
    const snapDistance = calculateSnapDistance(
      editor,
      targetBoundsInTargetSpace,
      arrowKind === "elbow" ? util2.options.elbowArrowCenterSnapDistance : util2.options.arcArrowCenterSnapDistance
    );
    if (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {
      snap = "center";
      anchorInPageSpace = targetCenterInPageSpace;
    }
  }
  const snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace);
  const normalizedAnchor = {
    x: invLerp(
      targetBoundsInTargetSpace.minX,
      targetBoundsInTargetSpace.maxX,
      snapPointInTargetSpace.x
    ),
    y: invLerp(
      targetBoundsInTargetSpace.minY,
      targetBoundsInTargetSpace.maxY,
      snapPointInTargetSpace.y
    )
  };
  const result = {
    target,
    arrowKind,
    handlesInPageSpace,
    centerInPageSpace: targetCenterInPageSpace,
    anchorInPageSpace,
    isExact,
    isPrecise: precise2,
    snap,
    normalizedAnchor
  };
  getArrowTargetAtom(editor).set(result);
  return result;
}
const targetFilterFallback = { type: "arrow" };
function calculateSnapDistance(editor, targetBoundsInTargetSpace, idealSnapDistance) {
  return clamp$3(
    Math.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,
    4,
    idealSnapDistance
  ) / editor.getZoomLevel();
}
const { PI } = Math;
const FIXED_PI = PI + 1e-4;
function getStrokeOutlineTracks(strokePoints, options = {}) {
  const { size: size2 = 16, smoothing = 0.5 } = options;
  if (strokePoints.length === 0 || size2 <= 0) {
    return { left: [], right: [] };
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const minDistance = Math.pow(size2 * smoothing, 2);
  const leftPts = [];
  const rightPts = [];
  let prevVector = strokePoints[0].vector;
  let pl = strokePoints[0].point;
  let pr = pl;
  let tl = pl;
  let tr2 = pr;
  let isPrevPointSharpCorner = false;
  let strokePoint;
  for (let i = 0; i < strokePoints.length; i++) {
    strokePoint = strokePoints[i];
    const { point, vector } = strokePoints[i];
    const prevDpr = strokePoint.vector.dpr(prevVector);
    const nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector;
    const nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1;
    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2;
    if (isPointSharpCorner || isNextPointSharpCorner) {
      if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {
        const offset22 = prevVector.clone().mul(strokePoint.radius);
        const cpr = prevVector.clone().cpr(nextVector);
        if (cpr < 0) {
          tl = Vec.Add(point, offset22);
          tr2 = Vec.Sub(point, offset22);
        } else {
          tl = Vec.Sub(point, offset22);
          tr2 = Vec.Add(point, offset22);
        }
        leftPts.push(tl);
        rightPts.push(tr2);
      } else {
        const offset22 = prevVector.clone().mul(strokePoint.radius).per();
        const start = Vec.Sub(strokePoint.input, offset22);
        for (let step = 1 / 13, t2 = 0; t2 < 1; t2 += step) {
          tl = Vec.RotWith(start, strokePoint.input, FIXED_PI * t2);
          leftPts.push(tl);
          tr2 = Vec.RotWith(start, strokePoint.input, FIXED_PI + FIXED_PI * -t2);
          rightPts.push(tr2);
        }
      }
      pl = tl;
      pr = tr2;
      if (isNextPointSharpCorner) {
        isPrevPointSharpCorner = true;
      }
      continue;
    }
    isPrevPointSharpCorner = false;
    if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {
      const offset22 = Vec.Per(vector).mul(strokePoint.radius);
      leftPts.push(Vec.Sub(point, offset22));
      rightPts.push(Vec.Add(point, offset22));
      continue;
    }
    const offset2 = Vec.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius);
    tl = Vec.Sub(point, offset2);
    if (i <= 1 || Vec.Dist2(pl, tl) > minDistance) {
      leftPts.push(tl);
      pl = tl;
    }
    tr2 = Vec.Add(point, offset2);
    if (i <= 1 || Vec.Dist2(pr, tr2) > minDistance) {
      rightPts.push(tr2);
      pr = tr2;
    }
    prevVector = vector;
    continue;
  }
  return {
    left: leftPts,
    right: rightPts
  };
}
function getStrokeOutlinePoints(strokePoints, options = {}) {
  const { size: size2 = 16, start = {}, end = {}, last: isComplete = false } = options;
  const { cap: capStart = true } = start;
  const { cap: capEnd = true } = end;
  if (strokePoints.length === 0 || size2 <= 0) {
    return [];
  }
  const firstStrokePoint = strokePoints[0];
  const lastStrokePoint = strokePoints[strokePoints.length - 1];
  const totalLength = lastStrokePoint.runningLength;
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size2, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size2, totalLength) : end.taper;
  const { left: leftPts, right: rightPts } = getStrokeOutlineTracks(strokePoints, options);
  const firstPoint = firstStrokePoint.point;
  const lastPoint = strokePoints.length > 1 ? strokePoints[strokePoints.length - 1].point : Vec.AddXY(firstStrokePoint.point, 1, 1);
  if (strokePoints.length === 1) {
    if (!(taperStart || taperEnd) || isComplete) {
      const start2 = Vec.Add(
        firstPoint,
        Vec.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)
      );
      const dotPts = [];
      for (let step = 1 / 13, t2 = step; t2 <= 1; t2 += step) {
        dotPts.push(Vec.RotWith(start2, firstPoint, FIXED_PI * 2 * t2));
      }
      return dotPts;
    }
  }
  const startCap = [];
  if (taperStart || taperEnd && strokePoints.length === 1) ;
  else if (capStart) {
    for (let step = 1 / 8, t2 = step; t2 <= 1; t2 += step) {
      const pt = Vec.RotWith(rightPts[0], firstPoint, FIXED_PI * t2);
      startCap.push(pt);
    }
  } else {
    const cornersVector = Vec.Sub(leftPts[0], rightPts[0]);
    const offsetA = Vec.Mul(cornersVector, 0.5);
    const offsetB = Vec.Mul(cornersVector, 0.51);
    startCap.push(
      Vec.Sub(firstPoint, offsetA),
      Vec.Sub(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetB),
      Vec.Add(firstPoint, offsetA)
    );
  }
  const endCap = [];
  const direction = lastStrokePoint.vector.clone().per().neg();
  if (taperEnd || taperStart && strokePoints.length === 1) {
    endCap.push(lastPoint);
  } else if (capEnd) {
    const start2 = Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius));
    for (let step = 1 / 29, t2 = step; t2 < 1; t2 += step) {
      endCap.push(Vec.RotWith(start2, lastPoint, FIXED_PI * 3 * t2));
    }
  } else {
    endCap.push(
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius)),
      Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),
      Vec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))
    );
  }
  return leftPts.concat(endCap, rightPts.reverse(), startCap);
}
const MIN_START_PRESSURE = 0.025;
const MIN_END_PRESSURE = 0.01;
function getStrokePoints(rawInputPoints, options = {}) {
  const { streamline = 0.5, size: size2 = 16, simulatePressure = false } = options;
  if (rawInputPoints.length === 0) return [];
  const t2 = 0.15 + (1 - streamline) * 0.85;
  let pts = rawInputPoints.map(Vec.From);
  let pointsRemovedFromNearEnd = 0;
  if (!simulatePressure) {
    let pt2 = pts[0];
    while (pt2) {
      if (pt2.z >= MIN_START_PRESSURE) break;
      pts.shift();
      pt2 = pts[0];
    }
  }
  if (!simulatePressure) {
    let pt2 = pts[pts.length - 1];
    while (pt2) {
      if (pt2.z >= MIN_END_PRESSURE) break;
      pts.pop();
      pt2 = pts[pts.length - 1];
    }
  }
  if (pts.length === 0)
    return [
      {
        point: Vec.From(rawInputPoints[0]),
        input: Vec.From(rawInputPoints[0]),
        pressure: simulatePressure ? 0.5 : 0.15,
        vector: new Vec(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let pt = pts[1];
  while (pt) {
    if (Vec.Dist2(pt, pts[0]) > (size2 / 3) ** 2) break;
    pts[0].z = Math.max(pts[0].z, pt.z);
    pts.splice(1, 1);
    pt = pts[1];
  }
  const last2 = pts.pop();
  pt = pts[pts.length - 1];
  while (pt) {
    if (Vec.Dist2(pt, last2) > (size2 / 3) ** 2) break;
    pts.pop();
    pt = pts[pts.length - 1];
    pointsRemovedFromNearEnd++;
  }
  pts.push(last2);
  const isComplete = options.last || !options.simulatePressure || pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size2 ** 2 || pointsRemovedFromNearEnd > 0;
  if (pts.length === 2 && options.simulatePressure) {
    const last22 = pts[1];
    pts = pts.slice(0, -1);
    for (let i = 1; i < 5; i++) {
      const next = Vec.Lrp(pts[0], last22, i / 4);
      next.z = (pts[0].z + (last22.z - pts[0].z)) * i / 4;
      pts.push(next);
    }
  }
  const strokePoints = [
    {
      point: pts[0],
      input: pts[0],
      pressure: simulatePressure ? 0.5 : pts[0].z,
      vector: new Vec(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let totalLength = 0;
  let prev = strokePoints[0];
  let point, distance;
  if (isComplete && streamline > 0) {
    pts.push(pts[pts.length - 1].clone());
  }
  for (let i = 1, n2 = pts.length; i < n2; i++) {
    point = !t2 || options.last && i === n2 - 1 ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t2);
    if (prev.point.equals(point)) continue;
    distance = Vec.Dist(point, prev.point);
    totalLength += distance;
    if (i < 4 && totalLength < size2) {
      continue;
    }
    prev = {
      input: pts[i],
      // The adjusted point
      point,
      // The input pressure (or .5 if not specified)
      pressure: simulatePressure ? 0.5 : pts[i].z,
      // The vector from the current point to the previous point
      vector: Vec.Sub(prev.point, point).uni(),
      // The distance between the current point and the previous point
      distance,
      // The total distance so far
      runningLength: totalLength,
      // The stroke point's radius
      radius: 1
    };
    strokePoints.push(prev);
  }
  if (strokePoints[1]?.vector) {
    strokePoints[0].vector = strokePoints[1].vector.clone();
  }
  if (totalLength < 1) {
    const maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s2) => s2.pressure));
    strokePoints.forEach((s2) => s2.pressure = maxPressureAmongPoints);
  }
  return strokePoints;
}
const { min } = Math;
const RATE_OF_PRESSURE_CHANGE = 0.275;
function setStrokePointRadii(strokePoints, options) {
  const {
    size: size2 = 16,
    thinning = 0.5,
    simulatePressure = true,
    easing = (t2) => t2,
    start = {},
    end = {}
  } = options;
  const { easing: taperStartEase = EASINGS.easeOutQuad } = start;
  const { easing: taperEndEase = EASINGS.easeOutCubic } = end;
  const totalLength = strokePoints[strokePoints.length - 1].runningLength;
  let firstRadius;
  let prevPressure = strokePoints[0].pressure;
  let strokePoint;
  if (!simulatePressure && totalLength < size2) {
    const max2 = strokePoints.reduce((max22, curr) => Math.max(max22, curr.pressure), 0.5);
    strokePoints.forEach((sp) => {
      sp.pressure = max2;
      sp.radius = size2 * easing(0.5 - thinning * (0.5 - sp.pressure));
    });
    return strokePoints;
  } else {
    let p;
    for (let i = 0, n2 = strokePoints.length; i < n2; i++) {
      strokePoint = strokePoints[i];
      if (strokePoint.runningLength > size2 * 5) break;
      const sp = min(1, strokePoint.distance / size2);
      if (simulatePressure) {
        const rp = min(1, 1 - sp);
        p = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
      } else {
        p = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5);
      }
      prevPressure = prevPressure + (p - prevPressure) * 0.5;
    }
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      if (thinning) {
        let { pressure } = strokePoint;
        const sp = min(1, strokePoint.distance / size2);
        if (simulatePressure) {
          const rp = min(1, 1 - sp);
          pressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
        } else {
          pressure = min(
            1,
            prevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)
          );
        }
        strokePoint.radius = size2 * easing(0.5 - thinning * (0.5 - pressure));
        prevPressure = pressure;
      } else {
        strokePoint.radius = size2 / 2;
      }
      if (firstRadius === void 0) {
        firstRadius = strokePoint.radius;
      }
    }
  }
  const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size2, totalLength) : start.taper;
  const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size2, totalLength) : end.taper;
  if (taperStart || taperEnd) {
    for (let i = 0; i < strokePoints.length; i++) {
      strokePoint = strokePoints[i];
      const { runningLength } = strokePoint;
      const ts2 = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
      const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
      strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts2, te));
    }
  }
  return strokePoints;
}
function TldrawCropHandles({
  size: size2,
  width,
  height,
  hideAlternateHandles
}) {
  const cropStrokeWidth = toDomPrecision(size2 / 3);
  const offset2 = cropStrokeWidth / 2;
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "tl-overlays__item", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(0 - offset2)},${toDomPrecision(size2)} 
						${toDomPrecision(0 - offset2)},${toDomPrecision(0 - offset2)} 
						${toDomPrecision(size2)},${toDomPrecision(0 - offset2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_left",
        role: "button",
        "aria-label": msg2("handle.crop.top-left")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size2),
        y1: toDomPrecision(0 - offset2),
        x2: toDomPrecision(width / 2 + size2),
        y2: toDomPrecision(0 - offset2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top",
        role: "button",
        "aria-label": msg2("handle.crop.top")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: classNames("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(width - size2)},${toDomPrecision(0 - offset2)} 
						${toDomPrecision(width + offset2)},${toDomPrecision(0 - offset2)} 
						${toDomPrecision(width + offset2)},${toDomPrecision(size2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.top_right",
        role: "button",
        "aria-label": msg2("handle.crop.top-right")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width + offset2),
        y1: toDomPrecision(height / 2 - size2),
        x2: toDomPrecision(width + offset2),
        y2: toDomPrecision(height / 2 + size2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.right",
        role: "button",
        "aria-label": msg2("handle.crop.right")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${toDomPrecision(width + offset2)},${toDomPrecision(height - size2)} 
						${toDomPrecision(width + offset2)},${toDomPrecision(height + offset2)}
						${toDomPrecision(width - size2)},${toDomPrecision(height + offset2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_right",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-right")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(width / 2 - size2),
        y1: toDomPrecision(height + offset2),
        x2: toDomPrecision(width / 2 + size2),
        y2: toDomPrecision(height + offset2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom",
        role: "button",
        "aria-label": msg2("handle.crop.bottom")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "polyline",
      {
        className: classNames("tl-corner-crop-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        points: `
						${toDomPrecision(0 + size2)},${toDomPrecision(height + offset2)} 
						${toDomPrecision(0 - offset2)},${toDomPrecision(height + offset2)}
						${toDomPrecision(0 - offset2)},${toDomPrecision(height - size2)}`,
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.bottom_left",
        role: "button",
        "aria-label": msg2("handle.crop.bottom-left")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        className: classNames("tl-corner-crop-edge-handle", {
          "tl-hidden": hideAlternateHandles
        }),
        x1: toDomPrecision(0 - offset2),
        y1: toDomPrecision(height / 2 - size2),
        x2: toDomPrecision(0 - offset2),
        y2: toDomPrecision(height / 2 + size2),
        strokeWidth: cropStrokeWidth,
        "data-testid": "selection.crop.left",
        role: "button",
        "aria-label": msg2("handle.crop.left")
      }
    )
  ] });
}
track(function TldrawSelectionForeground2({
  bounds,
  rotation
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rSvg = reactExports.useRef(null);
  const isReadonlyMode = useReadonly();
  const topEvents = useSelectionEvents("top");
  const rightEvents = useSelectionEvents("right");
  const bottomEvents = useSelectionEvents("bottom");
  const leftEvents = useSelectionEvents("left");
  const topLeftEvents = useSelectionEvents("top_left");
  const topRightEvents = useSelectionEvents("top_right");
  const bottomRightEvents = useSelectionEvents("bottom_right");
  const bottomLeftEvents = useSelectionEvents("bottom_left");
  const isDefaultCursor = editor.getInstanceState().cursor.type === "default";
  const isCoarsePointer = editor.getInstanceState().isCoarsePointer;
  const onlyShape = editor.getOnlySelectedShape();
  const isLockedShape = onlyShape && editor.isShapeOrAncestorLocked(onlyShape);
  const expandOutlineBy = onlyShape ? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
  const expandedBounds = expandOutlineBy instanceof Box ? bounds.clone().expand(expandOutlineBy).zeroFix() : bounds.clone().expandBy(expandOutlineBy).zeroFix();
  useTransform(rSvg, bounds?.x, bounds?.y, 1, editor.getSelectionRotation(), {
    x: expandedBounds.x - bounds.x,
    y: expandedBounds.y - bounds.y
  });
  if (onlyShape && editor.isShapeHidden(onlyShape)) return null;
  const zoom = editor.getZoomLevel();
  const isChangingStyle = editor.getInstanceState().isChangingStyle;
  const width = expandedBounds.width;
  const height = expandedBounds.height;
  const size2 = 8 / zoom;
  const isTinyX = width < size2 * 2;
  const isTinyY = height < size2 * 2;
  const isSmallX = width < size2 * 4;
  const isSmallY = height < size2 * 4;
  const isSmallCropX = width < size2 * 5;
  const isSmallCropY = height < size2 * 5;
  const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1;
  const targetSize = 6 / zoom * mobileHandleMultiplier;
  const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
  const showSelectionBounds = (onlyShape ? !editor.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) && !isChangingStyle;
  let shouldDisplayBox = showSelectionBounds && editor.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || showSelectionBounds && editor.isIn("select.resizing") && onlyShape && editor.isShapeOfType(onlyShape, "text");
  if (onlyShape && shouldDisplayBox) {
    if (tlenv.isFirefox && editor.isShapeOfType(onlyShape, "embed")) {
      shouldDisplayBox = false;
    }
  }
  const showCropHandles = editor.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !isChangingStyle && !isReadonlyMode;
  const shouldDisplayControls = editor.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !isChangingStyle && !isReadonlyMode;
  const showCornerRotateHandles = !isCoarsePointer && !(isTinyX || isTinyY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showMobileRotateHandle = isCoarsePointer && (!isSmallX || !isSmallY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) && !isLockedShape;
  const showResizeHandles = shouldDisplayControls && (onlyShape ? editor.getShapeUtil(onlyShape).canResize(onlyShape) && !editor.getShapeUtil(onlyShape).hideResizeHandles(onlyShape) : true) && !showCropHandles && !isLockedShape;
  const hideAlternateCornerHandles = isTinyX || isTinyY;
  const showOnlyOneHandle = isTinyX && isTinyY;
  const hideAlternateCropHandles = isSmallCropX || isSmallCropY;
  const showHandles = showResizeHandles || showCropHandles;
  const hideRotateCornerHandles = !showCornerRotateHandles;
  const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle;
  const hideTopLeftCorner = !shouldDisplayControls || !showHandles;
  const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
  const hideBottomRightCorner = !shouldDisplayControls || !showHandles || showOnlyOneHandle && !showCropHandles;
  let hideVerticalEdgeTargets = true;
  let hideHorizontalEdgeTargets = true;
  if (showCropHandles) {
    hideVerticalEdgeTargets = hideAlternateCropHandles;
    hideHorizontalEdgeTargets = hideAlternateCropHandles;
  } else if (showResizeHandles) {
    hideVerticalEdgeTargets = hideAlternateCornerHandles || showOnlyOneHandle || isCoarsePointer;
    const isMobileAndTextShape = isCoarsePointer && onlyShape && onlyShape.type === "text";
    hideHorizontalEdgeTargets = hideVerticalEdgeTargets && !isMobileAndTextShape;
  }
  const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3);
  const showTextResizeHandles = shouldDisplayControls && isCoarsePointer && onlyShape && editor.isShapeOfType(onlyShape, "text") && textHandleHeight * zoom >= 4;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "tl-overlays__item tl-selection__fg", "data-testid": "selection-foreground", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { ref: rSvg, children: [
    shouldDisplayBox && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        className: "tl-selection__fg__outline",
        width: toDomPrecision(width),
        height: toDomPrecision(height)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.top-left",
        cx: 0,
        cy: 0,
        targetSize,
        corner: "top_left_rotate",
        cursor: isDefaultCursor ? getCursor("nwse-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.top-right",
        cx: width + targetSize * 3,
        cy: 0,
        targetSize,
        corner: "top_right_rotate",
        cursor: isDefaultCursor ? getCursor("nesw-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.bottom-left",
        cx: 0,
        cy: height + targetSize * 3,
        targetSize,
        corner: "bottom_left_rotate",
        cursor: isDefaultCursor ? getCursor("swne-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RotateCornerHandle,
      {
        "data-testid": "selection.rotate.bottom-right",
        cx: width + targetSize * 3,
        cy: height + targetSize * 3,
        targetSize,
        corner: "bottom_right_rotate",
        cursor: isDefaultCursor ? getCursor("senw-rotate", rotation) : void 0,
        isHidden: hideRotateCornerHandles
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MobileRotateHandle,
      {
        "data-testid": "selection.rotate.mobile",
        cx: isSmallX ? -targetSize * 1.5 : width / 2,
        cy: isSmallX ? height / 2 : -targetSize * 1.5,
        size: size2,
        isHidden: hideMobileRotateHandle
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideVerticalEdgeTargets,
        dataTestId: "selection.resize.top",
        ariaLabel: msg2("handle.resize-top"),
        x: 0,
        y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY)),
        width: toDomPrecision(width),
        height: toDomPrecision(Math.max(1, targetSizeY * 2)),
        cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
        events: topEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideHorizontalEdgeTargets,
        dataTestId: "selection.resize.right",
        ariaLabel: msg2("handle.resize-right"),
        x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX)),
        y: 0,
        height: toDomPrecision(height),
        width: toDomPrecision(Math.max(1, targetSizeX * 2)),
        cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
        events: rightEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideVerticalEdgeTargets,
        dataTestId: "selection.resize.bottom",
        ariaLabel: msg2("handle.resize-bottom"),
        x: 0,
        y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY)),
        width: toDomPrecision(width),
        height: toDomPrecision(Math.max(1, targetSizeY * 2)),
        cursor: isDefaultCursor ? getCursor("ns-resize", rotation) : void 0,
        events: bottomEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideHorizontalEdgeTargets,
        dataTestId: "selection.resize.left",
        ariaLabel: msg2("handle.resize-left"),
        x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX)),
        y: 0,
        height: toDomPrecision(height),
        width: toDomPrecision(Math.max(1, targetSizeX * 2)),
        cursor: isDefaultCursor ? getCursor("ew-resize", rotation) : void 0,
        events: leftEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideTopLeftCorner,
        dataTestId: "selection.target.top-left",
        ariaLabel: msg2("handle.resize-top-left"),
        x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX * 1.5)),
        y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
        events: topLeftEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideTopRightCorner,
        dataTestId: "selection.target.top-right",
        ariaLabel: msg2("handle.resize-top-right"),
        x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX * 1.5)),
        y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
        events: topRightEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideBottomRightCorner,
        dataTestId: "selection.target.bottom-right",
        ariaLabel: msg2("handle.resize-bottom-right"),
        x: toDomPrecision(width - (isSmallX ? targetSizeX : targetSizeX * 1.5)),
        y: toDomPrecision(height - (isSmallY ? targetSizeY : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nwse-resize", rotation) : void 0,
        events: bottomRightEvents
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ResizeHandle,
      {
        hide: hideBottomLeftCorner,
        dataTestId: "selection.target.bottom-left",
        ariaLabel: msg2("handle.resize-bottom-left"),
        x: toDomPrecision(0 - (isSmallX ? targetSizeX * 3 : targetSizeX * 1.5)),
        y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY * 1.5)),
        width: toDomPrecision(targetSizeX * 3),
        height: toDomPrecision(targetSizeY * 3),
        cursor: isDefaultCursor ? getCursor("nesw-resize", rotation) : void 0,
        events: bottomLeftEvents
      }
    ),
    showResizeHandles && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          "data-testid": "selection.resize.top-left",
          className: classNames("tl-corner-handle", {
            "tl-hidden": hideTopLeftCorner
          }),
          x: toDomPrecision(0 - size2 / 2),
          y: toDomPrecision(0 - size2 / 2),
          width: toDomPrecision(size2),
          height: toDomPrecision(size2)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          "data-testid": "selection.resize.top-right",
          className: classNames("tl-corner-handle", {
            "tl-hidden": hideTopRightCorner
          }),
          x: toDomPrecision(width - size2 / 2),
          y: toDomPrecision(0 - size2 / 2),
          width: toDomPrecision(size2),
          height: toDomPrecision(size2)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          "data-testid": "selection.resize.bottom-right",
          className: classNames("tl-corner-handle", {
            "tl-hidden": hideBottomRightCorner
          }),
          x: toDomPrecision(width - size2 / 2),
          y: toDomPrecision(height - size2 / 2),
          width: toDomPrecision(size2),
          height: toDomPrecision(size2)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          "data-testid": "selection.resize.bottom-left",
          className: classNames("tl-corner-handle", {
            "tl-hidden": hideBottomLeftCorner
          }),
          x: toDomPrecision(0 - size2 / 2),
          y: toDomPrecision(height - size2 / 2),
          width: toDomPrecision(size2),
          height: toDomPrecision(size2)
        }
      )
    ] }),
    showTextResizeHandles && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          "data-testid": "selection.text-resize.left.handle",
          className: "tl-text-handle",
          x: toDomPrecision(0 - size2 / 4),
          y: toDomPrecision(height / 2 - textHandleHeight / 2),
          rx: size2 / 4,
          width: toDomPrecision(size2 / 2),
          height: toDomPrecision(textHandleHeight)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          "data-testid": "selection.text-resize.right.handle",
          className: "tl-text-handle",
          rx: size2 / 4,
          x: toDomPrecision(width - size2 / 4),
          y: toDomPrecision(height / 2 - textHandleHeight / 2),
          width: toDomPrecision(size2 / 2),
          height: toDomPrecision(textHandleHeight)
        }
      )
    ] }),
    showCropHandles && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawCropHandles,
      {
        ...{
          size: size2,
          width,
          height,
          hideAlternateHandles: hideAlternateCropHandles
        }
      }
    )
  ] }) });
});
const ResizeHandle = function ResizeHandle2({
  hide: hide2,
  dataTestId,
  ariaLabel,
  x,
  y: y2,
  width,
  height,
  cursor,
  events
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "rect",
    {
      className: classNames("tl-resize-handle", "tl-transparent", {
        "tl-hidden": hide2
      }),
      "data-testid": dataTestId,
      role: "button",
      "aria-label": ariaLabel,
      pointerEvents: "all",
      x,
      y: y2,
      width,
      height,
      cursor,
      ...events
    }
  );
};
const RotateCornerHandle = function RotateCornerHandle2({
  cx,
  cy,
  targetSize,
  corner,
  cursor,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents(corner);
  const msg2 = useTranslation();
  const label = msg2(`handle.rotate.${corner}`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "rect",
    {
      className: classNames("tl-transparent", "tl-rotate-corner", { "tl-hidden": isHidden2 }),
      "data-testid": testId,
      role: "button",
      "aria-label": label,
      pointerEvents: "all",
      x: toDomPrecision(cx - targetSize * 3),
      y: toDomPrecision(cy - targetSize * 3),
      width: toDomPrecision(Math.max(1, targetSize * 3)),
      height: toDomPrecision(Math.max(1, targetSize * 3)),
      cursor,
      ...events
    }
  );
};
const SQUARE_ROOT_PI = Math.sqrt(Math.PI);
const MobileRotateHandle = function RotateHandle({
  cx,
  cy,
  size: size2,
  isHidden: isHidden2,
  "data-testid": testId
}) {
  const events = useSelectionEvents("mobile_rotate");
  const editor = useEditor();
  const zoom = useValue("zoom level", () => editor.getZoomLevel(), [editor]);
  const bgRadius = Math.max(14 * (1 / zoom), 20 / Math.max(1, zoom));
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { role: "button", "aria-label": msg2("handle.rotate.mobile_rotate"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "circle",
      {
        "data-testid": testId,
        pointerEvents: "all",
        className: classNames("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: bgRadius,
        ...events
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "circle",
      {
        className: classNames("tl-mobile-rotate__fg", { "tl-hidden": isHidden2 }),
        cx,
        cy,
        r: size2 / SQUARE_ROOT_PI
      }
    )
  ] });
};
function getStraightArrowInfo(editor, shape, bindings) {
  const { arrowheadStart, arrowheadEnd } = shape.props;
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const a2 = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c2 = Vec.Med(a2, b);
  if (Vec.Equals(a2, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a2,
        point: a2,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c2,
      isValid: false,
      length: 0
    };
  }
  const uAB = Vec.Sub(b, a2).uni();
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const arrowPageTransform = editor.getShapePageTransform(shape);
  updateArrowheadPointWithBoundShape(
    b,
    // <-- will be mutated
    terminalsInArrowSpace.start,
    arrowPageTransform,
    endShapeInfo
  );
  updateArrowheadPointWithBoundShape(
    a2,
    // <-- will be mutated
    terminalsInArrowSpace.end,
    arrowPageTransform,
    startShapeInfo
  );
  let offsetA = 0;
  let offsetB = 0;
  let strokeOffsetA = 0;
  let strokeOffsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  const isSelfIntersection = startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape;
  const relationship = startShapeInfo && endShapeInfo ? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id) : "safe";
  if (relationship === "safe" && startShapeInfo && endShapeInfo && !isSelfIntersection && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {
      if (startShapeInfo.isClosed) {
        a2.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    } else if (!endShapeInfo.didIntersect) {
      if (endShapeInfo.isClosed) {
        b.setTo(a2.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)));
      }
    }
  }
  const distance = Vec.Sub(b, a2);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const didFlip = !Vec.Equals(u, uAB);
  if (!isSelfIntersection) {
    if (relationship !== "start-contains-end" && startShapeInfo && arrowheadStart !== "none" && !startShapeInfo.isExact) {
      strokeOffsetA = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES$1[startShapeInfo.shape.props.size] / 2 : 0);
      offsetA = (BOUND_ARROW_OFFSET + strokeOffsetA) * shape.props.scale;
      minLength += strokeOffsetA * shape.props.scale;
    }
    if (relationship !== "end-contains-start" && endShapeInfo && arrowheadEnd !== "none" && !endShapeInfo.isExact) {
      strokeOffsetB = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES$1[endShapeInfo.shape.props.size] / 2 : 0);
      offsetB = (BOUND_ARROW_OFFSET + strokeOffsetB) * shape.props.scale;
      minLength += strokeOffsetB * shape.props.scale;
    }
  }
  const tA = a2.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  const tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -1;
    } else if (offsetB !== 0) {
      offsetB *= -1;
    } else ;
  }
  a2.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)));
  b.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)));
  if (didFlip) {
    if (startShapeInfo && endShapeInfo) {
      b.setTo(Vec.Add(a2, u.clone().mul(-MIN_ARROW_LENGTH * shape.props.scale)));
    }
    c2.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end));
  } else {
    c2.setTo(Vec.Med(a2, b));
  }
  const length = Vec.Dist(a2, b);
  return {
    bindings,
    type: "straight",
    start: {
      handle: terminalsInArrowSpace.start,
      point: a2,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      handle: terminalsInArrowSpace.end,
      point: b,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c2,
    isValid: length > 0,
    length
  };
}
function updateArrowheadPointWithBoundShape(point, opposite, arrowPageTransform, targetShapeInfo) {
  if (targetShapeInfo === void 0) {
    return;
  }
  if (targetShapeInfo.isExact) {
    return;
  }
  const pageFrom = Mat.applyToPoint(arrowPageTransform, opposite);
  const pageTo = Mat.applyToPoint(arrowPageTransform, point);
  const targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom);
  const targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo);
  const intersection = Array.from(
    targetShapeInfo.geometry.intersectLineSegment(targetFrom, targetTo, {
      includeLabels: false,
      includeInternal: false
    })
  );
  let targetInt;
  if (intersection.length) {
    targetInt = intersection.sort((p1, p2) => Vec.Dist2(p1, targetFrom) - Vec.Dist2(p2, targetFrom))[0] ?? (targetShapeInfo.isClosed ? void 0 : targetTo);
  }
  if (targetInt === void 0) {
    targetInt = targetShapeInfo.geometry.nearestPoint(targetTo);
    if (!Vec.DistMin(targetInt, targetTo, 1)) {
      return;
    }
  }
  const pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt);
  const arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt);
  point.setTo(arrowInt);
  targetShapeInfo.didIntersect = true;
}
function getCurvedArrowInfo(editor, shape, bindings) {
  const { arrowheadEnd, arrowheadStart } = shape.props;
  const bend = shape.props.bend;
  if (Math.abs(bend) > Math.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings);
  const med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end);
  const distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start);
  const u = Vec.Len(distance) ? distance.uni() : Vec.From(distance);
  const middle = Vec.Add(med, u.per().mul(-bend));
  const startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "start");
  const endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, "end");
  const a2 = terminalsInArrowSpace.start.clone();
  const b = terminalsInArrowSpace.end.clone();
  const c2 = middle.clone();
  if (Vec.Equals(a2, b)) {
    return {
      bindings,
      type: "straight",
      start: {
        handle: a2,
        point: a2,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: b,
        point: b,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c2,
      isValid: false,
      length: 0
    };
  }
  const isClockwise = shape.props.bend < 0;
  const distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist;
  const handleArc = getArcInfo(a2, b, c2);
  const handle_aCA = Vec.Angle(handleArc.center, a2);
  const handle_aCB = Vec.Angle(handleArc.center, b);
  const handle_dAB = distFn(handle_aCA, handle_aCB);
  if (handleArc.length === 0 || handleArc.size === 0 || !isSafeFloat(handleArc.length) || !isSafeFloat(handleArc.size)) {
    return getStraightArrowInfo(editor, shape, bindings);
  }
  const tempA = a2.clone();
  const tempB = b.clone();
  const tempC = c2.clone();
  const arrowPageTransform = editor.getShapePageTransform(shape);
  let offsetA = 0;
  let offsetB = 0;
  let minLength = MIN_ARROW_LENGTH * shape.props.scale;
  if (startShapeInfo && !startShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const inverseTransform = Mat.Inverse(startShapeInfo.transform);
    const startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const { isClosed } = startShapeInfo;
    let point;
    let intersections = Array.from(
      startShapeInfo.geometry.intersectCircle(centerInStartShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace);
      const angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB2
      );
      const targetDist = dAB2 * 0.25;
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = startShapeInfo.geometry.nearestPoint(startInStartShapeLocalSpace);
        if (Vec.DistMin(nearestPoint, startInStartShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = startInStartShapeLocalSpace;
      }
    }
    if (point) {
      tempA.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))
      );
      startShapeInfo.didIntersect = true;
      if (arrowheadStart !== "none") {
        const strokeOffset = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in startShapeInfo.shape.props ? STROKE_SIZES$1[startShapeInfo.shape.props.size] / 2 : 0);
        offsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  if (endShapeInfo && !endShapeInfo.isExact) {
    const startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA);
    const endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB);
    const centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center);
    const inverseTransform = Mat.Inverse(endShapeInfo.transform);
    const startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace);
    const centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace);
    const endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace);
    const isClosed = endShapeInfo.isClosed;
    let point;
    let intersections = Array.from(
      endShapeInfo.geometry.intersectCircle(centerInEndShapeLocalSpace, handleArc.radius, {
        includeLabels: false,
        includeInternal: false
      })
    );
    if (intersections.length) {
      const angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace);
      const angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace);
      const dAB2 = distFn(angleToStart, angleToEnd);
      const targetDist = dAB2 * 0.75;
      intersections = intersections.filter(
        (pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB2
      );
      intersections.sort(
        isClosed ? (p0, p1) => Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) < Math.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist) ? -1 : 1 : (p0, p1) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) < distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) ? -1 : 1
      );
      point = intersections[0];
    }
    if (!point) {
      if (isClosed) {
        const nearestPoint = endShapeInfo.geometry.nearestPoint(endInEndShapeLocalSpace);
        if (Vec.DistMin(nearestPoint, endInEndShapeLocalSpace, 1)) {
          point = nearestPoint;
        }
      } else {
        point = endInEndShapeLocalSpace;
      }
    }
    if (point) {
      tempB.setTo(
        editor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))
      );
      endShapeInfo.didIntersect = true;
      if (arrowheadEnd !== "none") {
        const strokeOffset = STROKE_SIZES$1[shape.props.size] / 2 + ("size" in endShapeInfo.shape.props ? STROKE_SIZES$1[endShapeInfo.shape.props.size] / 2 : 0);
        offsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale;
        minLength += strokeOffset * shape.props.scale;
      }
    }
  }
  let aCA = Vec.Angle(handleArc.center, tempA);
  let aCB = Vec.Angle(handleArc.center, tempB);
  let dAB = distFn(aCA, aCB);
  let lAB = dAB * handleArc.radius;
  const tA = tempA.clone();
  const tB = tempB.clone();
  if (offsetA !== 0) {
    tA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (Vec.DistMin(tA, tB, minLength)) {
    if (offsetA !== 0 && offsetB !== 0) {
      offsetA *= -1.5;
      offsetB *= -1.5;
    } else if (offsetA !== 0) {
      offsetA *= -2;
    } else if (offsetB !== 0) {
      offsetB *= -2;
    } else ;
    const minOffsetA = 0.1 - distFn(handle_aCA, aCA) * handleArc.radius;
    const minOffsetB = 0.1 - distFn(aCB, handle_aCB) * handleArc.radius;
    offsetA = Math.max(offsetA, minOffsetA);
    offsetB = Math.max(offsetB, minOffsetB);
  }
  if (offsetA !== 0) {
    tempA.setTo(handleArc.center).add(
      Vec.FromAngle(aCA + dAB * (offsetA / lAB * (isClockwise ? 1 : -1))).mul(handleArc.radius)
    );
  }
  if (offsetB !== 0) {
    tempB.setTo(handleArc.center).add(
      Vec.FromAngle(aCB + dAB * (offsetB / lAB * (isClockwise ? -1 : 1))).mul(handleArc.radius)
    );
  }
  if (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {
    aCA = Vec.Angle(handleArc.center, tempA);
    aCB = Vec.Angle(handleArc.center, tempB);
    dAB = distFn(aCA, aCB);
    lAB = dAB * handleArc.radius;
    const relationship = getBoundShapeRelationships(
      editor,
      startShapeInfo.shape.id,
      endShapeInfo.shape.id
    );
    if (relationship === "double-bound" && lAB < 30) {
      tempA.setTo(a2);
      tempB.setTo(b);
      tempC.setTo(c2);
    } else if (relationship === "safe") {
      if (startShapeInfo && !startShapeInfo.didIntersect) {
        tempA.setTo(a2);
      }
      if (endShapeInfo && !endShapeInfo.didIntersect || distFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)) {
        tempB.setTo(handleArc.center).add(
          Vec.FromAngle(
            aCA + dAB * (Math.min(0.9, MIN_ARROW_LENGTH * shape.props.scale / lAB) * (isClockwise ? 1 : -1))
          ).mul(handleArc.radius)
        );
      }
    }
  }
  placeCenterHandle(
    handleArc.center,
    handleArc.radius,
    tempA,
    tempB,
    tempC,
    handle_dAB,
    isClockwise
  );
  if (tempA.equals(tempB)) {
    tempA.setTo(tempC.clone().addXY(1, 1));
    tempB.setTo(tempC.clone().subXY(1, 1));
  }
  a2.setTo(tempA);
  b.setTo(tempB);
  c2.setTo(tempC);
  const bodyArc = getArcInfo(a2, b, c2);
  return {
    bindings,
    type: "arc",
    start: {
      point: a2,
      handle: terminalsInArrowSpace.start,
      arrowhead: shape.props.arrowheadStart
    },
    end: {
      point: b,
      handle: terminalsInArrowSpace.end,
      arrowhead: shape.props.arrowheadEnd
    },
    middle: c2,
    handleArc,
    bodyArc,
    isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y)
  };
}
function getArcInfo(a2, b, c2) {
  const center = centerOfCircleFromThreePoints(a2, b, c2) ?? Vec.Med(a2, b);
  const radius = Vec.Dist(center, a2);
  const sweepFlag = +Vec.Clockwise(a2, c2, b);
  const ab = ((a2.y - b.y) ** 2 + (a2.x - b.x) ** 2) ** 0.5;
  const bc = ((b.y - c2.y) ** 2 + (b.x - c2.x) ** 2) ** 0.5;
  const ca = ((c2.y - a2.y) ** 2 + (c2.x - a2.x) ** 2) ** 0.5;
  const theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2;
  const largeArcFlag = +(PI$1 > theta);
  const size2 = (PI2 - theta) * (sweepFlag ? 1 : -1);
  const length = size2 * radius;
  return {
    center,
    radius,
    size: size2,
    length,
    largeArcFlag,
    sweepFlag
  };
}
function placeCenterHandle(center, radius, tempA, tempB, tempC, originalArcLength, isClockwise) {
  const aCA = Vec.Angle(center, tempA);
  const aCB = Vec.Angle(center, tempB);
  let dAB = clockwiseAngleDist(aCA, aCB);
  if (!isClockwise) dAB = PI2 - dAB;
  tempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius));
  if (dAB > originalArcLength) {
    tempC.rotWith(center, PI$1);
    const t2 = tempB.clone();
    tempB.setTo(tempA);
    tempA.setTo(t2);
  }
}
function expandRange(range, amount) {
  const newRange = {
    min: range.min - amount,
    max: range.max + amount
  };
  if (newRange.min > newRange.max) {
    return null;
  }
  return newRange;
}
function subtractRange(a2, b) {
  assert(a2.min <= a2.max && b.min <= b.max);
  if (a2.min <= b.min && b.max <= a2.max) {
    return [
      { min: a2.min, max: b.min },
      { min: b.max, max: a2.max }
    ];
  }
  if (b.max <= a2.min || b.min >= a2.max) {
    return [a2];
  }
  if (b.min <= a2.min && a2.max <= b.max) {
    return [];
  }
  if (isWithinRange(a2.min, b)) {
    return [{ min: b.max, max: a2.max }];
  }
  if (isWithinRange(a2.max, b)) {
    return [{ min: a2.min, max: b.min }];
  }
  return [];
}
function createRange(a2, b) {
  return { min: Math.min(a2, b), max: Math.max(a2, b) };
}
function isWithinRange(value, range) {
  return value >= range.min && value <= range.max;
}
function rangeSize(range) {
  return range.max - range.min;
}
function flipEdgeCrossInPlace(edge) {
  if (!edge) return;
  const tmp = edge.cross.min;
  edge.cross.min = -edge.cross.max;
  edge.cross.max = -tmp;
  edge.crossTarget = -edge.crossTarget;
}
function flipEdgeValueInPlace(edge) {
  if (!edge) return;
  edge.value = -edge.value;
  edge.expanded = edge.expanded === null ? null : -edge.expanded;
}
const ElbowArrowTransform = {
  Identity: { x: 1, y: 1, transpose: false },
  Rotate90: { x: -1, y: 1, transpose: true },
  Rotate180: { x: -1, y: -1, transpose: false },
  Rotate270: { x: 1, y: -1, transpose: true },
  FlipY: { x: 1, y: -1, transpose: false }
};
function invertElbowArrowTransform(transform) {
  if (transform.transpose) {
    return {
      x: transform.y,
      y: transform.x,
      transpose: true
    };
  }
  return transform;
}
function transformElbowArrowTransform(a2, b) {
  const next = { ...a2 };
  if (b.transpose) {
    swap(next, "x", "y");
    next.transpose = !next.transpose;
  }
  if (b.x === -1) {
    next.x = -next.x;
  }
  if (b.y === -1) {
    next.y = -next.y;
  }
  return next;
}
function swap(object2, a2, b) {
  const temp = object2[a2];
  object2[a2] = object2[b];
  object2[b] = temp;
}
function transformVecInPlace(transform, point) {
  point.x = transform.x * point.x;
  point.y = transform.y * point.y;
  if (transform.transpose) {
    swap(point, "x", "y");
  }
}
function transformBoxInPlace(transform, box) {
  if (transform.x === -1) {
    box.x = -(box.x + box.width);
  }
  if (transform.y === -1) {
    box.y = -(box.y + box.height);
  }
  if (transform.transpose) {
    swap(box, "x", "y");
    swap(box, "width", "height");
  }
}
function transformEdgesInPlace(transform, edges) {
  if (transform.x === -1) {
    swap(edges, "left", "right");
    flipEdgeCrossInPlace(edges.top);
    flipEdgeCrossInPlace(edges.bottom);
    flipEdgeValueInPlace(edges.left);
    flipEdgeValueInPlace(edges.right);
  }
  if (transform.y === -1) {
    swap(edges, "top", "bottom");
    flipEdgeCrossInPlace(edges.left);
    flipEdgeCrossInPlace(edges.right);
    flipEdgeValueInPlace(edges.top);
    flipEdgeValueInPlace(edges.bottom);
  }
  if (transform.transpose) {
    swap(edges, "left", "top");
    swap(edges, "right", "bottom");
  }
}
class ElbowArrowWorkingInfo {
  options;
  A;
  B;
  common;
  gapX;
  gapY;
  midX;
  midY;
  bias;
  constructor(info) {
    this.options = info.options;
    this.A = info.A;
    this.B = info.B;
    this.common = info.common;
    this.midX = info.midX;
    this.midY = info.midY;
    this.gapX = info.gapX;
    this.gapY = info.gapY;
    this.bias = new Vec(1, 1);
  }
  transform = ElbowArrowTransform.Identity;
  inverse = ElbowArrowTransform.Identity;
  apply(transform) {
    this.transform = transformElbowArrowTransform(transform, this.transform);
    this.inverse = invertElbowArrowTransform(this.transform);
    transformBoxInPlace(transform, this.A.original);
    transformBoxInPlace(transform, this.B.original);
    transformBoxInPlace(transform, this.common.original);
    transformBoxInPlace(transform, this.A.expanded);
    transformBoxInPlace(transform, this.B.expanded);
    transformBoxInPlace(transform, this.common.expanded);
    transformEdgesInPlace(transform, this.A.edges);
    transformEdgesInPlace(transform, this.B.edges);
    transformVecInPlace(transform, this.bias);
    if (transform.x === -1) {
      this.gapX = -this.gapX;
      this.midX = this.midX === null ? null : -this.midX;
    }
    if (transform.y === -1) {
      this.gapY = -this.gapY;
      this.midY = this.midY === null ? null : -this.midY;
    }
    if (transform.transpose) {
      let temp = this.midX;
      this.midX = this.midY;
      this.midY = temp;
      temp = this.gapX;
      this.gapX = this.gapY;
      this.gapY = temp;
    }
  }
  reset() {
    this.apply(this.inverse);
  }
  vec(x, y2) {
    const point = new Vec(x, y2);
    transformVecInPlace(this.inverse, point);
    return point;
  }
}
const MIN_DISTANCE = 0.01;
class ElbowArrowRouteBuilder {
  constructor(info, name) {
    this.info = info;
    this.name = name;
  }
  points = [];
  add(x, y2) {
    this.points.push(this.info.vec(x, y2));
    return this;
  }
  _midpointHandle = null;
  midpointHandle(axis) {
    assert(this._midpointHandle === null, "midX/midY called multiple times");
    const point = Vec.Lrp(
      this.points[this.points.length - 2],
      this.points[this.points.length - 1],
      0.5
    );
    this._midpointHandle = {
      axis: this.info.transform.transpose ? axis === "x" ? "y" : "x" : axis,
      point,
      segmentStart: this.points[this.points.length - 2].clone(),
      segmentEnd: this.points[this.points.length - 1].clone()
    };
    return this;
  }
  build() {
    const finalPoints = [];
    for (let i = 0; i < this.points.length; i++) {
      const p0 = this.points[i];
      const p1 = finalPoints[finalPoints.length - 1];
      const p2 = finalPoints[finalPoints.length - 2];
      if (!p1 || !p2) {
        finalPoints.push(p0);
      } else {
        const d1x = Math.abs(p0.x - p1.x);
        const d1y = Math.abs(p0.y - p1.y);
        const d2x = Math.abs(p0.x - p2.x);
        const d2y = Math.abs(p0.y - p2.y);
        if (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) ;
        else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {
          p1.y = p0.y;
        } else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {
          p1.x = p0.x;
        } else {
          finalPoints.push(p0);
        }
      }
    }
    return {
      name: this.name,
      points: finalPoints,
      distance: measureRouteManhattanDistance(finalPoints),
      aEdgePicking: "manual",
      bEdgePicking: "manual",
      skipPointsWhenDrawing: /* @__PURE__ */ new Set(),
      midpointHandle: this._midpointHandle
    };
  }
}
function measureRouteManhattanDistance(path) {
  let distance = 0;
  for (let i = 0; i < path.length - 1; i++) {
    const start = path[i];
    const end = path[i + 1];
    distance += Math.abs(end.x - start.x) + Math.abs(end.y - start.y);
  }
  return distance;
}
function routeRightToLeft(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.left;
  if (!aEdge || !bEdge) return null;
  if (aEdge.crossTarget > bEdge.crossTarget) {
    info.apply(ElbowArrowTransform.FlipY);
  }
  if (info.gapX > 0 && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 1").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded === null || bEdge.expanded === null) return null;
  if (info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 2").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.expanded, info.midY).midpointHandle("y").add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  const arrow3Distance = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.bottom) + Math.abs(info.common.expanded.right - bEdge.expanded) + Math.abs(info.common.expanded.bottom - bEdge.crossTarget) + info.options.expandElbowLegLength + 6;
  const arrow4Distance = info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(aEdge.expanded - info.common.expanded.left) + Math.abs(info.common.expanded.top - bEdge.crossTarget) + Math.abs(info.common.expanded.left - bEdge.value) + // 6 points in this arrow, plus bias towards down/right:
  6 + info.bias.y;
  const arrow5Distance = info.gapX < 0 && info.midX !== null ? info.options.expandElbowLegLength + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + info.common.expanded.width + Math.abs(info.A.expanded.bottom - info.B.expanded.top) + Math.abs(info.B.expanded.top - bEdge.crossTarget) + info.options.expandElbowLegLength + // 8 points in this arrow
  8 : Infinity;
  if (arrow3Distance < arrow4Distance && arrow3Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 3").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.bottom).add(bEdge.expanded, info.common.expanded.bottom).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (arrow4Distance < arrow5Distance) {
    return new ElbowArrowRouteBuilder(info, "to left 4").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.common.expanded.top).add(info.common.expanded.left, info.common.expanded.top).add(info.common.expanded.left, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to left 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, info.B.expanded.top).midpointHandle("y").add(bEdge.expanded, info.B.expanded.top).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
function routeRightToTop(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.top;
  if (!aEdge || !bEdge) return null;
  if (aEdge.crossTarget < (bEdge.expanded ?? bEdge.value) && bEdge.crossTarget > (aEdge.expanded ?? aEdge.value) || info.A.isPoint && info.B.expanded.containsPoint(info.A.original.center)) {
    return new ElbowArrowRouteBuilder(info, "to top 1").add(aEdge.value, aEdge.crossTarget).add(bEdge.crossTarget, aEdge.crossTarget).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapX > 0 && info.midX !== null && bEdge.expanded !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 2").add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (info.gapY > 0 && aEdge.expanded !== null && bEdge.crossTarget < aEdge.expanded && info.midY !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 3").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(bEdge.crossTarget, info.midY).midpointHandle("y").add(bEdge.crossTarget, bEdge.value).build();
  }
  const arrow4Length = Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.common.expanded.top) + Math.abs(bEdge.crossTarget - info.common.expanded.right) + Math.abs(bEdge.value - info.common.expanded.top);
  const arrow5Length = aEdge.expanded !== null && info.midY !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - aEdge.expanded) + Math.abs(info.B.expanded.left - aEdge.expanded) + Math.abs(info.B.expanded.left - bEdge.crossTarget) + Math.abs(aEdge.crossTarget - info.B.expanded.top) + Math.abs(bEdge.value - bEdge.expanded) : Infinity;
  const arrow6Length = aEdge.expanded !== null && info.midX !== null && bEdge.expanded !== null ? Math.abs(aEdge.value - info.common.expanded.right) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.expanded - bEdge.crossTarget) + Math.abs(info.A.expanded.bottom - bEdge.expanded) + Math.abs(bEdge.expanded - bEdge.value) : Infinity;
  if (arrow4Length < arrow5Length && arrow4Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 4").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, info.common.expanded.top).add(bEdge.crossTarget, info.common.expanded.top).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midY !== null && arrow5Length < arrow6Length) {
    return new ElbowArrowRouteBuilder(info, "to top 5").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.midY).add(info.B.expanded.left, info.midY).midpointHandle("y").add(info.B.expanded.left, bEdge.expanded).add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  if (bEdge.expanded !== null && aEdge.expanded !== null && info.midX !== null) {
    return new ElbowArrowRouteBuilder(info, "to top 6").add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded.bottom).add(info.midX, info.A.expanded.bottom).add(info.midX, bEdge.expanded).midpointHandle("x").add(bEdge.crossTarget, bEdge.expanded).add(bEdge.crossTarget, bEdge.value).build();
  }
  return null;
}
function routeRightToBottom(info) {
  info.apply(ElbowArrowTransform.FlipY);
  return routeRightToTop(info);
}
function routeRightToRight(info) {
  const aEdge = info.A.edges.right;
  const bEdge = info.B.edges.right;
  if (!aEdge || !bEdge) return null;
  if ((info.gapX <= 0 || aEdge.crossTarget > info.B.expanded.bottom || aEdge.crossTarget < info.B.expanded.top) && (bEdge.value > info.A.original.left || bEdge.crossTarget > info.A.expanded.bottom || bEdge.crossTarget < info.A.expanded.top)) {
    return new ElbowArrowRouteBuilder(info, "to right 1").add(aEdge.value, aEdge.crossTarget).add(info.common.expanded.right, aEdge.crossTarget).add(info.common.expanded.right, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (info.midX === null) return null;
  if (bEdge.expanded !== null && info.gapX >= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.B.expanded.bottom) + Math.abs(aEdge.crossTarget - info.B.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.B.expanded.top) + Math.abs(aEdge.crossTarget - info.B.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 2 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(info.midX, aEdge.crossTarget).add(info.midX, info.B.expanded[topOrBottom]).midpointHandle("x").add(bEdge.expanded, info.B.expanded[topOrBottom]).add(bEdge.expanded, bEdge.crossTarget).add(bEdge.value, bEdge.crossTarget).build();
  }
  if (aEdge.expanded !== null && info.gapX <= 0) {
    const viaBottomLength = Math.abs(bEdge.crossTarget - info.A.expanded.bottom) + Math.abs(aEdge.crossTarget - info.A.expanded.bottom);
    const viaTopLength = Math.abs(bEdge.crossTarget - info.A.expanded.top) + Math.abs(aEdge.crossTarget - info.A.expanded.top);
    const topOrBottom = viaBottomLength < viaTopLength ? "bottom" : "top";
    return new ElbowArrowRouteBuilder(info, `to right 3 via ${topOrBottom}`).add(aEdge.value, aEdge.crossTarget).add(aEdge.expanded, aEdge.crossTarget).add(aEdge.expanded, info.A.expanded[topOrBottom]).add(info.midX, info.A.expanded[topOrBottom]).add(info.midX, bEdge.crossTarget).midpointHandle("x").add(bEdge.value, bEdge.crossTarget).build();
  }
  return null;
}
const routes = {
  top: {
    top: [ElbowArrowTransform.Rotate270, routeRightToRight],
    left: [ElbowArrowTransform.Rotate270, routeRightToTop],
    bottom: [ElbowArrowTransform.Rotate270, routeRightToLeft],
    right: [ElbowArrowTransform.Rotate270, routeRightToBottom]
  },
  right: {
    top: [ElbowArrowTransform.Identity, routeRightToTop],
    right: [ElbowArrowTransform.Identity, routeRightToRight],
    bottom: [ElbowArrowTransform.Identity, routeRightToBottom],
    left: [ElbowArrowTransform.Identity, routeRightToLeft]
  },
  bottom: {
    top: [ElbowArrowTransform.Rotate90, routeRightToLeft],
    left: [ElbowArrowTransform.Rotate90, routeRightToBottom],
    bottom: [ElbowArrowTransform.Rotate90, routeRightToRight],
    right: [ElbowArrowTransform.Rotate90, routeRightToTop]
  },
  left: {
    top: [ElbowArrowTransform.Rotate180, routeRightToBottom],
    left: [ElbowArrowTransform.Rotate180, routeRightToRight],
    bottom: [ElbowArrowTransform.Rotate180, routeRightToTop],
    right: [ElbowArrowTransform.Rotate180, routeRightToLeft]
  }
};
function tryRouteArrow(info, aEdge, bEdge) {
  const [transform, routeFn] = routes[aEdge][bEdge];
  info.apply(transform);
  const route = routeFn(info);
  info.reset();
  return route;
}
function routeArrowWithAutoEdgePicking(info, reason) {
  let idealRoute = null;
  if (
    // +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket
    // to 45 deg (as gapx/gapy are almost equal and the result depends on floating point
    // precision)
    Math.abs(info.gapX) + 1 > Math.abs(info.gapY) && info.midX !== null
  ) {
    if (info.gapX > 0) {
      idealRoute = tryRouteArrow(info, "right", "left");
    } else {
      idealRoute = tryRouteArrow(info, "left", "right");
    }
  } else {
    const aRight = info.A.edges.right;
    const aLeft = info.A.edges.left;
    const bTop = info.B.edges.top;
    const bBottom = info.B.edges.bottom;
    if (info.A.isPoint && info.B.isPoint) {
      if (info.gapY > 0) {
        idealRoute = tryRouteArrow(info, "bottom", "top");
      } else {
        idealRoute = tryRouteArrow(info, "top", "bottom");
      }
    } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "right", "top");
    } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "right", "bottom");
    } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
      idealRoute = tryRouteArrow(info, "left", "top");
    } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
      idealRoute = tryRouteArrow(info, "left", "bottom");
    } else if (info.gapY > 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "bottom", "top");
    } else if (info.gapY < 0 && info.midY !== null) {
      idealRoute = tryRouteArrow(info, "top", "bottom");
    }
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = reason;
    idealRoute.bEdgePicking = reason;
    return idealRoute;
  }
  const aAvailableSide = ElbowArrowSides.filter((side) => info.A.edges[side]);
  const bAvailableSides = ElbowArrowSides.filter((side) => info.B.edges[side]);
  const nonPartialRouteCandidates = aAvailableSide.flatMap(
    (aSide) => bAvailableSides.map((bSide) => [aSide, bSide, reason, reason])
  );
  return pickBest(info, nonPartialRouteCandidates);
}
function routeArrowWithPartialEdgePicking(info, aSide) {
  let idealRoute = null;
  const aRight = info.A.edges.right;
  const aLeft = info.A.edges.left;
  const bTop = info.B.edges.top;
  const bBottom = info.B.edges.bottom;
  switch (aSide) {
    case "right":
      if (info.gapX > 0 && info.gapX > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "right", "left");
      } else if (aRight && bTop && (aRight.expanded ?? aRight.value) <= bTop.crossTarget && aRight.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "right", "top");
      } else if (aRight && bBottom && (aRight.expanded ?? aRight.value) <= bBottom.crossTarget && aRight.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "right", "bottom");
      }
      break;
    case "left":
      if (info.gapX < 0 && Math.abs(info.gapX) > Math.abs(info.gapY) && info.midX !== null) {
        idealRoute = tryRouteArrow(info, "left", "right");
      } else if (aLeft && bTop && (aLeft.expanded ?? aLeft.value) >= bTop.crossTarget && aLeft.crossTarget <= (bTop.expanded ?? bTop.value)) {
        idealRoute = tryRouteArrow(info, "left", "top");
      } else if (aLeft && bBottom && (aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget && aLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)) {
        idealRoute = tryRouteArrow(info, "left", "bottom");
      }
      break;
    case "top":
    case "bottom":
      break;
    default:
      exhaustiveSwitchError$1(aSide);
  }
  if (idealRoute) {
    idealRoute.aEdgePicking = "manual";
    idealRoute.bEdgePicking = "auto";
    return idealRoute;
  }
  switch (aSide) {
    case "top":
      return pickBest(info, [
        ["top", "bottom", "manual", "auto"],
        ["top", "right", "manual", "auto"],
        ["top", "left", "manual", "auto"],
        ["top", "top", "manual", "auto"]
      ]);
    case "bottom":
      return pickBest(info, [
        ["bottom", "top", "manual", "auto"],
        ["bottom", "right", "manual", "auto"],
        ["bottom", "left", "manual", "auto"],
        ["bottom", "bottom", "manual", "auto"]
      ]);
    case "left":
      return pickBest(info, [
        ["left", "right", "manual", "auto"],
        ["left", "bottom", "manual", "auto"],
        ["left", "left", "manual", "auto"],
        ["left", "top", "manual", "auto"]
      ]);
    case "right":
      return pickBest(info, [
        ["right", "left", "manual", "auto"],
        ["right", "bottom", "manual", "auto"],
        ["right", "right", "manual", "auto"],
        ["right", "top", "manual", "auto"]
      ]);
  }
}
function routeArrowWithManualEdgePicking(info, aSide, bSide) {
  const route = tryRouteArrow(info, aSide, bSide);
  if (route) return route;
  if (info.A.isPoint && info.B.isPoint) {
    return pickBest(info, [
      [ElbowArrowSideOpposites[aSide], ElbowArrowSideOpposites[bSide], "manual", "manual"],
      [aSide, ElbowArrowSideOpposites[bSide], "manual", "auto"],
      [ElbowArrowSideOpposites[aSide], bSide, "auto", "manual"]
    ]);
  } else if (info.A.isPoint) {
    return tryRouteArrow(info, ElbowArrowSideOpposites[aSide], bSide);
  } else if (info.B.isPoint) {
    return tryRouteArrow(info, aSide, ElbowArrowSideOpposites[bSide]);
  }
  return null;
}
function pickBest(info, edges) {
  let bestRoute = null;
  let bestCornerCount = Infinity;
  let bestDistance = Infinity;
  let distanceBias = 0;
  for (const [aSide, bSide, aEdgePicking, bEdgePicking] of edges) {
    distanceBias += 1;
    const route = tryRouteArrow(info, aSide, bSide);
    if (route) {
      route.aEdgePicking = aEdgePicking;
      route.bEdgePicking = bEdgePicking;
      if (route.points.length < bestCornerCount) {
        bestCornerCount = route.points.length;
        bestDistance = route.distance;
        bestRoute = route;
      } else if (route.points.length === bestCornerCount && route.distance + distanceBias < bestDistance) {
        bestDistance = route.distance;
        bestRoute = route;
      }
    }
  }
  return bestRoute;
}
function getElbowArrowInfo(editor, arrow2, bindings) {
  const shapeOptions = editor.getShapeUtil(arrow2.type).options;
  const options = {
    elbowMidpoint: arrow2.props.elbowMidPoint,
    expandElbowLegLength: shapeOptions.expandElbowLegLength[arrow2.props.size] * arrow2.props.scale,
    minElbowLegLength: shapeOptions.minElbowLegLength[arrow2.props.size] * arrow2.props.scale
  };
  let startTerminal = getElbowArrowTerminalInfo(editor, arrow2, bindings.start, arrow2.props.start);
  let endTerminal = getElbowArrowTerminalInfo(editor, arrow2, bindings.end, arrow2.props.end);
  startTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options);
  endTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options);
  const swapOrder = !!(!startTerminal.side && endTerminal.side);
  let { aTerminal, bTerminal } = swapOrder ? { aTerminal: endTerminal, bTerminal: startTerminal } : { aTerminal: startTerminal, bTerminal: endTerminal };
  let edgesA = {
    top: getUsableEdge(aTerminal, bTerminal, "top", options),
    right: getUsableEdge(aTerminal, bTerminal, "right", options),
    bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options),
    left: getUsableEdge(aTerminal, bTerminal, "left", options)
  };
  let edgesB = {
    top: getUsableEdge(bTerminal, aTerminal, "top", options),
    right: getUsableEdge(bTerminal, aTerminal, "right", options),
    bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options),
    left: getUsableEdge(bTerminal, aTerminal, "left", options)
  };
  const aIsUsable = hasUsableEdge(edgesA, aTerminal.side);
  const bIsUsable = hasUsableEdge(edgesB, bTerminal.side);
  let needsNewEdges = false;
  if (!aIsUsable || !bIsUsable) {
    needsNewEdges = true;
    if (!aIsUsable) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (!bIsUsable) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
    if (bTerminal.bounds.containsPoint(aTerminal.target, options.expandElbowLegLength)) {
      bTerminal = convertTerminalToPoint(bTerminal);
    }
    if (aTerminal.bounds.containsPoint(bTerminal.target, options.expandElbowLegLength)) {
      aTerminal = convertTerminalToPoint(aTerminal);
    }
  }
  if (needsNewEdges) {
    edgesA = {
      top: getUsableEdge(aTerminal, bTerminal, "top", options),
      right: getUsableEdge(aTerminal, bTerminal, "right", options),
      bottom: getUsableEdge(aTerminal, bTerminal, "bottom", options),
      left: getUsableEdge(aTerminal, bTerminal, "left", options)
    };
    edgesB = {
      top: getUsableEdge(bTerminal, aTerminal, "top", options),
      right: getUsableEdge(bTerminal, aTerminal, "right", options),
      bottom: getUsableEdge(bTerminal, aTerminal, "bottom", options),
      left: getUsableEdge(bTerminal, aTerminal, "left", options)
    };
  }
  const expandedA = aTerminal.isPoint ? aTerminal.bounds : aTerminal.bounds.clone().expandBy(options.expandElbowLegLength);
  const expandedB = bTerminal.isPoint ? bTerminal.bounds : bTerminal.bounds.clone().expandBy(options.expandElbowLegLength);
  const common = {
    original: Box.Common([aTerminal.bounds, bTerminal.bounds]),
    expanded: Box.Common([expandedA, expandedB])
  };
  let gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX;
  if (gapX < 0) {
    gapX = aTerminal.bounds.minX - bTerminal.bounds.maxX;
    if (gapX < 0) {
      gapX = 0;
    }
    gapX = -gapX;
  }
  let gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY;
  if (gapY < 0) {
    gapY = aTerminal.bounds.minY - bTerminal.bounds.maxY;
    if (gapY < 0) {
      gapY = 0;
    }
    gapY = -gapY;
  }
  const aMinLength = aTerminal.minEndSegmentLength * 3;
  const bMinLength = bTerminal.minEndSegmentLength * 3;
  const minLegDistanceNeeded = (aTerminal.isPoint ? aMinLength : options.minElbowLegLength) + (bTerminal.isPoint ? bMinLength : options.minElbowLegLength);
  let mxRange = null;
  if (gapX > minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,
      b: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX
    };
  } else if (gapX < -minLegDistanceNeeded) {
    mxRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,
      b: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX
    };
  }
  let myRange = null;
  if (gapY > minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,
      b: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY
    };
  } else if (gapY < -minLegDistanceNeeded) {
    myRange = {
      a: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,
      b: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY
    };
  }
  const midpoint = swapOrder ? 1 - options.elbowMidpoint : options.elbowMidpoint;
  const mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint) : null;
  const my = myRange ? lerp(myRange.a, myRange.b, midpoint) : null;
  const info = {
    options,
    swapOrder,
    A: {
      isPoint: aTerminal.isPoint,
      target: aTerminal.target,
      isExact: aTerminal.isExact,
      arrowheadOffset: aTerminal.arrowheadOffset,
      minEndSegmentLength: aTerminal.minEndSegmentLength,
      original: aTerminal.bounds,
      expanded: expandedA,
      edges: edgesA,
      geometry: aTerminal.geometry
    },
    B: {
      isPoint: bTerminal.isPoint,
      target: bTerminal.target,
      isExact: bTerminal.isExact,
      arrowheadOffset: bTerminal.arrowheadOffset,
      minEndSegmentLength: bTerminal.minEndSegmentLength,
      original: bTerminal.bounds,
      expanded: expandedB,
      edges: edgesB,
      geometry: bTerminal.geometry
    },
    common,
    gapX,
    gapY,
    midX: mx,
    midY: my
  };
  const workingInfo = new ElbowArrowWorkingInfo(info);
  const aSide = getSideToUse(aTerminal, bTerminal, info.A.edges);
  const bSide = getSideToUse(bTerminal, aTerminal, info.B.edges);
  let route;
  if (aSide && bSide) {
    route = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide);
  } else if (aSide && !bSide) {
    route = routeArrowWithPartialEdgePicking(workingInfo, aSide);
  }
  if (!route) {
    route = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? "fallback" : "auto");
  }
  if (route) {
    castPathSegmentIntoGeometry("first", info.A, info.B, route);
    castPathSegmentIntoGeometry("last", info.B, info.A, route);
    fixTinyEndNubs(route, aTerminal, bTerminal);
    if (swapOrder) route.points.reverse();
  }
  return {
    ...info,
    route,
    midXRange: mxRange ? swapOrder ? { lo: mxRange.b, hi: mxRange.a } : { lo: mxRange.a, hi: mxRange.b } : null,
    midYRange: myRange ? swapOrder ? { lo: myRange.b, hi: myRange.a } : { lo: myRange.a, hi: myRange.b } : null
  };
}
function getRouteHandlePath(info, route) {
  const startTarget = info.swapOrder ? info.B.target : info.A.target;
  const endTarget = info.swapOrder ? info.A.target : info.B.target;
  const firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1]);
  const lastSegmentLength = Vec.ManhattanDist(
    route.points[route.points.length - 2],
    route.points[route.points.length - 1]
  );
  const newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1]);
  const newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget);
  const firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength;
  const lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength;
  const newPoints = [startTarget, ...route.points, endTarget];
  return {
    name: route.name,
    distance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,
    points: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),
    aEdgePicking: route.aEdgePicking,
    bEdgePicking: route.bEdgePicking,
    skipPointsWhenDrawing: route.skipPointsWhenDrawing,
    midpointHandle: route.midpointHandle
  };
}
function getEdgeFromNormalizedAnchor(normalizedAnchor) {
  if (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {
    return null;
  }
  if (Math.abs(normalizedAnchor.x - 0.5) > // slightly bias towards x arrows to prevent flickering when the anchor is right on the line
  // between the two directions
  Math.abs(normalizedAnchor.y - 0.5) - 1e-4) {
    return normalizedAnchor.x < 0.5 ? "left" : "right";
  }
  return normalizedAnchor.y < 0.5 ? "top" : "bottom";
}
function getElbowArrowTerminalInfo(editor, arrow2, binding, point) {
  const arrowStrokeSize = STROKE_SIZES$1[arrow2.props.size] * arrow2.props.scale / 2;
  const minEndSegmentLength = arrowStrokeSize * arrow2.props.scale * 3;
  if (binding) {
    const target = editor.getShape(binding.toId);
    const geometry = getBindingGeometryInArrowSpace(editor, arrow2, binding.toId, binding.props);
    if (geometry && target) {
      let arrowheadOffset = 0;
      const arrowheadProp = binding.props.terminal === "start" ? "arrowheadStart" : "arrowheadEnd";
      if (arrow2.props[arrowheadProp] !== "none") {
        const targetScale = "scale" in target.props ? target.props.scale : 1;
        const targetStrokeSize = "size" in target.props ? (STROKE_SIZES$1[target.props.size] ?? 0) * targetScale / 2 : 0;
        arrowheadOffset = arrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow2.props.scale;
      }
      let side = null;
      const targetPoint = geometry.target;
      if (binding.props.isPrecise) {
        side = getEdgeFromNormalizedAnchor(
          Vec.RotWith(
            binding.props.normalizedAnchor,
            { x: 0.5, y: 0.5 },
            geometry.shapeToArrowTransform.rotation()
          )
        );
      }
      return {
        targetShapeId: binding.toId,
        isPoint: false,
        isExact: binding.props.isExact,
        bounds: geometry.bounds,
        geometry: geometry.geometry,
        target: targetPoint,
        arrowheadOffset,
        minEndSegmentLength,
        side,
        snap: binding.props.snap
      };
    }
  }
  return {
    targetShapeId: null,
    bounds: Box.FromCenter(point, { x: 0, y: 0 }),
    geometry: null,
    isExact: false,
    isPoint: true,
    target: Vec.From(point),
    arrowheadOffset: 0,
    minEndSegmentLength,
    side: null,
    snap: "none"
  };
}
function getBindingGeometryInArrowSpace(editor, arrow2, targetId, bindingProps) {
  const hasArrowhead = bindingProps.terminal === "start" ? arrow2.props.arrowheadStart !== "none" : arrow2.props.arrowheadEnd !== "none";
  const targetGeometryInTargetSpace = editor.getShapeGeometry(
    targetId,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  if (!targetGeometryInTargetSpace) {
    return null;
  }
  const arrowTransform = editor.getShapePageTransform(arrow2.id);
  const shapeTransform = editor.getShapePageTransform(targetId);
  const shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform);
  const targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform);
  const center = { x: 0.5, y: 0.5 };
  const normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center;
  const targetInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      normalizedAnchor.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      normalizedAnchor.y
    )
  };
  const centerInShapeSpace = {
    x: lerp(
      targetGeometryInTargetSpace.bounds.minX,
      targetGeometryInTargetSpace.bounds.maxX,
      center.x
    ),
    y: lerp(
      targetGeometryInTargetSpace.bounds.minY,
      targetGeometryInTargetSpace.bounds.maxY,
      center.y
    )
  };
  const targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace);
  const centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace);
  return {
    bounds: targetGeometryInArrowSpace.bounds,
    geometry: targetGeometryInArrowSpace,
    target: targetInArrowSpace,
    center: centerInArrowSpace,
    shapeToArrowTransform
  };
}
const sideProps = {
  top: {
    expand: -1,
    main: "minY",
    opposite: "maxY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "max",
    crossAxis: "x"
  },
  bottom: {
    expand: 1,
    main: "maxY",
    opposite: "minY",
    crossMid: "midX",
    crossMin: "minX",
    crossMax: "maxX",
    bRangeExpand: "min",
    crossAxis: "x"
  },
  left: {
    expand: -1,
    main: "minX",
    opposite: "maxX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "max",
    crossAxis: "y"
  },
  right: {
    expand: 1,
    main: "maxX",
    opposite: "minX",
    crossMid: "midY",
    crossMin: "minY",
    crossMax: "maxY",
    bRangeExpand: "min",
    crossAxis: "y"
  }
};
function getUsableEdge(a2, b, side, options) {
  const props = sideProps[side];
  const isSelfBoundAndShouldRouteExternal = a2.targetShapeId === b.targetShapeId && a2.targetShapeId !== null && (a2.snap === "edge" || a2.snap === "edge-point") && (b.snap === "edge" || b.snap === "edge-point");
  const aValue = a2.bounds[props.main];
  const aExpanded = a2.isPoint ? null : aValue + props.expand * options.expandElbowLegLength;
  const originalACrossRange = createRange(a2.bounds[props.crossMin], a2.bounds[props.crossMax]);
  let aCrossRange = originalACrossRange;
  if (!aCrossRange) {
    return null;
  }
  assert(originalACrossRange);
  const bRange = createRange(b.bounds[props.main], b.bounds[props.opposite]);
  if (!b.isPoint) {
    bRange[props.bRangeExpand] -= options.minElbowLegLength * 2 * props.expand;
  }
  const bCrossRange = expandRange(
    createRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),
    options.expandElbowLegLength
  );
  assert(bRange && bCrossRange);
  let isPartial = false;
  if (isWithinRange(aValue, bRange) && !a2.isPoint && !b.isPoint && !isSelfBoundAndShouldRouteExternal) {
    const subtracted = subtractRange(aCrossRange, bCrossRange);
    switch (subtracted.length) {
      case 0:
        return null;
      case 1:
        isPartial = subtracted[0] !== aCrossRange;
        aCrossRange = subtracted[0];
        break;
      case 2:
        isPartial = true;
        aCrossRange = rangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1];
        break;
      default:
        exhaustiveSwitchError$1(subtracted);
    }
  }
  if (!isWithinRange(a2.target[props.crossAxis], aCrossRange)) {
    return null;
  }
  const crossTarget = a2.target[props.crossAxis];
  return {
    value: aValue,
    expanded: aExpanded,
    cross: aCrossRange,
    crossTarget,
    isPartial
  };
}
function hasUsableEdge(edges, side) {
  if (side === null) {
    return !!(edges.bottom || edges.left || edges.right || edges.top);
  }
  if (side === "x") {
    return !!edges.left || !!edges.right;
  }
  if (side === "y") {
    return !!edges.top || !!edges.bottom;
  }
  return !!edges[side];
}
function getSideToUse(binding, other, edges) {
  switch (binding.side) {
    case null:
      return null;
    case "x":
      if (binding.bounds.center.x > other.bounds.center.x && edges?.left) {
        return "left";
      } else if (edges?.right) {
        return "right";
      }
      return null;
    case "y":
      if (binding.bounds.center.y > other.bounds.center.y && edges?.top) {
        return "top";
      } else if (edges?.bottom) {
        return "bottom";
      }
      return null;
    default:
      return binding.side;
  }
}
function convertTerminalToPoint(terminal) {
  if (terminal.isPoint) return terminal;
  let side = null;
  let arrowheadOffset = 0;
  if (terminal.snap === "edge" || terminal.snap === "edge-point") {
    arrowheadOffset = terminal.arrowheadOffset;
    if (terminal.side === "x" || terminal.side === "left" || terminal.side === "right") {
      side = "x";
    }
    if (terminal.side === "y" || terminal.side === "top" || terminal.side === "bottom") {
      side = "y";
    }
  }
  return {
    targetShapeId: terminal.targetShapeId,
    side,
    bounds: new Box(terminal.target.x, terminal.target.y, 0, 0),
    geometry: terminal.geometry,
    target: terminal.target,
    arrowheadOffset,
    minEndSegmentLength: terminal.minEndSegmentLength,
    isExact: terminal.isExact,
    isPoint: true,
    snap: terminal.snap
  };
}
function castPathSegmentIntoGeometry(segment, target, other, route) {
  if (!target.geometry) return;
  const point1 = segment === "first" ? route.points[0] : route.points[route.points.length - 1];
  const point2 = segment === "first" ? route.points[1] : route.points[route.points.length - 2];
  const pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target;
  const initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo);
  let nearestIntersectionToPoint2 = null;
  let nearestDistanceToPoint2 = Infinity;
  if (target.isExact) {
    nearestIntersectionToPoint2 = target.target;
  } else if (target.geometry) {
    const intersections = target.geometry.intersectLineSegment(point2, target.target, {
      includeLabels: false,
      includeInternal: false
    });
    if (target.geometry.hitTestPoint(
      target.target,
      Math.max(1, target.arrowheadOffset),
      true,
      Geometry2dFilters.EXCLUDE_NON_STANDARD
    )) {
      intersections.push(target.target);
    }
    for (const intersection of intersections) {
      const point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection);
      if (point2Distance < nearestDistanceToPoint2) {
        nearestDistanceToPoint2 = point2Distance;
        nearestIntersectionToPoint2 = intersection;
      }
    }
  }
  if (nearestIntersectionToPoint2) {
    let offset2 = target.arrowheadOffset;
    const currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2);
    const minLength = target.arrowheadOffset * 2;
    if (currentFinalSegmentLength < minLength) {
      const targetLength = minLength - target.arrowheadOffset;
      offset2 = currentFinalSegmentLength - targetLength;
    }
    if (offset2 < target.minEndSegmentLength) {
      if (target.geometry.bounds.containsPoint(other.target)) {
        offset2 = Math.max(0, offset2);
      } else {
        offset2 = -target.arrowheadOffset;
      }
    }
    let nudgedPoint = nearestIntersectionToPoint2;
    let shouldAddExtraPointForNudge = false;
    if (!target.isExact && offset2 !== 0) {
      const nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset2);
      nudgedPoint = nudged;
      if (offset2 < 0 && !target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)) {
        nudgedPoint = nearestIntersectionToPoint2;
      } else {
        if (offset2 < 0) {
          shouldAddExtraPointForNudge = true;
        }
        nudgedPoint = nudged;
      }
    }
    const newDistance = Vec.ManhattanDist(point2, nudgedPoint);
    route.distance += newDistance - initialDistance;
    point1.x = nudgedPoint.x;
    point1.y = nudgedPoint.y;
    if (shouldAddExtraPointForNudge) {
      const midPoint2 = Vec.Lrp(point2, point1, 0.5);
      route.skipPointsWhenDrawing.add(midPoint2);
      route.points.splice(segment === "first" ? 1 : route.points.length - 1, 0, midPoint2);
    }
  }
}
function fixTinyEndNubs(route, aTerminal, bTerminal) {
  if (!route) return;
  if (route.points.length >= 3) {
    const a2 = route.points[0];
    const b = route.points[1];
    const firstSegmentLength = Vec.ManhattanDist(a2, b);
    if (firstSegmentLength < aTerminal.minEndSegmentLength) {
      route.points.splice(1, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a2.x, b.x) ? "y" : "x";
        route.points[1][matchAxis] = a2[matchAxis];
      }
    }
  }
  if (route.points.length >= 3) {
    const a2 = route.points[route.points.length - 1];
    const b = route.points[route.points.length - 2];
    const lastSegmentLength = Vec.ManhattanDist(a2, b);
    if (lastSegmentLength < bTerminal.minEndSegmentLength) {
      route.points.splice(route.points.length - 2, 1);
      if (route.points.length >= 3) {
        const matchAxis = approximately(a2.x, b.x) ? "y" : "x";
        route.points[route.points.length - 2][matchAxis] = a2[matchAxis];
      }
    }
  }
}
function adjustTerminalForUnclosedPathIfNeeded(terminal, otherTerminal, options) {
  if (!terminal.geometry || terminal.geometry.isClosed) return terminal;
  const normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(
    terminal.target,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  );
  const prev = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath - 0.01 / terminal.geometry.length
  );
  const next = terminal.geometry.interpolateAlongEdge(
    normalizedPointAlongPath + 0.01 / terminal.geometry.length
  );
  const normal = next.sub(prev).per().uni();
  const axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y;
  if (terminal.geometry.bounds.containsPoint(otherTerminal.target, options.expandElbowLegLength)) {
    terminal.side = axis.self;
    return convertTerminalToPoint(terminal);
  }
  const min2 = axis.v(
    terminal.target[axis.self] - terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  const max2 = axis.v(
    terminal.target[axis.self] + terminal.bounds[axis.size] * 2,
    terminal.target[axis.cross]
  );
  let furthestIntersectionTowardsMin = null;
  let furthestIntersectionTowardsMinDistance = 0;
  let furthestIntersectionTowardsMax = null;
  let furthestIntersectionTowardsMaxDistance = 0;
  let side = axis.self;
  for (const intersection of terminal.geometry.intersectLineSegment(
    min2,
    max2,
    Geometry2dFilters.EXCLUDE_NON_STANDARD
  )) {
    if (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {
      continue;
    }
    if (intersection[axis.self] < terminal.target[axis.self]) {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance) {
        furthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMin = intersection;
      }
    } else {
      if (Vec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance) {
        furthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target);
        furthestIntersectionTowardsMax = intersection;
      }
    }
  }
  if (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    if (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {
      side = axis.hiEdge;
    } else {
      side = axis.loEdge;
    }
  } else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {
    side = axis.hiEdge;
  } else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {
    side = axis.loEdge;
  }
  terminal.side = side;
  return terminal;
}
const MIN_ARROW_BEND = 8;
function getIsArrowStraight(shape) {
  if (shape.props.kind !== "arc") return false;
  return Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale;
}
function getBoundShapeInfoForTerminal(editor, arrow2, terminalName) {
  const binding = editor.getBindingsFromShape(arrow2, "arrow").find((b) => b.props.terminal === terminalName);
  if (!binding) return;
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) return;
  const transform = editor.getShapePageTransform(boundShape);
  const hasArrowhead = terminalName === "start" ? arrow2.props.arrowheadStart !== "none" : arrow2.props.arrowheadEnd !== "none";
  const geometry = editor.getShapeGeometry(
    boundShape,
    hasArrowhead ? void 0 : { context: "@tldraw/arrow-without-arrowhead" }
  );
  return {
    shape: boundShape,
    transform,
    isClosed: geometry.isClosed,
    isExact: binding.props.isExact,
    didIntersect: false,
    geometry
  };
}
function getArrowTerminalInArrowSpace(editor, arrowPageTransform, binding, forceImprecise) {
  const boundShape = editor.getShape(binding.toId);
  if (!boundShape) {
    return new Vec(0, 0);
  } else {
    const { point, size: size2 } = editor.getShapeGeometry(boundShape).bounds;
    const shapePoint = Vec.Add(
      point,
      Vec.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        binding.props.isPrecise || forceImprecise ? binding.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        size2
      )
    );
    const pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape), shapePoint);
    const arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint);
    return arrowPoint;
  }
}
function getArrowBindings(editor, shape) {
  const bindings = editor.getBindingsFromShape(shape, "arrow");
  return {
    start: bindings.find((b) => b.props.terminal === "start"),
    end: bindings.find((b) => b.props.terminal === "end")
  };
}
const arrowInfoCache = createComputedCache(
  "arrow info",
  (editor, shape) => {
    const bindings = getArrowBindings(editor, shape);
    if (shape.props.kind === "elbow") {
      const elbowInfo = getElbowArrowInfo(editor, shape, bindings);
      if (!elbowInfo?.route) return getStraightArrowInfo(editor, shape, bindings);
      const start = elbowInfo.swapOrder ? elbowInfo.B : elbowInfo.A;
      const end = elbowInfo.swapOrder ? elbowInfo.A : elbowInfo.B;
      return {
        type: "elbow",
        bindings,
        start: {
          handle: start.target,
          point: elbowInfo.route.points[0],
          arrowhead: shape.props.arrowheadStart
        },
        end: {
          handle: end.target,
          point: elbowInfo.route.points[elbowInfo.route.points.length - 1],
          arrowhead: shape.props.arrowheadEnd
        },
        elbow: elbowInfo,
        route: elbowInfo.route,
        isValid: true
      };
    }
    return getIsArrowStraight(shape) ? getStraightArrowInfo(editor, shape, bindings) : getCurvedArrowInfo(editor, shape, bindings);
  }
);
function getArrowInfo(editor, shape) {
  const id = typeof shape === "string" ? shape : shape.id;
  return arrowInfoCache.get(editor, id);
}
function getArrowTerminalsInArrowSpace(editor, shape, bindings) {
  const arrowPageTransform = editor.getShapePageTransform(shape);
  const boundShapeRelationships = getBoundShapeRelationships(
    editor,
    bindings.start?.toId,
    bindings.end?.toId
  );
  const start = bindings.start ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.start,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "start-contains-end"
  ) : Vec.From(shape.props.start);
  const end = bindings.end ? getArrowTerminalInArrowSpace(
    editor,
    arrowPageTransform,
    bindings.end,
    boundShapeRelationships === "double-bound" || boundShapeRelationships === "end-contains-start"
  ) : Vec.From(shape.props.end);
  return { start, end };
}
function createOrUpdateArrowBinding(editor, arrow2, target, props) {
  const arrowId = typeof arrow2 === "string" ? arrow2 : arrow2.id;
  const targetId = typeof target === "string" ? target : target.id;
  const existingMany = editor.getBindingsFromShape(arrowId, "arrow").filter((b) => b.props.terminal === props.terminal);
  if (existingMany.length > 1) {
    editor.deleteBindings(existingMany.slice(1));
  }
  const existing = existingMany[0];
  if (existing) {
    editor.updateBinding({
      ...existing,
      toId: targetId,
      props
    });
  } else {
    editor.createBinding({
      type: "arrow",
      fromId: arrowId,
      toId: targetId,
      props
    });
  }
}
function removeArrowBinding(editor, arrow2, terminal) {
  const existing = editor.getBindingsFromShape(arrow2, "arrow").filter((b) => b.props.terminal === terminal);
  editor.deleteBindings(existing);
}
const MIN_ARROW_LENGTH = 10;
const BOUND_ARROW_OFFSET = 10;
const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
const STROKE_SIZES$1 = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function getBoundShapeRelationships(editor, startShapeId, endShapeId) {
  if (!startShapeId || !endShapeId) return "safe";
  if (startShapeId === endShapeId) return "double-bound";
  const startBounds = editor.getShapePageBounds(startShapeId);
  const endBounds = editor.getShapePageBounds(endShapeId);
  if (startBounds && endBounds) {
    if (startBounds.contains(endBounds)) return "start-contains-end";
    if (endBounds.contains(startBounds)) return "end-contains-start";
  }
  return "safe";
}
class ArrowBindingUtil extends BindingUtil {
  static type = "arrow";
  static props = arrowBindingProps;
  static migrations = arrowBindingMigrations;
  getDefaultProps() {
    return {
      isPrecise: false,
      isExact: false,
      normalizedAnchor: { x: 0.5, y: 0.5 },
      snap: "none"
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding }) {
    const arrow2 = this.editor.getShape(binding.fromId);
    if (!arrow2) return;
    arrowDidUpdate(this.editor, arrow2);
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter }) {
    const arrow2 = this.editor.getShape(bindingAfter.fromId);
    if (!arrow2) return;
    arrowDidUpdate(this.editor, arrow2);
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter
  }) {
    arrowDidUpdate(this.editor, shapeAfter);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({ binding }) {
    reparentArrow(this.editor, binding.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding
  }) {
    const arrow2 = this.editor.getShape(binding.fromId);
    if (!arrow2) return;
    updateArrowTerminal({
      editor: this.editor,
      arrow: arrow2,
      terminal: binding.props.terminal
    });
  }
}
function reparentArrow(editor, arrowId) {
  const arrow2 = editor.getShape(arrowId);
  if (!arrow2) return;
  const bindings = getArrowBindings(editor, arrow2);
  const { start, end } = bindings;
  const startShape = start ? editor.getShape(start.toId) : void 0;
  const endShape = end ? editor.getShape(end.toId) : void 0;
  const parentPageId = editor.getAncestorPageId(arrow2);
  if (!parentPageId) return;
  let nextParentId;
  if (startShape && endShape) {
    nextParentId = editor.findCommonAncestor([startShape, endShape]) ?? parentPageId;
  } else if (startShape || endShape) {
    const bindingParentId = (startShape || endShape)?.parentId;
    if (bindingParentId && bindingParentId === arrow2.parentId) {
      nextParentId = arrow2.parentId;
    } else {
      nextParentId = parentPageId;
    }
  } else {
    return;
  }
  if (nextParentId && nextParentId !== arrow2.parentId) {
    editor.reparentShapes([arrowId], nextParentId);
  }
  const reparentedArrow = editor.getShape(arrowId);
  if (!reparentedArrow) throw Error("no reparented arrow");
  const startSibling = editor.getShapeNearestSibling(reparentedArrow, startShape);
  const endSibling = editor.getShapeNearestSibling(reparentedArrow, endShape);
  let highestSibling;
  if (startSibling && endSibling) {
    highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;
  } else if (startSibling && !endSibling) {
    highestSibling = startSibling;
  } else if (endSibling && !startSibling) {
    highestSibling = endSibling;
  } else {
    return;
  }
  let finalIndex;
  const higherSiblings = editor.getSortedChildIdsForParent(highestSibling.parentId).map((id) => editor.getShape(id)).filter((sibling) => sibling.index > highestSibling.index);
  if (higherSiblings.length) {
    const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
      (!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
    ) {
      return;
    }
    finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index);
  } else {
    finalIndex = getIndexAbove(highestSibling.index);
  }
  if (finalIndex !== reparentedArrow.index) {
    editor.updateShapes([{ id: arrowId, type: "arrow", index: finalIndex }]);
  }
}
function arrowDidUpdate(editor, arrow2) {
  const bindings = getArrowBindings(editor, arrow2);
  for (const handle of ["start", "end"]) {
    const binding = bindings[handle];
    if (!binding) continue;
    const boundShape = editor.getShape(binding.toId);
    const isShapeInSamePageAsArrow = editor.getAncestorPageId(arrow2) === editor.getAncestorPageId(boundShape);
    if (!boundShape || !isShapeInSamePageAsArrow) {
      updateArrowTerminal({ editor, arrow: arrow2, terminal: handle, unbind: true });
    }
  }
  reparentArrow(editor, arrow2.id);
}
function updateArrowTerminal({
  editor,
  arrow: arrow2,
  terminal,
  unbind: unbind2 = false,
  useHandle = false
}) {
  const info = getArrowInfo(editor, arrow2);
  if (!info) {
    throw new Error("expected arrow info");
  }
  const startPoint = useHandle ? info.start.handle : info.start.point;
  const endPoint = useHandle ? info.end.handle : info.end.point;
  const point = terminal === "start" ? startPoint : endPoint;
  const update = {
    id: arrow2.id,
    type: "arrow",
    props: {
      [terminal]: { x: point.x, y: point.y },
      bend: arrow2.props.bend
    }
  };
  if (info.type === "arc") {
    const newStart = terminal === "start" ? startPoint : info.start.handle;
    const newEnd = terminal === "end" ? endPoint : info.end.handle;
    const newMidPoint = Vec.Med(newStart, newEnd);
    const lineSegment = Vec.Sub(newStart, newEnd).per().uni().mul(info.handleArc.radius * 2 * Math.sign(arrow2.props.bend));
    const intersections = intersectLineSegmentCircle(
      info.handleArc.center,
      Vec.Add(newMidPoint, lineSegment),
      info.handleArc.center,
      info.handleArc.radius
    );
    assert(intersections?.length === 1);
    const bend = Vec.Dist(newMidPoint, intersections[0]) * Math.sign(arrow2.props.bend);
    if (!approximately(bend, update.props.bend)) {
      update.props.bend = bend;
    }
  }
  editor.updateShape(update);
  if (unbind2) {
    removeArrowBinding(editor, arrow2, terminal);
  }
}
const defaultBindingUtils = [ArrowBindingUtil];
const TEXT_PROPS = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
};
const STROKE_SIZES = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
const FONT_SIZES = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
};
const LABEL_FONT_SIZES = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
};
const ARROW_LABEL_FONT_SIZES = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
};
const FONT_FAMILIES = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
};
const LABEL_TO_ARROW_PADDING = 20;
const ARROW_LABEL_PADDING = 4.25;
const LABEL_PADDING = 16;
const oc = {
  gray: ["#f8f9fa", "#e9ecef", "#ced4da", "#868e96", "#343a40"],
  red: ["#fff5f5", "#ffc9c9", "#ff8787", "#fa5252", "#e03131"],
  pink: ["#fff0f6", "#fcc2d7", "#f783ac", "#e64980", "#c2255c"],
  grape: ["#f8f0fc", "#eebefa", "#da77f2", "#be4bdb", "#9c36b5"],
  violet: ["#f3f0ff", "#d0bfff", "#9775fa", "#7950f2", "#6741d9"],
  indigo: ["#edf2ff", "#bac8ff", "#748ffc", "#4c6ef5", "#3b5bdb"],
  blue: ["#e7f5ff", "#a5d8ff", "#4dabf7", "#228be6", "#1971c2"],
  cyan: ["#e3fafc", "#99e9f2", "#3bc9db", "#15aabf", "#0c8599"],
  teal: ["#e6fcf5", "#96f2d7", "#38d9a9", "#12b886", "#099268"],
  green: ["#ebfbee", "#b2f2bb", "#69db7c", "#40c057", "#2f9e44"],
  lime: ["#f4fce3", "#d8f5a2", "#a9e34b", "#82c91e", "#66a80f"],
  yellow: ["#fff9db", "#ffec99", "#ffd43b", "#fab005", "#f08c00"],
  orange: ["#fff4e6", "#ffd8a8", "#ffa94d", "#fd7e14", "#e8590c"]
};
function mapExcalidrawColorToTldrawColors(excalidrawColor, light, dark) {
  const colors = [0, 1, 2, 3, 4].map((index2) => oc[excalidrawColor][index2]);
  return Object.fromEntries(colors.map((c2, i) => [c2, i < 3 ? light : dark]));
}
({
  ...mapExcalidrawColorToTldrawColors("gray", "grey", "black"),
  ...mapExcalidrawColorToTldrawColors("red", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("pink", "light-red", "red"),
  ...mapExcalidrawColorToTldrawColors("grape", "light-violet", "violet"),
  ...mapExcalidrawColorToTldrawColors("blue", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("cyan", "light-blue", "blue"),
  ...mapExcalidrawColorToTldrawColors("teal", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("green", "light-green", "green"),
  ...mapExcalidrawColorToTldrawColors("yellow", "yellow", "orange"),
  ...mapExcalidrawColorToTldrawColors("orange", "yellow", "orange")
});
const inputRegex$5 = /(^|[^`])`([^`]+)`(?!`)/;
const pasteRegex$2 = /(^|[^`])`([^`]+)`(?!`)/g;
const Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleCode: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetCode: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$2,
        type: this.type
      })
    ];
  }
});
const inputRegex$4 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
const pasteRegex$1 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
const Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })
    ];
  }
});
const encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
const encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
const assign = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
const numeric = "numeric";
const ascii = "ascii";
const alpha = "alpha";
const asciinumeric = "asciinumeric";
const alphanumeric = "alphanumeric";
const domain = "domain";
const emoji = "emoji";
const scheme = "scheme";
const slashscheme = "slashscheme";
const whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c2 in groups) {
    if (groups[c2].indexOf(t2) >= 0) {
      result[c2] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
const ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
const tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
const ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
const tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
const WORD = "WORD";
const UWORD = "UWORD";
const ASCIINUMERICAL = "ASCIINUMERICAL";
const ALPHANUMERICAL = "ALPHANUMERICAL";
const LOCALHOST = "LOCALHOST";
const TLD = "TLD";
const UTLD = "UTLD";
const SCHEME = "SCHEME";
const SLASH_SCHEME = "SLASH_SCHEME";
const NUM = "NUM";
const WS = "WS";
const NL = "NL";
const OPENBRACE = "OPENBRACE";
const CLOSEBRACE = "CLOSEBRACE";
const OPENBRACKET = "OPENBRACKET";
const CLOSEBRACKET = "CLOSEBRACKET";
const OPENPAREN = "OPENPAREN";
const CLOSEPAREN = "CLOSEPAREN";
const OPENANGLEBRACKET = "OPENANGLEBRACKET";
const CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
const FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
const FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
const LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
const RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
const LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
const RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
const FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
const FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
const AMPERSAND = "AMPERSAND";
const APOSTROPHE = "APOSTROPHE";
const ASTERISK = "ASTERISK";
const AT = "AT";
const BACKSLASH = "BACKSLASH";
const BACKTICK = "BACKTICK";
const CARET = "CARET";
const COLON = "COLON";
const COMMA = "COMMA";
const DOLLAR = "DOLLAR";
const DOT = "DOT";
const EQUALS = "EQUALS";
const EXCLAMATION = "EXCLAMATION";
const HYPHEN = "HYPHEN";
const PERCENT = "PERCENT";
const PIPE = "PIPE";
const PLUS = "PLUS";
const POUND = "POUND";
const QUERY = "QUERY";
const QUOTE = "QUOTE";
const FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
const SEMI = "SEMI";
const SLASH = "SLASH";
const TILDE = "TILDE";
const UNDERSCORE = "UNDERSCORE";
const EMOJI$1 = "EMOJI";
const SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL,
  AMPERSAND,
  APOSTROPHE,
  ASCIINUMERICAL,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  CLOSEANGLEBRACKET,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEPAREN,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EMOJI: EMOJI$1,
  EQUALS,
  EXCLAMATION,
  FULLWIDTHGREATERTHAN,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHLESSTHAN,
  FULLWIDTHMIDDLEDOT,
  FULLWIDTHRIGHTPAREN,
  HYPHEN,
  LEFTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  LOCALHOST,
  NL,
  NUM,
  OPENANGLEBRACKET,
  OPENBRACE,
  OPENBRACKET,
  OPENPAREN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  RIGHTCORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  SCHEME,
  SEMI,
  SLASH,
  SLASH_SCHEME,
  SYM,
  TILDE,
  TLD,
  UNDERSCORE,
  UTLD,
  UWORD,
  WORD,
  WS
});
const ASCII_LETTER = /[a-z]/;
const LETTER = /\p{L}/u;
const EMOJI = /\p{Emoji}/u;
const DIGIT = /\d/;
const SPACE = /\s/;
const CR = "\r";
const LF = "\n";
const EMOJI_VARIATION = "️";
const EMOJI_JOINER = "‍";
const OBJECT_REPLACEMENT = "￼";
let tlds = null, utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "（", FULLWIDTHLEFTPAREN);
  tt(Start, "）", FULLWIDTHRIGHTPAREN);
  tt(Start, "「", LEFTCORNERBRACKET);
  tt(Start, "」", RIGHTCORNERBRACKET);
  tt(Start, "『", LEFTWHITECORNERBRACKET);
  tt(Start, "』", RIGHTWHITECORNERBRACKET);
  tt(Start, "＜", FULLWIDTHLESSTHAN);
  tt(Start, "＞", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "・", FULLWIDTHMIDDLEDOT);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, DIGIT, Asciinumeric);
  tr(Word, ASCII_LETTER, Word);
  tr(Asciinumeric, DIGIT, Asciinumeric);
  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, DIGIT, Alphanumeric);
  tr(UWord, LETTER, UWord);
  tr(Alphanumeric, DIGIT, Alphanumeric);
  tr(Alphanumeric, ASCII_LETTER);
  tr(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr(Cr, SPACE, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr(Ws, SPACE, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a2, b) => a2[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start, str2) {
  const iterable = stringToArray(str2.replace(/[A-Z]/g, (c2) => c2.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str2.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str2) {
  const result = [];
  const len = str2.length;
  let index2 = 0;
  while (index2 < len) {
    let first2 = str2.charCodeAt(index2);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str2.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str2[index2] : str2.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack2 = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack2.join(""));
      for (let popCount2 = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount2 > 0; popCount2--) {
        stack2.pop();
      }
      i += popDigitCount;
    } else {
      stack2.push(encoded[i]);
      i++;
    }
  }
  return words;
}
const defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop2,
  formatHref: noop2,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o2 = assign({}, defaults);
  if (opts) {
    o2 = assign(o2, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o2.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o2;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable2 = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable2) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable2) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop2(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
const Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
const Text$1 = createTokenClass("text");
const Nl = createTokenClass("nl");
const Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
const makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text$1, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text$1, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
const warn = typeof console !== "undefined" && console && console.warn || (() => {
});
const warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
const INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str2) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str2, run$1(INIT.scanner.start, str2));
}
tokenize.scan = run$1;
function find(str2, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str2);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction2) => transaction2.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction2) => transaction2.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s2) => s2 !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a2, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let a2 = event.target;
        const els = [];
        while (a2.nodeName !== "DIV") {
          els.push(a2);
          a2 = a2.parentNode;
        }
        if (!els.find((value) => value.nodeName === "A")) {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const link = event.target;
        const href = (_a2 = link === null || link === void 0 ? void 0 : link.href) !== null && _a2 !== void 0 ? _a2 : attrs.href;
        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find((item) => item.isLink && item.value === textContent);
        if (!textContent || !link) {
          return false;
        }
        return options.editor.commands.setMark(options.type, {
          href: link.href
        });
      }
    }
  });
}
const ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(ATTR_WHITESPACE, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
const Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return [
        "a",
        mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }),
        0
      ];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain: chain2 }) => {
        return chain2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter((item) => item.isLink && this.options.isAllowedUri(item.value, {
              defaultValidate: (href) => !!isAllowedUri(href, protocols),
              protocols,
              defaultProtocol
            }));
            if (links.length) {
              links.forEach((link) => foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              }));
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a2;
          return {
            href: (_a2 = match.data) === null || _a2 === void 0 ? void 0 : _a2.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (url) => this.options.isAllowedUri(url, {
          defaultValidate: (href) => !!isAllowedUri(href, protocols),
          protocols,
          defaultProtocol
        }),
        shouldAutoLink: this.options.shouldAutoLink
      }));
    }
    if (this.options.openOnClick === true) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      }));
    }
    return plugins;
  }
});
const inputRegex$3 = /^\s*>\s$/;
const Blockquote = Node$1.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$3,
        type: this.type
      })
    ];
  }
});
const starInputRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
const underscorePasteRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
const Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
const ListItemName$1 = "listItem";
const TextStyleName$1 = "textStyle";
const inputRegex$2 = /^\s*([-+*])\s$/;
const BulletList = Node$1.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName$1, this.editor.getAttributes(TextStyleName$1)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex$2,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex$2,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName$1);
        },
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});
const backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
const tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
const CodeBlock = Node$1.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a2;
          const { languageClassPrefix } = this.options;
          const classNames2 = [...((_a2 = element.firstElementChild) === null || _a2 === void 0 ? void 0 : _a2.classList) || []];
          const languages = classNames2.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc2 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc2.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
class DropCursorView {
  constructor(editorView, options) {
    var _a2;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a2 = options.width) !== null && _a2 !== void 0 ? _a2 : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
const Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      dropCursor(this.options)
    ];
  }
});
class GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch2, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch2)
      dispatch2(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
const Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      gapCursor()
    ];
  },
  extendNodeSchema(extension) {
    var _a2;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a2 = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) !== null && _a2 !== void 0 ? _a2 : null
    };
  }
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain: chain2, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain2().insertContent({ type: this.name }).command(({ tr: tr2, dispatch: dispatch2 }) => {
              if (dispatch2 && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr2.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
const Heading = Node$1.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array2) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array2.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count2 = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count2++;
    });
    return count2;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last2 = items.length - 1;
          if (merged = items.length && items[last2].merge(newItem))
            items[last2] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items.reverse()), events);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n2) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n2-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch2) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch2) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch2(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
const undo = buildCommand(false, true);
const redo = buildCommand(true, true);
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch: dispatch2 }) => {
        return undo(state, dispatch2);
      },
      redo: () => ({ state, dispatch: dispatch2 }) => {
        return redo(state, dispatch2);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});
const HorizontalRule = Node$1.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: chain2, state }) => {
        const { selection } = state;
        const { $from: $originFrom, $to: $originTo } = selection;
        const currentChain = chain2();
        if ($originFrom.parentOffset === 0) {
          currentChain.insertContentAt({
            from: Math.max($originFrom.pos - 1, 0),
            to: $originTo.pos
          }, {
            type: this.name
          });
        } else if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr: tr2, dispatch: dispatch2 }) => {
          var _a2;
          if (dispatch2) {
            const { $to } = tr2.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr2.setSelection(NodeSelection.create(tr2.doc, $to.pos));
              } else {
                tr2.setSelection(TextSelection.create(tr2.doc, $to.pos));
              }
            } else {
              const node = (_a2 = $to.parent.type.contentMatch.defaultType) === null || _a2 === void 0 ? void 0 : _a2.create();
              if (node) {
                tr2.insert(posAfter, node);
                tr2.setSelection(TextSelection.create(tr2.doc, posAfter + 1));
              }
            }
            tr2.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
const starInputRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
const starPasteRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
const underscoreInputRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
const underscorePasteRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
const Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
const ListItem = Node$1.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const ListItemName = "listItem";
const TextStyleName = "textStyle";
const inputRegex$1 = /^(\d+)\.\s$/;
const OrderedList = Node$1.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start, ...attributesWithoutStart } = HTMLAttributes;
    return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands2.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: inputRegex$1,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: inputRegex$1,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [
      inputRule
    ];
  }
});
const Paragraph = Node$1.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const inputRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
const pasteRegex = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
const Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
const Text = Node$1.create({
  name: "text",
  group: "inline"
});
const StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure(this.options.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote.configure(this.options.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code.configure(this.options.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock.configure(this.options.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure(this.options.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure(this.options.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure(this.options.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure(this.options.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure(this.options.heading));
    }
    if (this.options.history !== false) {
      extensions.push(History.configure(this.options.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule.configure(this.options.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure(this.options.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure(this.options.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure(this.options.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text.configure(this.options.text));
    }
    return extensions;
  }
});
const DefaultFontFaces = {
  tldraw_draw: {
    normal: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw", format: "woff2" },
        weight: "normal"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_bold", format: "woff2" },
        weight: "bold"
      }
    },
    italic: {
      normal: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_draw",
        src: { url: "tldraw_draw_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_sans: {
    normal: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_sans",
        src: { url: "tldraw_sans_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_serif: {
    normal: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_serif",
        src: { url: "tldraw_serif_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  },
  tldraw_mono: {
    normal: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono", format: "woff2" },
        weight: "normal",
        style: "normal"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_bold", format: "woff2" },
        weight: "bold",
        style: "normal"
      }
    },
    italic: {
      normal: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic", format: "woff2" },
        weight: "normal",
        style: "italic"
      },
      bold: {
        family: "tldraw_mono",
        src: { url: "tldraw_mono_italic_bold", format: "woff2" },
        weight: "bold",
        style: "italic"
      }
    }
  }
};
objectMapValues(DefaultFontFaces).flatMap(
  (font) => objectMapValues(font).flatMap((fontFace) => Object.values(fontFace))
);
const TextDirection = Extension.create({
  name: "textDirection",
  addGlobalAttributes() {
    return [
      {
        types: ["heading", "paragraph"],
        attributes: {
          dir: {
            default: "auto",
            parseHTML: (element) => {
              const dirAttribute = element.getAttribute("dir");
              if (dirAttribute && ["ltr", "rtl", "auto"].includes(dirAttribute)) {
                return dirAttribute;
              } else {
                return "auto";
              }
            },
            renderHTML: (attributes) => {
              return { dir: attributes.dir };
            }
          }
        }
      }
    ];
  }
});
const KeyboardShiftEnterTweakExtension = Extension.create({
  name: "keyboardShiftEnterHandler",
  addKeyboardShortcuts() {
    return {
      // We don't support soft breaks, so we just use the default enter command.
      "Shift-Enter": ({ editor }) => editor.commands.enter()
    };
  }
});
Code.config.excludes = void 0;
Highlight.config.priority = 1100;
const tipTapDefaultExtensions = [
  StarterKit.configure({
    blockquote: false,
    codeBlock: false,
    horizontalRule: false
  }),
  Link.configure({
    openOnClick: false,
    autolink: true
  }),
  Highlight,
  KeyboardShiftEnterTweakExtension,
  TextDirection
];
function renderHtmlFromRichText(editor, richText) {
  const tipTapExtensions = editor.getTextOptions().tipTapConfig?.extensions ?? tipTapDefaultExtensions;
  const html2 = generateHTML(richText, tipTapExtensions);
  return html2.replaceAll('<p dir="auto"></p>', "<p><br /></p>") ?? "";
}
function renderHtmlFromRichTextForMeasurement(editor, richText) {
  const html2 = renderHtmlFromRichText(editor, richText);
  return `<div class="tl-rich-text">${html2}</div>`;
}
const plainTextFromRichTextCache = new WeakCache();
function isEmptyRichText(richText) {
  if (richText.content.length === 1) {
    if (!richText.content[0].content) return true;
  }
  return false;
}
function renderPlaintextFromRichText(editor, richText) {
  if (isEmptyRichText(richText)) return "";
  return plainTextFromRichTextCache.get(richText, () => {
    const tipTapExtensions = editor.getTextOptions().tipTapConfig?.extensions ?? tipTapDefaultExtensions;
    return generateText(richText, tipTapExtensions, {
      blockSeparator: "\n"
    });
  });
}
function defaultAddFontsFromNode(node, state, addFont) {
  for (const mark of node.marks) {
    if (mark.type.name === "bold" && state.weight !== "bold") {
      state = { ...state, weight: "bold" };
    }
    if (mark.type.name === "italic" && state.style !== "italic") {
      state = { ...state, style: "italic" };
    }
    if (mark.type.name === "code" && state.family !== "tldraw_mono") {
      state = { ...state, family: "tldraw_mono" };
    }
  }
  const fontsForFamily = getOwnProperty(DefaultFontFaces, state.family);
  if (!fontsForFamily) return state;
  const fontsForStyle = getOwnProperty(fontsForFamily, state.style);
  if (!fontsForStyle) return state;
  const fontsForWeight = getOwnProperty(fontsForStyle, state.weight);
  if (!fontsForWeight) return state;
  addFont(fontsForWeight);
  return state;
}
class TextHelpers {
  static fixNewLines = /\r?\n|\r/g;
  static normalizeText(text) {
    return text.replace(TextHelpers.fixNewLines, "\n");
  }
  static normalizeTextForDom(text) {
    return text.replace(TextHelpers.fixNewLines, "\n").split("\n").map((x) => x || " ").join("\n");
  }
}
const rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function isRightToLeftLanguage(text) {
  return rtlRegex.test(text);
}
const COMMON_ENTITY_MAP = {
  "&amp;": "&",
  "&quot;": '"',
  "&apos;": "'",
  "&#27;": "'",
  "&#34;": '"',
  "&#38;": "&",
  "&#39;": "'",
  "&#8211;": "–",
  "&#8212;": "—",
  "&#8216;": "‘",
  "&#8217;": "’",
  "&#8220;": "“",
  "&#8221;": "”",
  "&#8230;": "…"
};
const entityRegex = new RegExp(Object.keys(COMMON_ENTITY_MAP).join("|"), "g");
function convertCommonTitleHTMLEntities(text) {
  return text.replace(entityRegex, (m) => COMMON_ENTITY_MAP[m]);
}
const CLONE_HANDLE_MARGIN = 0;
const NOTE_SIZE = 200;
const NOTE_CENTER_OFFSET = new Vec(NOTE_SIZE / 2, NOTE_SIZE / 2);
const NOTE_ADJACENT_POSITION_SNAP_RADIUS = 10;
const BASE_NOTE_POSITIONS = (editor) => [
  [
    ["a1"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new Vec(NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ],
  // r
  [
    ["a3"],
    new Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new Vec(NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5)
  ]
  // l
];
function getBaseAdjacentNotePositions(editor, scale) {
  if (scale === 1) return BASE_NOTE_POSITIONS(editor);
  const s2 = NOTE_SIZE * scale;
  const m = editor.options.adjacentShapeMargin * scale;
  return [
    [["a1"], new Vec(s2 * 0.5, s2 * -0.5 - m)],
    // t
    [["a2"], new Vec(s2 * 1.5 + m, s2 * 0.5)],
    // r
    [["a3"], new Vec(s2 * 0.5, s2 * 1.5 + m)],
    // b
    [["a4"], new Vec(s2 * -0.5 - m, s2 * 0.5)]
    // l
  ];
}
function getNoteAdjacentPositions(editor, pagePoint, pageRotation, growY, extraHeight, scale) {
  return Object.fromEntries(
    getBaseAdjacentNotePositions(editor, scale).map(([id, v], i) => {
      const point = v.clone();
      if (i === 0 && extraHeight) {
        point.y -= extraHeight;
      } else if (i === 2 && growY) {
        point.y += growY;
      }
      return [id, point.rot(pageRotation).add(pagePoint)];
    })
  );
}
function getAvailableNoteAdjacentPositions(editor, rotation, scale, extraHeight) {
  const selectedShapeIds = new Set(editor.getSelectedShapeIds());
  const minSize = (NOTE_SIZE + editor.options.adjacentShapeMargin + extraHeight) ** 2;
  const allCenters = /* @__PURE__ */ new Map();
  const positions = [];
  for (const shape of editor.getCurrentPageShapes()) {
    if (!editor.isShapeOfType(shape, "note") || scale !== shape.props.scale || selectedShapeIds.has(shape.id)) {
      continue;
    }
    const transform = editor.getShapePageTransform(shape.id);
    if (rotation !== transform.rotation()) continue;
    allCenters.set(shape, editor.getShapePageBounds(shape).center);
    positions.push(
      ...Object.values(
        getNoteAdjacentPositions(
          editor,
          transform.point(),
          rotation,
          shape.props.growY,
          extraHeight,
          scale
        )
      )
    );
  }
  const len = positions.length;
  let position;
  for (const [shape, center] of allCenters) {
    for (let i = 0; i < len; i++) {
      position = positions[i];
      if (!position) continue;
      if (Vec.Dist2(center, position) > minSize) continue;
      if (editor.isPointInShape(shape, position)) {
        positions[i] = void 0;
      }
    }
  }
  return compact$1(positions);
}
function getNoteShapeForAdjacentPosition(editor, shape, center, pageRotation, forceNew = false) {
  let nextNote;
  const allShapesOnPage = editor.getCurrentPageShapesSorted();
  const minDistance = (NOTE_SIZE + editor.options.adjacentShapeMargin ** 2) ** shape.props.scale;
  for (let i = allShapesOnPage.length - 1; i >= 0; i--) {
    const otherNote = allShapesOnPage[i];
    if (otherNote.type === "note" && otherNote.id !== shape.id) {
      const otherBounds = editor.getShapePageBounds(otherNote);
      if (otherBounds && Vec.Dist2(otherBounds.center, center) < minDistance && editor.isPointInShape(otherNote, center)) {
        nextNote = otherNote;
        break;
      }
    }
  }
  editor.complete();
  if (!nextNote || forceNew) {
    editor.markHistoryStoppingPoint("creating note shape");
    const id = createShapeId();
    editor.createShape({
      id,
      type: "note",
      x: center.x,
      y: center.y,
      rotation: pageRotation,
      opacity: shape.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...shape.props,
        richText: toRichText(""),
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const createdShape = editor.getShape(id);
    if (!createdShape) return;
    const topLeft = editor.getPointInParentSpace(
      createdShape,
      Vec.Sub(
        center,
        Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(createdShape.props.scale), pageRotation)
      )
    );
    editor.updateShape({
      id,
      type: "note",
      x: topLeft.x,
      y: topLeft.y
    });
    nextNote = editor.getShape(id);
  }
  editor.zoomToSelectionIfOffscreen(16, {
    animation: {
      duration: editor.options.animationMediumMs
    },
    inset: 0
  });
  return nextNote;
}
function _updateHoveredShapeId(editor) {
  const hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint, {
    hitInside: false,
    hitLabels: false,
    margin: editor.options.hitTestMargin / editor.getZoomLevel(),
    renderingOnly: true
  });
  if (!hitShape) return editor.setHoveredShape(null);
  let shapeToHover = void 0;
  const outermostShape = editor.getOutermostSelectableShape(hitShape);
  if (outermostShape === hitShape) {
    shapeToHover = hitShape;
  } else {
    if (outermostShape.id === editor.getFocusedGroupId() || editor.getSelectedShapeIds().includes(outermostShape.id)) {
      shapeToHover = hitShape;
    } else {
      shapeToHover = outermostShape;
    }
  }
  return editor.setHoveredShape(shapeToHover.id);
}
throttle(
  _updateHoveredShapeId,
  32
);
function getVerticesCountForLength(length, spacing = 20) {
  return Math.max(8, Math.ceil(length / spacing));
}
class PathBuilder {
  static throughPoints(points, opts) {
    const path = new PathBuilder();
    path.moveTo(points[0].x, points[0].y, opts);
    for (let i = 1; i < points.length; i++) {
      path.lineTo(points[i].x, points[i].y);
    }
    return path;
  }
  constructor() {
  }
  lines = [];
  currentLine() {
    const lastLine = this.lines[this.lines.length - 1];
    assert(lastLine, "Start an SVGPathBuilder with `.moveTo()`");
    assert(!lastLine.closed, "Cannot work on a closed line");
    return lastLine;
  }
  moveTo(x, y2, opts) {
    this.lines.push({
      initial: { type: "moveTo", x, y: y2, opts },
      segments: [],
      closed: false
    });
    return this;
  }
  lineTo(x, y2, opts) {
    this.currentLine().segments.push({ type: "lineTo", x, y: y2, opts });
    return this;
  }
  arcTo(radius, largeArcFlag, sweepFlag, x, y2, opts) {
    this.currentLine().segments.push({
      type: "arcTo",
      radius,
      largeArcFlag,
      sweepFlag,
      x,
      y: y2,
      opts
    });
    return this;
  }
  close() {
    this.currentLine().closed = true;
    return this;
  }
  toD(opts = {}) {
    const closedOnly = opts.closedOnly ?? false;
    const parts = [];
    for (const { initial, segments, closed } of this.lines) {
      if (closedOnly && !closed) continue;
      parts.push("M", toDomPrecision(initial.x), toDomPrecision(initial.y));
      for (const segment of segments) {
        switch (segment.type) {
          case "lineTo":
            parts.push("L", toDomPrecision(segment.x), toDomPrecision(segment.y));
            break;
          case "arcTo":
            parts.push(
              "A",
              segment.radius,
              segment.radius,
              0,
              segment.largeArcFlag ? "1" : "0",
              segment.sweepFlag ? "1" : "0",
              toDomPrecision(segment.x),
              toDomPrecision(segment.y)
            );
            break;
        }
      }
      if (closed) {
        parts.push("Z");
      }
    }
    return parts.join(" ");
  }
  toSvg(opts) {
    if (opts.forceSolid) {
      return this.toSolidSvg(opts);
    }
    switch (opts.style) {
      case "solid":
        return this.toSolidSvg(opts);
      case "dashed":
      case "dotted":
        return this.toDashedSvg(opts);
      case "draw":
        return this.toDrawSvg(opts);
      default:
        exhaustiveSwitchError$1(opts, "style");
    }
  }
  toGeometry() {
    const geometries = [];
    for (const { initial, segments, closed } of this.lines) {
      if (initial.opts?.geometry === false) continue;
      const vertices = [new Vec(initial.x, initial.y)];
      for (const segment of segments) {
        switch (segment.type) {
          case "lineTo": {
            vertices.push(new Vec(segment.x, segment.y));
            break;
          }
          case "arcTo": {
            const info = getArcSegmentInfo(vertices[vertices.length - 1], segment);
            if (info === null) break;
            if (info === "straight-line") {
              vertices.push(new Vec(segment.x, segment.y));
              break;
            }
            const verticesCount = getVerticesCountForLength(info.length);
            for (let i = 0; i < verticesCount + 1; i++) {
              const t2 = i / verticesCount * info.sweepAngle;
              const point = Vec.Rot(info.startVector, t2).mul(info.radius).add(info.center);
              vertices.push(point);
            }
            break;
          }
          default:
            exhaustiveSwitchError$1(segment, "type");
        }
      }
      const geometry = closed ? new Polygon2d({ points: vertices, isFilled: false, ...initial.opts?.geometry }) : new Polyline2d({ points: vertices, ...initial.opts?.geometry });
      geometries.push(geometry);
    }
    if (geometries.length === 0) return null;
    if (geometries.length === 1) return geometries[0];
    return new Group2d({ children: geometries });
  }
  toSolidSvg(opts) {
    const { strokeWidth, props } = opts;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeWidth, d: this.toD(), ...props });
  }
  toDashedSvg(opts) {
    const {
      style: style2,
      strokeWidth,
      snap,
      end,
      start,
      lengthRatio,
      props: { markerStart, markerEnd, ...props } = {}
    } = opts;
    const parts = [];
    for (const { initial, segments, closed } of this.lines) {
      let lastPoint = initial;
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const isFirst = i === 0;
        const isLast = i === segments.length - 1 && !closed;
        const segmentLength = this.segmentLength(lastPoint, segment);
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          segmentLength,
          strokeWidth,
          {
            style: style2,
            snap,
            lengthRatio,
            start: isFirst ? closed ? "none" : start : "outset",
            end: isLast ? closed ? "none" : end : "outset"
          }
        );
        switch (segment.type) {
          case "lineTo":
            parts.push(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1: toDomPrecision(lastPoint.x),
                  y1: toDomPrecision(lastPoint.y),
                  x2: toDomPrecision(segment.x),
                  y2: toDomPrecision(segment.y),
                  strokeDasharray,
                  strokeDashoffset,
                  markerStart: isFirst ? markerStart : void 0,
                  markerEnd: isLast ? markerEnd : void 0
                },
                i
              )
            );
            break;
          case "arcTo":
            parts.push(
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: [
                    "M",
                    toDomPrecision(lastPoint.x),
                    toDomPrecision(lastPoint.y),
                    "A",
                    segment.radius,
                    segment.radius,
                    0,
                    segment.largeArcFlag ? "1" : "0",
                    segment.sweepFlag ? "1" : "0",
                    toDomPrecision(segment.x),
                    toDomPrecision(segment.y)
                  ].join(" "),
                  strokeDasharray,
                  strokeDashoffset,
                  markerStart: isFirst ? markerStart : void 0,
                  markerEnd: isLast ? markerEnd : void 0
                },
                i
              )
            );
            break;
          default:
            exhaustiveSwitchError$1(segment, "type");
        }
        lastPoint = segment;
      }
      if (closed && lastPoint !== initial) {
        const dist = Vec.Dist(lastPoint, initial);
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
          style: style2,
          snap,
          lengthRatio,
          start: "outset",
          end: "none"
        });
        parts.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "line",
            {
              x1: toDomPrecision(lastPoint.x),
              y1: toDomPrecision(lastPoint.y),
              x2: toDomPrecision(initial.x),
              y2: toDomPrecision(initial.y),
              strokeDasharray,
              strokeDashoffset,
              markerEnd
            },
            "last"
          )
        );
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { strokeWidth, ...props, children: parts });
  }
  toDrawSvg(opts) {
    const {
      strokeWidth,
      randomSeed,
      offset: defaultOffset = strokeWidth / 3,
      roundness: defaultRoundness = strokeWidth * 2,
      passes = 2,
      props
    } = opts;
    const parts = [];
    const tangents = this.lines.map(({ initial, segments, closed }) => {
      const tangents2 = [];
      const segmentCount = closed ? segments.length + 1 : segments.length;
      for (let i = 0; i < segmentCount; i++) {
        let previous = segments[i - 1];
        let current = segments[i];
        let next = segments[i + 1];
        if (!previous) previous = initial;
        if (!current) {
          current = initial;
          next = segments[0];
        }
        if (!next) {
          next = initial;
        }
        let tangentBefore, tangentAfter;
        switch (current.type) {
          case "lineTo":
          case "moveTo": {
            tangentBefore = Vec.Sub(previous, current).norm();
            break;
          }
          case "arcTo": {
            const info = getArcSegmentInfo(previous, current);
            if (info === null || info === "straight-line") {
              tangentBefore = Vec.Sub(current, previous).norm().per();
              break;
            }
            tangentBefore = Vec.Per(info.endVector).mul(Math.sign(info.sweepAngle));
            break;
          }
          default:
            exhaustiveSwitchError$1(current, "type");
        }
        switch (next.type) {
          case "lineTo":
          case "moveTo": {
            tangentAfter = Vec.Sub(next, current).norm();
            break;
          }
          case "arcTo": {
            const info = getArcSegmentInfo(current, next);
            if (info === null || info === "straight-line") {
              tangentAfter = Vec.Sub(next, current).norm().per();
              break;
            }
            tangentAfter = Vec.Per(info.startVector).mul(Math.sign(info.sweepAngle));
            break;
          }
          default:
            exhaustiveSwitchError$1(next, "type");
        }
        tangents2.push({ tangentBefore, tangentAfter });
      }
      return tangents2;
    });
    for (let pass = 0; pass < passes; pass++) {
      for (let lineIdx = 0; lineIdx < this.lines.length; lineIdx++) {
        const { initial, segments, closed } = this.lines[lineIdx];
        const random = rng(randomSeed + pass + lineIdx);
        const initialOffset = initial.opts?.offset ?? defaultOffset;
        const initialPOffset = {
          x: initial.x + random() * initialOffset,
          y: initial.y + random() * initialOffset
        };
        const offsetPoints = [];
        let lastDistance = Vec.Dist(initialPOffset, segments[0]);
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const nextSegment = i === segments.length - 1 ? closed ? segments[0] : null : segments[i + 1];
          const nextDistance = nextSegment ? Vec.Dist(segment, nextSegment) : Infinity;
          const shortestDistance = Math.min(lastDistance, nextDistance) - (segment.opts?.roundness ?? defaultRoundness);
          const offset2 = clamp$3(segment.opts?.offset ?? defaultOffset, 0, shortestDistance / 10);
          const offsetPoint = {
            x: segment.x + random() * offset2,
            y: segment.y + random() * offset2
          };
          offsetPoints.push(offsetPoint);
          lastDistance = nextDistance;
        }
        if (closed) {
          const roundness = initial.opts?.roundness ?? defaultRoundness;
          offsetPoints.push(initialPOffset);
          const next = offsetPoints[0];
          const nudgeAmount = Math.min(Vec.Dist(initialPOffset, next) / 2, roundness);
          const nudged = Vec.Nudge(initialPOffset, next, nudgeAmount);
          parts.push("M", toDomPrecision(nudged.x), toDomPrecision(nudged.y));
        } else {
          parts.push("M", toDomPrecision(initialPOffset.x), toDomPrecision(initialPOffset.y));
        }
        const segmentCount = closed ? segments.length + 1 : segments.length;
        for (let i = 0; i < segmentCount; i++) {
          const segment = i === segments.length ? initial : segments[i];
          const roundness = segment.opts?.roundness ?? defaultRoundness;
          const offsetP = offsetPoints[i];
          const { tangentBefore, tangentAfter } = tangents[lineIdx][i];
          const previousOffsetP = i === 0 ? initialPOffset : offsetPoints[i - 1];
          const nextOffsetP = i === segments.length - 1 && !closed ? null : offsetPoints[(i + 1) % offsetPoints.length];
          switch (segment.type) {
            case "lineTo":
            case "moveTo": {
              if (!nextOffsetP || roundness === 0) {
                parts.push("L", toDomPrecision(offsetP.x), toDomPrecision(offsetP.y));
                break;
              }
              const clampedRoundness = lerp(
                roundness,
                0,
                clamp$3(
                  invLerp(
                    Math.PI / 2,
                    Math.PI,
                    Math.abs(Vec.AngleBetween(tangentBefore, tangentAfter))
                  ),
                  0,
                  1
                )
              );
              const nudgeBeforeAmount = Math.min(
                Vec.Dist(previousOffsetP, offsetP) / 2,
                clampedRoundness
              );
              const nudgeBefore = Vec.Mul(tangentBefore, nudgeBeforeAmount).add(offsetP);
              const nudgeAfterAmount = Math.min(
                Vec.Dist(nextOffsetP, offsetP) / 2,
                clampedRoundness
              );
              const nudgeAfter = Vec.Mul(tangentAfter, nudgeAfterAmount).add(offsetP);
              parts.push(
                "L",
                toDomPrecision(nudgeBefore.x),
                toDomPrecision(nudgeBefore.y),
                "Q",
                toDomPrecision(offsetP.x),
                toDomPrecision(offsetP.y),
                toDomPrecision(nudgeAfter.x),
                toDomPrecision(nudgeAfter.y)
              );
              break;
            }
            case "arcTo":
              parts.push(
                "A",
                segment.radius,
                segment.radius,
                0,
                segment.largeArcFlag ? "1" : "0",
                segment.sweepFlag ? "1" : "0",
                toDomPrecision(offsetP.x),
                toDomPrecision(offsetP.y)
              );
              break;
            default:
              exhaustiveSwitchError$1(segment, "type");
          }
        }
        if (closed) {
          parts.push("Z");
        }
      }
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeWidth, d: parts.join(" "), ...props });
  }
  segmentLength(lastPoint, segment) {
    switch (segment.type) {
      case "lineTo":
        return Vec.Dist(lastPoint, segment);
      case "arcTo": {
        const info = getArcSegmentInfo(lastPoint, segment);
        if (info === null) return 0;
        if (info === "straight-line") return Vec.Dist(lastPoint, segment);
        return info.length;
      }
      default:
        exhaustiveSwitchError$1(segment, "type");
    }
  }
}
/*!
 * Adapted from https://github.com/rveciana/svg-path-properties
 * MIT License: https://github.com/rveciana/svg-path-properties/blob/master/LICENSE
 * https://github.com/rveciana/svg-path-properties/blob/74d850d14998274f6eae279424bdc2194f156490/src/arc.ts#L121
 */
function getArcSegmentInfo(lastPoint, { radius, largeArcFlag, sweepFlag, x, y: y2 }) {
  radius = Math.abs(radius);
  if (lastPoint.x === x && lastPoint.y === y2) {
    return null;
  }
  if (radius === 0) {
    return "straight-line";
  }
  const dx = (lastPoint.x - x) / 2;
  const dy = (lastPoint.y - y2) / 2;
  const radiiCheck = Math.pow(dx, 2) / Math.pow(radius, 2) + Math.pow(dy, 2) / Math.pow(radius, 2);
  if (radiiCheck > 1) {
    radius = Math.sqrt(radiiCheck) * radius;
  }
  const cSquareNumerator = Math.pow(radius, 2) * Math.pow(radius, 2) - Math.pow(radius, 2) * Math.pow(dy, 2) - Math.pow(radius, 2) * Math.pow(dx, 2);
  const cSquareRootDenom = Math.pow(radius, 2) * Math.pow(dy, 2) + Math.pow(radius, 2) * Math.pow(dx, 2);
  let cRadicand = cSquareNumerator / cSquareRootDenom;
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  const cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  const transformedCenter = {
    x: cCoef * (radius * dy / radius),
    y: cCoef * (-(radius * dx) / radius)
  };
  const center = {
    x: transformedCenter.x + (lastPoint.x + x) / 2,
    y: transformedCenter.y + (lastPoint.y + y2) / 2
  };
  const startVector = {
    x: (dx - transformedCenter.x) / radius,
    y: (dy - transformedCenter.y) / radius
  };
  const endVector = {
    x: (-dx - transformedCenter.x) / radius,
    y: (-dy - transformedCenter.y) / radius
  };
  let sweepAngle = Vec.AngleBetween(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  sweepAngle %= 2 * Math.PI;
  return {
    length: Math.abs(sweepAngle * radius),
    radius,
    sweepAngle,
    startVector,
    endVector,
    center
  };
}
const PlainTextArea = React.forwardRef(function TextArea({
  isEditing,
  text,
  handleFocus,
  handleChange,
  handleKeyDown: handleKeyDown2,
  handleBlur,
  handleInputPointerDown,
  handleDoubleClick: handleDoubleClick2
}, ref) {
  const onChange = (e) => {
    handleChange({ plaintext: e.target.value });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      ref,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      disabled: !isEditing,
      readOnly: !isEditing,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: text,
      onFocus: handleFocus,
      onChange,
      onKeyDown: (e) => handleKeyDown2(e.nativeEvent),
      onBlur: handleBlur,
      onTouchEnd: stopEventPropagation,
      onContextMenu: isEditing ? stopEventPropagation : void 0,
      onPointerDown: handleInputPointerDown,
      onDoubleClick: handleDoubleClick2,
      onDragStart: preventDefault
    }
  );
});
function getLegacyOffsetX(align, padding, spans, totalWidth) {
  if ((align === "start-legacy" || align === "end-legacy") && spans.length !== 0) {
    const spansBounds = Box.From(spans[0].box);
    for (const { box } of spans) {
      spansBounds.union(box);
    }
    if (align === "start-legacy") {
      return (totalWidth - 2 * padding - spansBounds.width) / 2;
    } else if (align === "end-legacy") {
      return -(totalWidth - 2 * padding - spansBounds.width) / 2;
    }
  }
}
function isLegacyAlign(align) {
  return align === "start-legacy" || align === "middle-legacy" || align === "end-legacy";
}
function useEditablePlainText(shapeId, type, text) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = reactExports.useRef(null);
  const isEmpty = (text || "").trim().length === 0;
  reactExports.useEffect(() => {
    function selectAllIfEditing(event) {
      if (event.shapeId === shapeId) {
        rInput.current?.select?.();
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
    };
  }, [editor, shapeId, isEditing]);
  reactExports.useEffect(() => {
    if (!isEditing) return;
    if (document.activeElement !== rInput.current) {
      rInput.current?.focus();
    }
    if (editor.getInstanceState().isCoarsePointer) {
      rInput.current?.select();
    }
    if (tlenv.isSafari) {
      rInput.current?.blur();
      rInput.current?.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, shapeId]
  );
  const handleChange = reactExports.useCallback(
    ({ plaintext }) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      const normalizedPlaintext = TextHelpers.normalizeText(plaintext || "");
      editor.updateShape({
        id: shapeId,
        type,
        props: { text: normalizedPlaintext }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}
function useIsReadyForEditing(editor, shapeId) {
  return useValue(
    "isReadyForEditing",
    () => {
      const editingShapeId = editor.getEditingShapeId();
      return (
        // something's being editing... and either it's this shape OR this shape is hovered
        editingShapeId !== null && (editingShapeId === shapeId || editor.getHoveredShapeId() === shapeId)
      );
    },
    [editor, shapeId]
  );
}
function useEditableTextCommon(shapeId) {
  const editor = useEditor();
  const isEditing = useValue("isEditing", () => editor.getEditingShapeId() === shapeId, [editor]);
  const isReadyForEditing = useIsReadyForEditing(editor, shapeId);
  const handleInputPointerDown = reactExports.useCallback(
    (e) => {
      editor.dispatch({
        ...getPointerInfo(e),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: editor.getShape(shapeId)
      });
      stopEventPropagation(e);
    },
    [editor, shapeId]
  );
  return {
    handleFocus: noop$3,
    handleBlur: noop$3,
    handleInputPointerDown,
    handleDoubleClick: stopEventPropagation,
    isEditing,
    isReadyForEditing
  };
}
const PlainTextLabel = React.memo(function PlainTextLabel2({
  shapeId,
  type,
  text: plaintext,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap2,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight
}) {
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditablePlainText(shapeId, type, plaintext);
  const finalPlainText = TextHelpers.normalizeTextForDom(plaintext || "");
  const hasText = finalPlainText.length > 0;
  const legacyAlign = isLegacyAlign(align);
  if (!isEditing && !hasText) {
    return null;
  }
  const cssPrefix = classNamePrefix || "tl-text";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-plain-text-wrapper`,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-is-ready-for-editing": isReadyForEditing,
      "data-textwrap": !!wrap2,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: Math.floor(fontSize * lineHeight) + "px",
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: finalPlainText.split("\n").map((lineOfText, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dir: "auto", children: lineOfText }, index2)) }),
            (isReadyForEditing || isSelected) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              PlainTextArea,
              {
                ref: rInput,
                text: plaintext,
                isEditing,
                shapeId,
                ...editableTextRest,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function useDefaultColorTheme() {
  return getDefaultColorTheme({ isDarkMode: useIsDarkMode() });
}
function getFillDefForExport(fill) {
  return {
    key: `${DefaultFontStyle.id}:${fill}`,
    async getElement() {
      if (fill !== "pattern") return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HashPatternForExport, {});
    }
  };
}
function HashPatternForExport() {
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const maskId = useUniqueSafeId();
  const theme = useDefaultColorTheme();
  const t2 = 8 / 12;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("mask", { id: maskId, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { strokeLinecap: "round", stroke: "black", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: t2 * 1, y1: t2 * 3, x2: t2 * 3, y2: t2 * 1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: t2 * 5, y1: t2 * 7, x2: t2 * 7, y2: t2 * 5 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: t2 * 9, y1: t2 * 11, x2: t2 * 11, y2: t2 * 9 })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "pattern",
      {
        id: getHashPatternZoomName(1, theme.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: theme.solid, mask: `url(#${maskId})` })
      }
    )
  ] });
}
function getFillDefForCanvas() {
  return {
    key: `${DefaultFontStyle.id}:pattern`,
    component: PatternFillDefForCanvas
  };
}
const TILE_PATTERN_SIZE = 8;
const generateImage = (dpr, currentZoom, darkMode) => {
  return new Promise((resolve, reject) => {
    const size2 = TILE_PATTERN_SIZE * currentZoom * dpr;
    const canvasEl = document.createElement("canvas");
    canvasEl.width = size2;
    canvasEl.height = size2;
    const ctx = canvasEl.getContext("2d");
    if (!ctx) return;
    ctx.fillStyle = darkMode ? DefaultColorThemePalette.darkMode.solid : DefaultColorThemePalette.lightMode.solid;
    ctx.fillRect(0, 0, size2, size2);
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineCap = "round";
    ctx.lineWidth = 1.25 * currentZoom * dpr;
    const t2 = 8 / 12;
    const s2 = (v) => v * currentZoom * dpr;
    ctx.beginPath();
    ctx.moveTo(s2(t2 * 1), s2(t2 * 3));
    ctx.lineTo(s2(t2 * 3), s2(t2 * 1));
    ctx.moveTo(s2(t2 * 5), s2(t2 * 7));
    ctx.lineTo(s2(t2 * 7), s2(t2 * 5));
    ctx.moveTo(s2(t2 * 9), s2(t2 * 11));
    ctx.lineTo(s2(t2 * 11), s2(t2 * 9));
    ctx.stroke();
    canvasEl.toBlob((blob) => {
      if (!blob || debugFlags.throwToBlob.get()) {
        reject();
      } else {
        resolve(blob);
      }
    });
  });
};
const canvasBlob = (size2, fn) => {
  const canvas = document.createElement("canvas");
  canvas.width = size2[0];
  canvas.height = size2[1];
  const ctx = canvas.getContext("2d");
  if (!ctx) return "";
  fn(ctx);
  return canvas.toDataURL();
};
let defaultPixels = null;
function getDefaultPixels() {
  if (!defaultPixels) {
    defaultPixels = {
      white: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#f8f9fa";
        ctx.fillRect(0, 0, 1, 1);
      }),
      black: canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#212529";
        ctx.fillRect(0, 0, 1, 1);
      })
    };
  }
  return defaultPixels;
}
function getPatternLodForZoomLevel(zoom) {
  return Math.ceil(Math.log2(Math.max(1, zoom)));
}
function useGetHashPatternZoomName() {
  const id = useSharedSafeId("hash_pattern");
  return reactExports.useCallback(
    (zoom, theme) => {
      const lod = getPatternLodForZoomLevel(zoom);
      return suffixSafeId(id, `${theme}_${lod}`);
    },
    [id]
  );
}
function getPatternLodsToGenerate(maxZoom) {
  const levels = [];
  const minLod = 0;
  const maxLod = getPatternLodForZoomLevel(maxZoom);
  for (let i = minLod; i <= maxLod; i++) {
    levels.push(Math.pow(2, i));
  }
  return levels;
}
function getDefaultPatterns(maxZoom) {
  const defaultPixels2 = getDefaultPixels();
  return getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
    { zoom, url: defaultPixels2.white, theme: "light" },
    { zoom, url: defaultPixels2.black, theme: "dark" }
  ]);
}
function usePattern() {
  const editor = useEditor();
  const dpr = useValue("devicePixelRatio", () => editor.getInstanceState().devicePixelRatio, [
    editor
  ]);
  const maxZoom = useValue("maxZoom", () => Math.ceil(last$1(editor.getCameraOptions().zoomSteps)), [
    editor
  ]);
  const [isReady, setIsReady] = reactExports.useState(false);
  const [backgroundUrls, setBackgroundUrls] = reactExports.useState(
    () => getDefaultPatterns(maxZoom)
  );
  const getHashPatternZoomName = useGetHashPatternZoomName();
  reactExports.useEffect(() => {
    const promise = Promise.all(
      getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [
        generateImage(dpr, zoom, false).then((blob) => ({
          zoom,
          theme: "light",
          url: URL.createObjectURL(blob)
        })),
        generateImage(dpr, zoom, true).then((blob) => ({
          zoom,
          theme: "dark",
          url: URL.createObjectURL(blob)
        }))
      ])
    );
    let isCancelled = false;
    promise.then((urls) => {
      if (isCancelled) return;
      setBackgroundUrls(urls);
      setIsReady(true);
    });
    return () => {
      isCancelled = true;
      setIsReady(false);
      promise.then((patterns) => {
        for (const { url } of patterns) {
          URL.revokeObjectURL(url);
        }
      });
    };
  }, [dpr, maxZoom]);
  const defs = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: backgroundUrls.map((item) => {
    const id = getHashPatternZoomName(item.zoom, item.theme);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "pattern",
      {
        id,
        width: TILE_PATTERN_SIZE,
        height: TILE_PATTERN_SIZE,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: item.url, width: TILE_PATTERN_SIZE, height: TILE_PATTERN_SIZE })
      },
      id
    );
  }) });
  return { defs, isReady };
}
function PatternFillDefForCanvas() {
  const editor = useEditor();
  const containerRef = reactExports.useRef(null);
  const { defs, isReady } = usePattern();
  reactExports.useEffect(() => {
    if (isReady && tlenv.isSafari) {
      const htmlLayer = findHtmlLayerParent(containerRef.current);
      if (htmlLayer) {
        editor.timers.requestAnimationFrame(() => {
          htmlLayer.style.display = "none";
          editor.timers.requestAnimationFrame(() => {
            htmlLayer.style.display = "";
          });
        });
      }
    }
  }, [editor, isReady]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { ref: containerRef, "data-testid": isReady ? "ready-pattern-fill-defs" : void 0, children: defs });
}
function findHtmlLayerParent(element) {
  if (element.classList.contains("tl-html-layer")) return element;
  if (element.parentElement) return findHtmlLayerParent(element.parentElement);
  return null;
}
const ShapeFill = React.memo(function ShapeFill2({
  theme,
  d,
  color,
  fill,
  scale
}) {
  switch (fill) {
    case "none": {
      return null;
    }
    case "solid": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: theme[color].semi, d });
    }
    case "semi": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: theme.solid, d });
    }
    case "fill": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: theme[color].fill, d });
    }
    case "pattern": {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PatternFill, { theme, color, fill, d, scale });
    }
  }
});
function PatternFill({ d, color, theme }) {
  const editor = useEditor();
  const svgExport = useSvgExportContext();
  const zoomLevel = useValue("zoomLevel", () => editor.getZoomLevel(), [editor]);
  const getHashPatternZoomName = useGetHashPatternZoomName();
  const teenyTiny = editor.getZoomLevel() <= 0.18;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: theme[color].pattern, d }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        fill: svgExport ? `url(#${getHashPatternZoomName(1, theme.id)})` : teenyTiny ? theme[color].semi : `url(#${getHashPatternZoomName(zoomLevel, theme.id)})`,
        d
      }
    )
  ] });
}
function correctSpacesToNbsp(input) {
  return input.replace(/\s/g, " ");
}
function createTextJsxFromSpans(editor, spans, opts) {
  const { padding = 0 } = opts;
  if (spans.length === 0) return null;
  const bounds = Box.From(spans[0].box);
  for (const { box } of spans) {
    bounds.union(box);
  }
  const offsetX = padding + (opts.offsetX ?? 0);
  const offsetY = (opts.offsetY ?? 0) + opts.fontSize / 2 + (opts.verticalTextAlign === "start" ? padding : opts.verticalTextAlign === "end" ? opts.height - padding - bounds.height : (Math.ceil(opts.height) - bounds.height) / 2);
  let currentLineTop = null;
  const children = [];
  for (const { text, box } of spans) {
    const didBreakLine = currentLineTop !== null && box.y > currentLineTop;
    if (didBreakLine) {
      children.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "tspan",
          {
            alignmentBaseline: "mathematical",
            x: offsetX,
            y: box.y + offsetY,
            children: "\n"
          },
          children.length
        )
      );
    }
    children.push(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: box.x + offsetX,
          y: box.y + offsetY,
          unicodeBidi: "plaintext",
          children: correctSpacesToNbsp(text)
        },
        children.length
      )
    );
    currentLineTop = box.y;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "text",
    {
      fontSize: opts.fontSize,
      fontFamily: opts.fontFamily,
      fontStyle: opts.fontStyle,
      fontWeight: opts.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: opts.stroke,
      strokeWidth: opts.strokeWidth,
      fill: opts.fill,
      children
    }
  );
}
function SvgTextLabel({
  fontSize,
  font,
  align,
  verticalAlign,
  text,
  labelColor,
  bounds,
  padding = 16,
  stroke = true
}) {
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const opts = {
    fontSize,
    fontFamily: DefaultFontFamilies[font],
    textAlign: align,
    verticalTextAlign: verticalAlign,
    width: Math.ceil(bounds.width),
    height: Math.ceil(bounds.height),
    padding,
    lineHeight: TEXT_PROPS.lineHeight,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "wrap",
    offsetX: 0,
    offsetY: 0,
    fill: labelColor,
    stroke: void 0,
    strokeWidth: void 0
  };
  const spans = editor.textMeasure.measureTextSpans(text, opts);
  const offsetX = getLegacyOffsetX(align, padding, spans, bounds.width);
  if (offsetX) {
    opts.offsetX = offsetX;
  }
  opts.offsetX += bounds.x;
  opts.offsetY += bounds.y;
  const mainSpans = createTextJsxFromSpans(editor, spans, opts);
  let outlineSpans = null;
  if (stroke) {
    opts.fill = theme.background;
    opts.stroke = theme.background;
    opts.strokeWidth = 2;
    outlineSpans = createTextJsxFromSpans(editor, spans, opts);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    outlineSpans,
    mainSpans
  ] });
}
function getArrowBodyPath(shape, info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 }).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 }).arcTo(
        info.bodyArc.radius,
        !!info.bodyArc.largeArcFlag,
        !!info.bodyArc.sweepFlag,
        info.end.point.x,
        info.end.point.y,
        { offset: 0, roundness: 0 }
      ).toSvg(opts);
    case "elbow": {
      const path = new PathBuilder();
      path.moveTo(info.start.point.x, info.start.point.y, {
        offset: 0
      });
      for (let i = 1; i < info.route.points.length; i++) {
        const point = info.route.points[i];
        if (info.route.skipPointsWhenDrawing.has(point)) {
          continue;
        }
        path.lineTo(point.x, point.y, {
          offset: i === info.route.points.length - 1 ? 0 : void 0
        });
      }
      return path.toSvg(opts);
    }
    default:
      exhaustiveSwitchError$1(info, "type");
  }
}
function getArrowHandlePath(info, opts) {
  switch (info.type) {
    case "straight":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).lineTo(info.end.handle.x, info.end.handle.y).toSvg(opts);
    case "arc":
      return new PathBuilder().moveTo(info.start.handle.x, info.start.handle.y).arcTo(
        info.handleArc.radius,
        !!info.handleArc.largeArcFlag,
        !!info.handleArc.sweepFlag,
        info.end.handle.x,
        info.end.handle.y
      ).toSvg(opts);
    case "elbow": {
      const handleRoute = getRouteHandlePath(info.elbow, info.route);
      return PathBuilder.throughPoints(handleRoute.points).toSvg(opts);
    }
    default:
      exhaustiveSwitchError$1(info, "type");
  }
}
const arrowBodyGeometryCache = createComputedCache(
  "arrow body geometry",
  (editor, shape) => {
    const info = getArrowInfo(editor, shape);
    switch (info.type) {
      case "straight":
        return new Edge2d({
          start: Vec.From(info.start.point),
          end: Vec.From(info.end.point)
        });
      case "arc":
        return new Arc2d({
          center: Vec.Cast(info.handleArc.center),
          start: Vec.Cast(info.start.point),
          end: Vec.Cast(info.end.point),
          sweepFlag: info.bodyArc.sweepFlag,
          largeArcFlag: info.bodyArc.largeArcFlag
        });
      case "elbow":
        return new Polyline2d({ points: info.route.points });
      default:
        exhaustiveSwitchError$1(info, "type");
    }
  }
);
const labelSizeCache = createComputedCache(
  "arrow label size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    let width = 0;
    let height = 0;
    const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
    const text = shape.props.text || "i";
    const bodyBounds = bodyGeom.bounds;
    const fontSize = getArrowLabelFontSize(shape);
    const { w, h } = editor.textMeasure.measureText(text, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize,
      maxWidth: null
    });
    width = w;
    height = h;
    let shouldSquish = false;
    const info = getArrowInfo(editor, shape);
    const labelToArrowPadding = getLabelToArrowPadding(shape);
    const margin = info.type === "elbow" ? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) + Math.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32) : 64;
    if (bodyBounds.width > bodyBounds.height) {
      width = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w));
      shouldSquish = true;
    } else if (width > 16 * fontSize) {
      width = 16 * fontSize;
      shouldSquish = true;
    }
    if (shouldSquish) {
      const { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureText(text, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize,
        maxWidth: width
      });
      width = squishedWidth;
      height = squishedHeight;
    }
    return new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale);
  },
  { areRecordsEqual: (a2, b) => a2.props === b.props }
);
function getArrowLabelSize(editor, shape) {
  return labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0);
}
function getLabelToArrowPadding(shape) {
  const strokeWidth = STROKE_SIZES[shape.props.size];
  const labelToArrowPadding = (LABEL_TO_ARROW_PADDING + (strokeWidth - STROKE_SIZES.s) * 2 + (strokeWidth === STROKE_SIZES.xl ? 20 : 0)) * shape.props.scale;
  return labelToArrowPadding;
}
function getArrowLabelRange(editor, shape, info) {
  const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
  const dbgPoints = [];
  const dbg = [new Group2d({ children: [bodyGeom], debugColor: "lime" })];
  const labelSize = getArrowLabelSize(editor, shape);
  const labelToArrowPadding = getLabelToArrowPadding(shape);
  const paddingRelative = labelToArrowPadding / bodyGeom.length;
  let startBox, endBox;
  if (info.type === "elbow") {
    dbgPoints.push(info.start.point, info.end.point);
    startBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding);
    endBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding);
  } else {
    const startPoint = bodyGeom.interpolateAlongEdge(paddingRelative);
    const endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative);
    dbgPoints.push(startPoint, endPoint);
    startBox = Box.FromCenter(startPoint, labelSize);
    endBox = Box.FromCenter(endPoint, labelSize);
  }
  const startIntersections = bodyGeom.intersectPolygon(startBox.corners);
  const endIntersections = bodyGeom.intersectPolygon(endBox.corners);
  const startConstrained = furthest(info.start.point, startIntersections);
  const endConstrained = furthest(info.end.point, endIntersections);
  let startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5;
  let endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5;
  if (startRelative > endRelative) {
    startRelative = 0.5;
    endRelative = 0.5;
  }
  for (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {
    dbg.push(
      new Circle2d({
        x: pt.x - 3,
        y: pt.y - 3,
        radius: 3,
        isFilled: false,
        debugColor: "magenta",
        ignore: true
      })
    );
  }
  dbg.push(
    new Polygon2d({
      points: startBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    }),
    new Polygon2d({
      points: endBox.corners,
      debugColor: "lime",
      isFilled: false,
      ignore: true
    })
  );
  return { start: startRelative, end: endRelative, dbg };
}
function getArrowLabelPosition(editor, shape) {
  const debugGeom = [];
  const info = getArrowInfo(editor, shape);
  const arrowheadInfo = {
    hasStartBinding: !!info.bindings.start,
    hasEndBinding: !!info.bindings.end,
    hasStartArrowhead: info.start.arrowhead !== "none",
    hasEndArrowhead: info.end.arrowhead !== "none"
  };
  const range = getArrowLabelRange(editor, shape, info);
  if (range.dbg) debugGeom.push(...range.dbg);
  const clampedPosition = getClampedPosition(shape, range, arrowheadInfo);
  const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
  const labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition);
  const labelSize = getArrowLabelSize(editor, shape);
  return { box: Box.FromCenter(labelCenter, labelSize), debugGeom };
}
function getClampedPosition(shape, range, arrowheadInfo) {
  const { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo;
  const clampedPosition = clamp$3(
    shape.props.labelPosition,
    hasStartArrowhead || hasStartBinding ? range.start : 0,
    hasEndArrowhead || hasEndBinding ? range.end : 1
  );
  return clampedPosition;
}
function furthest(from2, candidates) {
  let furthest2 = null;
  let furthestDist = -Infinity;
  for (const candidate of candidates) {
    const dist = Vec.Dist2(from2, candidate);
    if (dist > furthestDist) {
      furthest2 = candidate;
      furthestDist = dist;
    }
  }
  return furthest2;
}
function getArrowLabelFontSize(shape) {
  return ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale;
}
function getArrowLabelDefaultPosition(editor, shape) {
  const info = getArrowInfo(editor, shape);
  switch (info.type) {
    case "straight":
    case "arc":
      return 0.5;
    case "elbow": {
      const midpointHandle = info.route.midpointHandle;
      const bodyGeom = arrowBodyGeometryCache.get(editor, shape.id);
      if (midpointHandle && bodyGeom) {
        return bodyGeom.uninterpolateAlongEdge(midpointHandle.point);
      }
      return 0.5;
    }
    default:
      exhaustiveSwitchError$1(info, "type");
  }
}
function getArrowPoints(info, side, strokeWidth) {
  const point = side === "end" ? info.end.point : info.start.point;
  let int;
  switch (info.type) {
    case "straight": {
      const opposite = side === "end" ? info.start.point : info.end.point;
      const compareLength = Vec.Dist(opposite, point);
      const length = clamp$3(compareLength / 5, strokeWidth, strokeWidth * 3);
      int = Vec.Nudge(point, opposite, length);
      break;
    }
    case "arc": {
      const compareLength = Math.abs(info.bodyArc.length);
      const length = clamp$3(compareLength / 5, strokeWidth, strokeWidth * 3);
      const intersections = intersectCircleCircle(
        point,
        length,
        info.handleArc.center,
        info.handleArc.radius
      );
      int = side === "end" ? info.handleArc.sweepFlag ? intersections[0] : intersections[1] : info.handleArc.sweepFlag ? intersections[1] : intersections[0];
      break;
    }
    case "elbow": {
      const previousPoint = side === "end" ? info.route.points[info.route.points.length - 2] : info.route.points[1];
      const previousSegmentLength = Vec.ManhattanDist(previousPoint, point);
      const length = clamp$3(previousSegmentLength / 2, strokeWidth, strokeWidth * 3);
      int = previousPoint ? Vec.Nudge(point, previousPoint, length) : point;
      break;
    }
    default:
      exhaustiveSwitchError$1(info, "type");
  }
  if (Vec.IsNaN(int)) {
    int = point;
  }
  return { point, int };
}
function getArrowhead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI$1 / 6);
  const PR = Vec.RotWith(int, point, -PI$1 / 6);
  return `M ${PL.x} ${PL.y} L ${point.x} ${point.y} L ${PR.x} ${PR.y}`;
}
function getTriangleHead({ point, int }) {
  const PL = Vec.RotWith(int, point, PI$1 / 6);
  const PR = Vec.RotWith(int, point, -PI$1 / 6);
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y} L ${point.x} ${point.y} Z`;
}
function getInvertedTriangleHead({ point, int }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`;
}
function getDotHead({ point, int }) {
  const A = Vec.Lrp(point, int, 0.45);
  const r2 = Vec.Dist(A, point);
  return `M ${A.x - r2},${A.y}
  a ${r2},${r2} 0 1,0 ${r2 * 2},0
  a ${r2},${r2} 0 1,0 -${r2 * 2},0 `;
}
function getDiamondHead({ point, int }) {
  const PB = Vec.Lrp(point, int, 0.75);
  const PL = Vec.RotWith(PB, point, PI$1 / 4);
  const PR = Vec.RotWith(PB, point, -PI$1 / 4);
  const PQ = Vec.Lrp(PL, PR, 0.5);
  PQ.add(Vec.Sub(PQ, point));
  return `M ${PQ.x} ${PQ.y} L ${PR.x} ${PR.y} ${point.x} ${point.y} L ${PL.x} ${PL.y} Z`;
}
function getSquareHead({ int, point }) {
  const PB = Vec.Lrp(point, int, 0.85);
  const d = Vec.Sub(PB, point).div(2);
  const PL1 = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR1 = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  const PL2 = Vec.Add(PB, Vec.Rot(d, HALF_PI));
  const PR2 = Vec.Sub(PB, Vec.Rot(d, HALF_PI));
  return `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`;
}
function getBarHead({ int, point }) {
  const d = Vec.Sub(int, point).div(2);
  const PL = Vec.Add(point, Vec.Rot(d, HALF_PI));
  const PR = Vec.Sub(point, Vec.Rot(d, HALF_PI));
  return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`;
}
function getArrowheadPathForType(info, side, strokeWidth) {
  const type = side === "end" ? info.end.arrowhead : info.start.arrowhead;
  if (type === "none") return;
  const points = getArrowPoints(info, side, strokeWidth);
  if (!points) return;
  switch (type) {
    case "bar":
      return getBarHead(points);
    case "square":
      return getSquareHead(points);
    case "diamond":
      return getDiamondHead(points);
    case "dot":
      return getDotHead(points);
    case "inverted":
      return getInvertedTriangleHead(points);
    case "arrow":
      return getArrowhead(points);
    case "triangle":
      return getTriangleHead(points);
  }
  return "";
}
function ElbowArrowDebug({ arrow: arrow2 }) {
  const editor = useEditor();
  const info = useValue(
    "elbow arrow grid",
    () => {
      try {
        const info2 = getElbowArrowInfo(
          editor,
          editor.getShape(arrow2.id),
          getArrowBindings(editor, arrow2)
        );
        return info2;
      } catch (err) {
        console.error(err);
        return void 0;
      }
    },
    [editor, arrow2.id]
  );
  if (!info) return null;
  const fullBox = Box.Common([info.A.original, info.B.original]).expandBy(50);
  const label = info.route?.name ?? "";
  const midPoint2 = info.route?.midpointHandle;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    info.midX !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: info.midX, y: fullBox.minY },
        b: { x: info.midX, y: fullBox.maxY },
        stroke: "red"
      }
    ),
    info.midY !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: fullBox.minX, y: info.midY },
        b: { x: fullBox.maxX, y: info.midY },
        stroke: "blue"
      }
    ),
    midPoint2?.axis === "x" && info.midXRange && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: info.midXRange.lo, y: midPoint2.point.y },
        b: { x: info.midXRange.hi, y: midPoint2.point.y },
        stroke: "red",
        strokeDasharray: "0 2"
      }
    ),
    midPoint2?.axis === "y" && info.midYRange && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: { x: midPoint2.point.x, y: info.midYRange.lo },
        b: { x: midPoint2.point.x, y: info.midYRange.hi },
        stroke: "blue",
        strokeDasharray: "0 2"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.A.original, stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.A.expanded, stroke: "orange", strokeWidth: 0.5 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugBox,
      {
        box: info.A.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "orange",
        strokeWidth: 0.5
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.B.original, stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugBox, { box: info.B.expanded, stroke: "lightskyblue", strokeWidth: 0.5 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugBox,
      {
        box: info.B.original.clone().expandBy(info.options.minElbowLegLength),
        stroke: "lightskyblue",
        strokeWidth: 0.5
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.top, axis: "x", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.top, axis: "x", stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.right, axis: "y", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.right, axis: "y", stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.bottom, axis: "x", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.bottom, axis: "x", stroke: "lightskyblue" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.A.edges.left, axis: "y", stroke: "orange" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DebugEdge, { edge: info.B.edges.left, axis: "y", stroke: "lightskyblue" }),
    info.route && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugRoute, { route: info.route.points, strokeWidth: 10 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "text",
      {
        x: fullBox.minX + 5,
        y: fullBox.minY - 3,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: label
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "text",
      {
        x: info.A.expanded.x,
        y: info.A.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "A",
          info.route && `, ${info.route.aEdgePicking}`,
          info.A.isPoint && `, point`
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "text",
      {
        x: info.B.expanded.x,
        y: info.B.expanded.y,
        fontSize: 10,
        fill: "black",
        stroke: "var(--color-background)",
        strokeWidth: 2,
        paintOrder: "stroke",
        children: [
          "B",
          info.route && `, ${info.route.bEdgePicking}`,
          info.B.isPoint && `, point`
        ]
      }
    )
  ] });
}
function DebugLine({ a: a2, b, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "line",
    {
      fill: "none",
      strokeWidth: 1,
      strokeDasharray: "4,4",
      stroke: "green",
      x1: a2.x,
      y1: a2.y,
      x2: b.x,
      y2: b.y,
      ...props
    }
  );
}
function DebugRoute({ route, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "polyline",
    {
      fill: "none",
      stroke: "darkorchid",
      strokeWidth: 3,
      opacity: 0.5,
      points: route.map((r2) => `${r2.x},${r2.y}`).join(" "),
      ...props
    }
  );
}
function DebugEdge({
  edge,
  axis,
  ...props
}) {
  if (!edge || edge.expanded === null) return null;
  const vec = (vec2) => axis === "x" ? { x: vec2.y, y: vec2.x } : vec2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: vec({ x: edge.expanded, y: edge.cross.min }),
        b: vec({ x: edge.expanded, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.min }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.min }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLine,
      {
        a: vec({ x: edge.expanded - 4, y: edge.cross.max }),
        b: vec({ x: edge.expanded + 4, y: edge.cross.max }),
        strokeDasharray: "0",
        strokeWidth: 1.5,
        ...props
      }
    )
  ] });
}
function DebugBox({ box, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "rect",
    {
      x: box.minX,
      y: box.minY,
      width: box.width,
      height: box.height,
      strokeDasharray: "4,4",
      strokeWidth: 1,
      fill: "none",
      ...props
    }
  );
}
const snapLinesStore = new WeakCache();
function getElbowArrowSnapLines(editor) {
  return snapLinesStore.get(editor, (editor2) => {
    const currentSelectedArrowShape = computed("current selected arrow shape", () => {
      const shape = editor2.getOnlySelectedShape();
      if (!shape || !editor2.isShapeOfType(shape, "arrow")) return null;
      return shape.id;
    });
    const unselectedArrowShapeIds = editor2.store.query.ids("shape", () => {
      const activeArrowShapeId = currentSelectedArrowShape.get();
      if (!activeArrowShapeId) return { type: { eq: "arrow" } };
      return {
        type: { eq: "arrow" },
        id: { neq: activeArrowShapeId }
      };
    });
    return computed("elbow arrow snap lines", () => {
      const result = /* @__PURE__ */ new Map();
      const currentPageShapeIds = editor2.getCurrentPageShapeIds();
      const viewportBounds = editor2.getViewportPageBounds();
      for (const id of unselectedArrowShapeIds.get()) {
        if (!currentPageShapeIds.has(id)) continue;
        const shape = editor2.getShape(id);
        if (shape?.type !== "arrow") continue;
        const shapeBounds = editor2.getShapePageBounds(id);
        if (!shapeBounds || !viewportBounds.includes(shapeBounds)) continue;
        const bindings = getArrowBindings(editor2, shape);
        const geometry = editor2.getShapePageGeometry(id);
        const vertices = geometry.getVertices({ includeInternal: false, includeLabels: false });
        for (let i = 1; i < vertices.length; i++) {
          const prev = vertices[i - 1];
          const curr = vertices[i];
          let angle = Vec.Angle(prev, curr);
          if (angle < 0) angle += Math.PI;
          let set = result.get(angle);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            result.set(angle, set);
          }
          const perpDistance = perpDistanceToLineAngle(prev, angle);
          set.add({
            perpDistance,
            startBoundShapeId: bindings.start?.toId,
            endBoundShapeId: bindings.end?.toId
          });
        }
      }
      return result;
    });
  }).get();
}
function perpDistanceToLineAngle(pointOnLine, lineAngle) {
  const perpDir = Vec.FromAngle(lineAngle).per();
  return Vec.Dpr(pointOnLine, perpDir);
}
class ArrowShapeUtil extends ShapeUtil {
  static type = "arrow";
  static props = arrowShapeProps;
  static migrations = arrowShapeMigrations;
  options = {
    expandElbowLegLength: {
      s: 28,
      m: 36,
      l: 44,
      xl: 66
    },
    minElbowLegLength: {
      s: STROKE_SIZES.s * 3,
      m: STROKE_SIZES.m * 3,
      l: STROKE_SIZES.l * 3,
      xl: STROKE_SIZES.xl * 3
    },
    minElbowHandleDistance: 16,
    arcArrowCenterSnapDistance: 16,
    elbowArrowCenterSnapDistance: 24,
    elbowArrowEdgeSnapDistance: 20,
    elbowArrowPointSnapDistance: 24,
    elbowArrowAxisSnapDistance: 16,
    labelCenterSnapDistance: 10,
    elbowMidpointSnapDistance: 10,
    elbowMinSegmentLengthToShowMidpointHandle: 20,
    hoverPreciseTimeout: 600,
    pointingPreciseTimeout: 320
  };
  canEdit() {
    return true;
  }
  canBind({ toShapeType }) {
    return toShapeType !== "arrow";
  }
  canSnap() {
    return false;
  }
  canTabTo(shape) {
    const bindings = getArrowBindings(this.editor, shape);
    return !!(bindings.start || bindings.end || shape.props.text);
  }
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  canBeLaidOut(shape, info) {
    if (info.type === "flip") {
      const bindings = getArrowBindings(this.editor, shape);
      const { start, end } = bindings;
      const { shapes = [] } = info;
      if (start && !shapes.find((s2) => s2.id === start.toId)) return false;
      if (end && !shapes.find((s2) => s2.id === end.toId)) return false;
    }
    return true;
  }
  getFontFaces(shape) {
    if (!shape.props.text) return EMPTY_ARRAY;
    return [DefaultFontFaces[`tldraw_${shape.props.font}`].normal.normal];
  }
  getDefaultProps() {
    return {
      kind: "arc",
      elbowMidPoint: 0.5,
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(shape) {
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const info = getArrowInfo(this.editor, shape);
    const debugGeom = [];
    const bodyGeom = info.type === "straight" ? new Edge2d({
      start: Vec.From(info.start.point),
      end: Vec.From(info.end.point)
    }) : info.type === "arc" ? new Arc2d({
      center: Vec.Cast(info.handleArc.center),
      start: Vec.Cast(info.start.point),
      end: Vec.Cast(info.end.point),
      sweepFlag: info.bodyArc.sweepFlag,
      largeArcFlag: info.bodyArc.largeArcFlag
    }) : new Polyline2d({ points: info.route.points });
    let labelGeom;
    if (isEditing || shape.props.text.trim()) {
      const labelPosition = getArrowLabelPosition(this.editor, shape);
      if (debugFlags.debugGeometry.get()) {
        debugGeom.push(...labelPosition.debugGeom);
      }
      labelGeom = new Rectangle2d({
        x: labelPosition.box.x,
        y: labelPosition.box.y,
        width: labelPosition.box.w,
        height: labelPosition.box.h,
        isFilled: true,
        isLabel: true
      });
    }
    return new Group2d({
      children: [...labelGeom ? [bodyGeom, labelGeom] : [bodyGeom], ...debugGeom]
    });
  }
  getHandles(shape) {
    const info = getArrowInfo(this.editor, shape);
    const handles = [
      {
        id: "start",
        type: "vertex",
        index: "a1",
        x: info.start.handle.x,
        y: info.start.handle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: info.end.handle.x,
        y: info.end.handle.y
      }
    ];
    if (shape.props.kind === "arc" && (info.type === "straight" || info.type === "arc")) {
      handles.push({
        id: "middle",
        type: "virtual",
        index: "a2",
        x: info.middle.x,
        y: info.middle.y
      });
    }
    if (shape.props.kind === "elbow" && info.type === "elbow" && info.route.midpointHandle) {
      const shapePageTransform = this.editor.getShapePageTransform(shape.id);
      const segmentStart = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentStart);
      const segmentEnd = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentEnd);
      const segmentLength = Vec.Dist(segmentStart, segmentEnd) * this.editor.getZoomLevel();
      if (segmentLength > this.options.elbowMinSegmentLengthToShowMidpointHandle) {
        handles.push({
          id: "middle",
          type: "vertex",
          index: "a2",
          x: info.route.midpointHandle.point.x,
          y: info.route.midpointHandle.point.y
        });
      }
    }
    return handles;
  }
  getText(shape) {
    return shape.props.text;
  }
  onHandleDrag(shape, info) {
    const handleId = info.handle.id;
    switch (handleId) {
      case "middle":
        switch (shape.props.kind) {
          case "arc":
            return this.onArcMidpointHandleDrag(shape, info);
          case "elbow":
            return this.onElbowMidpointHandleDrag(shape, info);
          default:
            exhaustiveSwitchError$1(shape.props.kind);
        }
      case "start":
      case "end":
        return this.onTerminalHandleDrag(shape, info, handleId);
      default:
        exhaustiveSwitchError$1(handleId);
    }
  }
  onArcMidpointHandleDrag(shape, { handle }) {
    const bindings = getArrowBindings(this.editor, shape);
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const delta = Vec.Sub(end, start);
    const v = Vec.Per(delta);
    const med = Vec.Med(end, start);
    const A = Vec.Sub(med, v);
    const B = Vec.Add(med, v);
    const point = Vec.NearestPointOnLineSegment(A, B, handle, false);
    let bend = Vec.Dist(point, med);
    if (Vec.Clockwise(point, end, med)) bend *= -1;
    return { id: shape.id, type: shape.type, props: { bend } };
  }
  onElbowMidpointHandleDrag(shape, { handle }) {
    const info = getArrowInfo(this.editor, shape);
    if (info?.type !== "elbow") return;
    const shapeToPageTransform = this.editor.getShapePageTransform(shape.id);
    const handlePagePoint = shapeToPageTransform.applyToPoint(handle);
    const axisName = info.route.midpointHandle?.axis;
    if (!axisName) return;
    const axis = ElbowArrowAxes[axisName];
    const midRange = info.elbow[axis.midRange];
    if (!midRange) return;
    let angle = Vec.Angle(
      shapeToPageTransform.applyToPoint(axis.v(0, 0)),
      shapeToPageTransform.applyToPoint(axis.v(0, 1))
    );
    if (angle < 0) angle += Math.PI;
    const handlePoint = perpDistanceToLineAngle(handlePagePoint, angle);
    const loPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.lo, 0)),
      angle
    );
    const hiPoint = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(midRange.hi, 0)),
      angle
    );
    const maxSnapDistance = this.options.elbowMidpointSnapDistance / this.editor.getZoomLevel();
    const midPoint2 = perpDistanceToLineAngle(
      shapeToPageTransform.applyToPoint(axis.v(lerp(midRange.lo, midRange.hi, 0.5), 0)),
      angle
    );
    let snapPoint = midPoint2;
    let snapDistance = Math.abs(midPoint2 - handlePoint);
    for (const [snapAngle, snapLines] of getElbowArrowSnapLines(this.editor)) {
      const { isParallel, isFlippedParallel } = anglesAreApproximatelyParallel(angle, snapAngle);
      if (isParallel || isFlippedParallel) {
        for (const snapLine of snapLines) {
          const doesShareStartIntersection = snapLine.startBoundShapeId && (snapLine.startBoundShapeId === info.bindings.start?.toId || snapLine.startBoundShapeId === info.bindings.end?.toId);
          const doesShareEndIntersection = snapLine.endBoundShapeId && (snapLine.endBoundShapeId === info.bindings.start?.toId || snapLine.endBoundShapeId === info.bindings.end?.toId);
          if (!doesShareStartIntersection && !doesShareEndIntersection) continue;
          const point = isFlippedParallel ? -snapLine.perpDistance : snapLine.perpDistance;
          const distance = Math.abs(point - handlePoint);
          if (distance < snapDistance) {
            snapPoint = point;
            snapDistance = distance;
          }
        }
      }
    }
    if (snapDistance > maxSnapDistance) {
      snapPoint = handlePoint;
    }
    const newMid = clamp$3(invLerp(loPoint, hiPoint, snapPoint), 0, 1);
    return {
      id: shape.id,
      type: shape.type,
      props: {
        elbowMidPoint: newMid
      }
    };
  }
  onTerminalHandleDrag(shape, { handle, isPrecise }, handleId) {
    const bindings = getArrowBindings(this.editor, shape);
    const update = { id: shape.id, type: "arrow", props: {} };
    const currentBinding = bindings[handleId];
    const oppositeHandleId = handleId === "start" ? "end" : "start";
    const oppositeBinding = bindings[oppositeHandleId];
    const targetInfo = updateArrowTargetState({
      editor: this.editor,
      pointInPageSpace: this.editor.getShapePageTransform(shape.id).applyToPoint(handle),
      arrow: shape,
      isPrecise,
      isExact: this.editor.inputs.altKey,
      currentBinding,
      oppositeBinding
    });
    if (!targetInfo) {
      removeArrowBinding(this.editor, shape, handleId);
      const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
      update.props[handleId] = {
        x: newPoint.x,
        y: newPoint.y
      };
      return update;
    }
    const bindingProps = {
      terminal: handleId,
      normalizedAnchor: targetInfo.normalizedAnchor,
      isPrecise: targetInfo.isPrecise,
      isExact: this.editor.inputs.altKey,
      snap: targetInfo.snap
    };
    createOrUpdateArrowBinding(this.editor, shape, targetInfo.target.id, bindingProps);
    const newBindings = getArrowBindings(this.editor, shape);
    if (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {
      if (Vec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)) {
        createOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {
          ...newBindings.end.props,
          normalizedAnchor: {
            x: newBindings.end.props.normalizedAnchor.x + 0.05,
            y: newBindings.end.props.normalizedAnchor.y
          }
        });
      }
    }
    return update;
  }
  onTranslateStart(shape) {
    const bindings = getArrowBindings(this.editor, shape);
    if (shape.props.kind === "elbow" && this.editor.getOnlySelectedShapeId() === shape.id) {
      const info = getArrowInfo(this.editor, shape);
      if (!info) return;
      const update = { id: shape.id, type: "arrow", props: {} };
      if (bindings.start) {
        update.props.start = { x: info.start.point.x, y: info.start.point.y };
        removeArrowBinding(this.editor, shape, "start");
      }
      if (bindings.end) {
        update.props.end = { x: info.end.point.x, y: info.end.point.y };
        removeArrowBinding(this.editor, shape, "end");
      }
      return update;
    }
    const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const selectedShapeIds = this.editor.getSelectedShapeIds();
    if (bindings.start && (selectedShapeIds.includes(bindings.start.toId) || this.editor.isAncestorSelected(bindings.start.toId)) || bindings.end && (selectedShapeIds.includes(bindings.end.toId) || this.editor.isAncestorSelected(bindings.end.toId))) {
      return;
    }
    shapeAtTranslationStart.set(shape, {
      pagePosition: shapePageTransform.applyToPoint(shape),
      terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
        const binding = bindings[terminalName];
        if (!binding) return null;
        return {
          binding,
          shapePosition: point,
          pagePosition: shapePageTransform.applyToPoint(point)
        };
      })
    });
    if (bindings.start) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "start",
        useHandle: true
      });
      shape = this.editor.getShape(shape.id);
    }
    if (bindings.end) {
      updateArrowTerminal({
        editor: this.editor,
        arrow: shape,
        terminal: "end",
        useHandle: true
      });
    }
    for (const handleName of [
      "start",
      "end"
      /* End */
    ]) {
      const binding = bindings[handleName];
      if (!binding) continue;
      this.editor.updateBinding({
        ...binding,
        props: { ...binding.props, isPrecise: true }
      });
    }
    return;
  }
  onTranslate(initialShape, shape) {
    const atTranslationStart = shapeAtTranslationStart.get(initialShape);
    if (!atTranslationStart) return;
    const shapePageTransform = this.editor.getShapePageTransform(shape.id);
    const pageDelta = Vec.Sub(
      shapePageTransform.applyToPoint(shape),
      atTranslationStart.pagePosition
    );
    for (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {
      if (!terminalBinding) continue;
      const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5));
      const newTarget = this.editor.getShapeAtPoint(newPagePoint, {
        hitInside: true,
        hitFrameInside: true,
        margin: 0,
        filter: (targetShape) => {
          return !targetShape.isLocked && this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: "arrow" });
        }
      });
      if (newTarget?.id === terminalBinding.binding.toId) {
        const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds);
        const pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint);
        const normalizedAnchor = {
          x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
          y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height
        };
        createOrUpdateArrowBinding(this.editor, shape, newTarget.id, {
          ...terminalBinding.binding.props,
          normalizedAnchor,
          isPrecise: true
        });
      } else {
        removeArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal);
      }
    }
  }
  _resizeInitialBindings = new WeakCache();
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const bindings = this._resizeInitialBindings.get(
      shape,
      () => getArrowBindings(this.editor, shape)
    );
    const terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings);
    const { start, end } = structuredClone(shape.props);
    let { bend } = shape.props;
    if (!bindings.start) {
      start.x = terminals.start.x * scaleX;
      start.y = terminals.start.y * scaleY;
    }
    if (!bindings.end) {
      end.x = terminals.end.x * scaleX;
      end.y = terminals.end.y * scaleY;
    }
    const mx = Math.abs(scaleX);
    const my = Math.abs(scaleY);
    const startNormalizedAnchor = bindings?.start ? Vec.From(bindings.start.props.normalizedAnchor) : null;
    const endNormalizedAnchor = bindings?.end ? Vec.From(bindings.end.props.normalizedAnchor) : null;
    if (scaleX < 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
      }
    } else if (scaleX >= 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    } else if (scaleX >= 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
    } else if (scaleX < 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
      if (startNormalizedAnchor) {
        startNormalizedAnchor.x = 1 - startNormalizedAnchor.x;
        startNormalizedAnchor.y = 1 - startNormalizedAnchor.y;
      }
      if (endNormalizedAnchor) {
        endNormalizedAnchor.x = 1 - endNormalizedAnchor.x;
        endNormalizedAnchor.y = 1 - endNormalizedAnchor.y;
      }
    }
    if (bindings.start && startNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {
        ...bindings.start.props,
        normalizedAnchor: startNormalizedAnchor.toJson()
      });
    }
    if (bindings.end && endNormalizedAnchor) {
      createOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {
        ...bindings.end.props,
        normalizedAnchor: endNormalizedAnchor.toJson()
      });
    }
    const next = {
      props: {
        start,
        end,
        bend
      }
    };
    return next;
  }
  onDoubleClickHandle(shape, handle) {
    switch (handle.id) {
      case "start": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadStart: shape.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      }
      case "end": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadEnd: shape.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
      }
    }
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const onlySelectedShape = this.editor.getOnlySelectedShape();
    const shouldDisplayHandles = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getIsReadonly();
    const info = getArrowInfo(this.editor, shape);
    if (!info?.isValid) return null;
    const labelPosition = getArrowLabelPosition(this.editor, shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isEditing = this.editor.getEditingShapeId() === shape.id;
    const showArrowLabel = isEditing || shape.props.text;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ArrowSvg,
          {
            shape,
            shouldDisplayHandles: shouldDisplayHandles && onlySelectedShape?.id === shape.id
          }
        ),
        shape.props.kind === "elbow" && debugFlags.debugElbowArrows.get() && /* @__PURE__ */ jsxRuntimeExports.jsx(ElbowArrowDebug, { arrow: shape })
      ] }),
      showArrowLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(
        PlainTextLabel,
        {
          shapeId: shape.id,
          classNamePrefix: "tl-arrow",
          type: "arrow",
          font: shape.props.font,
          fontSize: getArrowLabelFontSize(shape),
          lineHeight: TEXT_PROPS.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          text: shape.props.text,
          labelColor: theme[shape.props.labelColor].solid,
          textWidth: labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale,
          isSelected,
          padding: 0,
          style: {
            transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(shape) {
    const isEditing = useIsEditing(shape.id);
    const clipPathId = useSharedSafeId(shape.id + "_clip");
    const info = getArrowInfo(this.editor, shape);
    if (!info) return null;
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings);
    const geometry = this.editor.getShapeGeometry(shape);
    const bounds = geometry.bounds;
    const labelGeometry = isEditing || shape.props.text.trim() ? geometry.children[1] : null;
    if (Vec.Equals(start, end)) return null;
    const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const includeClipPath = as && info.start.arrowhead !== "arrow" || ae && info.end.arrowhead !== "arrow" || !!labelGeometry;
    if (isEditing && labelGeometry) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          x: toDomPrecision(labelGeometry.x),
          y: toDomPrecision(labelGeometry.y),
          width: labelGeometry.w,
          height: labelGeometry.h,
          rx: 3.5 * shape.props.scale,
          ry: 3.5 * shape.props.scale
        }
      );
    }
    const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
    const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      includeClipPath && /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ArrowClipPath,
        {
          radius: 3.5 * shape.props.scale,
          hasText: shape.props.text.trim().length > 0,
          bounds,
          labelBounds: labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0),
          as: clipStartArrowhead && as ? as : "",
          ae: clipEndArrowhead && ae ? ae : ""
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "g",
        {
          style: {
            clipPath: includeClipPath ? `url(#${clipPathId})` : void 0,
            WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : void 0
          },
          children: [
            includeClipPath && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "rect",
              {
                x: bounds.minX - 100,
                y: bounds.minY - 100,
                width: bounds.width + 200,
                height: bounds.height + 200,
                opacity: 0
              }
            ),
            getArrowBodyPath(
              shape,
              info,
              shape.props.dash === "draw" ? {
                style: "draw",
                randomSeed: shape.id,
                strokeWidth: 1,
                passes: 1,
                offset: 0,
                roundness: strokeWidth * 2,
                props: { strokeWidth: void 0 }
              } : { style: "solid", strokeWidth: 1, props: { strokeWidth: void 0 } }
            )
          ]
        }
      ),
      as && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: as }),
      ae && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: ae }),
      labelGeometry && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          x: toDomPrecision(labelGeometry.x),
          y: toDomPrecision(labelGeometry.y),
          width: labelGeometry.w,
          height: labelGeometry.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  onEditStart(shape) {
    if (shape.props.text.trim() === "") {
      const labelPosition = getArrowLabelDefaultPosition(this.editor, shape);
      this.editor.updateShape({
        id: shape.id,
        type: shape.type,
        props: { labelPosition }
      });
    }
  }
  onEditEnd(shape) {
    const {
      id,
      type,
      props: { text }
    } = shape;
    if (text.trimEnd() !== shape.props.text) {
      this.editor.updateShapes([
        {
          id,
          type,
          props: {
            text: text.trimEnd()
          }
        }
      ]);
    }
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const theme = getDefaultColorTheme(ctx);
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { transform: `scale(${scaleFactor})`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSvg, { shape, shouldDisplayHandles: false }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SvgTextLabel,
        {
          fontSize: getArrowLabelFontSize(shape),
          font: shape.props.font,
          align: "middle",
          verticalAlign: "middle",
          text: shape.props.text,
          labelColor: theme[shape.props.labelColor].solid,
          bounds: getArrowLabelPosition(this.editor, shape).box.clone().expandBy(-ARROW_LABEL_PADDING * shape.props.scale),
          padding: 0
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      getFillDefForCanvas(),
      {
        key: `arrow:dot`,
        component: ArrowheadDotDef
      },
      {
        key: `arrow:cross`,
        component: ArrowheadCrossDef
      }
    ];
  }
  getInterpolatedProps(startShape, endShape, progress) {
    return {
      ...progress > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, progress),
      start: {
        x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
        y: lerp(startShape.props.start.y, endShape.props.start.y, progress)
      },
      end: {
        x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
        y: lerp(startShape.props.end.y, endShape.props.end.y, progress)
      },
      bend: lerp(startShape.props.bend, endShape.props.bend, progress),
      labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress)
    };
  }
}
const ArrowSvg = track(function ArrowSvg2({
  shape,
  shouldDisplayHandles
}) {
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const info = getArrowInfo(editor, shape);
  const isForceSolid = useValue(
    "force solid",
    () => {
      return editor.getZoomLevel() < 0.2;
    },
    [editor]
  );
  const clipPathId = useSharedSafeId(shape.id + "_clip");
  const arrowheadDotId = useSharedSafeId("arrowhead-dot");
  const arrowheadCrossId = useSharedSafeId("arrowhead-cross");
  const isEditing = useIsEditing(shape.id);
  const geometry = editor.getShapeGeometry(shape);
  if (!geometry) return null;
  const bounds = Box.ZeroFix(geometry.bounds);
  const bindings = getArrowBindings(editor, shape);
  if (!info?.isValid) return null;
  const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale;
  const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
  const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
  let handlePath = null;
  if (shouldDisplayHandles && (bindings.start || bindings.end)) {
    handlePath = getArrowHandlePath(info, {
      style: "dashed",
      start: "skip",
      end: "skip",
      lengthRatio: 2.5,
      strokeWidth: 2 / editor.getZoomLevel(),
      props: {
        className: "tl-arrow-hint",
        markerStart: bindings.start ? bindings.start.props.isExact ? "" : bindings.start.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        markerEnd: bindings.end ? bindings.end.props.isExact ? "" : bindings.end.props.isPrecise ? `url(#${arrowheadCrossId})` : `url(#${arrowheadDotId})` : "",
        opacity: 0.16
      }
    });
  }
  const labelPosition = getArrowLabelPosition(editor, shape);
  const clipStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
  const clipEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: clipPathId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ArrowClipPath,
      {
        radius: 3.5 * shape.props.scale,
        hasText: isEditing || shape.props.text.trim().length > 0,
        bounds,
        labelBounds: labelPosition.box,
        as: clipStartArrowhead && as ? as : "",
        ae: clipEndArrowhead && ae ? ae : ""
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "g",
      {
        fill: "none",
        stroke: theme[shape.props.color].solid,
        strokeWidth,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          handlePath,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "g",
            {
              style: {
                clipPath: `url(#${clipPathId})`,
                WebkitClipPath: `url(#${clipPathId})`
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "rect",
                  {
                    x: toDomPrecision(bounds.minX - 100),
                    y: toDomPrecision(bounds.minY - 100),
                    width: toDomPrecision(bounds.width + 200),
                    height: toDomPrecision(bounds.height + 200),
                    opacity: 0
                  }
                ),
                getArrowBodyPath(shape, info, {
                  style: shape.props.dash,
                  strokeWidth,
                  forceSolid: isForceSolid,
                  randomSeed: shape.id
                })
              ]
            }
          ),
          as && clipStartArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ShapeFill,
            {
              theme,
              d: as,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          ae && clipEndArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ShapeFill,
            {
              theme,
              d: ae,
              color: shape.props.color,
              fill: shape.props.fill,
              scale: shape.props.scale
            }
          ),
          as && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: as }),
          ae && /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: ae })
        ]
      }
    )
  ] });
});
function ArrowClipPath({
  radius,
  hasText,
  bounds,
  labelBounds,
  as,
  ae
}) {
  const path = reactExports.useMemo(() => {
    const path2 = new PathBuilder();
    path2.moveTo(bounds.left - 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.top - 100).lineTo(bounds.right + 100, bounds.bottom + 100).lineTo(bounds.left - 100, bounds.bottom + 100).close();
    if (hasText) {
      path2.moveTo(labelBounds.left, labelBounds.top + radius).lineTo(labelBounds.left, labelBounds.bottom - radius).arcTo(radius, false, false, labelBounds.left + radius, labelBounds.bottom).lineTo(labelBounds.right - radius, labelBounds.bottom).arcTo(radius, false, false, labelBounds.right, labelBounds.bottom - radius).lineTo(labelBounds.right, labelBounds.top + radius).arcTo(radius, false, false, labelBounds.right - radius, labelBounds.top).lineTo(labelBounds.left + radius, labelBounds.top).arcTo(radius, false, false, labelBounds.left, labelBounds.top + radius).close();
    }
    return path2.toD();
  }, [
    radius,
    hasText,
    bounds.bottom,
    bounds.left,
    bounds.right,
    bounds.top,
    labelBounds.bottom,
    labelBounds.left,
    labelBounds.right,
    labelBounds.top
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: `${path}${as}${ae}` });
}
const shapeAtTranslationStart = /* @__PURE__ */ new WeakMap();
function ArrowheadDotDef() {
  const id = useSharedSafeId("arrowhead-dot");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function ArrowheadCrossDef() {
  const id = useSharedSafeId("arrowhead-cross");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("marker", { id, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
function anglesAreApproximatelyParallel(a2, b, tolerance = 1e-4) {
  const diff = Math.abs(a2 - b);
  const isParallel = diff < tolerance;
  const isFlippedParallel = Math.abs(diff - Math.PI) < tolerance;
  const is360Parallel = Math.abs(diff - PI2) < tolerance;
  return { isParallel: isParallel || is360Parallel, isFlippedParallel };
}
const LINK_ICON$1 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function HyperlinkButton({ url }) {
  const editor = useEditor();
  const hideButton = useValue("zoomLevel", () => editor.getZoomLevel() < 0.32, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      className: classNames("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": hideButton
      }),
      href: url,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: stopEventPropagation,
      onPointerUp: stopEventPropagation,
      title: url,
      draggable: false,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${LINK_ICON$1}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${LINK_ICON$1}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const LINK_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
const ROTATING_BOX_SHADOWS = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function getRotatedBoxShadow(rotation) {
  const cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {
    const { offsetX, offsetY, blur: blur2, spread, color } = shadow;
    const vec = new Vec(offsetX, offsetY);
    const { x, y: y2 } = vec.rot(-rotation);
    return `${x}px ${y2}px ${blur2}px ${spread}px ${color}`;
  });
  return cssStrings.join(", ");
}
const BOOKMARK_WIDTH = 300;
const BOOKMARK_HEIGHT = 320;
const BOOKMARK_JUST_URL_HEIGHT = 46;
const SHORT_BOOKMARK_HEIGHT = 101;
class BookmarkShapeUtil extends BaseBoxShapeUtil {
  static type = "bookmark";
  static props = bookmarkShapeProps;
  static migrations = bookmarkShapeMigrations;
  canResize() {
    return false;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const asset = shape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null;
    if (!asset?.props.title) return void 0;
    return convertCommonTitleHTMLEntities(asset.props.title) + (asset.props.description ? ", " + asset.props.description : "");
  }
  getDefaultProps() {
    return {
      url: "",
      w: BOOKMARK_WIDTH,
      h: BOOKMARK_HEIGHT,
      assetId: null
    };
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BookmarkShapeComponent, { shape, util: this });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        rx: "6",
        ry: "6"
      }
    );
  }
  onBeforeCreate(next) {
    return getBookmarkSize(this.editor, next);
  }
  onBeforeUpdate(prev, shape) {
    if (prev.props.url !== shape.props.url) {
      if (!linkUrl.isValid(shape.props.url)) {
        return { ...shape, props: { ...shape.props, url: prev.props.url } };
      } else {
        updateBookmarkAssetOnUrlChange(this.editor, shape);
      }
    }
    if (prev.props.assetId !== shape.props.assetId) {
      return getBookmarkSize(this.editor, shape);
    }
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
}
function BookmarkShapeComponent({
  shape,
  util: util2
}) {
  const asset = shape.props.assetId ? util2.editor.getAsset(shape.props.assetId) : null;
  const isSafariExport = !!useSvgExportContext() && tlenv.isSafari;
  const pageRotation = util2.editor.getShapePageTransform(shape).rotation();
  const address = getHumanReadableAddress(shape);
  const [isFaviconValid, setIsFaviconValid] = reactExports.useState(true);
  const onFaviconError = () => setIsFaviconValid(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames(
        "tl-bookmark__container",
        isSafariExport && "tl-bookmark__container--safariExport"
      ),
      style: {
        boxShadow: isSafariExport ? void 0 : getRotatedBoxShadow(pageRotation),
        maxHeight: shape.props.h
      },
      children: [
        (!asset || asset.props.image) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-bookmark__image_container", children: [
          asset ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              className: "tl-bookmark__image",
              draggable: false,
              referrerPolicy: "strict-origin-when-cross-origin",
              src: asset?.props.image,
              alt: asset?.props.title || ""
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-bookmark__placeholder" }),
          asset?.props.image && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tl-bookmark__copy_container", children: [
          asset?.props.title ? /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "tl-bookmark__heading", children: convertCommonTitleHTMLEntities(asset.props.title) }) : null,
          asset?.props.description && asset?.props.image ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "tl-bookmark__description", children: asset.props.description }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "a",
            {
              className: "tl-bookmark__link",
              href: shape.props.url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              onPointerDown: stopEventPropagation,
              onPointerUp: stopEventPropagation,
              onClick: stopEventPropagation,
              children: [
                isFaviconValid && asset?.props.favicon ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: "tl-bookmark__favicon",
                    src: asset?.props.favicon,
                    referrerPolicy: "strict-origin-when-cross-origin",
                    onError: onFaviconError,
                    alt: `favicon of ${address}`
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "tl-hyperlink__icon",
                    style: {
                      mask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
                      WebkitMask: `url("${LINK_ICON}") center 100% / 100% no-repeat`
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: address })
              ]
            }
          )
        ] })
      ]
    }
  ) });
}
function getBookmarkSize(editor, shape) {
  const asset = shape.props.assetId ? editor.getAsset(shape.props.assetId) : null;
  let h = BOOKMARK_HEIGHT;
  if (asset) {
    if (!asset.props.image) {
      if (!asset.props.title) {
        h = BOOKMARK_JUST_URL_HEIGHT;
      } else {
        h = SHORT_BOOKMARK_HEIGHT;
      }
    }
  }
  return {
    ...shape,
    props: {
      ...shape.props,
      h
    }
  };
}
const getHumanReadableAddress = (shape) => {
  try {
    const url = new URL(shape.props.url);
    return url.hostname.replace(/^www\./, "");
  } catch {
    return shape.props.url;
  }
};
function updateBookmarkAssetOnUrlChange(editor, shape) {
  const { url } = shape.props;
  const assetId = AssetRecordType.createId(getHashForString(url));
  if (editor.getAsset(assetId)) {
    if (shape.props.assetId !== assetId) {
      editor.updateShapes([
        {
          id: shape.id,
          type: shape.type,
          props: { assetId }
        }
      ]);
    }
  } else {
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: null }
      }
    ]);
    createBookmarkAssetOnUrlChange(editor, shape);
  }
}
const createBookmarkAssetOnUrlChange = debounce(async (editor, shape) => {
  if (editor.isDisposed) return;
  const { url } = shape.props;
  const asset = await editor.getAssetForExternalContent({ type: "url", url });
  if (!asset) {
    return;
  }
  editor.run(() => {
    editor.createAssets([asset]);
    editor.updateShapes([
      {
        id: shape.id,
        type: shape.type,
        props: { assetId: asset.id }
      }
    ]);
  });
}, 500);
function getSvgPathFromStrokePoints(points, closed = false) {
  const len = points.length;
  if (len < 2) {
    return "";
  }
  let a2 = points[0].point;
  let b = points[1].point;
  if (len === 2) {
    return `M${precise(a2)}L${precise(b)}`;
  }
  let result = "";
  for (let i = 2, max2 = len - 1; i < max2; i++) {
    a2 = points[i].point;
    b = points[i + 1].point;
    result += average(a2, b);
  }
  if (closed) {
    return `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}T${result}${average(points[len - 1].point, points[0].point)}${average(
      points[0].point,
      points[1].point
    )}Z`;
  } else {
    return `M${precise(points[0].point)}Q${precise(points[1].point)}${average(
      points[1].point,
      points[2].point
    )}${points.length > 3 ? "T" : ""}${result}L${precise(points[len - 1].point)}`;
  }
}
function svgInk(rawInputPoints, options = {}) {
  const { start = {}, end = {} } = options;
  const { cap: capStart = true } = start;
  const { cap: capEnd = true } = end;
  assert(!start.taper && !end.taper, "cap taper not supported here");
  assert(!start.easing && !end.easing, "cap easing not supported here");
  assert(capStart && capEnd, "cap must be true");
  const points = getStrokePoints(rawInputPoints, options);
  setStrokePointRadii(points, options);
  const partitions = partitionAtElbows(points);
  let svg = "";
  for (const partition2 of partitions) {
    svg += renderPartition(partition2, options);
  }
  return svg;
}
function partitionAtElbows(points) {
  if (points.length <= 2) return [points];
  const result = [];
  let currentPartition = [points[0]];
  let prevV = Vec.Sub(points[1].point, points[0].point).uni();
  let nextV;
  let dpr;
  let prevPoint, thisPoint, nextPoint;
  for (let i = 1, n2 = points.length; i < n2 - 1; i++) {
    prevPoint = points[i - 1];
    thisPoint = points[i];
    nextPoint = points[i + 1];
    nextV = Vec.Sub(nextPoint.point, thisPoint.point).uni();
    dpr = Vec.Dpr(prevV, nextV);
    prevV = nextV;
    if (dpr < -0.8) {
      const elbowPoint = {
        ...thisPoint,
        point: thisPoint.input
      };
      currentPartition.push(elbowPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [elbowPoint];
      continue;
    }
    currentPartition.push(thisPoint);
    if (dpr > 0.7) {
      continue;
    }
    if ((Vec.Dist2(prevPoint.point, thisPoint.point) + Vec.Dist2(thisPoint.point, nextPoint.point)) / ((prevPoint.radius + thisPoint.radius + nextPoint.radius) / 3) ** 2 < 1.5) {
      currentPartition.push(thisPoint);
      result.push(cleanUpPartition(currentPartition));
      currentPartition = [thisPoint];
      continue;
    }
  }
  currentPartition.push(points[points.length - 1]);
  result.push(cleanUpPartition(currentPartition));
  return result;
}
function cleanUpPartition(partition2) {
  const startPoint = partition2[0];
  let nextPoint;
  while (partition2.length > 2) {
    nextPoint = partition2[1];
    if (Vec.Dist2(startPoint.point, nextPoint.point) < ((startPoint.radius + nextPoint.radius) / 2 * 0.5) ** 2) {
      partition2.splice(1, 1);
    } else {
      break;
    }
  }
  const endPoint = partition2[partition2.length - 1];
  let prevPoint;
  while (partition2.length > 2) {
    prevPoint = partition2[partition2.length - 2];
    if (Vec.Dist2(endPoint.point, prevPoint.point) < ((endPoint.radius + prevPoint.radius) / 2 * 0.5) ** 2) {
      partition2.splice(partition2.length - 2, 1);
    } else {
      break;
    }
  }
  if (partition2.length > 1) {
    partition2[0] = {
      ...partition2[0],
      vector: Vec.Sub(partition2[0].point, partition2[1].point).uni()
    };
    partition2[partition2.length - 1] = {
      ...partition2[partition2.length - 1],
      vector: Vec.Sub(
        partition2[partition2.length - 2].point,
        partition2[partition2.length - 1].point
      ).uni()
    };
  }
  return partition2;
}
function circlePath(cx, cy, r2) {
  return "M " + cx + " " + cy + " m -" + r2 + ", 0 a " + r2 + "," + r2 + " 0 1,1 " + r2 * 2 + ",0 a " + r2 + "," + r2 + " 0 1,1 -" + r2 * 2 + ",0";
}
function renderPartition(strokePoints, options = {}) {
  if (strokePoints.length === 0) return "";
  if (strokePoints.length === 1) {
    return circlePath(strokePoints[0].point.x, strokePoints[0].point.y, strokePoints[0].radius);
  }
  const { left, right } = getStrokeOutlineTracks(strokePoints, options);
  right.reverse();
  let svg = `M${precise(left[0])}T`;
  for (let i = 1; i < left.length; i++) {
    svg += average(left[i - 1], left[i]);
  }
  {
    const point = strokePoints[strokePoints.length - 1];
    const radius = point.radius;
    const direction = point.vector.clone().per().neg();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}T`;
  }
  for (let i = 1; i < right.length; i++) {
    svg += average(right[i - 1], right[i]);
  }
  {
    const point = strokePoints[0];
    const radius = point.radius;
    const direction = point.vector.clone().per();
    const arcStart = Vec.Add(point.point, Vec.Mul(direction, radius));
    const arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius));
    svg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(
      radius
    )} 0 0 1 ${precise(arcEnd)}Z`;
  }
  return svg;
}
const interpolateSegments = (startSegments, endSegments, progress) => {
  const startPoints = [];
  const endPoints = [];
  startSegments.forEach((segment) => startPoints.push(...segment.points));
  endSegments.forEach((segment) => endPoints.push(...segment.points));
  const maxLength = Math.max(startPoints.length, endPoints.length);
  const pointsToUseStart = [];
  const pointsToUseEnd = [];
  for (let i = 0; i < maxLength; i++) {
    pointsToUseStart.push(startPoints[i] || startPoints[startPoints.length - 1]);
    pointsToUseEnd.push(endPoints[i] || endPoints[endPoints.length - 1]);
  }
  const interpolatedPoints = pointsToUseStart.map((point, k) => {
    let z = 0.5;
    if (pointsToUseEnd[k].z !== void 0 && point.z !== void 0) {
      z = lerp(point.z, pointsToUseEnd[k].z, progress);
    }
    return {
      x: lerp(point.x, pointsToUseEnd[k].x, progress),
      y: lerp(point.y, pointsToUseEnd[k].y, progress),
      z
    };
  });
  return [
    {
      type: "free",
      points: interpolatedPoints
    }
  ];
};
const PEN_EASING = (t2) => t2 * 0.65 + SIN(t2 * PI$1 / 2) * 0.35;
const simulatePressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0.5,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    easing: EASINGS.easeOutSine,
    simulatePressure: true
  };
};
const realPressureSettings = (strokeWidth) => {
  return {
    size: 1 + strokeWidth * 1.2,
    thinning: 0.62,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: PEN_EASING
  };
};
const solidSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true),
    // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
const solidRealPressureSettings = (strokeWidth) => {
  return {
    size: strokeWidth,
    thinning: 0,
    streamline: 0.62,
    smoothing: 0.62,
    simulatePressure: false,
    easing: EASINGS.linear
  };
};
function getHighlightFreehandSettings({
  strokeWidth,
  showAsComplete
}) {
  return {
    size: 1 + strokeWidth,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: false,
    easing: EASINGS.easeOutSine,
    last: showAsComplete
  };
}
function getFreehandOptions(shapeProps, strokeWidth, forceComplete, forceSolid) {
  const last2 = shapeProps.isComplete || forceComplete;
  if (forceSolid) {
    if (shapeProps.isPen) {
      return { ...solidRealPressureSettings(strokeWidth), last: last2 };
    } else {
      return { ...solidSettings(strokeWidth), last: last2 };
    }
  }
  if (shapeProps.dash === "draw") {
    if (shapeProps.isPen) {
      return { ...realPressureSettings(strokeWidth), last: last2 };
    } else {
      return { ...simulatePressureSettings(strokeWidth), last: last2 };
    }
  }
  return { ...solidSettings(strokeWidth), last: last2 };
}
function getPointsFromSegments(segments) {
  const points = [];
  for (const segment of segments) {
    if (segment.type === "free" || segment.points.length < 2) {
      points.push(...segment.points.map(Vec.Cast));
    } else {
      const pointsToInterpolate = Math.max(
        4,
        Math.floor(Vec.Dist(segment.points[0], segment.points[1]) / 16)
      );
      points.push(...Vec.PointsBetween(segment.points[0], segment.points[1], pointsToInterpolate));
    }
  }
  return points;
}
function getDrawShapeStrokeDashArray(shape, strokeWidth, dotAdjustment) {
  return {
    draw: "none",
    solid: `none`,
    dotted: `${dotAdjustment} ${strokeWidth * 2}`,
    dashed: `${strokeWidth * 2} ${strokeWidth * 2}`
  }[shape.props.dash];
}
class DrawShapeUtil extends ShapeUtil {
  static type = "draw";
  static props = drawShapeProps;
  static migrations = drawShapeMigrations;
  options = {
    maxPointsPerShape: 600
  };
  canTabTo() {
    return false;
  }
  hideResizeHandles(shape) {
    return getIsDot$1(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot$1(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot$1(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: false,
      isClosed: false,
      isPen: false,
      scale: 1
    };
  }
  getGeometry(shape) {
    const points = getPointsFromSegments(shape.props.segments);
    const sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale;
    if (shape.props.segments.length === 1) {
      const box = Box.FromPoints(points);
      if (box.width < sw * 2 && box.height < sw * 2) {
        return new Circle2d({
          x: -sw,
          y: -sw,
          radius: sw,
          isFilled: true
        });
      }
    }
    const strokePoints = getStrokePoints(
      points,
      getFreehandOptions(shape.props, sw, shape.props.isPen, true)
    ).map((p) => p.point);
    if (shape.props.isClosed) {
      return new Polygon2d({
        points: strokePoints,
        isFilled: shape.props.fill !== "none"
      });
    }
    return new Polyline2d({
      points: strokePoints
    });
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawShapeSvg, { shape }) });
  }
  indicator(shape) {
    const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
    let sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale;
    const forceSolid = useValue(
      "force solid",
      () => {
        const zoomLevel = this.editor.getZoomLevel();
        return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
      },
      [this.editor, sw]
    );
    if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
      sw += rng(shape.id)() * (sw / 6);
    }
    const showAsComplete = shape.props.isComplete || last$1(shape.props.segments)?.type === "straight";
    const options = getFreehandOptions(shape.props, sw, showAsComplete, true);
    const strokePoints = getStrokePoints(allPointsFromSegments, options);
    const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: solidStrokePath });
  }
  toSvg(shape, ctx) {
    ctx.addExportDef(getFillDefForExport(shape.props.fill));
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(${scaleFactor})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawShapeSvg, { shape, zoomOverride: 1 }) });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const newSegments = [];
    for (const segment of shape.props.segments) {
      newSegments.push({
        ...segment,
        points: segment.points.map(({ x, y: y2, z }) => {
          return {
            x: toFixed(scaleX * x),
            y: toFixed(scaleY * y2),
            z
          };
        })
      });
    }
    return {
      props: {
        segments: newSegments
      }
    };
  }
  expandSelectionOutlinePx(shape) {
    const multiplier = shape.props.dash === "draw" ? 1.6 : 1;
    return STROKE_SIZES[shape.props.size] * multiplier / 2 * shape.props.scale;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getDot(point, sw) {
  const r2 = (sw + 1) * 0.5;
  return `M ${point.x} ${point.y} m -${r2}, 0 a ${r2},${r2} 0 1,0 ${r2 * 2},0 a ${r2},${r2} 0 1,0 -${r2 * 2},0`;
}
function getIsDot$1(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
}
function DrawShapeSvg({ shape, zoomOverride }) {
  const theme = useDefaultColorTheme();
  const editor = useEditor();
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  const showAsComplete = shape.props.isComplete || last$1(shape.props.segments)?.type === "straight";
  let sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale;
  const forceSolid = useValue(
    "force solid",
    () => {
      const zoomLevel = zoomOverride ?? editor.getZoomLevel();
      return zoomLevel < 0.5 && zoomLevel < 1.5 / sw;
    },
    [editor, sw, zoomOverride]
  );
  const dotAdjustment = useValue(
    "dot adjustment",
    () => {
      const zoomLevel = zoomOverride ?? editor.getZoomLevel();
      return zoomLevel < 0.2 ? 0 : 0.1;
    },
    [editor, zoomOverride]
  );
  if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid);
  if (!forceSolid && shape.props.dash === "draw") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      shape.props.isClosed && shape.props.fill && allPointsFromSegments.length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        ShapeFill,
        {
          d: getSvgPathFromStrokePoints(
            getStrokePoints(allPointsFromSegments, options),
            shape.props.isClosed
          ),
          theme,
          color: shape.props.color,
          fill: shape.props.isClosed ? shape.props.fill : "none",
          scale: shape.props.scale
        }
      ) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: svgInk(allPointsFromSegments, options),
          strokeLinecap: "round",
          fill: theme[shape.props.color].solid
        }
      )
    ] });
  }
  const strokePoints = getStrokePoints(allPointsFromSegments, options);
  const isDot = strokePoints.length < 2;
  const solidStrokePath = isDot ? getDot(allPointsFromSegments[0], 0) : getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ShapeFill,
      {
        d: solidStrokePath,
        theme,
        color: shape.props.color,
        fill: isDot || shape.props.isClosed ? shape.props.fill : "none",
        scale: shape.props.scale
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: solidStrokePath,
        strokeLinecap: "round",
        fill: isDot ? theme[shape.props.color].solid : "none",
        stroke: theme[shape.props.color].solid,
        strokeWidth: sw,
        strokeDasharray: isDot ? "none" : getDrawShapeStrokeDashArray(shape, sw, dotAdjustment),
        strokeDashoffset: "0"
      }
    )
  ] });
}
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function matchEmbedUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const originalUrl = localEmbedDef.fromEmbedUrl(url);
      if (originalUrl) {
        return {
          definition: localEmbedDef,
          url: originalUrl,
          embedUrl: url
        };
      }
    }
  }
}
const globlikeRegExp = (input) => {
  return input.split("*").map((str2) => escapeStringRegexp(str2)).join(".+");
};
const checkHostnames = (hostnames, targetHostname) => {
  return !!hostnames.find((hostname) => {
    const re = new RegExp(globlikeRegExp(hostname));
    return targetHostname.match(re);
  });
};
function matchUrl(definitions, url) {
  const parsed = safeParseUrl(url);
  if (!parsed) return;
  const host = parsed.host.replace("www.", "");
  for (const localEmbedDef of definitions) {
    if (checkHostnames(localEmbedDef.hostnames, host)) {
      const embedUrl = localEmbedDef.toEmbedUrl(url);
      if (embedUrl) {
        return {
          definition: localEmbedDef,
          embedUrl,
          url
        };
      }
    }
  }
}
function getEmbedInfo(definitions, inputUrl) {
  try {
    return matchUrl(definitions, inputUrl) ?? matchEmbedUrl(definitions, inputUrl);
  } catch {
    return void 0;
  }
}
const getSandboxPermissions = (permissions) => {
  return Object.entries(permissions).filter(([_perm, isEnabled]) => isEnabled).map(([perm]) => perm).join(" ");
};
class EmbedShapeUtil extends BaseBoxShapeUtil {
  static type = "embed";
  static props = embedShapeProps;
  static migrations = embedShapeMigrations;
  static embedDefinitions = DEFAULT_EMBED_DEFINITIONS;
  static setEmbedDefinitions(embedDefinitions) {
    EmbedShapeUtil.embedDefinitions = embedDefinitions;
  }
  getEmbedDefinitions() {
    return EmbedShapeUtil.embedDefinitions;
  }
  getEmbedDefinition(url) {
    return getEmbedInfo(EmbedShapeUtil.embedDefinitions, url);
  }
  getText(shape) {
    return shape.props.url;
  }
  getAriaDescriptor(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo?.definition.title;
  }
  hideSelectionBoundsFg(shape) {
    return !this.canResize(shape);
  }
  canEdit() {
    return true;
  }
  canResize(shape) {
    return !!this.getEmbedDefinition(shape.props.url)?.definition?.doesResize;
  }
  canEditInReadonly() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  isAspectRatioLocked(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return embedInfo?.definition.isAspectRatioLocked ?? false;
  }
  onResize(shape, info) {
    const isAspectRatioLocked = this.isAspectRatioLocked(shape);
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    let minWidth = embedInfo?.definition.minWidth ?? 200;
    let minHeight = embedInfo?.definition.minHeight ?? 200;
    if (isAspectRatioLocked) {
      const aspectRatio = shape.props.w / shape.props.h;
      if (aspectRatio > 1) {
        minWidth *= aspectRatio;
      } else {
        minHeight /= aspectRatio;
      }
    }
    return resizeBox(shape, info, { minWidth, minHeight });
  }
  component(shape) {
    const svgExport = useSvgExportContext();
    const { w, h, url } = shape.props;
    const isEditing = useIsEditing(shape.id);
    const embedInfo = this.getEmbedDefinition(url);
    const isHoveringWhileEditingSameShape = useValue(
      "is hovering",
      () => {
        const { editingShapeId, hoveredShapeId } = this.editor.getCurrentPageState();
        if (editingShapeId && hoveredShapeId !== editingShapeId) {
          const editingShape = this.editor.getShape(editingShapeId);
          if (editingShape && this.editor.isShapeOfType(editingShape, "embed")) {
            return true;
          }
        }
        return false;
      },
      []
    );
    const pageRotation = this.editor.getShapePageTransform(shape).rotation();
    if (svgExport) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tl-embed",
          style: {
            border: 0,
            boxShadow: getRotatedBoxShadow(pageRotation),
            borderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,
            background: embedInfo?.definition.backgroundColor ?? "var(--color-background)",
            width: w,
            height: h
          }
        }
      ) });
    }
    const isInteractive = isEditing || isHoveringWhileEditingSameShape;
    const isIframe = typeof window !== "undefined" && (window !== window.top || window.self !== window.parent);
    if (isIframe && embedInfo?.definition.type === "tldraw") return null;
    if (embedInfo?.definition.type === "github_gist") {
      const idFromGistUrl = embedInfo.url.split("/").pop();
      if (!idFromGistUrl) throw Error("No gist id!");
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Gist,
        {
          id: idFromGistUrl,
          width: toDomPrecision(w),
          height: toDomPrecision(h),
          isInteractive,
          pageRotation
        }
      ) });
    }
    const sandbox = getSandboxPermissions({
      ...embedShapePermissionDefaults,
      ...embedInfo?.definition.overridePermissions ?? {}
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: embedInfo?.definition ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        className: "tl-embed",
        sandbox,
        src: embedInfo.embedUrl,
        width: toDomPrecision(w),
        height: toDomPrecision(h),
        draggable: false,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        tabIndex: isEditing ? 0 : -1,
        style: {
          border: 0,
          pointerEvents: isInteractive ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: isInteractive ? "" : "-1",
          boxShadow: getRotatedBoxShadow(pageRotation),
          borderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,
          background: embedInfo?.definition.backgroundColor
        }
      }
    ) : null });
  }
  indicator(shape) {
    const embedInfo = this.getEmbedDefinition(shape.props.url);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        rx: embedInfo?.definition.overrideOutlineRadius ?? 8,
        ry: embedInfo?.definition.overrideOutlineRadius ?? 8
      }
    );
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
}
function Gist({
  id,
  isInteractive,
  width,
  height,
  style: style2,
  pageRotation
}) {
  if (!id.match(/^[0-9a-f]+$/)) throw Error("No gist id!");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "iframe",
    {
      className: "tl-embed",
      draggable: false,
      width: toDomPrecision(width),
      height: toDomPrecision(height),
      frameBorder: "0",
      scrolling: "no",
      referrerPolicy: "no-referrer-when-downgrade",
      tabIndex: isInteractive ? 0 : -1,
      style: {
        ...style2,
        pointerEvents: isInteractive ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: isInteractive ? "" : "-1",
        boxShadow: getRotatedBoxShadow(pageRotation)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${id}.js`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
function getFrameHeadingSide(editor, shape) {
  const pageRotation = canonicalizeRotation(editor.getShapePageTransform(shape.id).rotation());
  const offsetRotation = pageRotation + Math.PI / 4;
  const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4;
  return Math.floor(scaledRotation);
}
const measurementWeakmap = /* @__PURE__ */ new WeakMap();
function getFrameHeadingSize(editor, shape, opts) {
  let width = measurementWeakmap.get(shape.props);
  if (!width) {
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const spans = editor.textMeasure.measureTextSpans(frameTitle, opts);
    const firstSpan = spans[0];
    const lastSpan = last$1(spans);
    width = lastSpan.box.w + lastSpan.box.x - firstSpan.box.x;
    measurementWeakmap.set(shape.props, width);
  }
  return new Box(0, -opts.height, width, opts.height);
}
function getFrameHeadingOpts(width, isSvg) {
  return {
    fontSize: 12,
    fontFamily: isSvg ? "Arial" : "Inter, sans-serif",
    textAlign: "start",
    width,
    height: 24,
    // --frame-height
    padding: 0,
    lineHeight: 1,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "truncate-ellipsis",
    verticalTextAlign: "middle",
    offsetY: -34,
    // --frame-minimum-height + (border width * 2)
    offsetX: 0
  };
}
function getFrameHeadingTranslation(shape, side, isSvg) {
  const u = isSvg ? "" : "px";
  const r2 = isSvg ? "" : "deg";
  let labelTranslate;
  switch (side) {
    case 0:
      labelTranslate = ``;
      break;
    case 3:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, 0${u}) rotate(90${r2})`;
      break;
    case 2:
      labelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, ${toDomPrecision(
        shape.props.h
      )}${u}) rotate(180${r2})`;
      break;
    case 1:
      labelTranslate = `translate(0${u}, ${toDomPrecision(shape.props.h)}${u}) rotate(270${r2})`;
      break;
    default:
      throw Error("labelSide out of bounds");
  }
  return labelTranslate;
}
const FrameLabelInput = reactExports.forwardRef(({ id, name, isEditing }, ref) => {
  const editor = useEditor();
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      if (e.key === "Enter" && !e.nativeEvent.isComposing) {
        stopEventPropagation(e);
        e.currentTarget.blur();
        editor.setEditingShape(null);
      }
    },
    [editor]
  );
  const handleBlur = reactExports.useCallback(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const name2 = shape.props.name;
      const value = e.currentTarget.value.trim();
      if (name2 === value) return;
      editor.updateShapes([
        {
          id,
          type: "frame",
          props: { name: value }
        }
      ]);
    },
    [id, editor]
  );
  const handleChange = reactExports.useCallback(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const name2 = shape.props.name;
      const value = e.currentTarget.value;
      if (name2 === value) return;
      editor.updateShapes([
        {
          id,
          type: "frame",
          props: { name: value }
        }
      ]);
    },
    [id, editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `tl-frame-label ${isEditing ? "tl-frame-label__editing" : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        className: "tl-frame-name-input",
        ref,
        disabled: !isEditing,
        readOnly: !isEditing,
        style: { display: isEditing ? void 0 : "none" },
        value: name,
        autoFocus: true,
        onKeyDown: handleKeyDown2,
        onBlur: handleBlur,
        onChange: handleChange,
        onPointerDown: isEditing ? stopEventPropagation : void 0,
        draggable: false
      }
    ),
    defaultEmptyAs(name, "Frame") + String.fromCharCode(8203)
  ] });
});
const FrameHeading = reactExports.memo(function FrameHeading2({
  id,
  name,
  width,
  height,
  fill,
  stroke,
  color,
  offsetX,
  showColors
}) {
  const editor = useEditor();
  const { side, translation } = useValue(
    "shape rotation",
    () => {
      const shape = editor.getShape(id);
      if (!shape) {
        return {
          side: 0,
          translation: "translate(0, 0)"
        };
      }
      const labelSide = getFrameHeadingSide(editor, shape);
      return {
        side: labelSide,
        translation: getFrameHeadingTranslation(shape, labelSide, false)
      };
    },
    [editor, offsetX, id]
  );
  const rInput = reactExports.useRef(null);
  const isEditing = useIsEditing(id);
  reactExports.useEffect(() => {
    const el = rInput.current;
    if (el && isEditing) {
      el.focus();
      el.select();
    }
  }, [rInput, isEditing]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: isEditing ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${side === 0 || side === 2 ? Math.ceil(width) : Math.ceil(height)}px + ${showColors ? "0px" : "var(--frame-offset-width)"})`,
        bottom: "100%",
        transform: `${translation} scale(var(--tl-scale)) translateX(${offsetX}px)`
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tl-frame-heading-hit-area",
          style: { color, backgroundColor: fill, boxShadow: `inset 0px 0px 0px 1px ${stroke}` },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(FrameLabelInput, { ref: rInput, id, name, isEditing })
        }
      )
    }
  );
});
const FRAME_HEADING_EXTRA_WIDTH = 12;
const FRAME_HEADING_MIN_WIDTH = 32;
const FRAME_HEADING_NOCOLORS_OFFSET_X = -7;
const FRAME_HEADING_OFFSET_Y = 4;
function defaultEmptyAs(str2, dflt) {
  if (str2.match(/^\s*$/)) {
    return dflt;
  }
  return str2;
}
class FrameShapeUtil extends BaseBoxShapeUtil {
  static type = "frame";
  static props = frameShapeProps;
  static migrations = frameShapeMigrations;
  options = {
    showColors: false
  };
  // evil crimes :)
  // By default, showColors is off. Because they use style props, which are picked up
  // automatically, we don't have DefaultColorStyle in the props in the schema by default.
  // Instead, when someone calls .configure to turn the option on, we manually add in the color
  // style here so it plays nicely with the other editor APIs.
  static configure(options) {
    const withOptions = super.configure.call(this, options);
    if (options.showColors) {
      withOptions.props = { ...withOptions.props, color: DefaultColorStyle };
    }
    return withOptions;
  }
  canEdit() {
    return true;
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "", color: "black" };
  }
  getAriaDescriptor(shape) {
    return shape.props.name;
  }
  getGeometry(shape) {
    const { editor } = this;
    const z = editor.getZoomLevel();
    const labelSide = getFrameHeadingSide(editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth, false);
    const headingSize = getFrameHeadingSize(editor, shape, opts);
    const isShowingFrameColors = this.options.showColors;
    const extraWidth = FRAME_HEADING_EXTRA_WIDTH / z;
    const minWidth = FRAME_HEADING_MIN_WIDTH / z;
    const maxWidth = rotatedTopEdgeWidth + (isShowingFrameColors ? 1 : extraWidth);
    const labelWidth = headingSize.w / z;
    const labelHeight = headingSize.h / z;
    const clampedLabelWidth = clamp$3(labelWidth + extraWidth, minWidth, maxWidth);
    const offsetX = (isShowingFrameColors ? -1 : FRAME_HEADING_NOCOLORS_OFFSET_X) / z;
    const offsetY = FRAME_HEADING_OFFSET_Y / z;
    const width = isVertical ? labelHeight : clampedLabelWidth;
    const height = isVertical ? clampedLabelWidth : labelHeight;
    let x, y2;
    switch (labelSide) {
      case 0: {
        x = offsetX;
        y2 = -(labelHeight + offsetY);
        break;
      }
      case 1: {
        x = -(labelHeight + offsetY);
        y2 = shape.props.h - (offsetX + clampedLabelWidth);
        break;
      }
      case 2: {
        x = shape.props.w - (offsetX + clampedLabelWidth);
        y2 = shape.props.h + offsetY;
        break;
      }
      case 3: {
        x = shape.props.w + offsetY;
        y2 = offsetX;
        break;
      }
    }
    return new Group2d({
      children: [
        new Rectangle2d({
          width: shape.props.w,
          height: shape.props.h,
          isFilled: false
        }),
        new Rectangle2d({
          x,
          y: y2,
          width,
          height,
          isFilled: true,
          isLabel: true
        })
      ]
    });
  }
  getText(shape) {
    return shape.props.name;
  }
  component(shape) {
    const theme = useDefaultColorTheme();
    const isCreating = useValue(
      "is creating this shape",
      () => {
        const resizingState = this.editor.getStateDescendant("select.resizing");
        if (!resizingState) return false;
        if (!resizingState.getIsActive()) return false;
        const info = resizingState?.info;
        if (!info) return false;
        return info.isCreating && this.editor.getOnlySelectedShapeId() === shape.id;
      },
      [shape.id]
    );
    const zoomLevel = useValue("zoom level", () => this.editor.getZoomLevel(), [this.editor]);
    const showFrameColors = this.options.showColors;
    const color = theme[shape.props.color];
    const frameFill = showFrameColors ? color.frame.fill : theme.black.frame.fill;
    const frameStroke = showFrameColors ? color.frame.stroke : theme.black.frame.stroke;
    const frameHeadingStroke = showFrameColors ? color.frame.headingStroke : theme.background;
    const frameHeadingFill = showFrameColors ? color.frame.headingFill : theme.background;
    const frameHeadingText = showFrameColors ? color.frame.text : theme.text;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          className: classNames("tl-frame__body", { "tl-frame__creating": isCreating }),
          width: shape.props.w + 1 / zoomLevel,
          height: shape.props.h + 1 / zoomLevel,
          fill: frameFill,
          stroke: frameStroke,
          y: -0.5 / zoomLevel,
          x: -0.5 / zoomLevel
        }
      ) }),
      isCreating ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
        FrameHeading,
        {
          id: shape.id,
          name: shape.props.name,
          fill: frameHeadingFill,
          stroke: frameHeadingStroke,
          color: frameHeadingText,
          width: shape.props.w,
          height: shape.props.h,
          offsetX: showFrameColors ? -1 : -7,
          showColors: this.options.showColors
        }
      )
    ] });
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const labelSide = getFrameHeadingSide(this.editor, shape);
    const isVertical = labelSide % 2 === 1;
    const rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w;
    const labelTranslate = getFrameHeadingTranslation(shape, labelSide, true);
    const opts = getFrameHeadingOpts(rotatedTopEdgeWidth - 12, true);
    const frameTitle = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
    const labelBounds = getFrameHeadingSize(this.editor, shape, opts);
    const spans = this.editor.textMeasure.measureTextSpans(frameTitle, opts);
    const text = createTextJsxFromSpans(this.editor, spans, opts);
    const showFrameColors = this.options.showColors;
    const color = theme[shape.props.color];
    const frameFill = showFrameColors ? color.frame.fill : theme.black.frame.fill;
    const frameStroke = showFrameColors ? color.frame.stroke : theme.black.frame.stroke;
    const frameHeadingStroke = showFrameColors ? color.frame.headingStroke : theme.background;
    const frameHeadingFill = showFrameColors ? color.frame.headingFill : theme.background;
    const frameHeadingText = showFrameColors ? color.frame.text : theme.text;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          width: shape.props.w,
          height: shape.props.h,
          fill: frameFill,
          stroke: frameStroke,
          strokeWidth: 1,
          x: 0,
          rx: 0,
          ry: 0
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: frameHeadingText, transform: labelTranslate, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "rect",
          {
            x: labelBounds.x - (showFrameColors ? 0 : 6),
            y: labelBounds.y - 6,
            width: Math.min(rotatedTopEdgeWidth, labelBounds.width + 12),
            height: labelBounds.height,
            fill: frameHeadingFill,
            stroke: frameHeadingStroke,
            rx: 4,
            ry: 4
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `translate(${showFrameColors ? 8 : 0}, 4)`, children: text })
      ] })
    ] });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        width: toDomPrecision(shape.props.w),
        height: toDomPrecision(shape.props.h),
        className: `tl-frame-indicator`
      }
    );
  }
  canReceiveNewChildrenOfType(shape, _type) {
    return !shape.isLocked;
  }
  providesBackgroundForChildren() {
    return true;
  }
  canDropShapes(shape, _shapes) {
    return !shape.isLocked;
  }
  onDragShapesOver(frame2, shapes) {
    if (!shapes.every((child) => child.parentId === frame2.id)) {
      this.editor.reparentShapes(shapes, frame2.id);
    }
  }
  onDragShapesOut(_shape, shapes) {
    const parent = this.editor.getShape(_shape.parentId);
    const isInGroup = parent && this.editor.isShapeOfType(parent, "group");
    if (isInGroup) {
      this.editor.reparentShapes(shapes, parent.id);
    } else {
      this.editor.reparentShapes(shapes, this.editor.getCurrentPageId());
    }
  }
  onResize(shape, info) {
    return resizeBox(shape, info);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2)
    };
  }
  onDoubleClickEdge(shape, info) {
    if (info.target !== "selection") return;
    const { handle } = info;
    if (!handle) return;
    const isHorizontalEdge = handle === "left" || handle === "right";
    const isVerticalEdge = handle === "top" || handle === "bottom";
    const childIds = this.editor.getSortedChildIdsForParent(shape.id);
    const children = compact$1(childIds.map((id) => this.editor.getShape(id)));
    if (!children.length) return;
    const { dx, dy, w, h } = getFrameChildrenBounds(children, this.editor, { padding: 10 });
    this.editor.run(() => {
      const changes = childIds.map((childId) => {
        const childShape = this.editor.getShape(childId);
        return {
          id: childShape.id,
          type: childShape.type,
          x: isHorizontalEdge ? childShape.x + dx : childShape.x,
          y: isVerticalEdge ? childShape.y + dy : childShape.y
        };
      });
      this.editor.updateShapes(changes);
    });
    return {
      id: shape.id,
      type: shape.type,
      props: {
        w: isHorizontalEdge ? w : shape.props.w,
        h: isVerticalEdge ? h : shape.props.h
      }
    };
  }
  onDoubleClickCorner(shape) {
    fitFrameToContent(this.editor, shape.id, { padding: 10 });
    return {
      id: shape.id,
      type: shape.type
    };
  }
}
const RichTextArea = React.forwardRef(function RichTextArea2({
  shapeId,
  isEditing,
  richText,
  handleFocus,
  handleChange,
  handleBlur,
  handleKeyDown: handleKeyDown2,
  handleDoubleClick: handleDoubleClick2,
  hasCustomTabBehavior
}, ref) {
  const editor = useEditor();
  const tipTapId = useUniqueSafeId("tip-tap-editor");
  const tipTapConfig = editor.getTextOptions().tipTapConfig;
  const rInitialRichText = reactExports.useRef(richText);
  const rTextEditor = reactExports.useRef(null);
  const rTextEditorEl = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (!rTextEditor.current) {
      rInitialRichText.current = richText;
    } else if (rInitialRichText.current !== richText) {
      rTextEditor.current.commands.setContent(richText);
    }
  }, [richText]);
  const rCreateInfo = reactExports.useRef({
    selectAll: false,
    caretPosition: null
  });
  reactExports.useLayoutEffect(() => {
    function selectAllIfEditing(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.selectAll = true;
      }
    }
    function placeCaret(event) {
      if (event.shapeId === editor.getEditingShapeId()) {
        rCreateInfo.current.caretPosition = event.point;
      }
    }
    editor.on("select-all-text", selectAllIfEditing);
    editor.on("place-caret", placeCaret);
    return () => {
      editor.off("select-all-text", selectAllIfEditing);
      editor.off("place-caret", placeCaret);
    };
  }, [editor, isEditing]);
  const onChange = useEvent(handleChange);
  const onKeyDown = useEvent(handleKeyDown2);
  const onFocus = useEvent(handleFocus);
  const onBlur = useEvent(handleBlur);
  const onDoubleClick = useEvent(handleDoubleClick2);
  reactExports.useLayoutEffect(() => {
    if (!isEditing || !tipTapConfig || !rTextEditorEl.current) return;
    const { editorProps, ...restOfTipTapConfig } = tipTapConfig;
    const textEditorInstance = new Editor2({
      element: rTextEditorEl.current,
      autofocus: true,
      editable: isEditing,
      onUpdate: (props) => {
        const content = props.editor.state.doc.toJSON();
        rInitialRichText.current = content;
        onChange({ richText: content });
      },
      onFocus,
      onBlur,
      // onCreate is called after a `setTimeout(0)`
      onCreate: (props) => {
        if (editor.getEditingShapeId() !== shapeId) return;
        const textEditor = props.editor;
        editor.setRichTextEditor(textEditor);
        const { selectAll: selectAll2, caretPosition } = rCreateInfo.current;
        if (selectAll2) {
          textEditor.chain().focus().selectAll().run();
        } else if (caretPosition) {
          const pos = textEditor.view.posAtCoords({
            left: caretPosition.x,
            top: caretPosition.y
          })?.pos;
          if (pos) {
            textEditor.chain().focus().setTextSelection(pos).run();
          } else {
            textEditor.chain().focus().selectAll().run();
          }
        }
      },
      editorProps: {
        handleKeyDown: (view, event) => {
          if (!hasCustomTabBehavior && event.key === "Tab") {
            handleTab(editor, view, event);
          }
          onKeyDown(event);
        },
        handleDoubleClick: (view, pos, event) => onDoubleClick(event),
        ...editorProps
      },
      coreExtensionOptions: {
        clipboardTextSerializer: {
          blockSeparator: "\n"
        }
      },
      ...restOfTipTapConfig,
      content: rInitialRichText.current
    });
    const timeout = editor.timers.setTimeout(() => {
      if (rCreateInfo.current.caretPosition || rCreateInfo.current.selectAll) {
        textEditorInstance.commands.focus();
      } else {
        textEditorInstance.commands.focus("end");
      }
      rCreateInfo.current.selectAll = false;
      rCreateInfo.current.caretPosition = null;
    }, 100);
    rTextEditor.current = textEditorInstance;
    return () => {
      rTextEditor.current = null;
      clearTimeout(timeout);
      textEditorInstance.destroy();
    };
  }, [
    isEditing,
    tipTapConfig,
    onFocus,
    onBlur,
    onDoubleClick,
    onChange,
    onKeyDown,
    editor,
    shapeId,
    hasCustomTabBehavior
  ]);
  if (!isEditing || !tipTapConfig) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      id: tipTapId,
      ref,
      tabIndex: -1,
      "data-testid": "rich-text-area",
      className: "tl-rich-text tl-text tl-text-input",
      onContextMenu: isEditing ? stopEventPropagation : void 0,
      onPointerDownCapture: stopEventPropagation,
      onTouchEnd: stopEventPropagation,
      onDragStart: preventDefault,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-rich-text", ref: rTextEditorEl })
    }
  );
});
function handleTab(editor, view, event) {
  event.preventDefault();
  const textEditor = editor.getRichTextEditor();
  if (textEditor?.isActive("bulletList") || textEditor?.isActive("orderedList")) return;
  const { state, dispatch: dispatch2 } = view;
  const { $from, $to } = state.selection;
  const isShift = event.shiftKey;
  let tr2 = state.tr;
  let pos = $to.end();
  while (pos >= $from.start()) {
    const line = state.doc.resolve(pos).blockRange();
    if (!line) break;
    const lineStart = line.start;
    const lineEnd = line.end;
    const lineText = state.doc.textBetween(lineStart, lineEnd, "\n");
    let isInList = false;
    state.doc.nodesBetween(lineStart, lineEnd, (node) => {
      if (node.type.name === "bulletList" || node.type.name === "orderedList") {
        isInList = true;
        return false;
      }
    });
    if (!isInList) {
      if (!isShift) {
        tr2 = tr2.insertText("	", lineStart + 1);
      } else {
        if (lineText.startsWith("	")) {
          tr2 = tr2.delete(lineStart + 1, lineStart + 2);
        }
      }
    }
    pos = lineStart - 1;
  }
  const mappedSelection = state.selection.map(tr2.doc, tr2.mapping);
  tr2.setSelection(mappedSelection);
  if (tr2.docChanged) {
    dispatch2(tr2);
  }
}
function useEditableRichText(shapeId, type, richText) {
  const commonUseEditableTextHandlers = useEditableTextCommon(shapeId);
  const isEditing = commonUseEditableTextHandlers.isEditing;
  const editor = useEditor();
  const rInput = reactExports.useRef(null);
  const isEmpty = richText && isEmptyRichText(richText);
  reactExports.useEffect(() => {
    if (!isEditing) return;
    const contentEditable = rInput.current?.querySelector("[contenteditable]");
    if (contentEditable && document.activeElement !== rInput.current) {
      contentEditable.focus();
    }
  }, [editor, isEditing]);
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, shapeId]
  );
  const handleChange = reactExports.useCallback(
    ({ richText: richText2 }) => {
      if (editor.getEditingShapeId() !== shapeId) return;
      editor.updateShape({
        id: shapeId,
        type,
        props: { richText: richText2 }
      });
    },
    [editor, shapeId, type]
  );
  return {
    rInput,
    handleKeyDown: handleKeyDown2,
    handleChange,
    isEmpty,
    ...commonUseEditableTextHandlers
  };
}
const RichTextLabel = React.memo(function RichTextLabel2({
  shapeId,
  type,
  richText,
  labelColor,
  font,
  fontSize,
  lineHeight,
  align,
  verticalAlign,
  wrap: wrap2,
  isSelected,
  padding = 0,
  onKeyDown: handleKeyDownCustom,
  classNamePrefix,
  style: style2,
  textWidth,
  textHeight,
  hasCustomTabBehavior
}) {
  const editor = useEditor();
  const isDragging = React.useRef(false);
  const { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } = useEditableRichText(shapeId, type, richText);
  const html2 = reactExports.useMemo(() => {
    if (richText) {
      return renderHtmlFromRichText(editor, richText);
    }
  }, [editor, richText]);
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  useReactor(
    "isDragging",
    () => {
      editor.getInstanceState();
      isDragging.current = editor.inputs.isDragging;
    },
    [editor]
  );
  const legacyAlign = isLegacyAlign(align);
  const handlePointerDown = (e) => {
    if (e.target instanceof HTMLElement && (e.target.tagName === "A" || e.target.closest("a"))) {
      preventDefault(e);
      if (!selectToolActive) return;
      const link = e.target.closest("a")?.getAttribute("href") ?? "";
      const handlePointerUp = (e2) => {
        if (e2.name !== "pointer_up") return;
        if (!isDragging.current) {
          window.open(link, "_blank", "noopener, noreferrer");
        }
        editor.off("event", handlePointerUp);
      };
      editor.on("event", handlePointerUp);
    }
  };
  if (!isEditing && isEmpty) return null;
  const cssPrefix = classNamePrefix || "tl-text";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `${cssPrefix}-label tl-text-wrapper tl-rich-text-wrapper`,
      "data-font": font,
      "data-align": align,
      "data-hastext": !isEmpty,
      "data-isediting": isEditing,
      "data-textwrap": !!wrap2,
      "data-isselected": isSelected,
      style: {
        justifyContent: align === "middle" || legacyAlign ? "center" : align,
        alignItems: verticalAlign === "middle" ? "center" : verticalAlign,
        padding,
        ...style2
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${cssPrefix}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize,
            lineHeight: Math.floor(fontSize * lineHeight) + "px",
            minHeight: Math.floor(fontSize * lineHeight) + "px",
            minWidth: Math.ceil(textWidth || 0),
            color: labelColor,
            width: textWidth ? Math.ceil(textWidth) : void 0,
            height: textHeight ? Math.ceil(textHeight) : void 0
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${cssPrefix} tl-text tl-text-content`, dir: "auto", children: richText && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "tl-rich-text",
                "data-is-select-tool-active": selectToolActive,
                dangerouslySetInnerHTML: { __html: html2 || "" },
                onPointerDown: handlePointerDown,
                "data-is-ready-for-editing": isReadyForEditing
              }
            ) }),
            (isReadyForEditing || isSelected) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              RichTextArea,
              {
                ref: rInput,
                richText,
                isEditing,
                shapeId,
                ...editableTextRest,
                hasCustomTabBehavior,
                handleKeyDown: handleKeyDownCustom ?? editableTextRest.handleKeyDown
              }
            )
          ]
        }
      )
    }
  );
});
function RichTextSVG({
  bounds,
  richText,
  fontSize,
  font,
  align,
  verticalAlign,
  wrap: wrap2,
  labelColor,
  padding
}) {
  const editor = useEditor();
  const html2 = renderHtmlFromRichText(editor, richText);
  const textAlign = align === "middle" ? "center" : align === "start" ? "start" : "end";
  const justifyContent = align === "middle" ? "center" : align === "start" ? "flex-start" : "flex-end";
  const alignItems = verticalAlign === "middle" ? "center" : verticalAlign === "start" ? "flex-start" : "flex-end";
  const wrapperStyle = {
    display: "flex",
    fontFamily: DefaultFontFamilies[font],
    height: `100%`,
    justifyContent,
    alignItems,
    padding: `${padding}px`
  };
  const style2 = {
    fontSize: `${fontSize}px`,
    wrap: wrap2 ? "wrap" : "nowrap",
    color: labelColor,
    lineHeight: TEXT_PROPS.lineHeight,
    textAlign,
    width: "100%",
    wordWrap: "break-word",
    overflowWrap: "break-word",
    whiteSpace: "pre-wrap"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "foreignObject",
    {
      x: bounds.minX,
      y: bounds.minY,
      width: bounds.w,
      height: bounds.h,
      className: "tl-export-embed-styles tl-rich-text tl-rich-text-svg",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: wrapperStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: html2 }, style: style2 }) })
    }
  );
}
function getOvalPerimeter(h, w) {
  if (h > w) return (PI$1 * (w / 2) + (h - w)) * 2;
  else return (PI$1 * (h / 2) + (w - h)) * 2;
}
function getHeartPath(w, h) {
  return getHeartParts(w, h).map((c2, i) => c2.getSvgPathData(i === 0)).join(" ") + " Z";
}
function getDrawHeartPath(w, h, sw, id) {
  const o2 = w / 4;
  const k = h / 4;
  const random = rng(id);
  const mutDistance = sw * 0.75;
  const mut = (v) => v.addXY(random() * mutDistance, random() * mutDistance);
  const A = new Vec(w / 2, h);
  const B = new Vec(0, k * 1.2);
  const C = new Vec(w / 2, k * 0.9);
  const D = new Vec(w, k * 1.2);
  const Am = mut(new Vec(w / 2, h));
  const Bm = mut(new Vec(0, k * 1.2));
  const Cm = mut(new Vec(w / 2, k * 0.9));
  const Dm = mut(new Vec(w, k * 1.2));
  const parts = [
    new CubicBezier2d({
      start: A,
      cp1: new Vec(o2 * 1.5, k * 3),
      cp2: new Vec(0, k * 2.5),
      end: B
    }),
    new CubicBezier2d({
      start: B,
      cp1: new Vec(0, -k * 0.32),
      cp2: new Vec(o2 * 1.85, -k * 0.32),
      end: C
    }),
    new CubicBezier2d({
      start: C,
      cp1: new Vec(o2 * 2.15, -k * 0.32),
      cp2: new Vec(w, -k * 0.32),
      end: D
    }),
    new CubicBezier2d({
      start: D,
      cp1: new Vec(w, k * 2.5),
      cp2: new Vec(o2 * 2.5, k * 3),
      end: Am
    }),
    new CubicBezier2d({
      start: Am,
      cp1: new Vec(o2 * 1.5, k * 3),
      cp2: new Vec(0, k * 2.5),
      end: Bm
    }),
    new CubicBezier2d({
      start: Bm,
      cp1: new Vec(0, -k * 0.32),
      cp2: new Vec(o2 * 1.85, -k * 0.32),
      end: Cm
    }),
    new CubicBezier2d({
      start: Cm,
      cp1: new Vec(o2 * 2.15, -k * 0.32),
      cp2: new Vec(w, -k * 0.32),
      end: Dm
    }),
    new CubicBezier2d({
      start: Dm,
      cp1: new Vec(w, k * 2.5),
      cp2: new Vec(o2 * 2.5, k * 3),
      end: A
    })
  ];
  return parts.map((c2, i) => c2.getSvgPathData(i === 0)).join(" ") + " Z";
}
function getHeartParts(w, h) {
  const o2 = w / 4;
  const k = h / 4;
  return [
    new CubicBezier2d({
      start: new Vec(w / 2, h),
      cp1: new Vec(o2 * 1.5, k * 3),
      cp2: new Vec(0, k * 2.5),
      end: new Vec(0, k * 1.2)
    }),
    new CubicBezier2d({
      start: new Vec(0, k * 1.2),
      cp1: new Vec(0, -k * 0.32),
      cp2: new Vec(o2 * 1.85, -k * 0.32),
      end: new Vec(w / 2, k * 0.9)
    }),
    new CubicBezier2d({
      start: new Vec(w / 2, k * 0.9),
      cp1: new Vec(o2 * 2.15, -k * 0.32),
      cp2: new Vec(w, -k * 0.32),
      end: new Vec(w, k * 1.2)
    }),
    new CubicBezier2d({
      start: new Vec(w, k * 1.2),
      cp1: new Vec(w, k * 2.5),
      cp2: new Vec(o2 * 2.5, k * 3),
      end: new Vec(w / 2, h)
    })
  ];
}
function getEllipseStrokeOptions(strokeWidth) {
  return {
    size: 1 + strokeWidth,
    thinning: 0.25,
    end: { taper: strokeWidth },
    start: { taper: strokeWidth },
    streamline: 0,
    smoothing: 1,
    simulatePressure: false
  };
}
function getEllipseStrokePoints(id, width, height, strokeWidth) {
  const getRandom = rng(id);
  const rx = width / 2;
  const ry = height / 2;
  const perimeter = perimeterOfEllipse(rx, ry);
  const points = [];
  const start = PI2 * getRandom();
  const length = PI2 + HALF_PI / 2 + Math.abs(getRandom()) * HALF_PI;
  const count2 = Math.max(16, perimeter / 10);
  for (let i = 0; i < count2; i++) {
    const t2 = i / (count2 - 1);
    const r2 = start + t2 * length;
    const c2 = Math.cos(r2);
    const s2 = Math.sin(r2);
    points.push(
      new Vec(
        rx * c2 + width * 0.5 + 0.05 * getRandom(),
        ry * s2 + height / 2 + 0.05 * getRandom(),
        Math.min(
          1,
          0.5 + Math.abs(0.5 - (getRandom() > 0 ? EASINGS.easeInOutSine(t2) : EASINGS.easeInExpo(t2))) / 2
        )
      )
    );
  }
  return getStrokePoints(points, getEllipseStrokeOptions(strokeWidth));
}
function getEllipseDrawIndicatorPath(id, width, height, strokeWidth) {
  return getSvgPathFromStrokePoints(getEllipseStrokePoints(id, width, height, strokeWidth));
}
function getRoundedInkyPolygonPath(points) {
  let polylineA = `M`;
  const len = points.length;
  let p0;
  let p1;
  let p2;
  for (let i = 0, n2 = len; i < n2; i += 3) {
    p0 = points[i];
    p1 = points[i + 1];
    p2 = points[i + 2];
    polylineA += `${precise(p0)}L${precise(p1)}Q${precise(p2)}`;
  }
  polylineA += `${precise(points[0])}`;
  return polylineA;
}
function getRoundedPolygonPoints(id, outline, offset2, roundness, passes) {
  const results = [];
  const random = rng(id);
  let p0 = outline[0];
  let p1;
  const len = outline.length;
  for (let i = 0, n2 = len * passes; i < n2; i++) {
    p1 = Vec.AddXY(outline[(i + 1) % len], random() * offset2, random() * offset2);
    const delta = Vec.Sub(p1, p0);
    const distance = Vec.Len(delta);
    const vector = Vec.Div(delta, distance).mul(Math.min(distance / 4, roundness));
    results.push(Vec.Add(p0, vector), Vec.Add(p1, vector.neg()), p1);
    p0 = p1;
  }
  return results;
}
function getPillPoints(width, height, numPoints) {
  const radius = Math.min(width, height) / 2;
  const longSide = Math.max(width, height) - radius * 2;
  const circumference = Math.PI * (radius * 2) + 2 * longSide;
  const spacing = circumference / numPoints;
  const sections = width > height ? [
    {
      type: "straight",
      start: new Vec(radius, 0),
      delta: new Vec(1, 0)
    },
    {
      type: "arc",
      center: new Vec(width - radius, radius),
      startAngle: -PI$1 / 2
    },
    {
      type: "straight",
      start: new Vec(width - radius, height),
      delta: new Vec(-1, 0)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI$1 / 2
    }
  ] : [
    {
      type: "straight",
      start: new Vec(width, radius),
      delta: new Vec(0, 1)
    },
    {
      type: "arc",
      center: new Vec(radius, height - radius),
      startAngle: 0
    },
    {
      type: "straight",
      start: new Vec(0, height - radius),
      delta: new Vec(0, -1)
    },
    {
      type: "arc",
      center: new Vec(radius, radius),
      startAngle: PI$1
    }
  ];
  let sectionOffset = 0;
  const points = [];
  for (let i = 0; i < numPoints; i++) {
    const section = sections[0];
    if (section.type === "straight") {
      points.push(Vec.Add(section.start, Vec.Mul(section.delta, sectionOffset)));
    } else {
      points.push(
        getPointOnCircle(section.center, radius, section.startAngle + sectionOffset / radius)
      );
    }
    sectionOffset += spacing;
    let sectionLength = section.type === "straight" ? longSide : PI$1 * radius;
    while (sectionOffset > sectionLength) {
      sectionOffset -= sectionLength;
      sections.push(sections.shift());
      sectionLength = sections[0].type === "straight" ? longSide : PI$1 * radius;
    }
  }
  return points;
}
const SIZES = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
};
const BUMP_PROTRUSION = 0.2;
function getCloudArcs(width, height, seed, size2, scale) {
  const getRandom = rng(seed);
  const pillCircumference = getOvalPerimeter(width, height);
  const numBumps = Math.max(
    Math.ceil(pillCircumference / SIZES[size2]),
    6,
    Math.ceil(pillCircumference / Math.min(width, height))
  );
  const targetBumpProtrusion = pillCircumference / numBumps * BUMP_PROTRUSION;
  const innerWidth = Math.max(width - targetBumpProtrusion * 2, 1);
  const innerHeight2 = Math.max(height - targetBumpProtrusion * 2, 1);
  const innerCircumference = getOvalPerimeter(innerWidth, innerHeight2);
  const distanceBetweenPointsOnPerimeter = innerCircumference / numBumps;
  const paddingX = (width - innerWidth) / 2;
  const paddingY = (height - innerHeight2) / 2;
  const bumpPoints = getPillPoints(innerWidth, innerHeight2, numBumps).map((p) => {
    return p.addXY(paddingX, paddingY);
  });
  const maxWiggleX = width < 20 ? 0 : targetBumpProtrusion * 0.3;
  const maxWiggleY = height < 20 ? 0 : targetBumpProtrusion * 0.3;
  const wiggledPoints = bumpPoints.slice(0);
  for (let i = 0; i < Math.floor(numBumps / 2); i++) {
    wiggledPoints[i] = Vec.AddXY(
      wiggledPoints[i],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
    wiggledPoints[numBumps - i - 1] = Vec.AddXY(
      wiggledPoints[numBumps - i - 1],
      getRandom() * maxWiggleX * scale,
      getRandom() * maxWiggleY * scale
    );
  }
  const arcs = [];
  for (let i = 0; i < wiggledPoints.length; i++) {
    const j = i === wiggledPoints.length - 1 ? 0 : i + 1;
    const leftWigglePoint = wiggledPoints[i];
    const rightWigglePoint = wiggledPoints[j];
    const leftPoint = bumpPoints[i];
    const rightPoint = bumpPoints[j];
    const distanceBetweenOriginalPoints = Vec.Dist(leftPoint, rightPoint);
    const curvatureOffset = distanceBetweenPointsOnPerimeter - distanceBetweenOriginalPoints;
    const distanceBetweenWigglePoints = Vec.Dist(leftWigglePoint, rightWigglePoint);
    const relativeSize = distanceBetweenWigglePoints / distanceBetweenOriginalPoints;
    const finalDistance = (Math.max(paddingX, paddingY) + curvatureOffset) * relativeSize;
    const arcPoint = Vec.Lrp(leftPoint, rightPoint, 0.5).add(
      Vec.Sub(rightPoint, leftPoint).uni().per().mul(finalDistance)
    );
    if (arcPoint.x < 0) {
      arcPoint.x = 0;
    } else if (arcPoint.x > width) {
      arcPoint.x = width;
    }
    if (arcPoint.y < 0) {
      arcPoint.y = 0;
    } else if (arcPoint.y > height) {
      arcPoint.y = height;
    }
    const center = centerOfCircleFromThreePoints(leftWigglePoint, rightWigglePoint, arcPoint);
    const radius = Vec.Dist(
      center ? center : Vec.Average([leftWigglePoint, rightWigglePoint]),
      leftWigglePoint
    );
    arcs.push({
      leftPoint: leftWigglePoint,
      rightPoint: rightWigglePoint,
      arcPoint,
      center,
      radius
    });
  }
  return arcs;
}
function cloudOutline(width, height, seed, size2, scale) {
  const path = [];
  const arcs = getCloudArcs(width, height, seed, size2, scale);
  for (const { center, radius, leftPoint, rightPoint } of arcs) {
    path.push(...getPointsOnArc(leftPoint, rightPoint, center, radius, 10));
  }
  return path;
}
function getCloudPath(width, height, seed, size2, scale) {
  const arcs = getCloudArcs(width, height, seed, size2, scale);
  let path = `M${arcs[0].leftPoint.toFixed()}`;
  for (const { leftPoint, rightPoint, radius, center } of arcs) {
    if (center === null) {
      path += ` L${rightPoint.toFixed()}`;
      continue;
    }
    const arc = Vec.Clockwise(leftPoint, rightPoint, center) ? "0" : "1";
    path += ` A${toDomPrecision(radius)},${toDomPrecision(radius)} 0 ${arc},1 ${rightPoint.toFixed()}`;
  }
  path += " Z";
  return path;
}
const DRAW_OFFSETS = {
  s: 0.5,
  m: 0.7,
  l: 0.9,
  xl: 1.6
};
function inkyCloudSvgPath(width, height, seed, size2, scale) {
  const getRandom = rng(seed);
  const mutMultiplier = DRAW_OFFSETS[size2] * scale;
  const arcs = getCloudArcs(width, height, seed, size2, scale);
  const avgArcLengthSquared = arcs.reduce((sum, arc) => sum + Vec.Dist2(arc.leftPoint, arc.rightPoint), 0) / arcs.length;
  const shouldMutatePoints = avgArcLengthSquared > (mutMultiplier * 15) ** 2;
  const mutPoint = shouldMutatePoints ? (p) => Vec.AddXY(p, getRandom() * mutMultiplier * 2, getRandom() * mutMultiplier * 2) : (p) => p;
  let pathA = `M${arcs[0].leftPoint.toFixed()}`;
  let leftMutPoint = mutPoint(arcs[0].leftPoint);
  let pathB = `M${leftMutPoint.toFixed()}`;
  for (const { leftPoint, center, rightPoint, radius, arcPoint } of arcs) {
    if (center === null) {
      pathA += ` L${rightPoint.toFixed()}`;
      const rightMutPoint2 = mutPoint(rightPoint);
      pathB += ` L${rightMutPoint2.toFixed()}`;
      leftMutPoint = rightMutPoint2;
      continue;
    }
    const arc = Vec.Clockwise(leftPoint, rightPoint, center) ? "0" : "1";
    pathA += ` A${toDomPrecision(radius)},${toDomPrecision(radius)} 0 ${arc},1 ${rightPoint.toFixed()}`;
    const rightMutPoint = mutPoint(rightPoint);
    const mutArcPoint = mutPoint(arcPoint);
    const mutCenter = centerOfCircleFromThreePoints(leftMutPoint, rightMutPoint, mutArcPoint);
    if (!mutCenter) {
      pathB += ` L${rightMutPoint.toFixed()}`;
      leftMutPoint = rightMutPoint;
      continue;
    }
    const mutRadius = Math.abs(Vec.Dist(mutCenter, leftMutPoint));
    pathB += ` A${toDomPrecision(mutRadius)},${toDomPrecision(
      mutRadius
    )} 0 ${arc},1 ${rightMutPoint.toFixed()}`;
    leftMutPoint = rightMutPoint;
  }
  return pathA + pathB + " Z";
}
function getLines(props, sw) {
  switch (props.geo) {
    case "x-box": {
      return getXBoxLines(props.w, props.h, sw, props.dash);
    }
    case "check-box": {
      return getCheckBoxLines(props.w, props.h);
    }
    default: {
      return void 0;
    }
  }
}
function getXBoxLines(w, h, sw, dash) {
  const inset = dash === "draw" ? 0.62 : 0;
  if (dash === "dashed") {
    return [
      [new Vec(0, 0), new Vec(w / 2, h / 2)],
      [new Vec(w, h), new Vec(w / 2, h / 2)],
      [new Vec(0, h), new Vec(w / 2, h / 2)],
      [new Vec(w, 0), new Vec(w / 2, h / 2)]
    ];
  }
  const clampX = (x) => Math.max(0, Math.min(w, x));
  const clampY = (y2) => Math.max(0, Math.min(h, y2));
  return [
    [
      new Vec(clampX(sw * inset), clampY(sw * inset)),
      new Vec(clampX(w - sw * inset), clampY(h - sw * inset))
    ],
    [
      new Vec(clampX(sw * inset), clampY(h - sw * inset)),
      new Vec(clampX(w - sw * inset), clampY(sw * inset))
    ]
  ];
}
function getCheckBoxLines(w, h) {
  const size2 = Math.min(w, h) * 0.82;
  const ox = (w - size2) / 2;
  const oy = (h - size2) / 2;
  const clampX = (x) => Math.max(0, Math.min(w, x));
  const clampY = (y2) => Math.max(0, Math.min(h, y2));
  return [
    [
      new Vec(clampX(ox + size2 * 0.25), clampY(oy + size2 * 0.52)),
      new Vec(clampX(ox + size2 * 0.45), clampY(oy + size2 * 0.82))
    ],
    [
      new Vec(clampX(ox + size2 * 0.45), clampY(oy + size2 * 0.82)),
      new Vec(clampX(ox + size2 * 0.82), clampY(oy + size2 * 0.22))
    ]
  ];
}
function GeoShapeBody({
  shape,
  shouldScale,
  forceSolid
}) {
  const scaleToUse = shouldScale ? shape.props.scale : 1;
  const editor = useEditor();
  const theme = useDefaultColorTheme();
  const { id, props } = shape;
  const { w, color, fill, dash, growY, size: size2, scale } = props;
  const strokeWidth = STROKE_SIZES[size2] * scaleToUse;
  const h = props.h + growY;
  switch (props.geo) {
    case "cloud": {
      if (dash === "solid") {
        const d = getCloudPath(w, h, id, size2, scale);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      } else if (dash === "draw") {
        const d = inkyCloudSvgPath(w, h, id, size2, scale);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      } else {
        const d = getCloudPath(w, h, id, size2, scale);
        const arcs = getCloudArcs(w, h, id, size2, scale);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "g",
            {
              strokeWidth,
              stroke: theme[color].solid,
              fill: "none",
              pointerEvents: "all",
              children: arcs.map(({ leftPoint, rightPoint, center, radius }, i) => {
                const arcLength = center ? radius * canonicalizeRotation(
                  canonicalizeRotation(Vec.Angle(center, rightPoint)) - canonicalizeRotation(Vec.Angle(center, leftPoint))
                ) : Vec.Dist(leftPoint, rightPoint);
                const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                  arcLength,
                  strokeWidth,
                  {
                    style: dash,
                    start: "outset",
                    end: "outset",
                    forceSolid
                  }
                );
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: center ? `M${leftPoint.x},${leftPoint.y}A${radius},${radius},0,0,1,${rightPoint.x},${rightPoint.y}` : `M${leftPoint.x},${leftPoint.y}L${rightPoint.x},${rightPoint.y}`,
                    strokeDasharray,
                    strokeDashoffset
                  },
                  i
                );
              })
            }
          )
        ] });
      }
    }
    case "ellipse": {
      const geometry = shouldScale ? (
        // cached
        editor.getShapeGeometry(shape)
      ) : (
        // not cached
        editor.getShapeUtil(shape).getGeometry(shape)
      );
      const d = geometry.getSvgPathData(true);
      if (dash === "dashed" || dash === "dotted") {
        const perimeter = geometry.length;
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          perimeter < 64 ? perimeter * 2 : perimeter,
          strokeWidth,
          {
            style: dash,
            snap: 4,
            closed: true,
            forceSolid
          }
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d,
              strokeWidth,
              fill: "none",
              stroke: theme[color].solid,
              strokeDasharray,
              strokeDashoffset
            }
          )
        ] });
      } else {
        const geometry2 = shouldScale ? (
          // cached
          editor.getShapeGeometry(shape)
        ) : (
          // not cached
          editor.getShapeUtil(shape).getGeometry(shape)
        );
        const d2 = geometry2.getSvgPathData(true);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d: d2, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: d2, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
    case "oval": {
      const geometry = shouldScale ? (
        // cached
        editor.getShapeGeometry(shape)
      ) : (
        // not cached
        editor.getShapeUtil(shape).getGeometry(shape)
      );
      const d = geometry.getSvgPathData(true);
      if (dash === "dashed" || dash === "dotted") {
        const perimeter = geometry.getLength();
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          perimeter < 64 ? perimeter * 2 : perimeter,
          strokeWidth,
          {
            style: dash,
            snap: 4,
            start: "outset",
            end: "outset",
            closed: true,
            forceSolid
          }
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              d,
              strokeWidth,
              fill: "none",
              stroke: theme[color].solid,
              strokeDasharray,
              strokeDashoffset
            }
          )
        ] });
      } else {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
    case "heart": {
      if (dash === "dashed" || dash === "dotted" || dash === "solid") {
        const d = getHeartPath(w, h);
        const curves = getHeartParts(w, h);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          curves.map((c2, i) => {
            const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
              c2.length,
              strokeWidth,
              {
                style: dash,
                snap: 1,
                start: "outset",
                end: "outset",
                closed: true,
                forceSolid
              }
            );
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: c2.getSvgPathData(),
                strokeWidth,
                fill: "none",
                stroke: theme[color].solid,
                strokeDasharray,
                strokeDashoffset,
                pointerEvents: "all"
              },
              `curve_${i}`
            );
          })
        ] });
      } else {
        const d = getDrawHeartPath(w, h, strokeWidth, shape.id);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
    default: {
      const geometry = shouldScale ? (
        // cached
        editor.getShapeGeometry(shape)
      ) : (
        // not cached
        editor.getShapeUtil(shape).getGeometry(shape)
      );
      const outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices;
      const lines = getLines(shape.props, strokeWidth);
      if (dash === "solid") {
        let d = "M" + outline[0] + "L" + outline.slice(1) + "Z";
        if (lines) {
          for (const [A, B] of lines) {
            d += `M${A.x},${A.y}L${B.x},${B.y}`;
          }
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      } else if (dash === "dashed" || dash === "dotted") {
        const d = "M" + outline[0] + "L" + outline.slice(1) + "Z";
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ShapeFill, { theme, d, color, fill, scale: scaleToUse }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "g",
            {
              strokeWidth,
              stroke: theme[color].solid,
              fill: "none",
              pointerEvents: "all",
              children: [
                Array.from(Array(outline.length)).map((_, i) => {
                  const A = Vec.ToFixed(outline[i]);
                  const B = Vec.ToFixed(outline[(i + 1) % outline.length]);
                  const dist = Vec.Dist(A, B);
                  const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                    dist,
                    strokeWidth,
                    {
                      style: dash,
                      start: "outset",
                      end: "outset",
                      forceSolid
                    }
                  );
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "line",
                    {
                      x1: A.x,
                      y1: A.y,
                      x2: B.x,
                      y2: B.y,
                      strokeDasharray,
                      strokeDashoffset
                    },
                    i
                  );
                }),
                lines && lines.map(([A, B], i) => {
                  const dist = Vec.Dist(A, B);
                  const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                    dist,
                    strokeWidth,
                    {
                      style: dash,
                      start: "skip",
                      end: "skip",
                      snap: dash === "dotted" ? 4 : void 0,
                      forceSolid
                    }
                  );
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: `M${A.x},${A.y}L${B.x},${B.y}`,
                      stroke: theme[color].solid,
                      strokeWidth,
                      fill: "none",
                      strokeDasharray,
                      strokeDashoffset
                    },
                    `line_fg_${i}`
                  );
                })
              ]
            }
          )
        ] });
      } else if (dash === "draw") {
        let d = getRoundedInkyPolygonPath(
          getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2)
        );
        if (lines) {
          for (const [A, B] of lines) {
            d += `M${A.toFixed()}L${B.toFixed()}`;
          }
        }
        const innerPathData = getRoundedInkyPolygonPath(
          getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ShapeFill,
            {
              theme,
              d: innerPathData,
              color,
              fill,
              scale: scaleToUse
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d, stroke: theme[color].solid, strokeWidth, fill: "none" })
        ] });
      }
    }
  }
}
const MIN_SIZE_WITH_LABEL = 17 * 3;
class GeoShapeUtil extends BaseBoxShapeUtil {
  static type = "geo";
  static props = geoShapeProps;
  static migrations = geoShapeMigrations;
  canEdit() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      url: "",
      scale: 1,
      richText: toRichText("")
    };
  }
  getGeometry(shape) {
    const w = Math.max(1, shape.props.w);
    const h = Math.max(1, shape.props.h + shape.props.growY);
    const cx = w / 2;
    const cy = h / 2;
    const isFilled = shape.props.fill !== "none";
    let body;
    switch (shape.props.geo) {
      case "cloud": {
        body = new Polygon2d({
          points: cloudOutline(w, h, shape.id, shape.props.size, shape.props.scale),
          isFilled
        });
        break;
      }
      case "triangle": {
        body = new Polygon2d({
          points: [new Vec(cx, 0), new Vec(w, h), new Vec(0, h)],
          isFilled
        });
        break;
      }
      case "diamond": {
        body = new Polygon2d({
          points: [new Vec(cx, 0), new Vec(w, cy), new Vec(cx, h), new Vec(0, cy)],
          isFilled
        });
        break;
      }
      case "pentagon": {
        body = new Polygon2d({
          points: getPolygonVertices(w, h, 5),
          isFilled
        });
        break;
      }
      case "hexagon": {
        body = new Polygon2d({
          points: getPolygonVertices(w, h, 6),
          isFilled
        });
        break;
      }
      case "octagon": {
        body = new Polygon2d({
          points: getPolygonVertices(w, h, 8),
          isFilled
        });
        break;
      }
      case "ellipse": {
        body = new Ellipse2d({
          width: w,
          height: h,
          isFilled
        });
        break;
      }
      case "oval": {
        body = new Stadium2d({
          width: w,
          height: h,
          isFilled
        });
        break;
      }
      case "star": {
        const sides2 = 5;
        const step = PI2 / sides2 / 2;
        const rightMostIndex = Math.floor(sides2 / 4) * 2;
        const leftMostIndex = sides2 * 2 - rightMostIndex;
        const topMostIndex = 0;
        const bottomMostIndex = Math.floor(sides2 / 2) * 2;
        const maxX = Math.cos(-HALF_PI + rightMostIndex * step) * w / 2;
        const minX = Math.cos(-HALF_PI + leftMostIndex * step) * w / 2;
        const minY = Math.sin(-HALF_PI + topMostIndex * step) * h / 2;
        const maxY = Math.sin(-HALF_PI + bottomMostIndex * step) * h / 2;
        const diffX = w - Math.abs(maxX - minX);
        const diffY = h - Math.abs(maxY - minY);
        const offsetX = w / 2 + minX - (w / 2 - maxX);
        const offsetY = h / 2 + minY - (h / 2 - maxY);
        const ratio = 1;
        const cx2 = (w - offsetX) / 2;
        const cy2 = (h - offsetY) / 2;
        const ox = (w + diffX) / 2;
        const oy = (h + diffY) / 2;
        const ix = ox * ratio / 2;
        const iy = oy * ratio / 2;
        body = new Polygon2d({
          points: Array.from(Array(sides2 * 2)).map((_, i) => {
            const theta = -HALF_PI + i * step;
            return new Vec(
              cx2 + (i % 2 ? ix : ox) * Math.cos(theta),
              cy2 + (i % 2 ? iy : oy) * Math.sin(theta)
            );
          }),
          isFilled
        });
        break;
      }
      case "rhombus": {
        const offset2 = Math.min(w * 0.38, h * 0.38);
        body = new Polygon2d({
          points: [new Vec(offset2, 0), new Vec(w, 0), new Vec(w - offset2, h), new Vec(0, h)],
          isFilled
        });
        break;
      }
      case "rhombus-2": {
        const offset2 = Math.min(w * 0.38, h * 0.38);
        body = new Polygon2d({
          points: [new Vec(0, 0), new Vec(w - offset2, 0), new Vec(w, h), new Vec(offset2, h)],
          isFilled
        });
        break;
      }
      case "trapezoid": {
        const offset2 = Math.min(w * 0.38, h * 0.38);
        body = new Polygon2d({
          points: [new Vec(offset2, 0), new Vec(w - offset2, 0), new Vec(w, h), new Vec(0, h)],
          isFilled
        });
        break;
      }
      case "arrow-right": {
        const ox = Math.min(w, h) * 0.38;
        const oy = h * 0.16;
        body = new Polygon2d({
          points: [
            new Vec(0, oy),
            new Vec(w - ox, oy),
            new Vec(w - ox, 0),
            new Vec(w, h / 2),
            new Vec(w - ox, h),
            new Vec(w - ox, h - oy),
            new Vec(0, h - oy)
          ],
          isFilled
        });
        break;
      }
      case "arrow-left": {
        const ox = Math.min(w, h) * 0.38;
        const oy = h * 0.16;
        body = new Polygon2d({
          points: [
            new Vec(ox, 0),
            new Vec(ox, oy),
            new Vec(w, oy),
            new Vec(w, h - oy),
            new Vec(ox, h - oy),
            new Vec(ox, h),
            new Vec(0, h / 2)
          ],
          isFilled
        });
        break;
      }
      case "arrow-up": {
        const ox = w * 0.16;
        const oy = Math.min(w, h) * 0.38;
        body = new Polygon2d({
          points: [
            new Vec(w / 2, 0),
            new Vec(w, oy),
            new Vec(w - ox, oy),
            new Vec(w - ox, h),
            new Vec(ox, h),
            new Vec(ox, oy),
            new Vec(0, oy)
          ],
          isFilled
        });
        break;
      }
      case "arrow-down": {
        const ox = w * 0.16;
        const oy = Math.min(w, h) * 0.38;
        body = new Polygon2d({
          points: [
            new Vec(ox, 0),
            new Vec(w - ox, 0),
            new Vec(w - ox, h - oy),
            new Vec(w, h - oy),
            new Vec(w / 2, h),
            new Vec(0, h - oy),
            new Vec(ox, h - oy)
          ],
          isFilled
        });
        break;
      }
      case "check-box":
      case "x-box":
      case "rectangle": {
        body = new Rectangle2d({
          width: w,
          height: h,
          isFilled
        });
        break;
      }
      case "heart": {
        const parts = getHeartParts(w, h);
        const points = parts.reduce((acc, part) => {
          acc.push(...part.vertices);
          return acc;
        }, []);
        body = new Polygon2d({
          points,
          isFilled
        });
        break;
      }
      default: {
        exhaustiveSwitchError$1(shape.props.geo);
      }
    }
    const unscaledlabelSize = getUnscaledLabelSize(this.editor, shape);
    const unscaledW = w / shape.props.scale;
    const unscaledH = h / shape.props.scale;
    const unscaledminWidth = Math.min(100, unscaledW / 2);
    const unscaledMinHeight = Math.min(
      LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,
      unscaledH / 2
    );
    const unscaledLabelWidth = Math.min(
      unscaledW,
      Math.max(unscaledlabelSize.w, Math.min(unscaledminWidth, Math.max(1, unscaledW - 8)))
    );
    const unscaledLabelHeight = Math.min(
      unscaledH,
      Math.max(unscaledlabelSize.h, Math.min(unscaledMinHeight, Math.max(1, unscaledH - 8)))
    );
    const lines = getLines(shape.props, STROKE_SIZES[shape.props.size] * shape.props.scale);
    const edges = lines ? lines.map((line) => new Polyline2d({ points: line, isInternal: true })) : [];
    return new Group2d({
      children: [
        body,
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? (unscaledW - unscaledLabelWidth) * shape.props.scale : (unscaledW - unscaledLabelWidth) / 2 * shape.props.scale,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? (unscaledH - unscaledLabelHeight) * shape.props.scale : (unscaledH - unscaledLabelHeight) / 2 * shape.props.scale,
          width: unscaledLabelWidth * shape.props.scale,
          height: unscaledLabelHeight * shape.props.scale,
          isFilled: true,
          isLabel: true
        }),
        ...edges
      ]
    });
  }
  getHandleSnapGeometry(shape) {
    const geometry = this.getGeometry(shape);
    const outline = geometry.children[0];
    switch (shape.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline, points: [...outline.vertices, geometry.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline, points: [geometry.bounds.center] };
      default:
        exhaustiveSwitchError$1(shape.props.geo);
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const { id, type, props } = shape;
    const { fill, font, align, verticalAlign, size: size2, richText } = props;
    const theme = useDefaultColorTheme();
    const { editor } = this;
    const isOnlySelected = useValue(
      "isGeoOnlySelected",
      () => shape.id === editor.getOnlySelectedShapeId(),
      [editor]
    );
    const isReadyForEditing = useIsReadyForEditing(editor, shape.id);
    const isEmpty = isEmptyRichText(shape.props.richText);
    const showHtmlContainer = isReadyForEditing || !isEmpty;
    const isForceSolid = useValue("force solid", () => editor.getZoomLevel() < 0.2, [editor]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeoShapeBody, { shape, shouldScale: true, forceSolid: isForceSolid }) }),
      showHtmlContainer && /* @__PURE__ */ jsxRuntimeExports.jsx(
        HTMLContainer,
        {
          style: {
            overflow: "hidden",
            width: shape.props.w,
            height: shape.props.h + props.growY
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: LABEL_FONT_SIZES[size2] * shape.props.scale,
              lineHeight: TEXT_PROPS.lineHeight,
              padding: LABEL_PADDING * shape.props.scale,
              fill,
              align,
              verticalAlign,
              richText,
              isSelected: isOnlySelected,
              labelColor: theme[props.labelColor].solid,
              wrap: true
            }
          )
        }
      ),
      shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const geometry = this.editor.getShapeGeometry(shape);
    const isZoomedOut = useValue("isZoomedOut", () => this.editor.getZoomLevel() < 0.25, [
      this.editor
    ]);
    const path = getIndicatorPath(shape, geometry, isZoomedOut);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: path });
  }
  toSvg(shape, ctx) {
    const newShape = {
      ...shape,
      props: {
        ...shape.props,
        w: shape.props.w / shape.props.scale,
        h: shape.props.h / shape.props.scale
      }
    };
    const props = newShape.props;
    ctx.addExportDef(getFillDefForExport(props.fill));
    let textEl;
    if (!isEmptyRichText(props.richText)) {
      const theme = getDefaultColorTheme(ctx);
      const bounds = new Box(0, 0, props.w, props.h + props.growY);
      textEl = /* @__PURE__ */ jsxRuntimeExports.jsx(
        RichTextSVG,
        {
          fontSize: LABEL_FONT_SIZES[props.size],
          font: props.font,
          align: props.align,
          verticalAlign: props.verticalAlign,
          richText: props.richText,
          labelColor: theme[props.labelColor].solid,
          bounds,
          padding: LABEL_PADDING * shape.props.scale
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GeoShapeBody, { shouldScale: false, shape: newShape, forceSolid: false }),
      textEl
    ] });
  }
  getCanvasSvgDefs() {
    return [getFillDefForCanvas()];
  }
  onResize(shape, { handle, newPoint, scaleX, scaleY, initialShape }) {
    const unscaledInitialW = initialShape.props.w / initialShape.props.scale;
    const unscaledInitialH = initialShape.props.h / initialShape.props.scale;
    const unscaledGrowY = initialShape.props.growY / initialShape.props.scale;
    let unscaledW = unscaledInitialW * scaleX;
    let unscaledH = (unscaledInitialH + unscaledGrowY) * scaleY;
    let overShrinkX = 0;
    let overShrinkY = 0;
    const min2 = MIN_SIZE_WITH_LABEL;
    if (!isEmptyRichText(shape.props.richText)) {
      let newW = Math.max(Math.abs(unscaledW), min2);
      let newH = Math.max(Math.abs(unscaledH), min2);
      if (newW < min2 && newH === min2) newW = min2;
      if (newW === min2 && newH < min2) newH = min2;
      const unscaledLabelSize = getUnscaledLabelSize(this.editor, {
        ...shape,
        props: {
          ...shape.props,
          w: newW * shape.props.scale,
          h: newH * shape.props.scale
        }
      });
      const nextW = Math.max(Math.abs(unscaledW), unscaledLabelSize.w) * Math.sign(unscaledW);
      const nextH = Math.max(Math.abs(unscaledH), unscaledLabelSize.h) * Math.sign(unscaledH);
      overShrinkX = Math.abs(nextW) - Math.abs(unscaledW);
      overShrinkY = Math.abs(nextH) - Math.abs(unscaledH);
      unscaledW = nextW;
      unscaledH = nextH;
    }
    const scaledW = unscaledW * shape.props.scale;
    const scaledH = unscaledH * shape.props.scale;
    const offset2 = new Vec(0, 0);
    if (scaleX < 0) {
      offset2.x += scaledW;
    }
    if (handle === "left" || handle === "top_left" || handle === "bottom_left") {
      offset2.x += scaleX < 0 ? overShrinkX : -overShrinkX;
    }
    if (scaleY < 0) {
      offset2.y += scaledH;
    }
    if (handle === "top" || handle === "top_left" || handle === "top_right") {
      offset2.y += scaleY < 0 ? overShrinkY : -overShrinkY;
    }
    const { x, y: y2 } = offset2.rot(shape.rotation).add(newPoint);
    return {
      x,
      y: y2,
      props: {
        w: Math.max(Math.abs(scaledW), 1),
        h: Math.max(Math.abs(scaledH), 1),
        growY: 0
      }
    };
  }
  onBeforeCreate(shape) {
    if (isEmptyRichText(shape.props.richText)) {
      if (shape.props.growY) {
        return {
          ...shape,
          props: {
            ...shape.props,
            growY: 0
          }
        };
      } else {
        return;
      }
    }
    const unscaledPrevHeight = shape.props.h / shape.props.scale;
    const unscaledNextHeight = getUnscaledLabelSize(this.editor, shape).h;
    let growY = null;
    if (unscaledNextHeight > unscaledPrevHeight) {
      growY = unscaledNextHeight - unscaledPrevHeight;
    } else {
      if (shape.props.growY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      return {
        ...shape,
        props: {
          ...shape.props,
          // scale the growY
          growY: growY * shape.props.scale
        }
      };
    }
  }
  onBeforeUpdate(prev, next) {
    if (isEqual(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    const wasEmpty = isEmptyRichText(prev.props.richText);
    const isEmpty = isEmptyRichText(next.props.richText);
    if (!wasEmpty && isEmpty) {
      return {
        ...next,
        props: {
          ...next.props,
          growY: 0
        }
      };
    }
    const unscaledPrevWidth = prev.props.w / prev.props.scale;
    const unscaledPrevHeight = prev.props.h / prev.props.scale;
    const unscaledPrevGrowY = prev.props.growY / prev.props.scale;
    const unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next);
    if (wasEmpty && !isEmpty && renderPlaintextFromRichText(this.editor, next.props.richText)) {
      let unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w);
      let unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h);
      const min2 = MIN_SIZE_WITH_LABEL;
      if (unscaledPrevWidth < min2 && unscaledPrevHeight < min2) {
        unscaledW = Math.max(unscaledW, min2);
        unscaledH = Math.max(unscaledH, min2);
        unscaledW = Math.max(unscaledW, unscaledH);
        unscaledH = Math.max(unscaledW, unscaledH);
      }
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          w: unscaledW * next.props.scale,
          h: unscaledH * next.props.scale,
          growY: 0
        }
      };
    }
    let growY = null;
    if (unscaledNextLabelSize.h > unscaledPrevHeight) {
      growY = unscaledNextLabelSize.h - unscaledPrevHeight;
    } else {
      if (unscaledPrevGrowY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      const unscaledNextWidth = next.props.w / next.props.scale;
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          growY: growY * next.props.scale,
          w: Math.max(unscaledNextWidth, unscaledNextLabelSize.w) * next.props.scale
        }
      };
    }
    if (unscaledNextLabelSize.w > unscaledPrevWidth) {
      return {
        ...next,
        props: {
          ...next.props,
          // Scale the results
          w: unscaledNextLabelSize.w * next.props.scale
        }
      };
    }
  }
  onDoubleClick(shape) {
    if (this.editor.inputs.altKey) {
      switch (shape.props.geo) {
        case "rectangle": {
          return {
            ...shape,
            props: {
              geo: "check-box"
            }
          };
        }
        case "check-box": {
          return {
            ...shape,
            props: {
              geo: "rectangle"
            }
          };
        }
      }
    }
    return;
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getUnscaledLabelSize(editor, shape) {
  const { richText, font, size: size2, w } = shape.props;
  if (!richText || isEmptyRichText(richText)) {
    return { w: 0, h: 0 };
  }
  const minSize = editor.textMeasure.measureText("w", {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize: LABEL_FONT_SIZES[size2],
    maxWidth: 100
    // ?
  });
  const sizes = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  };
  const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
  const textSize = editor.textMeasure.measureHtml(html2, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize: LABEL_FONT_SIZES[size2],
    minWidth: minSize.w,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(minSize.w + sizes[size2]),
      // The actual text size
      Math.ceil(w / shape.props.scale - LABEL_PADDING * 2)
    )
  });
  return {
    w: textSize.w + LABEL_PADDING * 2,
    h: textSize.h + LABEL_PADDING * 2
  };
}
function getIndicatorPath(shape, geometry, isZoomedOut) {
  const { id } = shape;
  const { w, size: size2, geo, dash, scale, growY } = shape.props;
  const strokeWidth = STROKE_SIZES[size2];
  const h = shape.props.h + growY;
  switch (geo) {
    case "ellipse": {
      if (dash === "draw") {
        return getEllipseDrawIndicatorPath(id, w, h, strokeWidth);
      }
      return geometry.getSvgPathData(true);
    }
    case "heart": {
      return getHeartPath(w, h);
    }
    case "oval": {
      return geometry.getSvgPathData(true);
    }
    case "cloud": {
      return getCloudPath(w, h, id, size2, shape.props.scale);
    }
    default: {
      const outline = geometry instanceof Group2d ? geometry.children[0].vertices : geometry.vertices;
      let path;
      if (dash === "draw" && !isZoomedOut) {
        const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2 * scale, 1);
        path = getRoundedInkyPolygonPath(polygonPoints);
      } else {
        path = "M" + outline[0] + "L" + outline.slice(1) + "Z";
      }
      const lines = getLines(shape.props, strokeWidth);
      if (lines) {
        for (const [A, B] of lines) {
          path += `M${A.x},${A.y}L${B.x},${B.y}`;
        }
      }
      return path;
    }
  }
}
function useColorSpace() {
  const [supportsP3, setSupportsP3] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const supportsSyntax = CSS.supports("color", "color(display-p3 1 1 1)");
    const query = matchMedia("(color-gamut: p3)");
    setSupportsP3(supportsSyntax && query.matches);
    const onChange = () => setSupportsP3(supportsSyntax && query.matches);
    query.addEventListener("change", onChange);
    return () => query.removeEventListener("change", onChange);
  }, []);
  const forceSrgb = useValue(debugFlags.forceSrgb);
  return forceSrgb || !supportsP3 ? "srgb" : "p3";
}
class HighlightShapeUtil extends ShapeUtil {
  static type = "highlight";
  static props = highlightShapeProps;
  static migrations = highlightShapeMigrations;
  options = {
    maxPointsPerShape: 600,
    underlayOpacity: 0.82,
    overlayOpacity: 0.35
  };
  canTabTo() {
    return false;
  }
  hideResizeHandles(shape) {
    return getIsDot(shape);
  }
  hideRotateHandle(shape) {
    return getIsDot(shape);
  }
  hideSelectionBoundsFg(shape) {
    return getIsDot(shape);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: false,
      isPen: false,
      scale: 1
    };
  }
  getGeometry(shape) {
    const strokeWidth = getStrokeWidth(shape);
    if (getIsDot(shape)) {
      return new Circle2d({
        x: -strokeWidth / 2,
        y: -strokeWidth / 2,
        radius: strokeWidth / 2,
        isFilled: true
      });
    }
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, true);
    const opts = getHighlightFreehandSettings({ strokeWidth: sw, showAsComplete: true });
    setStrokePointRadii(strokePoints, opts);
    return new Polygon2d({
      points: getStrokeOutlinePoints(strokePoints, opts),
      isFilled: true
    });
  }
  component(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  backgroundComponent(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        shape,
        forceSolid,
        strokeWidth,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  indicator(shape) {
    const forceSolid = useHighlightForceSolid(this.editor, shape);
    const strokeWidth = getStrokeWidth(shape);
    const { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, forceSolid);
    const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
    let strokePath;
    if (strokePoints.length < 2) {
      strokePath = getIndicatorDot(allPointsFromSegments[0], sw);
    } else {
      strokePath = getSvgPathFromStrokePoints(strokePoints, false);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: strokePath });
  }
  toSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(${scaleFactor})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.overlayOpacity
      }
    ) });
  }
  toBackgroundSvg(shape) {
    const strokeWidth = getStrokeWidth(shape);
    const forceSolid = strokeWidth < 1.5;
    const scaleFactor = 1 / shape.props.scale;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { transform: `scale(${scaleFactor})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      HighlightRenderer,
      {
        forceSolid,
        strokeWidth,
        shape,
        opacity: this.options.underlayOpacity
      }
    ) });
  }
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    const newSegments = [];
    for (const segment of shape.props.segments) {
      newSegments.push({
        ...segment,
        points: segment.points.map(({ x, y: y2, z }) => {
          return {
            x: scaleX * x,
            y: scaleY * y2,
            z
          };
        })
      });
    }
    return {
      props: {
        segments: newSegments
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      ...endShape.props,
      segments: interpolateSegments(startShape.props.segments, endShape.props.segments, t2),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getShapeDot(point) {
  const r2 = 0.1;
  return `M ${point.x} ${point.y} m -${r2}, 0 a ${r2},${r2} 0 1,0 ${r2 * 2},0 a ${r2},${r2} 0 1,0 -${r2 * 2},0`;
}
function getIndicatorDot(point, sw) {
  const r2 = sw / 2;
  return `M ${point.x} ${point.y} m -${r2}, 0 a ${r2},${r2} 0 1,0 ${r2 * 2},0 a ${r2},${r2} 0 1,0 -${r2 * 2},0`;
}
function getHighlightStrokePoints(shape, strokeWidth, forceSolid) {
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  const showAsComplete = shape.props.isComplete || last$1(shape.props.segments)?.type === "straight";
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (strokeWidth / 6);
  }
  const options = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options);
  return { strokePoints, sw };
}
function getStrokeWidth(shape) {
  return FONT_SIZES[shape.props.size] * 1.12 * shape.props.scale;
}
function getIsDot(shape) {
  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
}
function HighlightRenderer({
  strokeWidth,
  forceSolid,
  shape,
  opacity
}) {
  const theme = useDefaultColorTheme();
  const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
  let sw = strokeWidth;
  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {
    sw += rng(shape.id)() * (sw / 6);
  }
  const options = getHighlightFreehandSettings({
    strokeWidth: sw,
    showAsComplete: shape.props.isComplete || last$1(shape.props.segments)?.type === "straight"
  });
  const strokePoints = getStrokePoints(allPointsFromSegments, options);
  const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, false) : getShapeDot(shape.props.segments[0].points[0]);
  const colorSpace = useColorSpace();
  const color = theme[shape.props.color].highlight[colorSpace];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      d: solidStrokePath,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: color,
      strokeWidth: sw,
      opacity
    }
  );
}
function useHighlightForceSolid(editor, shape) {
  return useValue(
    "forceSolid",
    () => {
      const sw = getStrokeWidth(shape);
      const zoomLevel = editor.getZoomLevel();
      if (sw / zoomLevel < 1.5) {
        return true;
      }
      return false;
    },
    [editor]
  );
}
function BrokenAssetIcon() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}
function getUncroppedSize(shapeSize, crop) {
  if (!crop) return { w: shapeSize.w, h: shapeSize.h };
  const w = shapeSize.w / (crop.bottomRight.x - crop.topLeft.x);
  const h = shapeSize.h / (crop.bottomRight.y - crop.topLeft.y);
  return { w, h };
}
function useImageOrVideoAsset({ shapeId, assetId, width }) {
  const editor = useEditor();
  const exportInfo = useSvgExportContext();
  const exportIsReady = useDelaySvgExport();
  const [result, setResult] = reactExports.useState(() => ({
    asset: assetId ? editor.getAsset(assetId) ?? null : null,
    url: null
  }));
  const didAlreadyResolve = reactExports.useRef(false);
  const previousUrl = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!assetId) return;
    let isCancelled = false;
    let cancelDebounceFn;
    const cleanupEffectScheduler = react$1("update state", () => {
      if (!exportInfo && shapeId && editor.getCulledShapes().has(shapeId)) return;
      const asset = editor.getAsset(assetId);
      if (!asset) {
        setResult((prev) => ({ ...prev, asset: null, url: null }));
        return;
      }
      if (!asset.props.src) {
        const preview = editor.getTemporaryAssetPreview(asset.id);
        if (preview) {
          if (previousUrl.current !== preview) {
            previousUrl.current = preview;
            setResult((prev) => ({ ...prev, isPlaceholder: true, url: preview }));
            exportIsReady();
          }
          return;
        }
      }
      const screenScale = exportInfo ? exportInfo.scale * (width / asset.props.w) : editor.getZoomLevel() * (width / asset.props.w);
      function resolve(asset2, url) {
        if (isCancelled) return;
        if (previousUrl.current === url) return;
        didAlreadyResolve.current = true;
        previousUrl.current = url;
        setResult({ asset: asset2, url });
        exportIsReady();
      }
      if (didAlreadyResolve.current) {
        let tick2 = 0;
        const resolveAssetAfterAWhile = () => {
          tick2++;
          if (tick2 > 500 / 16) {
            resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
            cancelDebounceFn?.();
          }
        };
        cancelDebounceFn?.();
        editor.on("tick", resolveAssetAfterAWhile);
        cancelDebounceFn = () => editor.off("tick", resolveAssetAfterAWhile);
      } else {
        resolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url));
      }
    });
    return () => {
      cleanupEffectScheduler();
      cancelDebounceFn?.();
      isCancelled = true;
    };
  }, [editor, assetId, exportInfo, exportIsReady, shapeId, width]);
  return result;
}
function resolveAssetUrl(editor, assetId, screenScale, exportInfo, callback) {
  editor.resolveAssetUrl(assetId, {
    screenScale,
    shouldResolveToOriginal: exportInfo ? exportInfo.pixelRatio === null : false,
    dpr: exportInfo?.pixelRatio ?? void 0
  }).then((url) => {
    callback(url);
  });
}
async function getDataURIFromURL(url) {
  const response = await fetch$1(url);
  const blob = await response.blob();
  return FileHelpers.blobToDataUrl(blob);
}
const imageSvgExportCache = new WeakCache();
class ImageShapeUtil extends BaseBoxShapeUtil {
  static type = "image";
  static props = imageShapeProps;
  static migrations = imageShapeMigrations;
  isAspectRatioLocked() {
    return true;
  }
  canCrop() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: true,
      url: "",
      crop: null,
      flipX: false,
      flipY: false,
      altText: ""
    };
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  onResize(shape, info) {
    let resized = resizeBox(shape, info);
    const { flipX, flipY } = info.initialShape.props;
    const { scaleX, scaleY, mode } = info;
    resized = {
      ...resized,
      props: {
        ...resized.props,
        flipX: scaleX < 0 !== flipX,
        flipY: scaleY < 0 !== flipY
      }
    };
    if (!shape.props.crop) return resized;
    const flipCropHorizontally = (
      // We used the flip horizontally feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleX === -1 || mode === "resize_bounds" && flipX !== resized.props.flipX
    );
    const flipCropVertically = (
      // We used the flip vertically feature
      // We resized the shape past it's bounds, so it flipped
      mode === "scale_shape" && scaleY === -1 || mode === "resize_bounds" && flipY !== resized.props.flipY
    );
    const { topLeft, bottomRight } = shape.props.crop;
    resized.props.crop = {
      topLeft: {
        x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
        y: flipCropVertically ? 1 - bottomRight.y : topLeft.y
      },
      bottomRight: {
        x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
        y: flipCropVertically ? 1 - topLeft.y : bottomRight.y
      }
    };
    return resized;
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageShape, { shape });
  }
  indicator(shape) {
    const isCropping = this.editor.getCroppingShapeId() === shape.id;
    if (isCropping) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    if (!shape.props.assetId) return null;
    const asset = this.editor.getAsset(shape.props.assetId);
    if (!asset) return null;
    const { w } = getUncroppedSize(shape.props, shape.props.crop);
    const src = await imageSvgExportCache.get(asset, async () => {
      let src2 = await ctx.resolveAssetUrl(asset.id, w);
      if (!src2) return null;
      if (src2.startsWith("blob:") || src2.startsWith("http") || src2.startsWith("/") || src2.startsWith("./")) {
        src2 = await getDataURIFromURL(src2) || "";
      }
      if (getIsAnimated(this.editor, asset.id)) {
        const { promise } = getFirstFrameOfAnimatedImage(src2);
        src2 = await promise;
      }
      return src2;
    });
    if (!src) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgImage, { shape, src });
  }
  onDoubleClickEdge(shape) {
    const props = shape.props;
    if (!props) return;
    if (this.editor.getCroppingShapeId() !== shape.id) {
      return;
    }
    const crop = structuredClone(props.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    };
    const { w, h } = getUncroppedSize(shape.props, crop);
    const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation);
    const partial = {
      id: shape.id,
      type: shape.type,
      x: shape.x - pointDelta.x,
      y: shape.y - pointDelta.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        },
        w,
        h
      }
    };
    this.editor.updateShapes([partial]);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    function interpolateCrop(startShape2, endShape2) {
      if (startShape2.props.crop === null && endShape2.props.crop === null) return null;
      const startTL = startShape2.props.crop?.topLeft || { x: 0, y: 0 };
      const startBR = startShape2.props.crop?.bottomRight || { x: 1, y: 1 };
      const endTL = endShape2.props.crop?.topLeft || { x: 0, y: 0 };
      const endBR = endShape2.props.crop?.bottomRight || { x: 1, y: 1 };
      return {
        topLeft: { x: lerp(startTL.x, endTL.x, t2), y: lerp(startTL.y, endTL.y, t2) },
        bottomRight: { x: lerp(startBR.x, endBR.x, t2), y: lerp(startBR.y, endBR.y, t2) }
      };
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      w: lerp(startShape.props.w, endShape.props.w, t2),
      h: lerp(startShape.props.h, endShape.props.h, t2),
      crop: interpolateCrop(startShape, endShape)
    };
  }
}
const ImageShape = reactExports.memo(function ImageShape2({ shape }) {
  const editor = useEditor();
  const { w } = getUncroppedSize(shape.props, shape.props.crop);
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: w
  });
  const prefersReducedMotion = usePrefersReducedMotion();
  const [staticFrameSrc, setStaticFrameSrc] = reactExports.useState("");
  const [loadedUrl, setLoadedUrl] = reactExports.useState(null);
  const isAnimated = asset && getIsAnimated(editor, asset.id);
  reactExports.useEffect(() => {
    if (url && isAnimated) {
      const { promise, cancel } = getFirstFrameOfAnimatedImage(url);
      promise.then((dataUrl) => {
        setStaticFrameSrc(dataUrl);
        setLoadedUrl(url);
      });
      return () => {
        cancel();
      };
    }
  }, [editor, isAnimated, prefersReducedMotion, url]);
  const showCropPreview = useValue(
    "show crop preview",
    () => shape.id === editor.getOnlySelectedShapeId() && editor.getCroppingShapeId() === shape.id && editor.isIn("select.crop"),
    [editor, shape.id]
  );
  const reduceMotion = prefersReducedMotion && (asset?.props.mimeType?.includes("video") || isAnimated);
  const containerStyle = getCroppedContainerStyle(shape);
  const nextSrc = url === loadedUrl ? null : url;
  const loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl;
  if (!url && !asset?.props.src) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          overflow: "hidden",
          width: shape.props.w,
          height: shape.props.h,
          color: "var(--color-text-3)",
          backgroundColor: "var(--color-low)",
          border: "1px solid var(--color-low-border)"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classNames("tl-image-container", asset && "tl-image-container-loading"),
              style: containerStyle,
              children: asset ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(BrokenAssetIcon, {})
            }
          ),
          "url" in shape.props && shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
        ]
      }
    );
  }
  const crossOrigin = isAnimated ? "anonymous" : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showCropPreview && loadedSrc && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: containerStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        className: "tl-image",
        style: { ...getFlipStyle(shape), opacity: 0.1 },
        crossOrigin,
        src: loadedSrc,
        referrerPolicy: "strict-origin-when-cross-origin",
        draggable: false
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      HTMLContainer,
      {
        id: shape.id,
        style: { overflow: "hidden", width: shape.props.w, height: shape.props.h },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("tl-image-container"), style: containerStyle, children: [
            loadedSrc && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: loadedSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false
              },
              loadedSrc
            ),
            nextSrc && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                className: "tl-image",
                style: getFlipStyle(shape),
                crossOrigin,
                src: nextSrc,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: false,
                onLoad: () => setLoadedUrl(nextSrc)
              },
              nextSrc
            )
          ] }),
          shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
        ]
      }
    )
  ] });
});
function getIsAnimated(editor, assetId) {
  const asset = assetId ? editor.getAsset(assetId) : void 0;
  if (!asset) return false;
  return "mimeType" in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType) || "isAnimated" in asset.props && asset.props.isAnimated;
}
function getCroppedContainerStyle(shape) {
  const crop = shape.props.crop;
  const topLeft = crop?.topLeft;
  if (!topLeft) {
    return {
      width: shape.props.w,
      height: shape.props.h
    };
  }
  const { w, h } = getUncroppedSize(shape.props, crop);
  const offsetX = -topLeft.x * w;
  const offsetY = -topLeft.y * h;
  return {
    transform: `translate(${offsetX}px, ${offsetY}px)`,
    width: w,
    height: h
  };
}
function getFlipStyle(shape, size2) {
  const { flipX, flipY } = shape.props;
  if (!flipX && !flipY) return void 0;
  const scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`;
  const translate = size2 ? `translate(${flipX ? size2.width : 0}px, ${flipY ? size2.height : 0}px)` : "";
  return {
    transform: `${translate} ${scale}`,
    // in SVG, flipping around the center doesn't work so we use explicit width/height
    transformOrigin: size2 ? "0 0" : "center center"
  };
}
function SvgImage({ shape, src }) {
  const cropClipId = useUniqueSafeId();
  const containerStyle = getCroppedContainerStyle(shape);
  const crop = shape.props.crop;
  if (containerStyle.transform && crop) {
    const { transform: cropTransform, width, height } = containerStyle;
    const croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width;
    const croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height;
    const points = [
      new Vec(0, 0),
      new Vec(croppedWidth, 0),
      new Vec(croppedWidth, croppedHeight),
      new Vec(0, croppedHeight)
    ];
    const flip2 = getFlipStyle(shape, { width, height });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: cropClipId, children: /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: points.map((p) => `${p.x},${p.y}`).join(" ") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("g", { clipPath: `url(#${cropClipId})`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "image",
        {
          href: src,
          width,
          height,
          style: flip2 ? { ...flip2, transform: `${cropTransform} ${flip2.transform}` } : { transform: cropTransform }
        }
      ) })
    ] });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "image",
      {
        href: src,
        width: shape.props.w,
        height: shape.props.h,
        style: getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })
      }
    );
  }
}
function getFirstFrameOfAnimatedImage(url) {
  let cancelled = false;
  const promise = new Promise((resolve) => {
    const image = Image();
    image.onload = () => {
      if (cancelled) return;
      const canvas = document.createElement("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.drawImage(image, 0, 0);
      resolve(canvas.toDataURL());
    };
    image.crossOrigin = "anonymous";
    image.src = url;
  });
  return { promise, cancel: () => cancelled = true };
}
function getLineDrawFreehandOptions(strokeWidth) {
  return {
    size: strokeWidth,
    thinning: 0.4,
    streamline: 0,
    smoothing: 0.5,
    simulatePressure: true,
    last: true
  };
}
function getLineStrokePoints(shape, spline, strokeWidth) {
  const points = spline.vertices;
  const options = getLineDrawFreehandOptions(strokeWidth);
  return getStrokePoints(points, options);
}
function getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth) {
  const options = getLineDrawFreehandOptions(strokeWidth);
  return getStrokeOutlinePoints(
    setStrokePointRadii(getLineStrokePoints(shape, spline, strokeWidth), options),
    options
  );
}
function getLineDrawPath(shape, spline, strokeWidth) {
  const stroke = getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth);
  return getSvgPathFromPoints(stroke);
}
function getLineIndicatorPath(shape, spline, strokeWidth) {
  if (shape.props.dash === "draw") {
    const strokePoints = getLineStrokePoints(shape, spline, strokeWidth);
    return getSvgPathFromStrokePoints(strokePoints);
  }
  return spline.getSvgPathData();
}
function getDrawLinePathData(id, outline, strokeWidth) {
  let innerPathData = `M ${precise(outline[0])}L`;
  let outerPathData2 = `M ${precise(outline[0])}L`;
  const offset2 = strokeWidth / 3;
  const roundness = strokeWidth * 2;
  const random = rng(id);
  let p0 = outline[0];
  let p1;
  let s0 = outline[0];
  let s1;
  const len = outline.length;
  for (let i = 0, n2 = len - 1; i < n2; i++) {
    p1 = outline[i + 1];
    s1 = Vec.AddXY(outline[i + 1], random() * offset2, random() * offset2);
    const delta = Vec.Sub(p1, p0);
    const distance = Vec.Len(delta);
    const vector = Vec.Div(delta, distance).mul(Math.min(distance / 4, roundness));
    const q0 = Vec.Add(p0, vector);
    const q1 = Vec.Add(p1, vector.neg());
    const sDelta = Vec.Sub(s1, s0);
    const sDistance = Vec.Len(sDelta);
    const sVector = Vec.Div(sDelta, sDistance).mul(Math.min(sDistance / 4, roundness));
    const sq0 = Vec.Add(s0, sVector);
    const sq1 = Vec.Add(s1, sVector.neg());
    if (i === n2 - 1) {
      innerPathData += `${precise(q0)}L ${precise(p1)}`;
      outerPathData2 += `${precise(sq0)}L ${precise(s1)}`;
    } else {
      innerPathData += `${precise(q0)}L ${precise(q1)}Q ${precise(p1)}`;
      outerPathData2 += `${precise(sq0)}L ${precise(sq1)}Q ${precise(s1)}`;
      p0 = p1;
      s0 = s1;
    }
  }
  return [innerPathData, innerPathData + outerPathData2];
}
const handlesCache = new WeakCache();
class LineShapeUtil extends ShapeUtil {
  static type = "line";
  static props = lineShapeProps;
  static migrations = lineShapeMigrations;
  canTabTo() {
    return false;
  }
  hideResizeHandles() {
    return true;
  }
  hideRotateHandle() {
    return true;
  }
  hideSelectionBoundsFg() {
    return true;
  }
  hideSelectionBoundsBg() {
    return true;
  }
  getDefaultProps() {
    const [start, end] = getIndices(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [start]: { id: start, index: start, x: 0, y: 0 },
        [end]: { id: end, index: end, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(shape) {
    return getGeometryForLineShape(shape);
  }
  getHandles(shape) {
    return handlesCache.get(shape.props, () => {
      const spline = getGeometryForLineShape(shape);
      const points = linePointsToArray(shape);
      const results = points.map((point) => ({
        ...point,
        id: point.index,
        type: "vertex",
        canSnap: true
      }));
      for (let i = 0; i < points.length - 1; i++) {
        const index2 = getIndexBetween(points[i].index, points[i + 1].index);
        const segment = spline.segments[i];
        const point = segment.midPoint();
        results.push({
          id: index2,
          type: "create",
          index: index2,
          x: point.x,
          y: point.y,
          canSnap: true
        });
      }
      return results.sort(sortByIndex$1);
    });
  }
  //   Events
  onResize(shape, info) {
    const { scaleX, scaleY } = info;
    return {
      props: {
        points: mapObjectMapValues(shape.props.points, (_, { id, index: index2, x, y: y2 }) => ({
          id,
          index: index2,
          x: x * scaleX,
          y: y2 * scaleY
        }))
      }
    };
  }
  onBeforeCreate(next) {
    const {
      props: { points }
    } = next;
    const pointKeys = Object.keys(points);
    if (pointKeys.length < 2) {
      return;
    }
    const firstPoint = points[pointKeys[0]];
    const allSame = pointKeys.every((key) => {
      const point = points[key];
      return point.x === firstPoint.x && point.y === firstPoint.y;
    });
    if (allSame) {
      const lastKey = pointKeys[pointKeys.length - 1];
      points[lastKey] = {
        ...points[lastKey],
        x: points[lastKey].x + 0.1,
        y: points[lastKey].y + 0.1
      };
      return next;
    }
    return;
  }
  onHandleDrag(shape, { handle }) {
    if (handle.type !== "vertex") return;
    const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor);
    return {
      ...shape,
      props: {
        ...shape.props,
        points: {
          ...shape.props.points,
          [handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y }
        }
      }
    };
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SVGContainer, { style: { minWidth: 50, minHeight: 50 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LineShapeSvg, { shape }) });
  }
  indicator(shape) {
    const strokeWidth = STROKE_SIZES$1[shape.props.size] * shape.props.scale;
    const spline = getGeometryForLineShape(shape);
    const { dash } = shape.props;
    let path;
    if (shape.props.spline === "line") {
      const outline = spline.points;
      if (dash === "solid" || dash === "dotted" || dash === "dashed") {
        path = "M" + outline[0] + "L" + outline.slice(1);
      } else {
        const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
        path = innerPathData;
      }
    } else {
      path = getLineIndicatorPath(shape, spline, strokeWidth);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: path });
  }
  toSvg(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(LineShapeSvg, { shouldScale: true, shape });
  }
  getHandleSnapGeometry(shape) {
    const points = linePointsToArray(shape);
    return {
      points,
      getSelfSnapPoints: (handle) => {
        const index2 = this.getHandles(shape).filter((h) => h.type === "vertex").findIndex((h) => h.id === handle.id);
        return points.filter((_, i) => Math.abs(i - index2) > 1).map(Vec.From);
      },
      getSelfSnapOutline: (handle) => {
        const index2 = this.getHandles(shape).filter((h) => h.type === "vertex").findIndex((h) => h.id === handle.id);
        const segments = getGeometryForLineShape(shape).segments.filter(
          (_, i) => i !== index2 - 1 && i !== index2
        );
        if (!segments.length) return null;
        return new Group2d({ children: segments });
      }
    };
  }
  getInterpolatedProps(startShape, endShape, t2) {
    const startPoints = linePointsToArray(startShape);
    const endPoints = linePointsToArray(endShape);
    const pointsToUseStart = [];
    const pointsToUseEnd = [];
    let index2 = ZERO_INDEX_KEY;
    if (startPoints.length > endPoints.length) {
      for (let i = 0; i < startPoints.length; i++) {
        pointsToUseStart[i] = { ...startPoints[i] };
        if (endPoints[i] === void 0) {
          pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index2 };
        } else {
          pointsToUseEnd[i] = { ...endPoints[i], id: index2 };
        }
        index2 = getIndexAbove(index2);
      }
    } else if (endPoints.length > startPoints.length) {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseEnd[i] = { ...endPoints[i] };
        if (startPoints[i] === void 0) {
          pointsToUseStart[i] = {
            ...startPoints[startPoints.length - 1],
            id: index2
          };
        } else {
          pointsToUseStart[i] = { ...startPoints[i], id: index2 };
        }
        index2 = getIndexAbove(index2);
      }
    } else {
      for (let i = 0; i < endPoints.length; i++) {
        pointsToUseStart[i] = startPoints[i];
        pointsToUseEnd[i] = endPoints[i];
      }
    }
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      points: Object.fromEntries(
        pointsToUseStart.map((point, i) => {
          const endPoint = pointsToUseEnd[i];
          return [
            point.id,
            {
              ...point,
              x: lerp(point.x, endPoint.x, t2),
              y: lerp(point.y, endPoint.y, t2)
            }
          ];
        })
      ),
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function linePointsToArray(shape) {
  return Object.values(shape.props.points).sort(sortByIndex$1);
}
function getGeometryForLineShape(shape) {
  const points = linePointsToArray(shape).map(Vec.From);
  switch (shape.props.spline) {
    case "cubic": {
      return new CubicSpline2d({ points });
    }
    case "line": {
      return new Polyline2d({ points });
    }
  }
}
function LineShapeSvg({
  shape,
  shouldScale = false,
  forceSolid = false
}) {
  const theme = useDefaultColorTheme();
  const spline = getGeometryForLineShape(shape);
  const { dash, color, size: size2 } = shape.props;
  const scaleFactor = 1 / shape.props.scale;
  const scale = shouldScale ? scaleFactor : 1;
  const strokeWidth = STROKE_SIZES$1[size2] * shape.props.scale;
  if (shape.props.spline === "line") {
    if (dash === "solid") {
      const outline = spline.points;
      const pathData = "M" + outline[0] + "L" + outline.slice(1);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: pathData,
          stroke: theme[color].solid,
          strokeWidth,
          fill: "none",
          transform: `scale(${scale})`
        }
      );
    }
    if (dash === "dashed" || dash === "dotted") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { stroke: theme[color].solid, strokeWidth, transform: `scale(${scale})`, children: spline.segments.map((segment, i) => {
        const { strokeDasharray, strokeDashoffset } = forceSolid ? { strokeDasharray: "none", strokeDashoffset: "none" } : getPerfectDashProps(segment.length, strokeWidth, {
          style: dash,
          start: i > 0 ? "outset" : "none",
          end: i < spline.segments.length - 1 ? "outset" : "none"
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            strokeDasharray,
            strokeDashoffset,
            d: segment.getSvgPathData(true),
            fill: "none"
          },
          i
        );
      }) });
    }
    if (dash === "draw") {
      const outline = spline.points;
      const [_, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: outerPathData,
          stroke: theme[color].solid,
          strokeWidth,
          fill: "none",
          transform: `scale(${scale})`
        }
      );
    }
  }
  if (shape.props.spline === "cubic") {
    const splinePath = spline.getSvgPathData();
    if (dash === "solid") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          strokeWidth,
          stroke: theme[color].solid,
          fill: "none",
          d: splinePath,
          transform: `scale(${scale})`
        }
      );
    }
    if (dash === "dashed" || dash === "dotted") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { stroke: theme[color].solid, strokeWidth, transform: `scale(${scale})`, children: spline.segments.map((segment, i) => {
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
          segment.length,
          strokeWidth,
          {
            style: dash,
            start: i > 0 ? "outset" : "none",
            end: i < spline.segments.length - 1 ? "outset" : "none",
            forceSolid
          }
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            strokeDasharray,
            strokeDashoffset,
            d: segment.getSvgPathData(),
            fill: "none"
          },
          i
        );
      }) });
    }
    if (dash === "draw") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: getLineDrawPath(shape, spline, strokeWidth),
          strokeWidth: 1,
          stroke: theme[color].solid,
          fill: theme[color].solid,
          transform: `scale(${scale})`
        }
      );
    }
  }
}
class NoteShapeUtil extends ShapeUtil {
  static type = "note";
  static props = noteShapeProps;
  static migrations = noteShapeMigrations;
  options = {
    resizeMode: "none"
  };
  canEdit() {
    return true;
  }
  hideResizeHandles() {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return true;
      }
      case "scale": {
        return false;
      }
      default: {
        throw exhaustiveSwitchError$1(resizeMode);
      }
    }
  }
  isAspectRatioLocked() {
    return this.options.resizeMode === "scale";
  }
  hideSelectionBoundsFg() {
    return false;
  }
  getDefaultProps() {
    return {
      color: "black",
      richText: toRichText(""),
      size: "m",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      labelColor: "black",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(shape) {
    const { labelHeight, labelWidth } = getLabelSize(this.editor, shape);
    const { scale } = shape.props;
    const lh = labelHeight * scale;
    const lw = labelWidth * scale;
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    return new Group2d({
      children: [
        new Rectangle2d({ width: nw, height: nh, isFilled: true }),
        new Rectangle2d({
          x: shape.props.align === "start" ? 0 : shape.props.align === "end" ? nw - lw : (nw - lw) / 2,
          y: shape.props.verticalAlign === "start" ? 0 : shape.props.verticalAlign === "end" ? nh - lh : (nh - lh) / 2,
          width: lw,
          height: lh,
          isFilled: true,
          isLabel: true
        })
      ]
    });
  }
  getHandles(shape) {
    const { scale } = shape.props;
    const isCoarsePointer = this.editor.getInstanceState().isCoarsePointer;
    if (isCoarsePointer) return [];
    const zoom = this.editor.getZoomLevel();
    if (zoom * scale < 0.25) return [];
    const nh = getNoteHeight(shape);
    const nw = NOTE_SIZE * scale;
    const offset2 = CLONE_HANDLE_MARGIN / zoom * scale;
    if (zoom * scale < 0.5) {
      return [
        {
          id: "bottom",
          index: "a3",
          type: "clone",
          x: nw / 2,
          y: nh + offset2
        }
      ];
    }
    return [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: nw / 2,
        y: -offset2
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: nw + offset2,
        y: nh / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: nw / 2,
        y: nh + offset2
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -offset2,
        y: nh / 2
      }
    ];
  }
  onResize(shape, info) {
    const { resizeMode } = this.options;
    switch (resizeMode) {
      case "none": {
        return void 0;
      }
      case "scale": {
        return resizeScaled(shape, info);
      }
      default: {
        throw exhaustiveSwitchError$1(resizeMode);
      }
    }
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  component(shape) {
    const {
      id,
      type,
      props: {
        labelColor,
        scale,
        color,
        font,
        size: size2,
        align,
        richText,
        verticalAlign,
        fontSizeAdjustment
      }
    } = shape;
    const handleKeyDown2 = useNoteKeydownHandler(id);
    const theme = useDefaultColorTheme();
    const nw = NOTE_SIZE * scale;
    const nh = getNoteHeight(shape);
    const rotation = useValue(
      "shape rotation",
      () => this.editor.getShapePageTransform(id)?.rotation() ?? 0,
      [this.editor]
    );
    const hideShadows = useValue("zoom", () => this.editor.getZoomLevel() < 0.35 / scale, [
      scale,
      this.editor
    ]);
    const isDarkMode = useValue("dark mode", () => this.editor.user.getIsDarkMode(), [this.editor]);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const isReadyForEditing = useIsReadyForEditing(this.editor, shape.id);
    const isEmpty = isEmptyRichText(richText);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          id,
          className: "tl-note__container",
          style: {
            width: nw,
            height: nh,
            backgroundColor: theme[color].note.fill,
            borderBottom: hideShadows ? isDarkMode ? `${2 * scale}px solid rgb(20, 20, 20)` : `${2 * scale}px solid rgb(144, 144, 144)` : "none",
            boxShadow: hideShadows ? "none" : getNoteShadow(shape.id, rotation, scale)
          },
          children: (isSelected || isReadyForEditing || !isEmpty) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            RichTextLabel,
            {
              shapeId: id,
              type,
              font,
              fontSize: (fontSizeAdjustment || LABEL_FONT_SIZES[size2]) * scale,
              lineHeight: TEXT_PROPS.lineHeight,
              align,
              verticalAlign,
              richText,
              isSelected,
              labelColor: labelColor === "black" ? theme[color].note.text : theme[labelColor].fill,
              wrap: true,
              padding: LABEL_PADDING * scale,
              hasCustomTabBehavior: true,
              onKeyDown: handleKeyDown2
            }
          )
        }
      ),
      "url" in shape.props && shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
    ] });
  }
  indicator(shape) {
    const { scale } = shape.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "rect",
      {
        rx: scale,
        width: toDomPrecision(NOTE_SIZE * scale),
        height: toDomPrecision(getNoteHeight(shape))
      }
    );
  }
  toSvg(shape, ctx) {
    const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode });
    const bounds = getBoundsForSVG(shape);
    const textLabel = /* @__PURE__ */ jsxRuntimeExports.jsx(
      RichTextSVG,
      {
        fontSize: shape.props.fontSizeAdjustment || LABEL_FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.align,
        verticalAlign: shape.props.verticalAlign,
        richText: shape.props.richText,
        labelColor: theme[shape.props.color].note.text,
        bounds,
        padding: LABEL_PADDING * shape.props.scale
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: 5, y: 5, rx: 1, width: NOTE_SIZE - 10, height: bounds.h, fill: "rgba(0,0,0,.1)" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "rect",
        {
          rx: 1,
          width: NOTE_SIZE,
          height: bounds.h,
          fill: theme[shape.props.color].note.fill
        }
      ),
      textLabel
    ] });
  }
  onBeforeCreate(next) {
    return getNoteSizeAdjustments(this.editor, next);
  }
  onBeforeUpdate(prev, next) {
    if (isEqual(prev.props.richText, next.props.richText) && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    return getNoteSizeAdjustments(this.editor, next);
  }
  getInterpolatedProps(startShape, endShape, t2) {
    return {
      ...t2 > 0.5 ? endShape.props : startShape.props,
      scale: lerp(startShape.props.scale, endShape.props.scale, t2)
    };
  }
}
function getNoteSizeAdjustments(editor, shape) {
  const { labelHeight, fontSizeAdjustment } = getLabelSize(editor, shape);
  const growY = Math.max(0, labelHeight - NOTE_SIZE);
  if (growY !== shape.props.growY || fontSizeAdjustment !== shape.props.fontSizeAdjustment) {
    return {
      ...shape,
      props: {
        ...shape.props,
        growY,
        fontSizeAdjustment
      }
    };
  }
}
function getNoteLabelSize(editor, shape) {
  const { richText } = shape.props;
  if (isEmptyRichText(richText)) {
    const minHeight = LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2;
    return { labelHeight: minHeight, labelWidth: 100, fontSizeAdjustment: 0 };
  }
  const unadjustedFontSize = LABEL_FONT_SIZES[shape.props.size];
  let fontSizeAdjustment = 0;
  let iterations = 0;
  let labelHeight = NOTE_SIZE;
  let labelWidth = NOTE_SIZE;
  const FUZZ = 1;
  do {
    fontSizeAdjustment = Math.min(unadjustedFontSize, unadjustedFontSize - iterations);
    const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
    const nextTextSize = editor.textMeasure.measureHtml(html2, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: fontSizeAdjustment,
      maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,
      disableOverflowWrapBreaking: true
    });
    labelHeight = nextTextSize.h + LABEL_PADDING * 2;
    labelWidth = nextTextSize.w + LABEL_PADDING * 2;
    if (fontSizeAdjustment <= 14) {
      const html22 = renderHtmlFromRichTextForMeasurement(editor, richText);
      const nextTextSizeWithOverflowBreak = editor.textMeasure.measureHtml(html22, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[shape.props.font],
        fontSize: fontSizeAdjustment,
        maxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ
      });
      labelHeight = nextTextSizeWithOverflowBreak.h + LABEL_PADDING * 2;
      labelWidth = nextTextSizeWithOverflowBreak.w + LABEL_PADDING * 2;
      break;
    }
    if (nextTextSize.scrollWidth.toFixed(0) === nextTextSize.w.toFixed(0)) {
      break;
    }
  } while (iterations++ < 50);
  return {
    labelHeight,
    labelWidth,
    fontSizeAdjustment
  };
}
const labelSizesForNote = new WeakCache();
function getLabelSize(editor, shape) {
  return labelSizesForNote.get(shape, () => getNoteLabelSize(editor, shape));
}
function useNoteKeydownHandler(id) {
  const editor = useEditor();
  const translation = useCurrentTranslation();
  return reactExports.useCallback(
    (e) => {
      const shape = editor.getShape(id);
      if (!shape) return;
      const isTab = e.key === "Tab";
      const isCmdEnter = (e.metaKey || e.ctrlKey) && e.key === "Enter";
      if (isTab || isCmdEnter) {
        e.preventDefault();
        const pageTransform = editor.getShapePageTransform(id);
        const pageRotation = pageTransform.rotation();
        const isRTL2 = !!(translation.dir === "rtl" || // todo: can we check a partial of the text, so that we don't have to render the whole thing?
        isRightToLeftLanguage(renderPlaintextFromRichText(editor, shape.props.richText)));
        const offsetLength = (NOTE_SIZE + editor.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (isCmdEnter && !e.shiftKey ? shape.props.growY : 0)) * shape.props.scale;
        const adjacentCenter = new Vec(
          isTab ? e.shiftKey != isRTL2 ? -1 : 1 : 0,
          isCmdEnter ? e.shiftKey ? -1 : 1 : 0
        ).mul(offsetLength).add(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale)).rot(pageRotation).add(pageTransform.point());
        const newNote = getNoteShapeForAdjacentPosition(editor, shape, adjacentCenter, pageRotation);
        if (newNote) {
          editor.markHistoryStoppingPoint("editing adjacent shape");
          startEditingShapeWithLabel(
            editor,
            newNote,
            true
            /* selectAll */
          );
        }
      }
    },
    [id, editor, translation.dir]
  );
}
function getNoteHeight(shape) {
  return (NOTE_SIZE + shape.props.growY) * shape.props.scale;
}
function getNoteShadow(id, rotation, scale) {
  const random = rng(id);
  const lift2 = Math.abs(random()) + 0.5;
  const oy = Math.cos(rotation);
  const a2 = 5 * scale;
  const b = 4 * scale;
  const c2 = 6 * scale;
  const d = 7 * scale;
  return `0px ${a2 - lift2}px ${a2}px -${a2}px rgba(15, 23, 31, .6),
	0px ${(b + lift2 * d) * Math.max(0, oy)}px ${c2 + lift2 * d}px -${b + lift2 * c2}px rgba(15, 23, 31, ${(0.3 + lift2 * 0.1).toFixed(2)}), 
	0px ${48 * scale}px ${10 * scale}px -${10 * scale}px inset rgba(15, 23, 44, ${((0.022 + random() * 5e-3) * ((1 + oy) / 2)).toFixed(2)})`;
}
function getBoundsForSVG(shape) {
  return new Box(0, 0, NOTE_SIZE, NOTE_SIZE + shape.props.growY);
}
const sizeCache = createComputedCache(
  "text size",
  (editor, shape) => {
    editor.fonts.trackFontsForShape(shape);
    return getTextSize(editor, shape.props);
  },
  { areRecordsEqual: (a2, b) => a2.props === b.props }
);
class TextShapeUtil extends ShapeUtil {
  static type = "text";
  static props = textShapeProps;
  static migrations = textShapeMigrations;
  options = {
    extraArrowHorizontalPadding: 10
  };
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      font: "draw",
      textAlign: "start",
      autoSize: true,
      scale: 1,
      richText: toRichText("")
    };
  }
  getMinDimensions(shape) {
    return sizeCache.get(this.editor, shape.id);
  }
  getGeometry(shape, opts) {
    const { scale } = shape.props;
    const { width, height } = this.getMinDimensions(shape);
    const context = opts?.context ?? "none";
    return new Rectangle2d({
      x: (context === "@tldraw/arrow-without-arrowhead" ? -this.options.extraArrowHorizontalPadding : 0) * scale,
      width: (width + (context === "@tldraw/arrow-without-arrowhead" ? this.options.extraArrowHorizontalPadding * 2 : 0)) * scale,
      height: height * scale,
      isFilled: true,
      isLabel: true
    });
  }
  getFontFaces(shape) {
    return getFontsFromRichText(this.editor, shape.props.richText, {
      family: `tldraw_${shape.props.font}`,
      weight: "normal",
      style: "normal"
    });
  }
  getText(shape) {
    return renderPlaintextFromRichText(this.editor, shape.props.richText);
  }
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(shape) {
    const {
      id,
      props: { font, size: size2, richText, color, scale, textAlign }
    } = shape;
    const { width, height } = this.getMinDimensions(shape);
    const isSelected = shape.id === this.editor.getOnlySelectedShapeId();
    const theme = useDefaultColorTheme();
    const handleKeyDown2 = useTextShapeKeydownHandler(id);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RichTextLabel,
      {
        shapeId: id,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font,
        fontSize: FONT_SIZES[size2],
        lineHeight: TEXT_PROPS.lineHeight,
        align: textAlign,
        verticalAlign: "middle",
        richText,
        labelColor: theme[color].solid,
        isSelected,
        textWidth: width,
        textHeight: height,
        style: {
          transform: `scale(${scale})`,
          transformOrigin: "top left"
        },
        wrap: true,
        onKeyDown: handleKeyDown2
      }
    );
  }
  indicator(shape) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const editor = useEditor();
    if (shape.props.autoSize && editor.getEditingShapeId() === shape.id) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(bounds.width), height: toDomPrecision(bounds.height) });
  }
  toSvg(shape, ctx) {
    const bounds = this.editor.getShapeGeometry(shape).bounds;
    const width = bounds.width / (shape.props.scale ?? 1);
    const height = bounds.height / (shape.props.scale ?? 1);
    const theme = getDefaultColorTheme(ctx);
    const exportBounds = new Box(0, 0, width, height);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      RichTextSVG,
      {
        fontSize: FONT_SIZES[shape.props.size],
        font: shape.props.font,
        align: shape.props.textAlign,
        verticalAlign: "middle",
        richText: shape.props.richText,
        labelColor: theme[shape.props.color].solid,
        bounds: exportBounds,
        padding: 0
      }
    );
  }
  onResize(shape, info) {
    const { newPoint, initialBounds, initialShape, scaleX, handle } = info;
    if (info.mode === "scale_shape" || handle !== "right" && handle !== "left") {
      return {
        id: shape.id,
        type: shape.type,
        ...resizeScaled(shape, info)
      };
    } else {
      const nextWidth = Math.max(1, Math.abs(initialBounds.width * scaleX));
      const { x, y: y2 } = scaleX < 0 ? Vec.Sub(newPoint, Vec.FromAngle(shape.rotation).mul(nextWidth)) : newPoint;
      return {
        id: shape.id,
        type: shape.type,
        x,
        y: y2,
        props: {
          w: nextWidth / initialShape.props.scale,
          autoSize: false
        }
      };
    }
  }
  onEditEnd(shape) {
    const trimmedText = renderPlaintextFromRichText(this.editor, shape.props.richText).trimEnd();
    if (trimmedText.length === 0) {
      this.editor.deleteShapes([shape.id]);
    }
  }
  onBeforeUpdate(prev, next) {
    if (!next.props.autoSize) return;
    const styleDidChange = prev.props.size !== next.props.size || prev.props.textAlign !== next.props.textAlign || prev.props.font !== next.props.font || prev.props.scale !== 1 && next.props.scale === 1;
    const textDidChange = !isEqual(prev.props.richText, next.props.richText);
    if (!styleDidChange && !textDidChange) return;
    const boundsA = this.getMinDimensions(prev);
    const boundsB = getTextSize(this.editor, next.props);
    const wA = boundsA.width * prev.props.scale;
    const hA = boundsA.height * prev.props.scale;
    const wB = boundsB.width * next.props.scale;
    const hB = boundsB.height * next.props.scale;
    let delta;
    switch (next.props.textAlign) {
      case "middle": {
        delta = new Vec((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      case "end": {
        delta = new Vec(wB - wA, textDidChange ? 0 : (hB - hA) / 2);
        break;
      }
      default: {
        if (textDidChange) break;
        delta = new Vec(0, (hB - hA) / 2);
        break;
      }
    }
    if (delta) {
      delta.rot(next.rotation);
      const { x, y: y2 } = next;
      return {
        ...next,
        x: x - delta.x,
        y: y2 - delta.y,
        props: { ...next.props, w: wB }
      };
    } else {
      return {
        ...next,
        props: { ...next.props, w: wB }
      };
    }
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
}
function getTextSize(editor, props) {
  const { font, richText, autoSize, size: size2, w } = props;
  const minWidth = autoSize ? 16 : Math.max(16, w);
  const fontSize = FONT_SIZES[size2];
  const cw = autoSize ? null : (
    // `measureText` floors the number so we need to do the same here to avoid issues.
    Math.floor(Math.max(minWidth, w))
  );
  const html2 = renderHtmlFromRichTextForMeasurement(editor, richText);
  const result = editor.textMeasure.measureHtml(html2, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[font],
    fontSize,
    maxWidth: cw
  });
  if (autoSize) {
    result.w += 1;
  }
  return {
    width: Math.max(minWidth, result.w),
    height: Math.max(fontSize, result.h)
  };
}
function useTextShapeKeydownHandler(id) {
  const editor = useEditor();
  return reactExports.useCallback(
    (e) => {
      if (editor.getEditingShapeId() !== id) return;
      switch (e.key) {
        case "Enter": {
          if (e.ctrlKey || e.metaKey) {
            editor.complete();
          }
          break;
        }
      }
    },
    [editor, id]
  );
}
const videoSvgExportCache = new WeakCache();
class VideoShapeUtil extends BaseBoxShapeUtil {
  static type = "video";
  static props = videoShapeProps;
  static migrations = videoShapeMigrations;
  canEdit() {
    return true;
  }
  isAspectRatioLocked() {
    return true;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: true,
      url: "",
      altText: ""
    };
  }
  getAriaDescriptor(shape) {
    return shape.props.altText;
  }
  component(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VideoShape, { shape });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
  }
  async toSvg(shape, ctx) {
    if (!shape.props.assetId) return null;
    const asset = this.editor.getAsset(shape.props.assetId);
    if (!asset) return null;
    const src = await videoSvgExportCache.get(asset, async () => {
      const assetUrl = await ctx.resolveAssetUrl(asset.id, shape.props.w);
      if (!assetUrl) return null;
      const video = await MediaHelpers.loadVideo(assetUrl);
      return await MediaHelpers.getVideoFrameAsDataUrl(video, 0);
    });
    if (!src) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("image", { href: src, width: shape.props.w, height: shape.props.h });
  }
}
const VideoShape = reactExports.memo(function VideoShape2({ shape }) {
  const editor = useEditor();
  const showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110;
  const isEditing = useIsEditing(shape.id);
  const prefersReducedMotion = usePrefersReducedMotion();
  const { Spinner: Spinner2 } = useEditorComponents();
  const { asset, url } = useImageOrVideoAsset({
    shapeId: shape.id,
    assetId: shape.props.assetId,
    width: shape.props.w
  });
  const rVideo = reactExports.useRef(null);
  const [isLoaded, setIsLoaded] = reactExports.useState(false);
  const [isFullscreen, setIsFullscreen] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current);
    document.addEventListener("fullscreenchange", fullscreenChange);
    return () => document.removeEventListener("fullscreenchange", fullscreenChange);
  });
  const handleLoadedData = reactExports.useCallback((e) => {
    const video = e.currentTarget;
    if (!video) return;
    setIsLoaded(true);
  }, []);
  reactExports.useEffect(() => {
    const video = rVideo.current;
    if (!video) return;
    if (isEditing) {
      if (document.activeElement !== video) {
        video.focus();
      }
    }
  }, [isEditing, isLoaded]);
  reactExports.useEffect(() => {
    if (prefersReducedMotion) {
      const video = rVideo.current;
      if (!video) return;
      video.pause();
      video.currentTime = 0;
    }
  }, [rVideo, prefersReducedMotion]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      HTMLContainer,
      {
        id: shape.id,
        style: {
          color: "var(--color-text-3)",
          backgroundColor: asset ? "transparent" : "var(--color-low)",
          border: asset ? "none" : "1px solid var(--color-low-border)"
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-counter-scaled", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tl-video-container", children: !asset ? /* @__PURE__ */ jsxRuntimeExports.jsx(BrokenAssetIcon, {}) : Spinner2 && !asset.props.src ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {}) : url ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "video",
            {
              ref: rVideo,
              style: isEditing ? { pointerEvents: "all" } : !isLoaded ? { display: "none" } : void 0,
              className: classNames("tl-video", `tl-video-shape-${shape.id.split(":")[1]}`, {
                "tl-video-is-fullscreen": isFullscreen
              }),
              width: "100%",
              height: "100%",
              draggable: false,
              playsInline: true,
              autoPlay: true,
              muted: true,
              loop: true,
              disableRemotePlayback: true,
              disablePictureInPicture: true,
              controls: isEditing && showControls,
              onLoadedData: handleLoadedData,
              hidden: !isLoaded,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: url })
            }
          ),
          !isLoaded && Spinner2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner2, {})
        ] }) : null }) })
      }
    ),
    "url" in shape.props && shape.props.url && /* @__PURE__ */ jsxRuntimeExports.jsx(HyperlinkButton, { url: shape.props.url })
  ] });
});
const defaultShapeUtils = [
  TextShapeUtil,
  BookmarkShapeUtil,
  DrawShapeUtil,
  GeoShapeUtil,
  NoteShapeUtil,
  LineShapeUtil,
  FrameShapeUtil,
  ArrowShapeUtil,
  HighlightShapeUtil,
  EmbedShapeUtil,
  ImageShapeUtil,
  VideoShapeUtil
];
var __create$2 = Object.create;
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __knownSymbol$2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$2 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$2 = (base2) => [, , , __create$2(null)];
var __decoratorStrings$2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$2("Function expected") : fn;
var __decoratorContext$2 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$2[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$2("Already initialized") : fns.push(__expectFn$2(fn || null)) });
var __decoratorMetadata$2 = (array2, target) => __defNormalProp$2(target, __knownSymbol$2("metadata"), array2[3]);
var __runInitializers$2 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$2 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$2[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$2(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$2(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$2(it) && (desc[key] = it);
  }
  return desc && __defProp$2(target, name, desc), target;
};
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
var _dispose_dec, _init$2;
const INITIAL_POINTER_LAG_DURATION = 20;
const FAST_POINTER_LAG_DURATION = 100;
_dispose_dec = [bind$1];
class DragAndDropManager {
  constructor(editor) {
    this.editor = editor;
    __runInitializers$2(_init$2, 5, this);
    __publicField$2(this, "prevDroppingShapeId", null);
    __publicField$2(this, "droppingNodeTimer", null);
    __publicField$2(this, "first", true);
    editor.disposables.add(this.dispose);
  }
  updateDroppingNode(movingShapes, cb) {
    if (this.first) {
      this.editor.setHintingShapes(
        movingShapes.map((s2) => this.editor.findShapeAncestor(s2, (v) => v.type !== "group")).filter((s2) => s2)
      );
      this.prevDroppingShapeId = this.editor.getDroppingOverShape(this.editor.inputs.originPagePoint, movingShapes)?.id ?? null;
      this.first = false;
    }
    if (this.droppingNodeTimer === null) {
      this.setDragTimer(movingShapes, INITIAL_POINTER_LAG_DURATION, cb);
    } else if (this.editor.inputs.pointerVelocity.len() > 0.5) {
      clearTimeout(this.droppingNodeTimer);
      this.setDragTimer(movingShapes, FAST_POINTER_LAG_DURATION, cb);
    }
  }
  setDragTimer(movingShapes, duration, cb) {
    this.droppingNodeTimer = this.editor.timers.setTimeout(() => {
      this.editor.run(() => {
        this.handleDrag(this.editor.inputs.currentPagePoint, movingShapes, cb);
      });
      this.droppingNodeTimer = null;
    }, duration);
  }
  handleDrag(point, movingShapes, cb) {
    movingShapes = compact$1(movingShapes.map((shape) => this.editor.getShape(shape.id)));
    const nextDroppingShapeId = this.editor.getDroppingOverShape(point, movingShapes)?.id ?? null;
    if (nextDroppingShapeId === this.prevDroppingShapeId) {
      this.hintParents(movingShapes);
      return;
    }
    const { prevDroppingShapeId } = this;
    const prevDroppingShape = prevDroppingShapeId && this.editor.getShape(prevDroppingShapeId);
    const nextDroppingShape = nextDroppingShapeId && this.editor.getShape(nextDroppingShapeId);
    if (prevDroppingShape) {
      this.editor.getShapeUtil(prevDroppingShape).onDragShapesOut?.(prevDroppingShape, movingShapes);
    }
    if (nextDroppingShape) {
      this.editor.getShapeUtil(nextDroppingShape).onDragShapesOver?.(nextDroppingShape, movingShapes);
    }
    this.hintParents(movingShapes);
    cb?.();
    this.prevDroppingShapeId = nextDroppingShapeId;
  }
  hintParents(movingShapes) {
    const shapesGroupedByAncestor = /* @__PURE__ */ new Map();
    for (const shape of movingShapes) {
      const ancestor = this.editor.findShapeAncestor(shape, (v) => v.type !== "group");
      if (!ancestor) continue;
      if (!shapesGroupedByAncestor.has(ancestor.id)) {
        shapesGroupedByAncestor.set(ancestor.id, []);
      }
      shapesGroupedByAncestor.get(ancestor.id).push(shape.id);
    }
    const hintingShapes = [];
    for (const [ancestorId, shapeIds] of shapesGroupedByAncestor) {
      const ancestor = this.editor.getShape(ancestorId);
      if (!ancestor) continue;
      if (getOccludedChildren(this.editor, ancestor).length < shapeIds.length) {
        hintingShapes.push(ancestor.id);
      }
    }
    this.editor.setHintingShapes(hintingShapes);
  }
  dropShapes(shapes) {
    const { prevDroppingShapeId } = this;
    this.handleDrag(this.editor.inputs.currentPagePoint, shapes);
    if (prevDroppingShapeId) {
      const shape = this.editor.getShape(prevDroppingShapeId);
      if (!shape) return;
      this.editor.getShapeUtil(shape).onDropShapesOver?.(shape, shapes);
    }
  }
  clear() {
    this.prevDroppingShapeId = null;
    if (this.droppingNodeTimer !== null) {
      clearTimeout(this.droppingNodeTimer);
    }
    this.droppingNodeTimer = null;
    this.editor.setHintingShapes([]);
    this.first = true;
  }
  dispose() {
    this.clear();
  }
}
_init$2 = __decoratorStart$2();
__decorateElement$2(_init$2, 1, "dispose", _dispose_dec, DragAndDropManager);
__decoratorMetadata$2(_init$2, DragAndDropManager);
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __knownSymbol$1 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError$1 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart$1 = (base2) => [, , , __create$1(base2?.[__knownSymbol$1("metadata")] ?? null)];
var __decoratorStrings$1 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn$1 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError$1("Function expected") : fn;
var __decoratorContext$1 = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings$1[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError$1("Already initialized") : fns.push(__expectFn$1(fn || null)) });
var __decoratorMetadata$1 = (array2, target) => __defNormalProp$1(target, __knownSymbol$1("metadata"), array2[3]);
var __runInitializers$1 = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement$1 = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings$1[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc$1(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext$1(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn$1(it) && (desc[key] = it);
  }
  return desc && __defProp$1(target, name, desc), target;
};
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var _updateParentTransforms_dec, _a, _init$1;
class Translating extends (_a = StateNode, _updateParentTransforms_dec = [bind$1], _a) {
  constructor() {
    super(...arguments);
    __runInitializers$1(_init$1, 5, this);
    __publicField$1(this, "info", {});
    __publicField$1(this, "selectionSnapshot", {});
    __publicField$1(this, "snapshot", {});
    __publicField$1(this, "markId", "");
    __publicField$1(this, "isCloning", false);
    __publicField$1(this, "isCreating", false);
    __publicField$1(this, "dragAndDropManager", new DragAndDropManager(this.editor));
  }
  onCreate(_shape) {
    return;
  }
  onEnter(info) {
    const { isCreating = false, creatingMarkId, onCreate = () => void 0 } = info;
    if (!this.editor.getSelectedShapeIds()?.length) {
      this.parent.transition("idle");
      return;
    }
    this.info = info;
    this.parent.setCurrentToolIdMask(info.onInteractionEnd);
    this.isCreating = isCreating;
    this.markId = "";
    if (isCreating) {
      if (creatingMarkId) {
        this.markId = creatingMarkId;
      } else {
        const markId = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        if (markId) {
          this.markId = markId;
        }
      }
    } else {
      this.markId = this.editor.markHistoryStoppingPoint("translating");
    }
    this.onCreate = onCreate;
    this.isCloning = false;
    this.info = info;
    this.editor.setCursor({ type: "move", rotation: 0 });
    this.selectionSnapshot = getTranslatingSnapshot(this.editor);
    if (!this.isCreating) {
      if (this.editor.inputs.altKey) {
        this.startCloning();
        return;
      }
    }
    this.snapshot = this.selectionSnapshot;
    this.handleStart();
    this.updateShapes();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0);
    this.selectionSnapshot = {};
    this.snapshot = {};
    this.editor.snaps.clearIndicators();
    this.editor.setCursor({ type: "default", rotation: 0 });
    this.dragAndDropManager.clear();
  }
  onTick({ elapsed }) {
    const { editor } = this;
    this.dragAndDropManager.updateDroppingNode(
      this.snapshot.movingShapes,
      this.updateParentTransforms
    );
    editor.edgeScrollManager.updateEdgeScrolling(elapsed);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    if (this.editor.inputs.altKey && !this.isCloning) {
      this.startCloning();
      return;
    }
    this.updateShapes();
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  startCloning() {
    if (this.isCreating) return;
    this.isCloning = true;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate cloning");
    this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds()));
    this.snapshot = getTranslatingSnapshot(this.editor);
    this.handleStart();
    this.updateShapes();
  }
  stopCloning() {
    this.isCloning = false;
    this.snapshot = this.selectionSnapshot;
    this.reset();
    this.markId = this.editor.markHistoryStoppingPoint("translate");
    this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    this.updateShapes();
    this.dragAndDropManager.dropShapes(this.snapshot.movingShapes);
    kickoutOccludedShapes(
      this.editor,
      this.snapshot.movingShapes.map((s2) => s2.id)
    );
    this.handleEnd();
    if (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd);
    } else {
      if (this.isCreating) {
        this.onCreate?.(this.editor.getOnlySelectedShape());
      } else {
        this.parent.transition("idle");
      }
    }
  }
  cancel() {
    this.reset();
    if (this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd);
    } else {
      this.parent.transition("idle", this.info);
    }
  }
  handleStart() {
    const { movingShapes } = this.snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      const util2 = this.editor.getShapeUtil(shape);
      const change = util2.onTranslateStart?.(shape);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
    this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes } = this.snapshot;
    if (this.isCloning && movingShapes.length > 0) {
      const currentAveragePagePoint = Vec.Average(
        movingShapes.map((s2) => this.editor.getShapePageTransform(s2.id).point())
      );
      const offset2 = Vec.Sub(currentAveragePagePoint, this.selectionSnapshot.averagePagePoint);
      if (!Vec.IsNaN(offset2)) {
        this.editor.updateInstanceState({
          duplicateProps: {
            shapeIds: movingShapes.map((s2) => s2.id),
            offset: { x: offset2.x, y: offset2.y }
          }
        });
      }
    }
    const changes = [];
    movingShapes.forEach((shape) => {
      const current = this.editor.getShape(shape.id);
      const util2 = this.editor.getShapeUtil(shape);
      const change = util2.onTranslateEnd?.(shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateShapes() {
    const { snapshot } = this;
    this.dragAndDropManager.updateDroppingNode(snapshot.movingShapes, this.updateParentTransforms);
    moveShapesToPoint({
      editor: this.editor,
      snapshot
    });
    const { movingShapes } = snapshot;
    const changes = [];
    movingShapes.forEach((shape) => {
      const current = this.editor.getShape(shape.id);
      const util2 = this.editor.getShapeUtil(shape);
      const change = util2.onTranslate?.(shape, current);
      if (change) {
        changes.push(change);
      }
    });
    if (changes.length > 0) {
      this.editor.updateShapes(changes);
    }
  }
  updateParentTransforms() {
    const {
      editor,
      snapshot: { shapeSnapshots }
    } = this;
    shapeSnapshots.forEach((shapeSnapshot) => {
      const shape = editor.getShape(shapeSnapshot.shape.id);
      if (!shape) return null;
      const parentTransform = isPageId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      shapeSnapshot.parentTransform = parentTransform;
    });
  }
}
_init$1 = __decoratorStart$1(_a);
__decorateElement$1(_init$1, 1, "updateParentTransforms", _updateParentTransforms_dec, Translating);
__decoratorMetadata$1(_init$1, Translating);
__publicField$1(Translating, "id", "translating");
function getTranslatingSnapshot(editor) {
  const movingShapes = [];
  const pagePoints = [];
  const selectedShapeIds = editor.getSelectedShapeIds();
  const shapeSnapshots = compact$1(
    selectedShapeIds.map((id) => {
      const shape = editor.getShape(id);
      if (!shape) return null;
      movingShapes.push(shape);
      const pageTransform = editor.getShapePageTransform(id);
      const pagePoint = pageTransform.point();
      const pageRotation = pageTransform.rotation();
      pagePoints.push(pagePoint);
      const parentTransform = PageRecordType.isId(shape.parentId) ? null : Mat.Inverse(editor.getShapePageTransform(shape.parentId));
      return {
        shape,
        pagePoint,
        pageRotation,
        parentTransform
      };
    })
  );
  const onlySelectedShape = editor.getOnlySelectedShape();
  let initialSnapPoints = [];
  if (onlySelectedShape) {
    initialSnapPoints = editor.snaps.shapeBounds.getSnapPoints(onlySelectedShape.id);
  } else {
    const selectionPageBounds = editor.getSelectionPageBounds();
    if (selectionPageBounds) {
      initialSnapPoints = selectionPageBounds.cornersAndCenter.map((p, i) => ({
        id: "selection:" + i,
        x: p.x,
        y: p.y
      }));
    }
  }
  let noteAdjacentPositions;
  let noteSnapshot;
  const { originPagePoint } = editor.inputs;
  const allHoveredNotes = shapeSnapshots.filter(
    (s2) => editor.isShapeOfType(s2.shape, "note") && editor.isPointInShape(s2.shape, originPagePoint)
  );
  if (allHoveredNotes.length === 0) ;
  else if (allHoveredNotes.length === 1) {
    noteSnapshot = allHoveredNotes[0];
  } else {
    const allShapesSorted = editor.getCurrentPageShapesSorted();
    noteSnapshot = allHoveredNotes.map((s2) => ({
      snapshot: s2,
      index: allShapesSorted.findIndex((shape) => shape.id === s2.shape.id)
    })).sort((a2, b) => b.index - a2.index)[0]?.snapshot;
  }
  if (noteSnapshot) {
    noteAdjacentPositions = getAvailableNoteAdjacentPositions(
      editor,
      noteSnapshot.pageRotation,
      noteSnapshot.shape.props.scale,
      noteSnapshot.shape.props.growY ?? 0
    );
  }
  return {
    averagePagePoint: Vec.Average(pagePoints),
    movingShapes,
    shapeSnapshots,
    initialPageBounds: editor.getSelectionPageBounds(),
    initialSnapPoints,
    noteAdjacentPositions,
    noteSnapshot
  };
}
function moveShapesToPoint({
  editor,
  snapshot
}) {
  const { inputs } = editor;
  const {
    noteSnapshot,
    noteAdjacentPositions,
    initialPageBounds,
    initialSnapPoints,
    shapeSnapshots,
    averagePagePoint
  } = snapshot;
  const isGridMode = editor.getInstanceState().isGridMode;
  const gridSize = editor.getDocumentSettings().gridSize;
  const delta = Vec.Sub(inputs.currentPagePoint, inputs.originPagePoint);
  const flatten = editor.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
  if (flatten === "x") {
    delta.x = 0;
  } else if (flatten === "y") {
    delta.y = 0;
  }
  editor.snaps.clearIndicators();
  const isSnapping = editor.user.getIsSnapMode() ? !inputs.ctrlKey : inputs.ctrlKey;
  let snappedToPit = false;
  if (isSnapping && editor.inputs.pointerVelocity.len() < 0.5) {
    const { nudge } = editor.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: delta,
      initialSelectionPageBounds: initialPageBounds,
      lockedAxis: flatten,
      initialSelectionSnapPoints: initialSnapPoints
    });
    delta.add(nudge);
  } else {
    if (noteSnapshot && noteAdjacentPositions) {
      const { scale } = noteSnapshot.shape.props;
      const pageCenter = noteSnapshot.pagePoint.clone().add(delta).add(NOTE_CENTER_OFFSET.clone().mul(scale).rot(noteSnapshot.pageRotation));
      let min2 = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel();
      let offset2 = new Vec(0, 0);
      for (const pit of noteAdjacentPositions) {
        const deltaToPit = Vec.Sub(pageCenter, pit);
        const dist = deltaToPit.len();
        if (dist < min2) {
          snappedToPit = true;
          min2 = dist;
          offset2 = deltaToPit;
        }
      }
      delta.sub(offset2);
    }
  }
  const averageSnappedPoint = Vec.Add(averagePagePoint, delta);
  const snapIndicators = editor.snaps.getIndicators();
  if (isGridMode && !inputs.ctrlKey && !snappedToPit && snapIndicators.length === 0) {
    averageSnappedPoint.snapToGrid(gridSize);
  }
  const averageSnap = Vec.Sub(averageSnappedPoint, averagePagePoint);
  editor.updateShapes(
    compact$1(
      shapeSnapshots.map(({ shape, pagePoint, parentTransform }) => {
        const newPagePoint = Vec.Add(pagePoint, averageSnap);
        const newLocalPoint = parentTransform ? Mat.applyToPoint(parentTransform, newPagePoint) : newPagePoint;
        return {
          id: shape.id,
          type: shape.type,
          x: newLocalPoint.x,
          y: newLocalPoint.y
        };
      })
    )
  );
}
function FollowingIndicator() {
  const editor = useEditor();
  const followingUserId = useValue("follow", () => editor.getInstanceState().followingUserId, [
    editor
  ]);
  if (!followingUserId) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FollowingIndicatorInner, { userId: followingUserId });
}
function FollowingIndicatorInner({ userId }) {
  const presence = usePresence$1(userId);
  if (!presence) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-following-indicator", style: { borderColor: presence.color } });
}
let defaultEditorAssetUrls = {
  fonts: {
    tldraw_mono: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Medium.woff2`,
    tldraw_mono_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-MediumItalic.woff2`,
    tldraw_mono_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-Bold.woff2`,
    tldraw_mono_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexMono-BoldItalic.woff2`,
    tldraw_serif: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Medium.woff2`,
    tldraw_serif_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-MediumItalic.woff2`,
    tldraw_serif_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-Bold.woff2`,
    tldraw_serif_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSerif-BoldItalic.woff2`,
    tldraw_sans: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Medium.woff2`,
    tldraw_sans_italic: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-MediumItalic.woff2`,
    tldraw_sans_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-Bold.woff2`,
    tldraw_sans_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/IBMPlexSans-BoldItalic.woff2`,
    tldraw_draw: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular.woff2`,
    tldraw_draw_italic: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Regular_Italic.woff2`,
    tldraw_draw_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold.woff2`,
    tldraw_draw_italic_bold: `${getDefaultCdnBaseUrl()}/fonts/Shantell_Sans-Informal_Bold_Italic.woff2`
  }
};
const iconTypes = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "arrow-arc",
  "arrow-elbow",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bold",
  "bookmark",
  "bring-forward",
  "bring-to-front",
  "broken",
  "bulletList",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "code",
  "color",
  "comment",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "heading",
  "help-circle",
  "highlight",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "italic",
  "leading",
  "link",
  "list",
  "lock",
  "manual",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "strike",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "underline",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
let defaultUiAssetUrls = {
  ...defaultEditorAssetUrls,
  icons: Object.fromEntries(
    iconTypes.map((name) => [name, `${getDefaultCdnBaseUrl()}/icons/icon/0_merged.svg#${name}`])
  ),
  translations: Object.fromEntries(
    LANGUAGES.map((lang) => [
      lang.locale,
      `${getDefaultCdnBaseUrl()}/translations/${lang.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    DEFAULT_EMBED_DEFINITIONS.map((def) => [
      def.type,
      `${getDefaultCdnBaseUrl()}/embed-icons/${def.type}.png`
    ])
  )
};
function useDefaultUiAssetUrlsWithOverrides(overrides) {
  if (!overrides) return defaultUiAssetUrls;
  return {
    fonts: Object.assign({ ...defaultUiAssetUrls.fonts }, { ...overrides?.fonts }),
    icons: Object.assign({ ...defaultUiAssetUrls.icons }, { ...overrides?.icons }),
    embedIcons: Object.assign({ ...defaultUiAssetUrls.embedIcons }, { ...overrides?.embedIcons }),
    translations: Object.assign(
      { ...defaultUiAssetUrls.translations },
      { ...overrides?.translations }
    )
  };
}
function TldrawUiPopover({ id, children, onOpenChange, open }) {
  const [isOpen, handleOpenChange] = useMenuIsOpen(id, onOpenChange);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$2, { onOpenChange: handleOpenChange, open: open || isOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-popover", children }) });
}
function TldrawUiPopoverTrigger({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { asChild: true, dir: "ltr", children });
}
function TldrawUiPopoverContent({
  side,
  children,
  align = "center",
  sideOffset = 8,
  alignOffset = 0,
  disableEscapeKeyDown = false,
  autoFocusFirstButton = true
}) {
  const container = useContainer();
  const ref = React.useRef(null);
  const handleOpenAutoFocus = React.useCallback(() => {
    if (!autoFocusFirstButton) return;
    const buttons = ref.current?.querySelectorAll("button:not([disabled])") ?? [];
    const visibleButtons = [...buttons].filter(
      (button) => button.offsetWidth || button.offsetHeight
    );
    const firstButton = visibleButtons[0];
    if (firstButton) firstButton.focus();
  }, [autoFocusFirstButton]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content22,
    {
      className: "tlui-popover__content",
      side,
      sideOffset,
      align,
      alignOffset,
      dir: "ltr",
      ref,
      onOpenAutoFocus: handleOpenAutoFocus,
      onEscapeKeyDown: (e) => disableEscapeKeyDown && e.preventDefault(),
      children
    }
  ) });
}
function shapesWithUnboundArrows(editor) {
  const selectedShapeIds = editor.getSelectedShapeIds();
  const selectedShapes = selectedShapeIds.map((id) => {
    return editor.getShape(id);
  });
  return selectedShapes.filter((shape) => {
    if (!shape) return false;
    if (editor.isShapeOfType(shape, "arrow")) {
      const bindings = getArrowBindings(editor, shape);
      if (bindings.start || bindings.end) return false;
    }
    return true;
  });
}
const useThreeStackableItems = () => {
  const editor = useEditor();
  return useValue("threeStackableItems", () => shapesWithUnboundArrows(editor).length > 2, [editor]);
};
const useIsInSelectState = () => {
  const editor = useEditor();
  return useValue("isInSelectState", () => editor.isIn("select"), [editor]);
};
const useAllowGroup = () => {
  const editor = useEditor();
  return useValue(
    "allow group",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length < 2) return false;
      for (const shape of selectedShapes) {
        if (editor.isShapeOfType(shape, "arrow")) {
          const bindings = getArrowBindings(editor, shape);
          if (bindings.start) {
            if (!selectedShapes.some((s2) => s2.id === bindings.start.toId)) {
              return false;
            }
          }
          if (bindings.end) {
            if (!selectedShapes.some((s2) => s2.id === bindings.end.toId)) {
              return false;
            }
          }
        }
      }
      return true;
    },
    [editor]
  );
};
const useAllowUngroup = () => {
  const editor = useEditor();
  return useValue(
    "allowUngroup",
    () => editor.getSelectedShapeIds().some((id) => editor.getShape(id)?.type === "group"),
    [editor]
  );
};
const showMenuPaste = typeof window !== "undefined" && "navigator" in window && Boolean(navigator.clipboard) && Boolean(navigator.clipboard.read);
function useAnySelectedShapesCount(min2, max2) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().length;
      {
        {
          return len >= min2;
        }
      }
    },
    [editor, min2, max2]
  );
}
function useUnlockedSelectedShapesCount(min2, max2) {
  const editor = useEditor();
  return useValue(
    "selectedShapes",
    () => {
      const len = editor.getSelectedShapes().filter((s2) => !editor.isShapeOrAncestorLocked(s2)).length;
      if (min2 === void 0) {
        {
          return len;
        }
      } else {
        {
          return len >= min2;
        }
      }
    },
    [editor]
  );
}
function useShowAutoSizeToggle() {
  const editor = useEditor();
  return useValue(
    "showAutoSizeToggle",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      return selectedShapes.length === 1 && editor.isShapeOfType(selectedShapes[0], "text") && selectedShapes[0].props.autoSize === false;
    },
    [editor]
  );
}
function useHasLinkShapeSelected() {
  const editor = useEditor();
  return useValue(
    "hasLinkShapeSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      return !!(onlySelectedShape && onlySelectedShape.type !== "embed" && "url" in onlySelectedShape.props && !onlySelectedShape.isLocked);
    },
    [editor]
  );
}
function useOnlyFlippableShape() {
  const editor = useEditor();
  return useValue(
    "onlyFlippableShape",
    () => {
      const shape = editor.getOnlySelectedShape();
      return shape && (editor.isShapeOfType(shape, "group") || editor.isShapeOfType(shape, "image") || editor.isShapeOfType(shape, "arrow") || editor.isShapeOfType(shape, "line") || editor.isShapeOfType(shape, "draw"));
    },
    [editor]
  );
}
function useCanRedo() {
  const editor = useEditor();
  return useValue("useCanRedo", () => editor.getCanRedo(), [editor]);
}
function useCanUndo() {
  const editor = useEditor();
  return useValue("useCanUndo", () => editor.getCanUndo(), [editor]);
}
function DefaultActionsMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AlignMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DistributeMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StackMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ReorderMenuItems, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomOrRotateMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCWMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkMenuItem$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(GroupOrUngroupMenuItem, {})
  ] });
}
function AlignMenuItems() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-left", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-right", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-top", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-vertical", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-bottom", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-vertical", disabled: !enabled })
  ] });
}
function DistributeMenuItems() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  const isInSelectState = useIsInSelectState();
  const enabled = threeSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-vertical", disabled: !enabled })
  ] });
}
function StackMenuItems() {
  const threeStackableItems = useThreeStackableItems();
  const isInSelectState = useIsInSelectState();
  const enabled = threeStackableItems && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-horizontal", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-vertical", disabled: !enabled })
  ] });
}
function ReorderMenuItems() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-to-back", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-backward", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-forward", disabled: !enabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-to-front", disabled: !enabled })
  ] });
}
function ZoomOrRotateMenuItem() {
  const breakpoint = useBreakpoint();
  return breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM ? /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTo100MenuItem$1, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCCWMenuItem, {});
}
function ZoomTo100MenuItem$1() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoom is 1", () => editor.getZoomLevel() === 1, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-100", disabled: isZoomedTo100 });
}
function RotateCCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "rotate-ccw", disabled: !enabled });
}
function RotateCWMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const enabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "rotate-cw", disabled: !enabled });
}
function EditLinkMenuItem$1() {
  const showEditLink = useHasLinkShapeSelected();
  const isInSelectState = useIsInSelectState();
  const enabled = showEditLink && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "edit-link", disabled: !enabled });
}
function GroupOrUngroupMenuItem() {
  const allowGroup = useAllowGroup();
  const allowUngroup = useAllowUngroup();
  return allowGroup ? /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem$1, {}) : allowUngroup ? /* @__PURE__ */ jsxRuntimeExports.jsx(UngroupMenuItem$1, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem$1, {});
}
function GroupMenuItem$1() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const isInSelectState = useIsInSelectState();
  const enabled = twoSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "group", disabled: !enabled });
}
function UngroupMenuItem$1() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "ungroup" });
}
const DefaultActionsMenu = reactExports.memo(function DefaultActionsMenu2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const editor = useEditor();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions when in readonly",
    () => editor.isInAny("hand", "zoom"),
    [editor]
  );
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultActionsMenuContent, {});
  if (isReadonlyMode && !isInAcceptableReadonlyState) return;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: "actions-menu", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        type: "icon",
        "data-testid": "actions-menu.button",
        title: msg2("actions-menu.title"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dots-vertical", small: true })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiPopoverContent,
      {
        side: breakpoint >= PORTRAIT_BREAKPOINT.TABLET ? "bottom" : "top",
        sideOffset: 6,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbar,
          {
            ref,
            label: msg2("actions-menu.title"),
            className: "tlui-actions-menu tlui-buttons__grid",
            "data-testid": "actions-menu.content",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "actions-menu", children: content })
          }
        )
      }
    )
  ] });
});
function ToggleAutoSizeMenuItem() {
  const shouldDisplay = useShowAutoSizeToggle();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-auto-size" });
}
function EditLinkMenuItem() {
  const shouldDisplay = useHasLinkShapeSelected();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "edit-link" });
}
function DuplicateMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "duplicate" });
}
function FlattenMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "should display flatten option",
    () => {
      const selectedShapeIds = editor.getSelectedShapeIds();
      if (selectedShapeIds.length === 0) return false;
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, "image")) {
        return false;
      }
      return true;
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flatten-to-image" });
}
function GroupMenuItem() {
  const shouldDisplay = useAllowGroup();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "group" });
}
function UngroupMenuItem() {
  const shouldDisplay = useAllowUngroup();
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "ungroup" });
}
function RemoveFrameMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow unframe",
    () => {
      const selectedShapes = editor.getSelectedShapes();
      if (selectedShapes.length === 0) return false;
      return selectedShapes.every((shape) => editor.isShapeOfType(shape, "frame"));
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "remove-frame" });
}
function FitFrameToContentMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue(
    "allow fit frame to content",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return editor.isShapeOfType(onlySelectedShape, "frame") && editor.getSortedChildIdsForParent(onlySelectedShape).length > 0;
    },
    [editor]
  );
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "fit-frame-to-content" });
}
function ToggleLockMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("selected shapes", () => editor.getSelectedShapes().length > 0, [
    editor
  ]);
  if (!shouldDisplay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-lock" });
}
function ToggleTransparentBgMenuItem() {
  const editor = useEditor();
  const isTransparentBg = useValue(
    "isTransparentBg",
    () => !editor.getInstanceState().exportBackground,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-transparent",
      checked: isTransparentBg,
      toggle: true
    }
  );
}
function UnlockAllMenuItem() {
  const editor = useEditor();
  const shouldDisplay = useValue("any shapes", () => editor.getCurrentPageShapeIds().size > 0, [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "unlock-all", disabled: !shouldDisplay });
}
function ZoomTo100MenuItem() {
  const editor = useEditor();
  const isZoomedTo100 = useValue("zoomed to 100", () => editor.getZoomLevel() === 1, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-100", noClose: true, disabled: isZoomedTo100 });
}
function ZoomToFitMenuItem() {
  const editor = useEditor();
  const hasShapes = useValue("has shapes", () => editor.getCurrentPageShapeIds().size > 0, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-fit",
      disabled: !hasShapes,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: true
    }
  );
}
function ZoomToSelectionMenuItem() {
  const editor = useEditor();
  const hasSelected = useValue("has shapes", () => editor.getSelectedShapeIds().length > 0, [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionItem,
    {
      actionId: "zoom-to-selection",
      disabled: !hasSelected,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: true
    }
  );
}
function ClipboardMenuGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "clipboard", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CutMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CopyMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PasteMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DuplicateMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteMenuItem, {})
  ] });
}
function CopyAsMenuGroup() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TldrawUiMenuSubmenu,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !atLeastOneShapeOnPage,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "copy-as-group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy-as-svg" }),
          Boolean(window.navigator.clipboard?.write) && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy-as-png" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "copy-as-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleTransparentBgMenuItem, {}) })
      ]
    }
  );
}
function CutMenuItem() {
  const shouldDisplay = useUnlockedSelectedShapesCount(1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "cut", disabled: !shouldDisplay });
}
function CopyMenuItem() {
  const shouldDisplay = useAnySelectedShapesCount(1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy", disabled: !shouldDisplay });
}
function PasteMenuItem() {
  const shouldDisplay = showMenuPaste;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "paste", disabled: !shouldDisplay });
}
function ConversionsMenuGroup() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  if (!atLeastOneShapeOnPage) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "conversions", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CopyAsMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "export-as-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-as-svg" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-as-png" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "export-as-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleTransparentBgMenuItem, {}) })
    ] })
  ] });
}
function SelectAllMenuItem() {
  const editor = useEditor();
  const atLeastOneShapeOnPage = useValue(
    "atLeastOneShapeOnPage",
    () => editor.getCurrentPageShapeIds().size > 0,
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "select-all", disabled: !atLeastOneShapeOnPage });
}
function DeleteMenuItem() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "delete", disabled: !oneSelected });
}
function EditMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  if (!useAnySelectedShapesCount(1)) return null;
  if (isReadonlyMode) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "edit", label: "context-menu.edit", size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UngroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FlattenMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FitFrameToContentMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveFrameMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToEmbedMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToBookmarkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleAutoSizeMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleLockMenuItem, {})
  ] });
}
function ArrangeMenuSubmenu() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const onlyFlippableShapeSelected = useOnlyFlippableShape();
  const isReadonlyMode = useReadonly();
  if (isReadonlyMode) return null;
  if (!(twoSelected || onlyFlippableShapeSelected)) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    twoSelected && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "align", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-left" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-right" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-top" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-bottom" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DistributeMenuGroup, {}),
    twoSelected && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "stretch", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stretch-vertical" })
    ] }),
    (twoSelected || onlyFlippableShapeSelected) && /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "flip", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-vertical" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OrderMenuGroup, {})
  ] });
}
function DistributeMenuGroup() {
  const threeSelected = useUnlockedSelectedShapesCount(3);
  if (!threeSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "distribute", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-horizontal" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "distribute-vertical" })
  ] });
}
function OrderMenuGroup() {
  const twoSelected = useUnlockedSelectedShapesCount(2);
  const threeStackableItems = useThreeStackableItems();
  if (!twoSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "order", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "pack" }),
    threeStackableItems && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-horizontal" }),
    threeStackableItems && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "stack-vertical" })
  ] });
}
function ReorderMenuSubmenu() {
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (isReadonlyMode) return null;
  if (!oneSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "reorder", label: "context-menu.reorder", size: "small", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "reorder", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-backward" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-to-back" })
  ] }) });
}
function MoveToPageMenu() {
  const editor = useEditor();
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPageId = useValue("current page id", () => editor.getCurrentPageId(), [editor]);
  const { addToast } = useToasts();
  const trackEvent = useUiEvents();
  const isReadonlyMode = useReadonly();
  const oneSelected = useUnlockedSelectedShapesCount(1);
  if (!oneSelected) return null;
  if (isReadonlyMode) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "pages", children: pages.map((page) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiMenuItem,
      {
        id: page.id,
        disabled: currentPageId === page.id,
        label: page.name.length > 30 ? `${page.name.slice(0, 30)}…` : page.name,
        onSelect: () => {
          editor.markHistoryStoppingPoint("move_shapes_to_page");
          editor.moveShapesToPage(editor.getSelectedShapeIds(), page.id);
          const toPage = editor.getPage(page.id);
          if (toPage) {
            addToast({
              title: "Changed Page",
              description: `Moved to ${toPage.name}.`,
              actions: [
                {
                  label: "Go Back",
                  type: "primary",
                  onClick: () => {
                    editor.markHistoryStoppingPoint("change-page");
                    editor.setCurrentPage(currentPageId);
                  }
                }
              ]
            });
          }
          trackEvent("move-to-page", { source: "context-menu" });
        }
      },
      page.id
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "new-page", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "move-to-new-page" }) })
  ] });
}
function ConvertToBookmarkMenuItem() {
  const editor = useEditor();
  const oneEmbedSelected = useValue(
    "oneEmbedSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "embed") && onlySelectedShape.props.url && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbedSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "convert-to-bookmark" });
}
function ConvertToEmbedMenuItem() {
  const editor = useEditor();
  const getEmbedDefinition = useGetEmbedDefinition();
  const oneEmbeddableBookmarkSelected = useValue(
    "oneEmbeddableBookmarkSelected",
    () => {
      const onlySelectedShape = editor.getOnlySelectedShape();
      if (!onlySelectedShape) return false;
      return !!(editor.isShapeOfType(onlySelectedShape, "bookmark") && onlySelectedShape.props.url && getEmbedDefinition(onlySelectedShape.props.url) && !editor.isShapeOrAncestorLocked(onlySelectedShape));
    },
    [editor]
  );
  if (!oneEmbeddableBookmarkSelected) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "convert-to-embed" });
}
function ToggleSnapModeItem() {
  const editor = useEditor();
  const isSnapMode = useValue("isSnapMode", () => editor.user.getIsSnapMode(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-snap-mode", checked: isSnapMode });
}
function ToggleToolLockItem() {
  const editor = useEditor();
  const isToolLock = useValue("isToolLock", () => editor.getInstanceState().isToolLocked, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-tool-lock", checked: isToolLock });
}
function ToggleGridItem() {
  const editor = useEditor();
  const isGridMode = useValue("isGridMode", () => editor.getInstanceState().isGridMode, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-grid", checked: isGridMode });
}
function ToggleWrapModeItem() {
  const editor = useEditor();
  const isWrapMode = useValue("isWrapMode", () => editor.user.getIsWrapMode(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-wrap-mode", checked: isWrapMode });
}
function ToggleFocusModeItem() {
  const editor = useEditor();
  const isFocusMode = useValue("isFocusMode", () => editor.getInstanceState().isFocusMode, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-focus-mode", checked: isFocusMode });
}
function ToggleEdgeScrollingItem() {
  const editor = useEditor();
  const edgeScrollSpeed = useValue("edgeScrollSpeed", () => editor.user.getEdgeScrollSpeed(), [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-edge-scrolling",
      checked: edgeScrollSpeed === 1
    }
  );
}
function ToggleReduceMotionItem() {
  const editor = useEditor();
  const animationSpeed = useValue("animationSpeed", () => editor.user.getAnimationSpeed(), [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-reduce-motion",
      checked: animationSpeed === 0
    }
  );
}
function ToggleDebugModeItem() {
  const editor = useEditor();
  const isDebugMode = useValue("isDebugMode", () => editor.getInstanceState().isDebugMode, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-debug-mode", checked: isDebugMode });
}
function ToggleDynamicSizeModeItem() {
  const editor = useEditor();
  const isDynamicResizeMode = useValue(
    "dynamic resize",
    () => editor.user.getIsDynamicResizeMode(),
    [editor]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionCheckboxItem,
    {
      actionId: "toggle-dynamic-size-mode",
      checked: isDynamicResizeMode
    }
  );
}
function TogglePasteAtCursorItem() {
  const editor = useEditor();
  const pasteAtCursor = useValue("paste at cursor", () => editor.user.getIsPasteAtCursorMode(), [
    editor
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionCheckboxItem, { actionId: "toggle-paste-at-cursor", checked: pasteAtCursor });
}
function CursorChatItem() {
  const editor = useEditor();
  const shouldShow = useValue(
    "show cursor chat",
    () => editor.getCurrentToolId() === "select" && !editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  if (!shouldShow) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" });
}
function DefaultContextMenuContent() {
  const editor = useEditor();
  const showCollaborationUi = useShowCollaborationUi();
  const selectToolActive = useValue(
    "isSelectToolActive",
    () => editor.getCurrentToolId() === "select",
    [editor]
  );
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  if (!selectToolActive) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showCollaborationUi && /* @__PURE__ */ jsxRuntimeExports.jsx(CursorChatItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "modify", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EditMenuSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrangeMenuSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReorderMenuSubmenu, {}),
      !isSinglePageMode && /* @__PURE__ */ jsxRuntimeExports.jsx(MoveToPageMenu, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConversionsMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "select-all", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectAllMenuItem, {}) })
  ] });
}
const DefaultContextMenu = reactExports.memo(function DefaultContextMenu2({
  children,
  disabled = false
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const { Canvas } = useEditorComponents();
  const cb = reactExports.useCallback(
    (isOpen2) => {
      if (!isOpen2) {
        const onlySelectedShape = editor.getOnlySelectedShape();
        if (onlySelectedShape && editor.isShapeOrAncestorLocked(onlySelectedShape)) {
          editor.setSelectedShapes([]);
        }
      } else {
        if (editor.getInstanceState().isCoarsePointer) {
          const selectedShapes = editor.getSelectedShapes();
          const {
            inputs: { currentPagePoint }
          } = editor;
          const shapesAtPoint = editor.getShapesAtPoint(currentPagePoint);
          if (
            // if there are no selected shapes
            !editor.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !shapesAtPoint.some((s2) => selectedShapes.includes(s2))
          ) {
            const lockedShapes = shapesAtPoint.filter((s2) => editor.isShapeOrAncestorLocked(s2));
            if (lockedShapes.length) {
              editor.select(...lockedShapes.map((s2) => s2.id));
            }
          }
        }
      }
    },
    [editor]
  );
  const container = useContainer();
  const [isOpen, handleOpenChange] = useMenuIsOpen("context menu", cb);
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContextMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$4, { dir: "ltr", onOpenChange: handleOpenChange, modal: false, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$2, { onContextMenu: void 0, dir: "ltr", disabled, children: Canvas ? /* @__PURE__ */ jsxRuntimeExports.jsx(Canvas, {}) : null }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2$1, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$2,
      {
        className: "tlui-menu scrollable",
        "data-testid": "context-menu",
        "aria-label": msg2("context-menu.title"),
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: preventDefault,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "context-menu", sourceId: "context-menu", children: content })
      }
    ) })
  ] });
});
const CHAT_MESSAGE_TIMEOUT_CLOSING = 2e3;
const CHAT_MESSAGE_TIMEOUT_CHATTING = 5e3;
const CursorChatBubble = track(function CursorChatBubble2() {
  const editor = useEditor();
  const { isChatting, chatMessage } = editor.getInstanceState();
  const rTimeout = reactExports.useRef(-1);
  const [value, setValue] = reactExports.useState("");
  reactExports.useEffect(() => {
    const closingUp = !isChatting && chatMessage;
    if (closingUp || isChatting) {
      const duration = isChatting ? CHAT_MESSAGE_TIMEOUT_CHATTING : CHAT_MESSAGE_TIMEOUT_CLOSING;
      rTimeout.current = editor.timers.setTimeout(() => {
        editor.updateInstanceState({ chatMessage: "", isChatting: false });
        setValue("");
        editor.focus();
      }, duration);
    }
    return () => {
      clearTimeout(rTimeout.current);
    };
  }, [editor, chatMessage, isChatting]);
  if (isChatting)
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CursorChatInput, { value, setValue, chatMessage });
  return chatMessage.trim() ? /* @__PURE__ */ jsxRuntimeExports.jsx(NotEditingChatMessage, { chatMessage }) : null;
});
function usePositionBubble(ref) {
  const editor = useEditor();
  reactExports.useLayoutEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    const { x, y: y2 } = editor.inputs.currentScreenPoint;
    ref.current?.style.setProperty("transform", `translate(${x}px, ${y2}px)`);
    function positionChatBubble(e) {
      const { minX, minY } = editor.getViewportScreenBounds();
      ref.current?.style.setProperty(
        "transform",
        `translate(${e.clientX - minX}px, ${e.clientY - minY}px)`
      );
    }
    window.addEventListener("pointermove", positionChatBubble);
    return () => {
      window.removeEventListener("pointermove", positionChatBubble);
    };
  }, [ref, editor]);
}
const NotEditingChatMessage = ({ chatMessage }) => {
  const editor = useEditor();
  const ref = reactExports.useRef(null);
  usePositionBubble(ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: editor.user.getColor() },
      children: chatMessage
    }
  );
};
const CursorChatInput = track(function CursorChatInput2({
  chatMessage,
  value,
  setValue
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  const placeholder = chatMessage || msg2("cursor-chat.type-to-chat");
  usePositionBubble(ref);
  reactExports.useLayoutEffect(() => {
    const elm = ref.current;
    if (!elm) return;
    const textMeasurement = editor.textMeasure.measureText(value || placeholder, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    elm.style.setProperty("width", textMeasurement.w + "px");
  }, [editor, value, placeholder]);
  reactExports.useLayoutEffect(() => {
    const raf = editor.timers.requestAnimationFrame(() => {
      ref.current?.focus();
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [editor]);
  const stopChatting = reactExports.useCallback(() => {
    editor.updateInstanceState({ isChatting: false });
    editor.focus();
  }, [editor]);
  const handleChange = reactExports.useCallback(
    (e) => {
      const { value: value2 } = e.target;
      setValue(value2.slice(0, 64));
      editor.updateInstanceState({ chatMessage: value2 });
    },
    [editor, setValue]
  );
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      const elm = ref.current;
      if (!elm) return;
      const { value: currentValue } = elm;
      switch (e.key) {
        case "Enter": {
          preventDefault(e);
          e.stopPropagation();
          if (!currentValue) {
            stopChatting();
            return;
          }
          setValue("");
          break;
        }
        case "Escape": {
          preventDefault(e);
          e.stopPropagation();
          stopChatting();
          break;
        }
      }
    },
    [stopChatting, setValue]
  );
  const handlePaste = reactExports.useCallback((e) => {
    e.stopPropagation();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      ref,
      className: `tl-cursor-chat`,
      style: { backgroundColor: editor.user.getColor() },
      onBlur: stopChatting,
      onChange: handleChange,
      onKeyDown: handleKeyDown2,
      onPaste: handlePaste,
      value,
      placeholder,
      spellCheck: false
    }
  );
});
function TldrawUiButtonCheck({ checked }) {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiIcon,
    {
      label: msg2(checked ? "ui.checked" : "ui.unchecked"),
      icon: checked ? "check" : "none",
      className: "tlui-button__icon",
      small: true
    }
  );
}
function DefaultDebugMenuContent() {
  const editor = useEditor();
  const { addToast } = useToasts();
  const { addDialog } = useDialogs();
  const [error, setError] = React.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "items", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "hard-reset", onSelect: hardResetEditor, label: "Hard reset" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "add-toast",
          onSelect: () => {
            addToast({
              id: uniqueId(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "success"
            });
            addToast({
              id: uniqueId(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: true,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            });
            addToast({
              id: uniqueId(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: true
            });
          },
          label: untranslated("Show toast")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            addDialog({
              component: ({ onClose }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                ExampleDialog,
                {
                  displayDontShowAgain: true,
                  onCancel: () => onClose(),
                  onContinue: () => onClose()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => createNShapes(editor, 100)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            const selectedShapes = editor.getSelectedShapes();
            const shapes = selectedShapes.length === 0 ? editor.getRenderingShapes() : selectedShapes;
            window.alert(
              `Shapes ${shapes.length}, DOM nodes:${document.querySelector(".tl-shapes").querySelectorAll("*")?.length}`
            );
          }
        }
      ),
      (() => {
        if (error) throw Error("oh no!");
        return null;
      })(),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "throw-error", onSelect: () => setError(true), label: "Throw error" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "flags", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DebugFlags, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureFlags, {})
    ] })
  ] });
}
function DebugFlags() {
  const items = Object.values(debugFlags);
  if (!items.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "debug flags", label: "Debug Flags", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "debug flags", children: items.map((flag) => /* @__PURE__ */ jsxRuntimeExports.jsx(DebugFlagToggle, { flag }, flag.name)) }) });
}
function FeatureFlags() {
  const items = Object.values(featureFlags);
  if (!items.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "feature flags", label: "Feature Flags", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "feature flags", children: items.map((flag) => /* @__PURE__ */ jsxRuntimeExports.jsx(DebugFlagToggle, { flag }, flag.name)) }) });
}
function ExampleDialog({
  title = "title",
  body = "hello hello hello",
  cancel = "Cancel",
  confirm = "Continue",
  displayDontShowAgain = false,
  maxWidth = "350",
  onCancel,
  onContinue
}) {
  const [dontShowAgain, setDontShowAgain] = React.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogBody, { style: { maxWidth }, children: body }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogFooter, { className: "tlui-dialog__footer__actions", children: [
      displayDontShowAgain && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        TldrawUiButton,
        {
          type: "normal",
          onClick: () => setDontShowAgain(!dontShowAgain),
          style: { marginRight: "auto" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonCheck, { checked: dontShowAgain }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: "Don’t show again" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "normal", onClick: onCancel, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: cancel }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "primary", onClick: async () => onContinue(), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: confirm }) })
    ] })
  ] });
}
const DebugFlagToggle = track(function DebugFlagToggle2({
  flag,
  onChange
}) {
  const value = flag.get();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: flag.name,
      title: flag.name,
      label: flag.name.replace(/([a-z0-9])([A-Z])/g, (m) => `${m[0]} ${m[1].toLowerCase()}`).replace(/^[a-z]/, (m) => m.toUpperCase()),
      checked: value,
      onSelect: () => {
        flag.set(!value);
        onChange?.(!value);
      }
    }
  );
});
let t = 0;
function createNShapes(editor, n2) {
  const gap = editor.options.adjacentShapeMargin;
  const shapesToCreate = Array(n2);
  const cols = Math.floor(Math.sqrt(n2));
  for (let i = 0; i < n2; i++) {
    t++;
    shapesToCreate[i] = {
      id: createShapeId("box" + t),
      type: "geo",
      x: i % cols * (100 + gap),
      y: Math.floor(i / cols) * (100 + gap)
    };
  }
  editor.run(() => {
    editor.createShapes(shapesToCreate).setSelectedShapes(shapesToCreate.map((s2) => s2.id));
  });
}
function DefaultDebugMenu({ children }) {
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultDebugMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: "debug", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "icon", title: "Debug menu", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dots-horizontal" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "debug-panel", children: content }) })
  ] });
}
const DefaultDebugPanel = reactExports.memo(function DefaultDebugPanel2() {
  const { DebugMenu } = useTldrawUiComponents();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { ref, className: "tlui-debug-panel", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CurrentState, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FPS, {}),
    DebugMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugMenu, {})
  ] });
});
function useTick(isEnabled = true) {
  const [_, setTick] = reactExports.useState(0);
  const editor = useEditor();
  reactExports.useEffect(() => {
    if (!isEnabled) return;
    const update = () => setTick((tick2) => tick2 + 1);
    editor.on("tick", update);
    return () => {
      editor.off("tick", update);
    };
  }, [editor, isEnabled]);
}
const CurrentState = track(function CurrentState2() {
  useTick();
  const editor = useEditor();
  const path = editor.getPath();
  const hoverShape = editor.getHoveredShape();
  const selectedShape = editor.getOnlySelectedShape();
  const shape = path === "select.idle" || !path.includes("select.") ? hoverShape : selectedShape;
  const shapeInfo = shape && path.includes("select.") ? ` / ${shape.type || ""}${"geo" in shape.props ? " / " + shape.props.geo : ""} / [${Vec.ToInt(editor.getPointInShapeSpace(shape, editor.inputs.currentPagePoint))}]` : "";
  const ruler = path.startsWith("select.") && !path.includes(".idle") ? ` / [${Vec.ToInt(editor.inputs.originPagePoint)}] → [${Vec.ToInt(
    editor.inputs.currentPagePoint
  )}] = ${Vec.Dist(editor.inputs.originPagePoint, editor.inputs.currentPagePoint).toFixed(0)}` : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-debug-panel__current-state", children: `${path}${shapeInfo}${ruler}` });
});
function FPS() {
  const editor = useEditor();
  const showFps = useValue("show_fps", () => debugFlags.showFps.get(), [debugFlags]);
  const fpsRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!showFps) return;
    const TICK_LENGTH = 250;
    let maxKnownFps = 0;
    let raf = -1;
    let start = performance.now();
    let currentTickLength = 0;
    let framesInCurrentTick = 0;
    let isSlow = false;
    function loop() {
      framesInCurrentTick++;
      currentTickLength = performance.now() - start;
      if (currentTickLength > TICK_LENGTH) {
        const fps = Math.round(
          framesInCurrentTick * (TICK_LENGTH / currentTickLength) * (1e3 / TICK_LENGTH)
        );
        if (fps > maxKnownFps) {
          maxKnownFps = fps;
        }
        const slowFps = maxKnownFps * 0.75;
        if (fps < slowFps && !isSlow || fps >= slowFps && isSlow) {
          isSlow = !isSlow;
        }
        fpsRef.current.innerHTML = `FPS ${fps.toString()}`;
        fpsRef.current.className = `tlui-debug-panel__fps` + (isSlow ? ` tlui-debug-panel__fps__slow` : ``);
        currentTickLength -= TICK_LENGTH;
        framesInCurrentTick = 0;
        start = performance.now();
      }
      raf = editor.timers.requestAnimationFrame(loop);
    }
    loop();
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [showFps, editor]);
  if (!showFps) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: fpsRef });
}
const DefaultMenuPanel = reactExports.memo(function MenuPanel() {
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const { MainMenu, QuickActions, ActionsMenu, PageMenu } = useTldrawUiComponents();
  const editor = useEditor();
  const isSinglePageMode = useValue("isSinglePageMode", () => editor.options.maxPages <= 1, [
    editor
  ]);
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? true : editor.options.actionShortcutsLocation === "toolbar" ? false : breakpoint >= PORTRAIT_BREAKPOINT.TABLET;
  if (!MainMenu && !PageMenu && !showQuickActions) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { ref, className: "tlui-menu-zone", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-buttons__horizontal", children: [
    MainMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(MainMenu, {}),
    PageMenu && !isSinglePageMode && /* @__PURE__ */ jsxRuntimeExports.jsx(PageMenu, {}),
    showQuickActions ? /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { className: "tlui-buttons__horizontal", label: msg2("actions-menu.title"), children: [
      QuickActions && /* @__PURE__ */ jsxRuntimeExports.jsx(QuickActions, {}),
      ActionsMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsMenu, {})
    ] }) : null
  ] }) });
});
function BackToContent() {
  const editor = useEditor();
  const actions = useActions();
  const [showBackToContent, setShowBackToContent] = reactExports.useState(false);
  const rIsShowing = reactExports.useRef(false);
  useQuickReactor(
    "toggle showback to content",
    () => {
      const showBackToContentPrev = rIsShowing.current;
      const shapeIds = editor.getCurrentPageShapeIds();
      let showBackToContentNow = false;
      if (shapeIds.size) {
        showBackToContentNow = shapeIds.size === editor.getCulledShapes().size;
      }
      if (showBackToContentPrev !== showBackToContentNow) {
        setShowBackToContent(showBackToContentNow);
        rIsShowing.current = showBackToContentNow;
      }
    },
    [editor]
  );
  if (!showBackToContent) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuActionItem,
    {
      actionId: "back-to-content",
      onSelect: () => {
        actions["back-to-content"].onSelect("helper-buttons");
        setShowBackToContent(false);
      }
    }
  );
}
function ExitPenMode() {
  const editor = useEditor();
  const isPenMode = useValue("is pen mode", () => editor.getInstanceState().isPenMode, [editor]);
  if (!isPenMode) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "exit-pen-mode" });
}
function StopFollowing() {
  const editor = useEditor();
  const actions = useActions();
  const followingUser = useValue(
    "is following user",
    () => !!editor.getInstanceState().followingUserId,
    [editor]
  );
  if (!followingUser) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { ...actions["stop-following"] });
}
function DefaultHelperButtonsContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ExitPenMode, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BackToContent, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StopFollowing, {})
  ] });
}
function DefaultHelperButtons({ children }) {
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultHelperButtonsContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-helper-buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "helper-buttons", sourceId: "helper-buttons", children: content }) });
}
function DefaultKeyboardShortcutsDialogContent() {
  const showCollaborationUi = useShowCollaborationUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.tools", id: "tools", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-tool-lock" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "insert-media" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "select" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "draw" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "eraser" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "hand" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "rectangle" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "ellipse" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "arrow" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "line" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "text" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "frame" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "note" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "laser" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "pointer-down",
          label: "tool.pointer-down",
          kbd: ",",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-dark-mode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-focus-mode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "toggle-grid" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.edit", id: "edit", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "undo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "redo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "cut" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "copy" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "paste" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "select-all" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "delete" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "duplicate" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.view", id: "view", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-100" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-fit" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-to-selection" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.transform", id: "transform", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-to-front" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "bring-forward" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-backward" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "send-to-back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "group" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "ungroup" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "flip-vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-top" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-bottom" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-left" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "align-right" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.text-formatting", id: "text", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-bold",
          label: "tool.rich-text-bold",
          kbd: "cmd+b",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-italic",
          label: "tool.rich-text-italic",
          kbd: "cmd+i",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-code",
          label: "tool.rich-text-code",
          kbd: "cmd+e",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-highlight",
          label: "tool.rich-text-highlight",
          kbd: "cmd+shift+h",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-strikethrough",
          label: "tool.rich-text-strikethrough",
          kbd: "cmd+shift+s",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-link",
          label: "tool.rich-text-link",
          kbd: "cmd+shift+k",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-header",
          label: "tool.rich-text-header",
          kbd: "cmd+shift+[[1-6]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-orderedList",
          label: "tool.rich-text-orderedList",
          kbd: "cmd+shift+7",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "text-bulletedlist",
          label: "tool.rich-text-bulletList",
          kbd: "cmd+shift+8",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { label: "shortcuts-dialog.a11y", id: "a11y", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape",
          label: "a11y.select-shape",
          kbd: "[[Tab]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-direction",
          label: "a11y.select-shape-direction",
          kbd: "cmd+↑→↓←",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-select-next-shape-container",
          label: "a11y.enter-leave-container",
          kbd: "cmd+shift+↑→",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-pan-camera",
          label: "a11y.pan-camera",
          kbd: "[[Space]]+↑→↓←",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "adjust-shape-styles",
          label: "a11y.adjust-shape-styles",
          kbd: "$+[[Enter]]",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape",
          label: "a11y.move-shape",
          kbd: "↑→↓←",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiMenuItem,
        {
          id: "a11y-move-shape-faster",
          label: "a11y.move-shape-faster",
          kbd: "shift+↑→↓←",
          onSelect: () => {
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "enlarge-shapes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "shrink-shapes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "a11y-repeat-shape-announce" })
    ] }),
    showCollaborationUi && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "open-cursor-chat" }) })
  ] });
}
const DefaultKeyboardShortcutsDialog = reactExports.memo(function DefaultKeyboardShortcutsDialog2({
  children
}) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultKeyboardShortcutsDialogContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDialogHeader, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogTitle, { children: msg2("shortcuts-dialog.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogCloseButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiDialogBody,
      {
        className: classNames("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": breakpoint <= PORTRAIT_BREAKPOINT.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": breakpoint <= PORTRAIT_BREAKPOINT.TABLET
        }),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "keyboard-shortcuts", sourceId: "kbd", children: content })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
});
function LanguageMenu() {
  const editor = useMaybeEditor();
  const trackEvent = useUiEvents();
  const currentLanguage = useValue("locale", () => editor?.user.getLocale(), [editor]);
  if (!editor) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "help menu language", label: "menu.language", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "languages", className: "tlui-language-menu", children: LANGUAGES.map(({ locale, label }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuCheckboxItem,
    {
      id: `language-${locale}`,
      title: locale,
      label,
      checked: locale === currentLanguage,
      readonlyOk: true,
      onSelect: () => {
        editor.user.updateUserPreferences({ locale });
        trackEvent("change-language", { source: "menu", locale });
      }
    },
    locale
  )) }) });
}
function DefaultHelpMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageMenu, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardShortcutsMenuItem, {})
  ] });
}
function KeyboardShortcutsMenuItem() {
  const { KeyboardShortcutsDialog } = useTldrawUiComponents();
  const { addDialog } = useDialogs();
  const handleSelect = reactExports.useCallback(() => {
    if (KeyboardShortcutsDialog) addDialog({ component: KeyboardShortcutsDialog });
  }, [addDialog, KeyboardShortcutsDialog]);
  if (!KeyboardShortcutsDialog) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiMenuItem,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: true,
      onSelect: handleSelect
    }
  );
}
function DefaultMainMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "basic", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EditSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ViewSubmenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ExportFileContentSubMenu, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ExtrasGroup, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PreferencesGroup, {})
  ] });
}
function ExportFileContentSubMenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "export-all-as-group", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-all-as-svg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "export-all-as-png" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "export-all-as-bg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleTransparentBgMenuItem, {}) })
  ] });
}
function EditSubmenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "edit", label: "menu.edit", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UndoRedoGroup$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ClipboardMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConversionsMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MiscMenuGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LockGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "select-all", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectAllMenuItem, {}) })
  ] });
}
function MiscMenuGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "misc", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UngroupMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditLinkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleAutoSizeMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveFrameMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FitFrameToContentMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToEmbedMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConvertToBookmarkMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FlattenMenuItem, {})
  ] });
}
function LockGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "lock", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleLockMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UnlockAllMenuItem, {})
  ] });
}
function UndoRedoGroup$1() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "undo-redo", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}
function ViewSubmenu() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuSubmenu, { id: "view", label: "menu.view", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "view-actions", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-in" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-out" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTo100MenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToFitMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToSelectionMenuItem, {})
  ] }) });
}
function ExtrasGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "insert-embed" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "insert-media" })
  ] });
}
function PreferencesGroup() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "preferences", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuSubmenu, { id: "preferences", label: "menu.preferences", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "preferences-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleSnapModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleToolLockItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGridItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleWrapModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleFocusModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleEdgeScrollingItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleReduceMotionItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleDynamicSizeModeItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TogglePasteAtCursorItem, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleDebugModeItem, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "color-scheme", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ColorSchemeMenu, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageMenu, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(KeyboardShortcutsMenuItem, {})
  ] });
}
const DefaultMainMenu = reactExports.memo(function DefaultMainMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("main menu");
  const msg2 = useTranslation();
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultMainMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$3, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { asChild: true, dir: "ltr", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "icon", "data-testid": "main-menu.button", title: msg2("menu.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "menu", small: true }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$1,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "main-menu", children: content })
      }
    ) })
  ] });
});
const memo = {};
function getRgba(colorString) {
  if (memo[colorString]) {
    return memo[colorString];
  }
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.fillStyle = colorString;
  context.fillRect(0, 0, 1, 1);
  const [r2, g, b, a2] = context.getImageData(0, 0, 1, 1).data;
  const result = new Float32Array([r2 / 255, g / 255, b / 255, a2 / 255]);
  memo[colorString] = result;
  return result;
}
const numArcSegmentsPerCorner = 10;
const roundedRectangleDataSize = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * numArcSegmentsPerCorner + // num triangles in center rect
  12 + 4 * 12
);
function pie(array2, {
  center,
  radius,
  numArcSegments = 20,
  startAngle = 0,
  endAngle = PI2,
  offset: offset2 = 0
}) {
  const angle = (endAngle - startAngle) / numArcSegments;
  let i = offset2;
  for (let a2 = startAngle; a2 < endAngle; a2 += angle) {
    array2[i++] = center.x;
    array2[i++] = center.y;
    array2[i++] = center.x + Math.cos(a2) * radius;
    array2[i++] = center.y + Math.sin(a2) * radius;
    array2[i++] = center.x + Math.cos(a2 + angle) * radius;
    array2[i++] = center.y + Math.sin(a2 + angle) * radius;
  }
  return array2;
}
function rectangle(array2, offset2, x, y2, w, h) {
  array2[offset2++] = x;
  array2[offset2++] = y2;
  array2[offset2++] = x;
  array2[offset2++] = y2 + h;
  array2[offset2++] = x + w;
  array2[offset2++] = y2;
  array2[offset2++] = x + w;
  array2[offset2++] = y2;
  array2[offset2++] = x;
  array2[offset2++] = y2 + h;
  array2[offset2++] = x + w;
  array2[offset2++] = y2 + h;
}
function roundedRectangle(data, box, radius) {
  const numArcSegments = numArcSegmentsPerCorner;
  radius = Math.min(radius, Math.min(box.w, box.h) / 2);
  const innerBox = Box.ExpandBy(box, -radius);
  if (innerBox.w <= 0 || innerBox.h <= 0) {
    pie(data, { center: box.center, radius, numArcSegments: numArcSegmentsPerCorner * 4 });
    return numArcSegmentsPerCorner * 4 * 6;
  }
  let offset2 = 0;
  rectangle(data, offset2, innerBox.minX, innerBox.minY, innerBox.w, innerBox.h);
  offset2 += 12;
  rectangle(data, offset2, innerBox.minX, box.minY, innerBox.w, radius);
  offset2 += 12;
  rectangle(data, offset2, innerBox.maxX, innerBox.minY, radius, innerBox.h);
  offset2 += 12;
  rectangle(data, offset2, innerBox.minX, innerBox.maxY, innerBox.w, radius);
  offset2 += 12;
  rectangle(data, offset2, box.minX, innerBox.minY, radius, innerBox.h);
  offset2 += 12;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: innerBox.point,
    radius,
    startAngle: PI$1,
    endAngle: PI$1 * 1.5
  });
  offset2 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: Vec.Add(innerBox.point, new Vec(innerBox.w, 0)),
    radius,
    startAngle: PI$1 * 1.5,
    endAngle: PI2
  });
  offset2 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: Vec.Add(innerBox.point, innerBox.size),
    radius,
    startAngle: 0,
    endAngle: HALF_PI
  });
  offset2 += numArcSegments * 6;
  pie(data, {
    numArcSegments,
    offset: offset2,
    center: Vec.Add(innerBox.point, new Vec(0, innerBox.h)),
    radius,
    startAngle: HALF_PI,
    endAngle: PI$1
  });
  return roundedRectangleDataSize;
}
function setupWebGl(canvas) {
  if (!canvas) throw new Error("Canvas element not found");
  const context = canvas.getContext("webgl2", {
    premultipliedAlpha: false
  });
  if (!context) throw new Error("Failed to get webgl2 context");
  const vertexShaderSourceCode = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`;
  const vertexShader = context.createShader(context.VERTEX_SHADER);
  if (!vertexShader) {
    throw new Error("Failed to create vertex shader");
  }
  context.shaderSource(vertexShader, vertexShaderSourceCode);
  context.compileShader(vertexShader);
  if (!context.getShaderParameter(vertexShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile vertex shader");
  }
  const fragmentShaderSourceCode = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`;
  const fragmentShader = context.createShader(context.FRAGMENT_SHADER);
  if (!fragmentShader) {
    throw new Error("Failed to create fragment shader");
  }
  context.shaderSource(fragmentShader, fragmentShaderSourceCode);
  context.compileShader(fragmentShader);
  if (!context.getShaderParameter(fragmentShader, context.COMPILE_STATUS)) {
    throw new Error("Failed to compile fragment shader");
  }
  const program = context.createProgram();
  if (!program) {
    throw new Error("Failed to create program");
  }
  context.attachShader(program, vertexShader);
  context.attachShader(program, fragmentShader);
  context.linkProgram(program);
  if (!context.getProgramParameter(program, context.LINK_STATUS)) {
    throw new Error("Failed to link program");
  }
  context.useProgram(program);
  const shapeVertexPositionAttributeLocation = context.getAttribLocation(
    program,
    "shapeVertexPosition"
  );
  if (shapeVertexPositionAttributeLocation < 0) {
    throw new Error("Failed to get shapeVertexPosition attribute location");
  }
  context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
  const canvasPageBoundsLocation = context.getUniformLocation(program, "canvasPageBounds");
  const fillColorLocation = context.getUniformLocation(program, "fillColor");
  const selectedShapesBuffer = context.createBuffer();
  if (!selectedShapesBuffer) throw new Error("Failed to create buffer");
  const unselectedShapesBuffer = context.createBuffer();
  if (!unselectedShapesBuffer) throw new Error("Failed to create buffer");
  return {
    context,
    selectedShapes: allocateBuffer(context, 1024),
    unselectedShapes: allocateBuffer(context, 4096),
    viewport: allocateBuffer(context, roundedRectangleDataSize),
    collaborators: allocateBuffer(context, 1024),
    prepareTriangles(stuff, len) {
      context.bindBuffer(context.ARRAY_BUFFER, stuff.buffer);
      context.bufferData(context.ARRAY_BUFFER, stuff.vertices, context.STATIC_DRAW, 0, len);
      context.enableVertexAttribArray(shapeVertexPositionAttributeLocation);
      context.vertexAttribPointer(
        shapeVertexPositionAttributeLocation,
        2,
        context.FLOAT,
        false,
        0,
        0
      );
    },
    drawTrianglesTransparently(len) {
      context.enable(context.BLEND);
      context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
      context.drawArrays(context.TRIANGLES, 0, len / 2);
      context.disable(context.BLEND);
    },
    drawTriangles(len) {
      context.drawArrays(context.TRIANGLES, 0, len / 2);
    },
    setFillColor(color) {
      context.uniform4fv(fillColorLocation, color);
    },
    setCanvasPageBounds(bounds) {
      context.uniform4fv(canvasPageBoundsLocation, bounds);
    }
  };
}
function allocateBuffer(context, size2) {
  const buffer = context.createBuffer();
  if (!buffer) throw new Error("Failed to create buffer");
  return { buffer, vertices: new Float32Array(size2) };
}
function appendVertices(bufferStuff, offset2, data) {
  let len = bufferStuff.vertices.length;
  while (len < offset2 + data.length) {
    len *= 2;
  }
  if (len != bufferStuff.vertices.length) {
    const newVertices = new Float32Array(len);
    newVertices.set(bufferStuff.vertices);
    bufferStuff.vertices = newVertices;
  }
  bufferStuff.vertices.set(data, offset2);
}
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart = (base2) => [, , , __create(null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind2, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind2], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array2, target) => __defNormalProp(target, __knownSymbol("metadata"), array2[3]);
var __runInitializers = (array2, flags, self2, value) => {
  for (var i = 0, fns = array2[flags >> 1], n2 = fns && fns.length; i < n2; i++) fns[i].call(self2);
  return value;
};
var __decorateElement = (array2, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p = false;
  var j = 2, key = __decoratorStrings[k + 5];
  var extraInitializers = array2[j] || (array2[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc(target, name));
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array2[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i])(desc[key], ctx), done._ = 1;
    __expectFn(it) && (desc[key] = it);
  }
  return desc && __defProp(target, name, desc), target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _render_dec, _getCanvasPageBoundsArray_dec, _getZoom_dec, _getCanvasPageBounds_dec, _getCanvasClientPosition_dec, _getCanvasSize_dec, _getContentScreenBounds_dec, _getContentPageBounds_dec, _getDpr_dec, _close_dec, _init;
_close_dec = [bind$1], _getDpr_dec = [computed], _getContentPageBounds_dec = [computed], _getContentScreenBounds_dec = [computed], _getCanvasSize_dec = [computed], _getCanvasClientPosition_dec = [computed], _getCanvasPageBounds_dec = [computed], _getZoom_dec = [computed], _getCanvasPageBoundsArray_dec = [computed], _render_dec = [bind$1];
class MinimapManager {
  constructor(editor, elem, container) {
    this.editor = editor;
    this.elem = elem;
    this.container = container;
    __runInitializers(_init, 5, this);
    __publicField(this, "disposables", []);
    __publicField(this, "gl");
    __publicField(this, "shapeGeometryCache");
    __publicField(this, "colors");
    __publicField(this, "id", uniqueId());
    __publicField(this, "canvasBoundingClientRect", atom("canvasBoundingClientRect", new Box()));
    __publicField(this, "originPagePoint", new Vec());
    __publicField(this, "originPageCenter", new Vec());
    __publicField(this, "isInViewport", false);
    this.gl = setupWebGl(elem);
    this.shapeGeometryCache = editor.store.createComputedCache("webgl-geometry", (r2) => {
      const bounds = editor.getShapeMaskedPageBounds(r2.id);
      if (!bounds) return null;
      const arr = new Float32Array(12);
      rectangle(arr, 0, bounds.x, bounds.y, bounds.w, bounds.h);
      return arr;
    });
    this.colors = this._getColors();
    this.disposables.push(this._listenForCanvasResize(), react$1("minimap render", this.render));
  }
  close() {
    return this.disposables.forEach((d) => d());
  }
  _getColors() {
    const style2 = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: getRgba(style2.getPropertyValue("--color-text-3").trim()),
      selectFill: getRgba(style2.getPropertyValue("--color-selected").trim()),
      viewportFill: getRgba(style2.getPropertyValue("--color-muted-1").trim()),
      background: getRgba(style2.getPropertyValue("--color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const viewportPageBounds = this.editor.getViewportPageBounds();
    const commonShapeBounds = this.editor.getCurrentPageBounds();
    return commonShapeBounds ? Box.Expand(commonShapeBounds, viewportPageBounds) : viewportPageBounds;
  }
  getContentScreenBounds() {
    const contentPageBounds = this.getContentPageBounds();
    const topLeft = this.editor.pageToScreen(contentPageBounds.point);
    const bottomRight = this.editor.pageToScreen(
      new Vec(contentPageBounds.maxX, contentPageBounds.maxY)
    );
    return new Box(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
  }
  _getCanvasBoundingRect() {
    const { x, y: y2, width, height } = this.elem.getBoundingClientRect();
    return new Box(x, y2, width, height);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const observer = new ResizeObserver(() => {
      const rect = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(rect);
    });
    observer.observe(this.elem);
    observer.observe(this.container);
    return () => observer.disconnect();
  }
  getCanvasSize() {
    const rect = this.canvasBoundingClientRect.get();
    const dpr = this.getDpr();
    return new Vec(rect.width * dpr, rect.height * dpr);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const canvasScreenBounds = this.getCanvasScreenBounds();
    const contentPageBounds = this.getContentPageBounds();
    const aspectRatio = canvasScreenBounds.width / canvasScreenBounds.height;
    let targetWidth = contentPageBounds.width;
    let targetHeight = targetWidth / aspectRatio;
    if (targetHeight < contentPageBounds.height) {
      targetHeight = contentPageBounds.height;
      targetWidth = targetHeight * aspectRatio;
    }
    const box = new Box(0, 0, targetWidth, targetHeight);
    box.center = contentPageBounds.center;
    return box;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x, y: y2, w, h } = this.getCanvasPageBounds();
    return new Float32Array([x, y2, w, h]);
  }
  getMinimapPagePoint(clientX, clientY) {
    const canvasPageBounds = this.getCanvasPageBounds();
    const canvasScreenBounds = this.getCanvasScreenBounds();
    let x = clientX - canvasScreenBounds.x;
    let y2 = clientY - canvasScreenBounds.y;
    x *= canvasPageBounds.width / canvasScreenBounds.width;
    y2 *= canvasPageBounds.height / canvasScreenBounds.height;
    x += canvasPageBounds.minX;
    y2 += canvasPageBounds.minY;
    return new Vec(x, y2, 1);
  }
  minimapScreenPointToPagePoint(x, y2, shiftKey = false, clampToBounds = false) {
    const { editor } = this;
    const vpPageBounds = editor.getViewportPageBounds();
    let { x: px, y: py } = this.getMinimapPagePoint(x, y2);
    if (clampToBounds) {
      const shapesPageBounds = this.editor.getCurrentPageBounds() ?? new Box();
      const minX = shapesPageBounds.minX - vpPageBounds.width / 2;
      const maxX = shapesPageBounds.maxX + vpPageBounds.width / 2;
      const minY = shapesPageBounds.minY - vpPageBounds.height / 2;
      const maxY = shapesPageBounds.maxY + vpPageBounds.height / 2;
      const lx = Math.max(0, minX + vpPageBounds.width - px);
      const rx = Math.max(0, -(maxX - vpPageBounds.width - px));
      const ly = Math.max(0, minY + vpPageBounds.height - py);
      const ry = Math.max(0, -(maxY - vpPageBounds.height - py));
      px += (lx - rx) / 2;
      py += (ly - ry) / 2;
      px = clamp$3(px, minX, maxX);
      py = clamp$3(py, minY, maxY);
    }
    if (shiftKey) {
      const { originPagePoint } = this;
      const dx = Math.abs(px - originPagePoint.x);
      const dy = Math.abs(py - originPagePoint.y);
      if (dx > dy) {
        py = originPagePoint.y;
      } else {
        px = originPagePoint.x;
      }
    }
    return new Vec(px, py);
  }
  render() {
    const context = this.gl.context;
    const canvasSize = this.getCanvasSize();
    this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray());
    this.elem.width = canvasSize.x;
    this.elem.height = canvasSize.y;
    context.viewport(0, 0, canvasSize.x, canvasSize.y);
    context.clearColor(
      this.colors.background[0],
      this.colors.background[1],
      this.colors.background[2],
      1
    );
    context.clear(context.COLOR_BUFFER_BIT);
    const selectedShapes = new Set(this.editor.getSelectedShapeIds());
    const colors = this.colors;
    let selectedShapeOffset = 0;
    let unselectedShapeOffset = 0;
    const ids = this.editor.getCurrentPageShapeIdsSorted();
    for (let i = 0, len = ids.length; i < len; i++) {
      const shapeId = ids[i];
      const geometry = this.shapeGeometryCache.get(shapeId);
      if (!geometry) continue;
      const len2 = geometry.length;
      if (selectedShapes.has(shapeId)) {
        appendVertices(this.gl.selectedShapes, selectedShapeOffset, geometry);
        selectedShapeOffset += len2;
      } else {
        appendVertices(this.gl.unselectedShapes, unselectedShapeOffset, geometry);
        unselectedShapeOffset += len2;
      }
    }
    this.drawShapes(this.gl.unselectedShapes, unselectedShapeOffset, colors.shapeFill);
    this.drawShapes(this.gl.selectedShapes, selectedShapeOffset, colors.selectFill);
    this.drawViewport();
    this.drawCollaborators();
  }
  drawShapes(stuff, len, color) {
    this.gl.prepareTriangles(stuff, len);
    this.gl.setFillColor(color);
    this.gl.drawTriangles(len);
  }
  drawViewport() {
    const viewport = this.editor.getViewportPageBounds();
    const len = roundedRectangle(this.gl.viewport.vertices, viewport, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, len);
    this.gl.setFillColor(this.colors.viewportFill);
    this.gl.drawTrianglesTransparently(len);
    if (tlenv.isSafari) {
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
      this.gl.drawTrianglesTransparently(len);
    }
  }
  drawCollaborators() {
    const collaborators = this.editor.getCollaboratorsOnCurrentPage();
    if (!collaborators.length) return;
    const numSegmentsPerCircle = 20;
    const dataSizePerCircle = numSegmentsPerCircle * 6;
    const totalSize = dataSizePerCircle * collaborators.length;
    if (this.gl.collaborators.vertices.length < totalSize) {
      this.gl.collaborators.vertices = new Float32Array(totalSize);
    }
    const vertices = this.gl.collaborators.vertices;
    let offset2 = 0;
    const zoom = this.getZoom();
    for (const { cursor } of collaborators) {
      if (!cursor) continue;
      pie(vertices, {
        center: Vec.From(cursor),
        radius: 3 * zoom,
        offset: offset2,
        numArcSegments: numSegmentsPerCircle
      });
      offset2 += dataSizePerCircle;
    }
    this.gl.prepareTriangles(this.gl.collaborators, totalSize);
    offset2 = 0;
    for (const { color } of collaborators) {
      this.gl.setFillColor(getRgba(color));
      this.gl.context.drawArrays(this.gl.context.TRIANGLES, offset2 / 2, dataSizePerCircle / 2);
      offset2 += dataSizePerCircle;
    }
  }
}
_init = __decoratorStart();
__decorateElement(_init, 1, "close", _close_dec, MinimapManager);
__decorateElement(_init, 1, "getDpr", _getDpr_dec, MinimapManager);
__decorateElement(_init, 1, "getContentPageBounds", _getContentPageBounds_dec, MinimapManager);
__decorateElement(_init, 1, "getContentScreenBounds", _getContentScreenBounds_dec, MinimapManager);
__decorateElement(_init, 1, "getCanvasSize", _getCanvasSize_dec, MinimapManager);
__decorateElement(_init, 1, "getCanvasClientPosition", _getCanvasClientPosition_dec, MinimapManager);
__decorateElement(_init, 1, "getCanvasPageBounds", _getCanvasPageBounds_dec, MinimapManager);
__decorateElement(_init, 1, "getZoom", _getZoom_dec, MinimapManager);
__decorateElement(_init, 1, "getCanvasPageBoundsArray", _getCanvasPageBoundsArray_dec, MinimapManager);
__decorateElement(_init, 1, "render", _render_dec, MinimapManager);
__decoratorMetadata(_init, MinimapManager);
function DefaultMinimap() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const rCanvas = reactExports.useRef(null);
  const rPointing = reactExports.useRef(false);
  const minimapRef = reactExports.useRef();
  reactExports.useEffect(() => {
    try {
      const minimap = new MinimapManager(editor, rCanvas.current, container);
      minimapRef.current = minimap;
      return minimapRef.current.close;
    } catch (e) {
      editor.annotateError(e, {
        origin: "minimap",
        willCrashApp: false
      });
      editor.timers.setTimeout(() => {
        throw e;
      });
    }
  }, [editor, container]);
  const onDoubleClick = reactExports.useCallback(
    (e) => {
      if (!editor.getCurrentPageShapeIds().size) return;
      if (!minimapRef.current) return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        true
      );
      minimapRef.current.originPagePoint.setTo(clampedPoint);
      minimapRef.current.originPageCenter.setTo(editor.getViewportPageBounds().center);
      editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
    },
    [editor]
  );
  const onPointerDown = reactExports.useCallback(
    (e) => {
      if (!minimapRef.current) return;
      const elm = e.currentTarget;
      setPointerCapture(elm, e);
      if (!editor.getCurrentPageShapeIds().size) return;
      rPointing.current = true;
      minimapRef.current.isInViewport = false;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        false,
        false
      );
      const _vpPageBounds = editor.getViewportPageBounds();
      const commonBounds = minimapRef.current.getContentPageBounds();
      const allowedBounds = new Box(
        commonBounds.x - _vpPageBounds.width / 2,
        commonBounds.y - _vpPageBounds.height / 2,
        commonBounds.width + _vpPageBounds.width,
        commonBounds.height + _vpPageBounds.height
      );
      if (allowedBounds.containsPoint(point) && !_vpPageBounds.containsPoint(point)) {
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(point);
        const delta = Vec.Sub(_vpPageBounds.center, _vpPageBounds.point);
        const pagePoint = Vec.Add(point, delta);
        minimapRef.current.originPagePoint.setTo(pagePoint);
        minimapRef.current.originPageCenter.setTo(point);
        editor.centerOnPoint(point, { animation: { duration: editor.options.animationMediumMs } });
      } else {
        const clampedPoint = minimapRef.current.minimapScreenPointToPagePoint(
          e.clientX,
          e.clientY,
          false,
          true
        );
        minimapRef.current.isInViewport = _vpPageBounds.containsPoint(clampedPoint);
        minimapRef.current.originPagePoint.setTo(clampedPoint);
        minimapRef.current.originPageCenter.setTo(_vpPageBounds.center);
      }
      function release(e2) {
        if (elm) {
          releasePointerCapture(elm, e2);
        }
        rPointing.current = false;
        document.body.removeEventListener("pointerup", release);
      }
      document.body.addEventListener("pointerup", release);
    },
    [editor]
  );
  const onPointerMove = reactExports.useCallback(
    (e) => {
      if (!minimapRef.current) return;
      const point = minimapRef.current.minimapScreenPointToPagePoint(
        e.clientX,
        e.clientY,
        e.shiftKey,
        true
      );
      if (rPointing.current) {
        if (minimapRef.current.isInViewport) {
          const delta = minimapRef.current.originPagePoint.clone().sub(minimapRef.current.originPageCenter);
          editor.centerOnPoint(Vec.Sub(point, delta));
          return;
        }
        editor.centerOnPoint(point);
      }
      const pagePoint = minimapRef.current.getMinimapPagePoint(e.clientX, e.clientY);
      const screenPoint = editor.pageToScreen(pagePoint);
      const info = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...getPointerInfo(e),
        point: screenPoint,
        isPen: editor.getInstanceState().isPenMode
      };
      editor.dispatch(info);
    },
    [editor]
  );
  const onWheel = reactExports.useCallback(
    (e) => {
      const offset2 = normalizeWheel(e);
      editor.dispatch({
        type: "wheel",
        name: "wheel",
        delta: offset2,
        point: new Vec(e.clientX, e.clientY),
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e)
      });
    },
    [editor]
  );
  const isDarkMode = useIsDarkMode();
  reactExports.useEffect(() => {
    editor.timers.setTimeout(() => {
      minimapRef.current?.updateColors();
      minimapRef.current?.render();
    });
  }, [isDarkMode, editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "canvas",
    {
      role: "img",
      "aria-label": msg2("navigation-zone.minimap"),
      ref: rCanvas,
      className: "tlui-minimap__canvas",
      onDoubleClick,
      onPointerMove,
      onPointerDown,
      onWheelCapture: onWheel
    }
  ) });
}
function useLocalStorageState(key, defaultValue) {
  const [state, setState] = React.useState(defaultValue);
  React.useLayoutEffect(() => {
    const value = getFromLocalStorage(key);
    if (value) {
      try {
        setState(JSON.parse(value));
      } catch {
        console.error(`Could not restore value ${key} from local storage.`);
      }
    }
  }, [key]);
  const updateValue = React.useCallback(
    (setter) => {
      setState((s2) => {
        const value = typeof setter === "function" ? setter(s2) : setter;
        setInLocalStorage(key, JSON.stringify(value));
        return value;
      });
    },
    [key]
  );
  return [state, updateValue];
}
const DefaultNavigationPanel = reactExports.memo(function DefaultNavigationPanel2() {
  const actions = useActions();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const [collapsed, setCollapsed] = useLocalStorageState("minimap", true);
  const toggleMinimap = reactExports.useCallback(() => {
    setCollapsed((s2) => !s2);
  }, [setCollapsed]);
  const { ZoomMenu, Minimap } = useTldrawUiComponents();
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: "tlui-navigation-panel", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { className: "tlui-buttons__horizontal", label: msg2("navigation-zone.title"), children: ZoomMenu && breakpoint < PORTRAIT_BREAKPOINT.TABLET ? /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomMenu, {}) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${msg2(unwrapLabel(actions["zoom-out"].label))} ${kbdStr(actions["zoom-out"].kbd)}`,
          onClick: () => actions["zoom-out"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "minus" })
        }
      ),
      ZoomMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomMenu, {}, "zoom-menu"),
      !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${msg2(unwrapLabel(actions["zoom-in"].label))} ${kbdStr(actions["zoom-in"].kbd)}`,
          onClick: () => actions["zoom-in"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "plus" })
        }
      ),
      Minimap && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: msg2("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-panel__toggle",
          onClick: toggleMinimap,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: collapsed ? "chevrons-ne" : "chevrons-sw" })
        }
      )
    ] }) }),
    Minimap && breakpoint >= PORTRAIT_BREAKPOINT.TABLET && !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx(Minimap, {})
  ] });
});
const PageItemInput = function PageItemInput2({
  name,
  id,
  isCurrentPage,
  onCancel,
  onComplete
}) {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const rInput = reactExports.useRef(null);
  const rMark = reactExports.useRef(null);
  const handleFocus = reactExports.useCallback(() => {
    rMark.current = editor.markHistoryStoppingPoint("rename page");
  }, [editor]);
  const handleChange = reactExports.useCallback(
    (value) => {
      editor.renamePage(id, value || "New Page");
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, id, trackEvent]
  );
  const handleCancel = reactExports.useCallback(() => {
    if (rMark.current) {
      editor.bailToMark(rMark.current);
    }
    onCancel();
  }, [editor, onCancel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiInput,
    {
      className: "tlui-page-menu__item__input",
      ref: (el) => rInput.current = el,
      defaultValue: name,
      onValueChange: handleChange,
      onComplete,
      onCancel: handleCancel,
      onFocus: handleFocus,
      shouldManuallyMaintainScrollPositionWhenFocused: true,
      autoFocus: isCurrentPage,
      autoSelect: true
    }
  );
};
const onMovePage = (editor, id, from2, to, trackEvent) => {
  let index2;
  const pages = editor.getPages();
  const below = from2 > to ? pages[to - 1] : pages[to];
  const above = from2 > to ? pages[to] : pages[to + 1];
  if (below && !above) {
    index2 = getIndexAbove(below.index);
  } else if (!below && above) {
    index2 = getIndexBelow(pages[0].index);
  } else {
    index2 = getIndexBetween(below.index, above.index);
  }
  if (index2 !== pages[from2].index) {
    editor.markHistoryStoppingPoint("moving page");
    editor.updatePage({
      id,
      index: index2
    });
    trackEvent("move-page", { source: "page-menu" });
  }
};
const PageItemSubmenu = track(function PageItemSubmenu2({
  index: index2,
  listSize,
  item,
  onRename
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const pages = editor.getPages();
  const trackEvent = useUiEvents();
  const onDuplicate = reactExports.useCallback(() => {
    editor.markHistoryStoppingPoint("creating page");
    const newId = PageRecordType.createId();
    editor.duplicatePage(item.id, newId);
    trackEvent("duplicate-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  const onMoveUp = reactExports.useCallback(() => {
    onMovePage(editor, item.id, index2, index2 - 1, trackEvent);
  }, [editor, item, index2, trackEvent]);
  const onMoveDown = reactExports.useCallback(() => {
    onMovePage(editor, item.id, index2, index2 + 1, trackEvent);
  }, [editor, item, index2, trackEvent]);
  const onDelete = reactExports.useCallback(() => {
    editor.markHistoryStoppingPoint("deleting page");
    editor.deletePage(item.id);
    trackEvent("delete-page", { source: "page-menu" });
  }, [editor, item, trackEvent]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: `page item submenu ${index2}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "icon", title: msg2("page-menu.submenu.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dots-vertical", small: true }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { alignOffset: 0, side: "right", sideOffset: -4, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuContextProvider, { type: "menu", sourceId: "page-menu", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiMenuGroup, { id: "modify", children: [
        onRename && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "rename", label: "page-menu.submenu.rename", onSelect: onRename }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiMenuItem,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: onDuplicate,
            disabled: pages.length >= editor.options.maxPages
          }
        ),
        index2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiMenuItem,
          {
            id: "move-up",
            onSelect: onMoveUp,
            label: "page-menu.submenu.move-up"
          }
        ),
        index2 < listSize - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiMenuItem,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: onMoveDown
          }
        )
      ] }),
      listSize > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuGroup, { id: "delete", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuItem, { id: "delete", onSelect: onDelete, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
});
const DefaultPageMenu = reactExports.memo(function DefaultPageMenu2() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const handleOpenChange = reactExports.useCallback(() => setIsEditing(false), []);
  const [isOpen, onOpenChange] = useMenuIsOpen("page-menu", handleOpenChange);
  const ITEM_HEIGHT = 36;
  const rSortableContainer = reactExports.useRef(null);
  const pages = useValue("pages", () => editor.getPages(), [editor]);
  const currentPage = useValue("currentPage", () => editor.getCurrentPage(), [editor]);
  const currentPageId = useValue("currentPageId", () => editor.getCurrentPageId(), [editor]);
  const isReadonlyMode = useReadonly();
  const maxPageCountReached = useValue(
    "maxPageCountReached",
    () => editor.getPages().length >= editor.options.maxPages,
    [editor]
  );
  const isCoarsePointer = useValue(
    "isCoarsePointer",
    () => editor.getInstanceState().isCoarsePointer,
    [editor]
  );
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const toggleEditing = reactExports.useCallback(() => {
    if (isReadonlyMode) return;
    setIsEditing((s2) => !s2);
  }, [isReadonlyMode]);
  const rMutables = reactExports.useRef({
    isPointing: false,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  });
  const [sortablePositionItems, setSortablePositionItems] = reactExports.useState(
    Object.fromEntries(
      pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
    )
  );
  reactExports.useLayoutEffect(() => {
    setSortablePositionItems(
      Object.fromEntries(
        pages.map((page, i) => [page.id, { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
      )
    );
  }, [ITEM_HEIGHT, pages]);
  reactExports.useEffect(() => {
    if (!isOpen) return;
    editor.timers.requestAnimationFrame(() => {
      const elm = document.querySelector(
        `[data-testid="page-menu-item-${currentPageId}"]`
      );
      if (elm) {
        const container = rSortableContainer.current;
        if (!container) return;
        const elmTopPosition = elm.offsetTop;
        const containerScrollTopPosition = container.scrollTop;
        if (elmTopPosition < containerScrollTopPosition) {
          container.scrollTo({ top: elmTopPosition });
        }
        const elmBottomPosition = elmTopPosition + ITEM_HEIGHT;
        const containerScrollBottomPosition = container.scrollTop + container.offsetHeight;
        if (elmBottomPosition > containerScrollBottomPosition) {
          container.scrollTo({ top: elmBottomPosition - container.offsetHeight });
        }
      }
    });
  }, [ITEM_HEIGHT, currentPageId, isOpen, editor]);
  const handlePointerDown = reactExports.useCallback(
    (e) => {
      const { clientY, currentTarget } = e;
      const {
        dataset: { id, index: index2 }
      } = currentTarget;
      if (!id || !index2) return;
      const mut = rMutables.current;
      setPointerCapture(e.currentTarget, e);
      mut.status = "pointing";
      mut.pointing = { id, index: +index2 };
      const current = sortablePositionItems[id];
      const dragY = current.y;
      mut.startY = clientY;
      mut.startIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
    },
    [ITEM_HEIGHT, pages.length, sortablePositionItems]
  );
  const handlePointerMove = reactExports.useCallback(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "pointing") {
        const { clientY } = e;
        const offset2 = clientY - mut.startY;
        if (Math.abs(offset2) > 5) {
          mut.status = "dragging";
        }
      }
      if (mut.status === "dragging") {
        const { clientY } = e;
        const offsetY = clientY - mut.startY;
        const current = sortablePositionItems[mut.pointing.id];
        const { startIndex, pointing } = mut;
        const dragY = current.y + offsetY;
        const dragIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
        const next = { ...sortablePositionItems };
        next[pointing.id] = {
          y: current.y,
          offsetY,
          isSelected: true
        };
        if (dragIndex !== mut.dragIndex) {
          mut.dragIndex = dragIndex;
          for (let i = 0; i < pages.length; i++) {
            const item = pages[i];
            if (item.id === mut.pointing.id) {
              continue;
            }
            let { y: y2 } = next[item.id];
            if (dragIndex === startIndex) {
              y2 = i * ITEM_HEIGHT;
            } else if (dragIndex < startIndex) {
              if (dragIndex <= i && i < startIndex) {
                y2 = (i + 1) * ITEM_HEIGHT;
              } else {
                y2 = i * ITEM_HEIGHT;
              }
            } else if (dragIndex > startIndex) {
              if (dragIndex >= i && i > startIndex) {
                y2 = (i - 1) * ITEM_HEIGHT;
              } else {
                y2 = i * ITEM_HEIGHT;
              }
            }
            if (y2 !== next[item.id].y) {
              next[item.id] = { y: y2, offsetY: 0, isSelected: true };
            }
          }
        }
        setSortablePositionItems(next);
      }
    },
    [ITEM_HEIGHT, pages, sortablePositionItems]
  );
  const handlePointerUp = reactExports.useCallback(
    (e) => {
      const mut = rMutables.current;
      if (mut.status === "dragging") {
        const { id, index: index2 } = mut.pointing;
        onMovePage(editor, id, index2, mut.dragIndex, trackEvent);
      }
      releasePointerCapture(e.currentTarget, e);
      mut.status = "idle";
    },
    [editor, trackEvent]
  );
  const handleKeyDown2 = reactExports.useCallback(
    (e) => {
      const mut = rMutables.current;
      if (e.key === "Escape") {
        if (mut.status === "dragging") {
          setSortablePositionItems(
            Object.fromEntries(
              pages.map((page, i) => [
                page.id,
                { y: i * ITEM_HEIGHT, offsetY: 0, isSelected: false }
              ])
            )
          );
        }
        mut.status = "idle";
      }
    },
    [ITEM_HEIGHT, pages]
  );
  const handleCreatePageClick = reactExports.useCallback(() => {
    if (isReadonlyMode) return;
    editor.run(() => {
      editor.markHistoryStoppingPoint("creating page");
      const newPageId = PageRecordType.createId();
      editor.createPage({ name: msg2("page-menu.new-page-initial-name"), id: newPageId });
      editor.setCurrentPage(newPageId);
      setIsEditing(true);
    });
    trackEvent("new-page", { source: "page-menu" });
  }, [editor, msg2, isReadonlyMode, trackEvent]);
  const changePage = reactExports.useCallback(
    (id) => {
      editor.setCurrentPage(id);
      trackEvent("change-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  const renamePage = reactExports.useCallback(
    (id, name) => {
      editor.renamePage(id, name);
      trackEvent("rename-page", { source: "page-menu" });
    },
    [editor, trackEvent]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: "pages", onOpenChange, open: isOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { "data-testid": "main.page-menu", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TldrawUiButton,
      {
        type: "menu",
        title: currentPage.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page-menu__name", children: currentPage.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-down", small: true })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiPopoverContent,
      {
        side: "bottom",
        align: "start",
        sideOffset: 6,
        disableEscapeKeyDown: isEditing,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-page-menu__header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page-menu__header__title", children: msg2("page-menu.title") }),
            !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-buttons__horizontal", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.edit",
                  title: msg2(isEditing ? "page-menu.edit-done" : "page-menu.edit-start"),
                  onClick: toggleEditing,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: isEditing ? "check" : "edit" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TldrawUiButton,
                {
                  type: "icon",
                  "data-testid": "page-menu.create",
                  title: msg2(
                    maxPageCountReached ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                  ),
                  disabled: maxPageCountReached,
                  onClick: handleCreatePageClick,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "plus" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              "data-testid": "page-menu.list",
              className: "tlui-page-menu__list tlui-menu__group",
              style: { height: ITEM_HEIGHT * pages.length + 4 },
              ref: rSortableContainer,
              children: pages.map((page, index2) => {
                const position = sortablePositionItems[page.id] ?? {
                  offsetY: 0
                };
                return isEditing ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    "data-testid": "page-menu.item",
                    className: "tlui-page_menu__item__sortable",
                    style: {
                      zIndex: page.id === currentPage.id ? 888 : index2,
                      transform: `translate(0px, ${position.y + position.offsetY}px)`
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        TldrawUiButton,
                        {
                          type: "icon",
                          tabIndex: -1,
                          className: "tlui-page_menu__item__sortable__handle",
                          onPointerDown: handlePointerDown,
                          onPointerUp: handlePointerUp,
                          onPointerMove: handlePointerMove,
                          onKeyDown: handleKeyDown2,
                          "data-id": page.id,
                          "data-index": index2,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "drag-handle-dots" })
                        }
                      ),
                      breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && isCoarsePointer ? (
                        // sigh, this is a workaround for iOS Safari
                        // because the device and the radix popover seem
                        // to be fighting over scroll position. Nothing
                        // else seems to work!
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiButton, {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const name = window.prompt("Rename page", page.name);
                            if (name && name !== page.name) {
                              renamePage(page.id, name);
                            }
                          },
                          onDoubleClick: toggleEditing,
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: page.name })
                          ]
                        })
                      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "tlui-page_menu__item__sortable__title",
                          style: { height: ITEM_HEIGHT },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            PageItemInput,
                            {
                              id: page.id,
                              name: page.name,
                              isCurrentPage: page.id === currentPage.id,
                              onComplete: () => {
                                setIsEditing(false);
                                editor.menus.clearOpenMenus();
                              },
                              onCancel: () => {
                                setIsEditing(false);
                                editor.menus.clearOpenMenus();
                              }
                            }
                          )
                        }
                      ),
                      !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": isEditing, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PageItemSubmenu, { index: index2, item: page, listSize: pages.length }) })
                    ]
                  },
                  page.id + "_editing"
                ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { "data-testid": "page-menu.item", className: "tlui-page-menu__item", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    TldrawUiButton,
                    {
                      type: "normal",
                      className: "tlui-page-menu__item__button",
                      onClick: () => changePage(page.id),
                      onDoubleClick: toggleEditing,
                      title: msg2("page-menu.go-to-page"),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonCheck, { checked: page.id === currentPage.id }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: page.name })
                      ]
                    }
                  ),
                  !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    PageItemSubmenu,
                    {
                      index: index2,
                      item: page,
                      listSize: pages.length,
                      onRename: () => {
                        if (tlenv.isIos) {
                          const name = window.prompt("Rename page", page.name);
                          if (name && name !== page.name) {
                            renamePage(page.id, name);
                          }
                        } else {
                          setIsEditing(true);
                          if (currentPageId !== page.id) {
                            changePage(page.id);
                          }
                        }
                      }
                    }
                  ) })
                ] }, page.id);
              })
            }
          )
        ] })
      }
    )
  ] });
});
function DefaultQuickActionsContent() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const isInAcceptableReadonlyState = useValue(
    "should display quick actions",
    () => editor.isInAny("select", "hand", "zoom"),
    [editor]
  );
  if (isReadonlyMode && !isInAcceptableReadonlyState) return;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UndoRedoGroup, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteDuplicateGroup, {})
  ] });
}
function DeleteDuplicateGroup() {
  const oneSelected = useUnlockedSelectedShapesCount(1);
  const isInSelectState = useIsInSelectState();
  const selectDependentActionsEnabled = oneSelected && isInSelectState;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "delete", disabled: !selectDependentActionsEnabled }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "duplicate", disabled: !selectDependentActionsEnabled })
  ] });
}
function UndoRedoGroup() {
  const canUndo = useCanUndo();
  const canRedo = useCanRedo();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "undo", disabled: !canUndo }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "redo", disabled: !canRedo })
  ] });
}
const DefaultQuickActions = reactExports.memo(function DefaultQuickActions2({
  children
}) {
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultQuickActionsContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "small-icons", sourceId: "quick-actions", children: content });
});
function PeopleMenuAvatar({ userId }) {
  const presence = usePresence$1(userId);
  if (!presence) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: presence.color
      },
      children: presence.userName?.[0] ?? ""
    },
    userId
  );
}
const PeopleMenuItem = track(function PeopleMenuItem2({ userId }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const presence = usePresence$1(userId);
  const handleFollowClick = reactExports.useCallback(() => {
    if (editor.getInstanceState().followingUserId === userId) {
      editor.stopFollowingUser();
      trackEvent("stop-following", { source: "people-menu" });
    } else {
      editor.startFollowingUser(userId);
      trackEvent("start-following", { source: "people-menu" });
    }
  }, [editor, userId, trackEvent]);
  const theyAreFollowingYou = presence?.followingUserId === editor.user.getId();
  const youAreFollowingThem = editor.getInstanceState().followingUserId === userId;
  if (!presence) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "tlui-people-menu__item tlui-buttons__horizontal",
      "data-follow": youAreFollowingThem || theyAreFollowingYou,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TldrawUiButton,
          {
            type: "menu",
            className: "tlui-people-menu__item__button",
            onClick: () => editor.zoomToUser(userId),
            onDoubleClick: handleFollowClick,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: msg2("people-menu.avatar-color"), icon: "color", color: presence.color }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__name", children: presence.userName?.trim() || msg2("people-menu.anonymous-user") })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-people-menu__item__follow",
            title: theyAreFollowingYou ? msg2("people-menu.leading") : youAreFollowingThem ? msg2("people-menu.following") : msg2("people-menu.follow"),
            onClick: handleFollowClick,
            disabled: theyAreFollowingYou,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiButtonIcon,
              {
                icon: theyAreFollowingYou ? "leading" : youAreFollowingThem ? "following" : "follow"
              }
            )
          }
        )
      ]
    }
  );
});
function PeopleMenuMore({ count: count2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__more", children: "+" + Math.abs(count2) });
}
const UserPresenceColorPicker = track(function UserPresenceColorPicker2() {
  const editor = useEditor();
  const container = useContainer();
  const msg2 = useTranslation();
  const trackEvent = useUiEvents();
  const rPointing = reactExports.useRef(false);
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const handleOpenChange = reactExports.useCallback((isOpen2) => {
    setIsOpen(isOpen2);
  }, []);
  const value = editor.user.getColor();
  const onValueChange = reactExports.useCallback(
    (item) => {
      editor.user.updateUserPreferences({ color: item });
      trackEvent("set-color", { source: "people-menu" });
    },
    [editor, trackEvent]
  );
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = React.useMemo(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      if (value === id) return;
      onValueChange(id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
      rPointing.current = true;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current) return;
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (!id) return;
      onValueChange(id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [value, onValueChange]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { onOpenChange: handleOpenChange, open: isOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { dir: "ltr", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: editor.user.getColor() },
        title: msg2("people-menu.change-color"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "color" })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content22,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-buttons__grid", children: USER_COLORS.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "icon",
            "data-id": item,
            "data-testid": item,
            "aria-label": item,
            isActive: value === item,
            title: item,
            className: "tlui-button-grid__button",
            style: { color: item },
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "color" })
          },
          item
        )) })
      }
    ) })
  ] });
});
function UserPresenceEditor() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  const userName = useValue("userName", () => editor.user.getName(), []);
  const msg2 = useTranslation();
  const rOriginalName = reactExports.useRef(userName);
  const rCurrentName = reactExports.useRef(userName);
  const [isEditingName, setIsEditingName] = reactExports.useState(false);
  const toggleEditingName = reactExports.useCallback(() => {
    setIsEditingName((s2) => !s2);
  }, []);
  const handleValueChange = reactExports.useCallback(
    (value) => {
      rCurrentName.current = value;
      editor.user.updateUserPreferences({ name: value });
    },
    [editor]
  );
  const handleBlur = reactExports.useCallback(() => {
    if (rOriginalName.current === rCurrentName.current) return;
    trackEvent("change-user-name", { source: "people-menu" });
    rOriginalName.current = rCurrentName.current;
  }, [trackEvent]);
  const handleCancel = reactExports.useCallback(() => {
    setIsEditingName(false);
    editor.user.updateUserPreferences({ name: rOriginalName.current });
    editor.menus.clearOpenMenus();
  }, [editor]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-people-menu__user", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(UserPresenceColorPicker, {}),
    isEditingName ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiInput,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: userName,
        onValueChange: handleValueChange,
        onComplete: toggleEditingName,
        onCancel: handleCancel,
        onBlur: handleBlur,
        shouldManuallyMaintainScrollPositionWhenFocused: true,
        autoFocus: true,
        autoSelect: true
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            if (!isEditingName) setIsEditingName(true);
          },
          children: userName || msg2("people-menu.anonymous-user")
        }
      ),
      !userName ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__user__label", children: msg2("people-menu.user") }) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: msg2("people-menu.change-name"),
        onClick: toggleEditingName,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: isEditingName ? "check" : "edit" })
      }
    )
  ] });
}
function PeopleMenu({ children }) {
  const msg2 = useTranslation();
  const container = useContainer();
  const editor = useEditor();
  const userIds = usePeerIds();
  const userColor = useValue("user", () => editor.user.getColor(), [editor]);
  const userName = useValue("user", () => editor.user.getName(), [editor]);
  const [isOpen, onOpenChange] = useMenuIsOpen("people menu");
  if (!userIds.length) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$2, { onOpenChange, open: isOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger, { dir: "ltr", asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "tlui-people-menu__avatars-button", title: msg2("people-menu.title"), children: [
      userIds.length > 5 && /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenuMore, { count: userIds.length - 5 }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-people-menu__avatars", children: [
        userIds.slice(-5).map((userId) => /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenuAvatar, { userId }, userId)),
        userIds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "tlui-people-menu__avatar",
            style: {
              backgroundColor: userColor
            },
            children: userName?.[0] ?? ""
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content22,
      {
        dir: "ltr",
        className: "tlui-menu",
        side: "bottom",
        sideOffset: 2,
        collisionPadding: 4,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-people-menu__wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserPresenceEditor, {}) }),
          userIds.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-people-menu__section", children: userIds.map((userId) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenuItem, { userId }, userId + "_presence");
          }) }),
          children
        ] })
      }
    ) })
  ] });
}
function DefaultSharePanel() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-share-zone", draggable: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PeopleMenu, {}) });
}
const selectToolStyles = Object.freeze([
  DefaultColorStyle,
  DefaultDashStyle,
  DefaultFillStyle,
  DefaultSizeStyle
]);
function useRelevantStyles(stylesToCheck = selectToolStyles) {
  const editor = useEditor();
  return useValue(
    "getRelevantStyles",
    () => {
      const styles = new SharedStyleMap(editor.getSharedStyles());
      const isInShapeSpecificTool = !!editor.root.getCurrent()?.shapeType;
      const hasShapesSelected = editor.isIn("select") && editor.getSelectedShapeIds().length > 0;
      if (styles.size === 0 && editor.isIn("select") && editor.getSelectedShapeIds().length === 0) {
        for (const style2 of stylesToCheck) {
          styles.applyValue(style2, editor.getStyleForNextShape(style2));
        }
      }
      if (isInShapeSpecificTool || hasShapesSelected || styles.size > 0) {
        return styles;
      }
      return null;
    },
    [editor]
  );
}
const STYLES = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowKind: [
    { value: "arc", icon: "arrow-arc" },
    { value: "elbow", icon: "arrow-elbow" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
};
const TldrawUiButtonPicker = reactExports.memo(function TldrawUiButtonPicker2(props) {
  const {
    uiType,
    items,
    title,
    style: style2,
    value,
    // columns = clamp(items.length, 2, 4),
    onValueChange,
    onHistoryMark,
    theme
  } = props;
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const rPointing = reactExports.useRef(false);
  const rPointingOriginalActiveElement = reactExports.useRef(null);
  const {
    handleButtonClick,
    handleButtonPointerDown,
    handleButtonPointerEnter,
    handleButtonPointerUp
  } = reactExports.useMemo(() => {
    const handlePointerUp = () => {
      rPointing.current = false;
      window.removeEventListener("pointerup", handlePointerUp);
      const origActiveEl = rPointingOriginalActiveElement.current;
      if (origActiveEl && (["TEXTAREA", "INPUT"].includes(origActiveEl.nodeName) || origActiveEl.isContentEditable)) {
        origActiveEl.focus();
      } else if (breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM) {
        editor.getContainer().focus();
      }
      rPointingOriginalActiveElement.current = null;
    };
    const handleButtonClick2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id) return;
      onHistoryMark?.("point picker item");
      onValueChange(style2, id);
    };
    const handleButtonPointerDown2 = (e) => {
      const { id } = e.currentTarget.dataset;
      onHistoryMark?.("point picker item");
      onValueChange(style2, id);
      rPointing.current = true;
      rPointingOriginalActiveElement.current = document.activeElement;
      window.addEventListener("pointerup", handlePointerUp);
    };
    const handleButtonPointerEnter2 = (e) => {
      if (!rPointing.current) return;
      const { id } = e.currentTarget.dataset;
      onValueChange(style2, id);
    };
    const handleButtonPointerUp2 = (e) => {
      const { id } = e.currentTarget.dataset;
      if (value.type === "shared" && value.value === id) return;
      onValueChange(style2, id);
    };
    return {
      handleButtonClick: handleButtonClick2,
      handleButtonPointerDown: handleButtonPointerDown2,
      handleButtonPointerEnter: handleButtonPointerEnter2,
      handleButtonPointerUp: handleButtonPointerUp2
    };
  }, [editor, breakpoint, value, onHistoryMark, onValueChange, style2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiToolbarToggleGroup,
    {
      "data-testid": `style.${uiType}`,
      type: "single",
      className: classNames("tlui-buttons__grid"),
      children: items.map((item) => {
        const label = title + " — " + msg2(`${uiType}-style.${item.value}`);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarToggleItem,
          {
            type: "icon",
            "data-id": item.value,
            "data-testid": `style.${uiType}.${item.value}`,
            "aria-label": label,
            value: item.value,
            "data-isactive": value.type === "shared" && value.value === item.value,
            title: label,
            className: classNames("tlui-button-grid__button"),
            style: style2 === DefaultColorStyle ? { color: theme[item.value].solid } : void 0,
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon })
          },
          item.value
        );
      })
    }
  );
});
const TldrawUiSlider = reactExports.memo(function Slider2({
  onHistoryMark,
  title,
  steps,
  value,
  label,
  onValueChange,
  ["data-testid"]: testId
}) {
  const msg2 = useTranslation();
  const [tabIndex, setTabIndex] = reactExports.useState(-1);
  reactExports.useEffect(() => {
    setTabIndex(0);
  }, []);
  const handleValueChange = reactExports.useCallback(
    (value2) => {
      onValueChange(value2[0]);
    },
    [onValueChange]
  );
  const handlePointerDown = reactExports.useCallback(() => {
    onHistoryMark("click slider");
  }, [onHistoryMark]);
  const handlePointerUp = reactExports.useCallback(() => {
    if (!value) return;
    onValueChange(value);
  }, [value, onValueChange]);
  const handleKeyEvent = reactExports.useCallback((event) => {
    if (event.key === "Tab") {
      event.stopPropagation();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Root,
    {
      "data-testid": testId,
      className: "tlui-slider",
      dir: "ltr",
      min: 0,
      max: steps,
      step: 1,
      value: value ? [value] : void 0,
      onPointerDown: handlePointerDown,
      onValueChange: handleValueChange,
      onPointerUp: handlePointerUp,
      onKeyDownCapture: handleKeyEvent,
      onKeyUpCapture: handleKeyEvent,
      title: title + " — " + msg2(label),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { className: "tlui-slider__track", dir: "ltr", children: value !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(Range$1, { className: "tlui-slider__range", dir: "ltr" }) }),
        value !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Thumb,
          {
            "aria-label": msg2("style-panel.opacity"),
            className: "tlui-slider__thumb",
            dir: "ltr",
            tabIndex
          }
        )
      ]
    }
  ) });
});
function DoubleDropdownPickerInner({
  label,
  uiTypeA,
  uiTypeB,
  labelA,
  labelB,
  itemsA,
  itemsB,
  styleA,
  styleB,
  valueA,
  valueB,
  onValueChange
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const [isOpenA, setIsOpenA] = reactExports.useState(false);
  const [isOpenB, setIsOpenB] = reactExports.useState(false);
  const iconA = reactExports.useMemo(
    () => itemsA.find((item) => valueA.type === "shared" && valueA.value === item.value)?.icon ?? "mixed",
    [itemsA, valueA]
  );
  const iconB = reactExports.useMemo(
    () => itemsB.find((item) => valueB.type === "shared" && valueB.value === item.value)?.icon ?? "mixed",
    [itemsB, valueB]
  );
  if (valueA === void 0 && valueB === void 0) return null;
  const idA = `style panel ${uiTypeA} A`;
  const idB = `style panel ${uiTypeB} B`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { title: msg2(label), className: "tlui-style-panel__double-select-picker-label", children: msg2(label) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { label: msg2(label), className: "tlui-buttons__horizontal", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: idA, open: isOpenA, onOpenChange: setIsOpenA, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarButton,
          {
            type: "icon",
            "data-testid": `style.${uiTypeA}`,
            title: msg2(labelA) + " — " + (valueA === null || valueA.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeA}-style.${valueA.value}`)),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconA, small: true, invertIcon: true })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2(labelA), className: "tlui-buttons__grid", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsA.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiToolbarButton,
            {
              "data-testid": `style.${uiTypeA}.${item.value}`,
              type: "icon",
              onClick: () => {
                onValueChange(styleA, item.value);
                tlmenus.deleteOpenMenu(idA, editor.contextId);
                setIsOpenA(false);
              },
              title: `${msg2(labelA)} — ${msg2(`${uiTypeA}-style.${item.value}`)}`,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon, invertIcon: true })
            },
            item.value
          );
        }) }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: idB, open: isOpenB, onOpenChange: setIsOpenB, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiToolbarButton,
          {
            type: "icon",
            "data-testid": `style.${uiTypeB}`,
            title: msg2(labelB) + " — " + (valueB === null || valueB.type === "mixed" ? msg2("style-panel.mixed") : msg2(`${uiTypeB}-style.${valueB.value}`)),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: iconB, small: true })
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2(labelB), className: "tlui-buttons__grid", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: itemsB.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiToolbarButton,
            {
              type: "icon",
              title: `${msg2(labelB)} — ${msg2(`${uiTypeB}-style.${item.value}`)}`,
              "data-testid": `style.${uiTypeB}.${item.value}`,
              onClick: () => {
                onValueChange(styleB, item.value);
                tlmenus.deleteOpenMenu(idB, editor.contextId);
                setIsOpenB(false);
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon })
            },
            item.value
          );
        }) }) }) })
      ] })
    ] })
  ] });
}
const DoubleDropdownPicker = reactExports.memo(
  DoubleDropdownPickerInner
);
function DropdownPickerInner({
  id,
  label,
  uiType,
  stylePanelType,
  style: style2,
  items,
  type,
  value,
  onValueChange
}) {
  const msg2 = useTranslation();
  const editor = useEditor();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const icon = reactExports.useMemo(
    () => items.find((item) => value.type === "shared" && item.value === value.value)?.icon,
    [items, value]
  );
  const stylePanelName = msg2(`style-panel.${stylePanelType}`);
  const titleStr = value.type === "mixed" ? msg2("style-panel.mixed") : stylePanelName + " — " + msg2(`${uiType}-style.${value.value}`);
  const labelStr = label ? msg2(label) : "";
  const popoverId = `style panel ${id}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: popoverId, open: isOpen, onOpenChange: setIsOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TldrawUiToolbarButton,
      {
        type,
        "data-testid": `style.${uiType}`,
        "data-direction": "left",
        title: titleStr,
        children: [
          labelStr && /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonLabel, { children: labelStr }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: icon ?? "mixed" })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "left", align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbar,
      {
        label: labelStr,
        className: classNames("tlui-buttons__grid", `tlui-buttons__${stylePanelType}`),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "icons", sourceId: "style-panel", children: items.map((item) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TldrawUiToolbarButton,
            {
              type: "icon",
              "data-testid": `style.${uiType}.${item.value}`,
              title: stylePanelName + " — " + msg2(`${uiType}-style.${item.value}`),
              isActive: icon === item.icon,
              onClick: () => {
                editor.markHistoryStoppingPoint("select style dropdown item");
                onValueChange(style2, item.value);
                tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                setIsOpen(false);
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: item.icon })
            },
            item.value
          );
        }) })
      }
    ) })
  ] });
}
const DropdownPicker = reactExports.memo(DropdownPickerInner);
function DefaultStylePanelContent({ styles }) {
  const isDarkMode = useIsDarkMode();
  if (!styles) return null;
  const geo = styles.get(GeoShapeGeoStyle);
  const arrowheadEnd = styles.get(ArrowShapeArrowheadEndStyle);
  const arrowheadStart = styles.get(ArrowShapeArrowheadStartStyle);
  const arrowKind = styles.get(ArrowShapeKindStyle);
  const spline = styles.get(LineShapeSplineStyle);
  const font = styles.get(DefaultFontStyle);
  const hideGeo = geo === void 0;
  const hideArrowHeads = arrowheadEnd === void 0 && arrowheadStart === void 0;
  const hideSpline = spline === void 0;
  const hideArrowKind = arrowKind === void 0;
  const hideText = font === void 0;
  const theme = getDefaultColorTheme({ isDarkMode });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CommonStylePickerSet, { theme, styles }),
    !hideText && /* @__PURE__ */ jsxRuntimeExports.jsx(TextStylePickerSet, { theme, styles }),
    !(hideGeo && hideArrowHeads && hideSpline && hideArrowKind) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-style-panel__section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GeoStylePickerSet, { styles }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowStylePickerSet, { styles }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowheadStylePickerSet, { styles }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SplineStylePickerSet, { styles })
    ] })
  ] });
}
function useStyleChangeCallback() {
  const editor = useEditor();
  const trackEvent = useUiEvents();
  return React.useMemo(
    () => function handleStyleChange(style2, value) {
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setStyleForSelectedShapes(style2, value);
        }
        editor.setStyleForNextShapes(style2, value);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: style2.id, value });
    },
    [editor, trackEvent]
  );
}
function CommonStylePickerSet({ styles, theme }) {
  const msg2 = useTranslation();
  const editor = useEditor();
  const onHistoryMark = reactExports.useCallback((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const handleValueChange = useStyleChangeCallback();
  const color = styles.get(DefaultColorStyle);
  const fill = styles.get(DefaultFillStyle);
  const dash = styles.get(DefaultDashStyle);
  const size2 = styles.get(DefaultSizeStyle);
  const showPickers = fill !== void 0 || dash !== void 0 || size2 !== void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-style-panel__section__common", "data-testid": "style.panel", children: [
      color === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.color"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.color"),
          uiType: "color",
          style: DefaultColorStyle,
          items: STYLES.color,
          value: color,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(OpacitySlider, {})
    ] }),
    showPickers && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-style-panel__section", children: [
      fill === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.fill"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.fill"),
          uiType: "fill",
          style: DefaultFillStyle,
          items: STYLES.fill,
          value: fill,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ) }),
      dash === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.dash"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.dash"),
          uiType: "dash",
          style: DefaultDashStyle,
          items: STYLES.dash,
          value: dash,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ) }),
      size2 === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.size"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.size"),
          uiType: "size",
          style: DefaultSizeStyle,
          items: STYLES.size,
          value: size2,
          onValueChange: (style2, value) => {
            handleValueChange(style2, value);
            const selectedShapeIds = editor.getSelectedShapeIds();
            if (selectedShapeIds.length > 0) {
              kickoutOccludedShapes(editor, selectedShapeIds);
            }
          },
          theme,
          onHistoryMark
        }
      ) })
    ] })
  ] });
}
function TextStylePickerSet({ theme, styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const editor = useEditor();
  const onHistoryMark = reactExports.useCallback((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const font = styles.get(DefaultFontStyle);
  const textAlign = styles.get(DefaultTextAlignStyle);
  const labelAlign = styles.get(DefaultHorizontalAlignStyle);
  const verticalLabelAlign = styles.get(DefaultVerticalAlignStyle);
  if (font === void 0 && labelAlign === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-style-panel__section", children: [
    font === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.font"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButtonPicker,
      {
        title: msg2("style-panel.font"),
        uiType: "font",
        style: DefaultFontStyle,
        items: STYLES.font,
        value: font,
        onValueChange: handleValueChange,
        theme,
        onHistoryMark
      }
    ) }),
    textAlign === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { label: msg2("style-panel.align"), className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.align"),
          uiType: "align",
          style: DefaultTextAlignStyle,
          items: STYLES.textAlign,
          value: textAlign,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-style-panel__row__extra-button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      ) })
    ] }),
    labelAlign === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiToolbar, { label: msg2("style-panel.label-align"), className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiButtonPicker,
        {
          title: msg2("style-panel.label-align"),
          uiType: "align",
          style: DefaultHorizontalAlignStyle,
          items: STYLES.horizontalAlign,
          value: labelAlign,
          onValueChange: handleValueChange,
          theme,
          onHistoryMark
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-style-panel__row__extra-button", children: verticalLabelAlign === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        TldrawUiToolbarButton,
        {
          type: "icon",
          title: msg2("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "vertical-align-middle" })
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        DropdownPicker,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          stylePanelType: "vertical-align",
          style: DefaultVerticalAlignStyle,
          items: STYLES.verticalAlign,
          value: verticalLabelAlign,
          onValueChange: handleValueChange
        }
      ) })
    ] })
  ] });
}
function GeoStylePickerSet({ styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const geo = styles.get(GeoShapeGeoStyle);
  if (geo === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.geo"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownPicker,
    {
      id: "geo",
      type: "menu",
      label: "style-panel.geo",
      uiType: "geo",
      stylePanelType: "geo",
      style: GeoShapeGeoStyle,
      items: STYLES.geo,
      value: geo,
      onValueChange: handleValueChange
    }
  ) });
}
function SplineStylePickerSet({ styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const spline = styles.get(LineShapeSplineStyle);
  if (spline === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.spline"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownPicker,
    {
      id: "spline",
      type: "menu",
      label: "style-panel.spline",
      uiType: "spline",
      stylePanelType: "spline",
      style: LineShapeSplineStyle,
      items: STYLES.spline,
      value: spline,
      onValueChange: handleValueChange
    }
  ) });
}
function ArrowStylePickerSet({ styles }) {
  const msg2 = useTranslation();
  const handleValueChange = useStyleChangeCallback();
  const arrowKind = styles.get(ArrowShapeKindStyle);
  if (arrowKind === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { label: msg2("style-panel.arrow-kind"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownPicker,
    {
      id: "arrow-kind",
      type: "menu",
      label: "style-panel.arrow-kind",
      uiType: "arrow-kind",
      stylePanelType: "arrow-kind",
      style: ArrowShapeKindStyle,
      items: STYLES.arrowKind,
      value: arrowKind,
      onValueChange: handleValueChange
    }
  ) });
}
function ArrowheadStylePickerSet({ styles }) {
  const handleValueChange = useStyleChangeCallback();
  const arrowheadEnd = styles.get(ArrowShapeArrowheadEndStyle);
  const arrowheadStart = styles.get(ArrowShapeArrowheadStartStyle);
  if (!arrowheadEnd || !arrowheadStart) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DoubleDropdownPicker,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: ArrowShapeArrowheadStartStyle,
      itemsA: STYLES.arrowheadStart,
      valueA: arrowheadStart,
      uiTypeB: "arrowheadEnd",
      styleB: ArrowShapeArrowheadEndStyle,
      itemsB: STYLES.arrowheadEnd,
      valueB: arrowheadEnd,
      onValueChange: handleValueChange,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
const tldrawSupportedOpacities = [0.1, 0.25, 0.5, 0.75, 1];
function OpacitySlider() {
  const editor = useEditor();
  const onHistoryMark = reactExports.useCallback((id) => editor.markHistoryStoppingPoint(id), [editor]);
  const opacity = useValue("opacity", () => editor.getSharedOpacity(), [editor]);
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const handleOpacityValueChange = React.useCallback(
    (value) => {
      const item = tldrawSupportedOpacities[value];
      editor.run(() => {
        if (editor.isIn("select")) {
          editor.setOpacityForSelectedShapes(item);
        }
        editor.setOpacityForNextShapes(item);
        editor.updateInstanceState({ isChangingStyle: true });
      });
      trackEvent("set-style", { source: "style-panel", id: "opacity", value });
    },
    [editor, trackEvent]
  );
  if (opacity === void 0) return null;
  const opacityIndex = opacity.type === "mixed" ? -1 : tldrawSupportedOpacities.indexOf(
    minBy(
      tldrawSupportedOpacities,
      (supportedOpacity) => Math.abs(supportedOpacity - opacity.value)
    )
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiSlider,
    {
      "data-testid": "style.opacity",
      value: opacityIndex >= 0 ? opacityIndex : tldrawSupportedOpacities.length - 1,
      label: opacity.type === "mixed" ? "style-panel.mixed" : `opacity-style.${opacity.value}`,
      onValueChange: handleOpacityValueChange,
      steps: tldrawSupportedOpacities.length - 1,
      title: msg2("style-panel.opacity"),
      onHistoryMark
    }
  );
}
const DefaultStylePanel = reactExports.memo(function DefaultStylePanel2({
  isMobile,
  children
}) {
  const editor = useEditor();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const styles = useRelevantStyles();
  const handlePointerOut = reactExports.useCallback(() => {
    if (!isMobile) {
      editor.updateInstanceState({ isChangingStyle: false });
    }
  }, [editor, isMobile]);
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultStylePanelContent, { styles });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: classNames("tlui-style-panel", { "tlui-style-panel__wrapper": !isMobile }),
      "data-ismobile": isMobile,
      onPointerLeave: handlePointerOut,
      children: content
    }
  );
});
const TldrawUiContextualToolbar = React.forwardRef(function TldrawUiContextualToolbar2({ children, className, label }, toolbarRef) {
  usePassThroughWheelEvents(toolbarRef);
  usePassThroughMouseOverEvents(toolbarRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: toolbarRef,
      "data-testid": "contextual-toolbar",
      className: classNames("tlui-contextual-toolbar", className),
      onPointerDown: stopEventPropagation,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToolbar, { className: "tlui-menu tlui-buttons__horizontal", label, children })
    }
  );
});
function DefaultRichTextToolbarContent({
  textEditor,
  onEditLinkStart
}) {
  const trackEvent = useUiEvents();
  const msg2 = useTranslation();
  const source = "rich-text-menu";
  const [_, set] = reactExports.useState(0);
  reactExports.useEffect(
    function forceUpdateWhenContentChanges() {
      function forceUpdate() {
        set((t2) => t2 + 1);
      }
      textEditor.on("update", forceUpdate);
      textEditor.on("selectionUpdate", forceUpdate);
    },
    [textEditor]
  );
  reactExports.useEffect(() => {
    function handleKeyDown2(event) {
      if (onEditLinkStart && isAccelKey(event) && event.shiftKey && event.key === "k") {
        event.preventDefault();
        onEditLinkStart();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [onEditLinkStart]);
  const actions = reactExports.useMemo(() => {
    function handleOp(name, op) {
      trackEvent("rich-text", { operation: name, source });
      textEditor.chain().focus()[op]().run();
    }
    return [
      // { name: 'heading', attrs: { level: 3 }, onSelect() { textEditor.chain().focus().toggleHeading({ level: 3}).run() }},
      {
        name: "bold",
        onSelect() {
          handleOp("bold", "toggleBold");
        }
      },
      {
        name: "italic",
        onSelect() {
          handleOp("bold", "toggleItalic");
        }
      },
      // { name: 'underline', onSelect() { handleOp('underline', 'toggleUnderline') }},
      // { name: 'strike', onSelect() { handleOp('strike', 'toggleStrike')  }},
      {
        name: "code",
        onSelect() {
          handleOp("bold", "toggleCode");
        }
      },
      onEditLinkStart ? {
        name: "link",
        onSelect() {
          onEditLinkStart();
        }
      } : void 0,
      // ? is this really optional?
      {
        name: "bulletList",
        onSelect() {
          handleOp("bulletList", "toggleBulletList");
        }
      },
      {
        name: "highlight",
        onSelect() {
          handleOp("bulletList", "toggleHighlight");
        }
      }
    ].filter(Boolean);
  }, [textEditor, trackEvent, onEditLinkStart]);
  return actions.map(({ name, attrs, onSelect }) => {
    const isActive2 = textEditor.isActive(name, attrs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiToolbarButton,
      {
        title: msg2(`tool.rich-text-${name}`),
        "data-testid": `rich-text.${name}`,
        type: "icon",
        isActive: isActive2,
        onPointerDown: preventDefault,
        onClick: onSelect,
        role: "option",
        "aria-pressed": isActive2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: name })
      },
      name
    );
  });
}
function LinkEditor({ textEditor, value: initialValue, onComplete }) {
  const editor = useEditor();
  const [value, setValue] = reactExports.useState(initialValue);
  const msg2 = useTranslation();
  const ref = reactExports.useRef(null);
  const trackEvent = useUiEvents();
  const source = "rich-text-menu";
  const linkifiedValue = value.startsWith("http") ? value : `https://${value}`;
  const handleValueChange = (value2) => setValue(value2);
  const handleLinkComplete = (link) => {
    trackEvent("rich-text", { operation: "link-edit", source });
    if (!link.startsWith("http://") && !link.startsWith("https://")) {
      link = `https://${link}`;
    }
    textEditor.commands.setLink({ href: link });
    if (editor.getInstanceState().isCoarsePointer) {
      textEditor.commands.blur();
    } else {
      textEditor.commands.focus();
    }
    onComplete();
  };
  const handleVisitLink = () => {
    trackEvent("rich-text", { operation: "link-visit", source });
    window.open(linkifiedValue, "_blank", "noopener, noreferrer");
    onComplete();
  };
  const handleRemoveLink = () => {
    trackEvent("rich-text", { operation: "link-remove", source });
    textEditor.chain().unsetLink().focus().run();
    onComplete();
  };
  const handleLinkCancel = () => onComplete();
  reactExports.useEffect(() => {
    if (!value) {
      ref.current?.focus();
    }
  }, [value]);
  reactExports.useEffect(() => {
    setValue(initialValue);
  }, [initialValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiInput,
      {
        ref,
        "data-testid": "rich-text.link-input",
        className: "tlui-rich-text__toolbar-link-input",
        value,
        onValueChange: handleValueChange,
        onComplete: handleLinkComplete,
        onCancel: handleLinkCancel,
        placeholder: "example.com"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-visit",
        title: msg2("tool.rich-text-link-visit"),
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleVisitLink,
        disabled: !value,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "external-link" })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        className: "tlui-rich-text__toolbar-link-remove",
        title: msg2("tool.rich-text-link-remove"),
        "data-testid": "rich-text.link-remove",
        type: "icon",
        onPointerDown: preventDefault,
        onClick: handleRemoveLink,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { small: true, icon: "trash" })
      }
    )
  ] });
}
const MOVE_TIMEOUT = 150;
const HIDE_VISIBILITY_TIMEOUT = 16;
const SHOW_VISIBILITY_TIMEOUT = 16;
const TOOLBAR_GAP = 8;
const SCREEN_MARGIN = 16;
const MIN_DISTANCE_TO_REPOSITION_SQUARED = 16 ** 2;
const HIDE_TOOLBAR_WHEN_CAMERA_IS_MOVING = true;
const DefaultRichTextToolbar = track(function DefaultRichTextToolbar2({
  children
}) {
  const editor = useEditor();
  const textEditor = useValue("textEditor", () => editor.getRichTextEditor(), [editor]);
  if (editor.getInstanceState().isCoarsePointer || !textEditor) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ContextualToolbarInner, { textEditor, children });
});
function ContextualToolbarInner({
  textEditor,
  children
}) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const rToolbar = reactExports.useRef(null);
  const { isVisible, isInteractive, hide: hide2, show, position, move } = useToolbarVisibilityStateMachine();
  const { isEditingLink, onEditLinkStart, onEditLinkComplete } = useEditingLinkBehavior(textEditor);
  const forcePositionUpdateAtom = useAtom("force toolbar position update", 0);
  reactExports.useEffect(
    function forceUpdateWhenSelectionUpdates() {
      function handleSelectionUpdate() {
        forcePositionUpdateAtom.update((t2) => t2 + 1);
      }
      tltime.requestAnimationFrame("first forced update", handleSelectionUpdate);
      textEditor.on("selectionUpdate", handleSelectionUpdate);
      return () => {
        textEditor.off("selectionUpdate", handleSelectionUpdate);
      };
    },
    [textEditor, forcePositionUpdateAtom]
  );
  useReactor(
    "shape change",
    function forceUpdateOnNextFrameWhenShapeChanges() {
      editor.getEditingShape();
      forcePositionUpdateAtom.update((t2) => t2 + 1);
    },
    [editor]
  );
  const rCouldShowToolbar = reactExports.useRef(false);
  const [hasValidToolbarPosition, setHasValidToolbarPosition] = reactExports.useState(false);
  useQuickReactor(
    "toolbar position",
    function updateToolbarPositionAndDisplay() {
      const toolbarElm = rToolbar.current;
      if (!toolbarElm) return;
      editor.getCamera();
      forcePositionUpdateAtom.get();
      const position2 = getToolbarScreenPosition(editor, toolbarElm);
      if (!position2) {
        if (rCouldShowToolbar.current) {
          rCouldShowToolbar.current = false;
          setHasValidToolbarPosition(false);
        }
        return;
      }
      const cameraState2 = editor.getCameraState();
      if (cameraState2 === "moving") {
        const elm = rToolbar.current;
        elm.style.setProperty("transform", `translate(${position2.x}px, ${position2.y}px)`);
      } else {
        move(position2.x, position2.y);
      }
      if (!rCouldShowToolbar.current) {
        rCouldShowToolbar.current = true;
        setHasValidToolbarPosition(true);
      }
    },
    [editor, textEditor, forcePositionUpdateAtom]
  );
  const cameraState = useValue("camera state", () => editor.getCameraState(), [editor]);
  const isMousingDown = useIsMousingDownOnTextEditor(textEditor);
  reactExports.useEffect(() => {
    if (cameraState === "moving" && HIDE_TOOLBAR_WHEN_CAMERA_IS_MOVING) {
      hide2(true);
      return;
    }
    if (isMousingDown || !hasValidToolbarPosition) {
      hide2();
      return;
    }
    show();
  }, [hasValidToolbarPosition, cameraState, isMousingDown, show, hide2]);
  reactExports.useLayoutEffect(() => {
    const elm = rToolbar.current;
    if (!elm) return;
    elm.dataset.visible = `${isVisible}`;
  }, [isVisible, position]);
  reactExports.useLayoutEffect(() => {
    const elm = rToolbar.current;
    if (!elm) return;
    elm.style.setProperty("transform", `translate(${position.x}px, ${position.y}px)`);
  }, [position]);
  reactExports.useLayoutEffect(() => {
    const elm = rToolbar.current;
    if (!elm) return;
    elm.dataset.interactive = `${isInteractive}`;
  }, [isInteractive]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiContextualToolbar,
    {
      ref: rToolbar,
      className: "tlui-rich-text__toolbar",
      "data-interactive": false,
      "data-visible": false,
      label: msg2("tool.rich-text-toolbar-title"),
      children: children ? children : isEditingLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        LinkEditor,
        {
          textEditor,
          value: textEditor.isActive("link") ? textEditor.getAttributes("link").href : "",
          onComplete: onEditLinkComplete
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultRichTextToolbarContent, { textEditor, onEditLinkStart })
    }
  );
}
function rectToBox(rect) {
  return new Box(rect.x, rect.y, rect.width, rect.height);
}
function getToolbarScreenPosition(editor, toolbarElm) {
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed) return;
  const rangeBoxes = [];
  for (let i = 0; i < selection.rangeCount; i++) {
    const range = selection.getRangeAt(i);
    rangeBoxes.push(rectToBox(range.getBoundingClientRect()));
  }
  const selectionBounds = Box.Common(rangeBoxes);
  const vsb = editor.getViewportScreenBounds();
  selectionBounds.x -= vsb.x;
  selectionBounds.y -= vsb.y;
  if (selectionBounds.midY < SCREEN_MARGIN || selectionBounds.midY > vsb.h - SCREEN_MARGIN || selectionBounds.midX < SCREEN_MARGIN || selectionBounds.midX > vsb.w - SCREEN_MARGIN) {
    return;
  }
  const toolbarBounds = rectToBox(toolbarElm.getBoundingClientRect());
  if (!toolbarBounds.width || !toolbarBounds.height) return;
  const { scrollLeft, scrollTop } = editor.getContainer();
  let x = selectionBounds.midX - toolbarBounds.w / 2;
  let y2 = selectionBounds.y - toolbarBounds.h - TOOLBAR_GAP;
  x = clamp$3(x, SCREEN_MARGIN, vsb.w - toolbarBounds.w - SCREEN_MARGIN);
  y2 = clamp$3(y2, SCREEN_MARGIN, vsb.h - toolbarBounds.h - SCREEN_MARGIN);
  x += scrollLeft;
  y2 += scrollTop;
  x = Math.round(x);
  y2 = Math.round(y2);
  return { x, y: y2 };
}
function useEditingLinkBehavior(textEditor) {
  const [isEditingLink, setIsEditingLink] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!textEditor) {
      setIsEditingLink(false);
      return;
    }
    const handleClick2 = () => {
      const isLinkActive = textEditor.isActive("link");
      setIsEditingLink(isLinkActive);
    };
    textEditor.view.dom.addEventListener("click", handleClick2);
    return () => {
      textEditor.view.dom.removeEventListener("click", handleClick2);
    };
  }, [textEditor, isEditingLink]);
  reactExports.useEffect(() => {
    if (!textEditor) {
      return;
    }
    if (textEditor.isActive("link")) {
      try {
        const { from: from2, to } = getMarkRange(
          textEditor.state.doc.resolve(textEditor.state.selection.from),
          textEditor.schema.marks.link
        );
        if (textEditor.state.selection.empty) {
          textEditor.commands.setTextSelection({ from: from2, to });
        }
      } catch {
      }
    }
  }, [textEditor, isEditingLink]);
  const onEditLinkStart = reactExports.useCallback(() => {
    setIsEditingLink(true);
  }, []);
  const onEditLinkCancel = reactExports.useCallback(() => {
    setIsEditingLink(false);
  }, []);
  const onEditLinkComplete = reactExports.useCallback(() => {
    setIsEditingLink(false);
    if (!textEditor) return;
    const from2 = textEditor.state.selection.from;
    textEditor.commands.setTextSelection({ from: from2, to: from2 });
  }, [textEditor]);
  return { isEditingLink, onEditLinkStart, onEditLinkComplete, onEditLinkCancel };
}
function sufficientlyDistant(curr, next) {
  {
    return Vec.Sub(next, curr).y ** 2 >= MIN_DISTANCE_TO_REPOSITION_SQUARED;
  }
}
function useToolbarVisibilityStateMachine() {
  const editor = useEditor();
  const rState = reactExports.useRef({ name: "hidden" });
  const [isInteractive, setIsInteractive] = reactExports.useState(false);
  const [isVisible, setIsVisible] = reactExports.useState(false);
  const [position, setPosition] = reactExports.useState({ x: -1e3, y: -1e3 });
  const rCurrPosition = reactExports.useRef(new Vec(-1e3, -1e3));
  const rNextPosition = reactExports.useRef(new Vec(-1e3, -1e3));
  const rStableVisibilityTimeout = reactExports.useRef(-1);
  const rStablePositionTimeout = reactExports.useRef(-1);
  const move = reactExports.useCallback(
    (x, y2) => {
      rNextPosition.current.x = x;
      rNextPosition.current.y = y2;
      if (rState.current.name === "hidden" || rState.current.name === "showing") return;
      clearTimeout(rStablePositionTimeout.current);
      rStablePositionTimeout.current = editor.timers.setTimeout(() => {
        if (rState.current.name === "shown" && sufficientlyDistant(rNextPosition.current, rCurrPosition.current)) {
          const { x: x2, y: y22 } = rNextPosition.current;
          rCurrPosition.current = new Vec(x2, y22);
          setPosition({ x: x2, y: y22 });
        }
      }, MOVE_TIMEOUT);
    },
    [editor]
  );
  const hide2 = reactExports.useCallback(
    (immediate = false) => {
      switch (rState.current.name) {
        case "showing": {
          clearTimeout(rStableVisibilityTimeout.current);
          rState.current = { name: "hidden" };
          break;
        }
        case "shown": {
          rState.current = { name: "hiding" };
          setIsInteractive(false);
          if (immediate) {
            rState.current = { name: "hidden" };
            setIsVisible(false);
          } else {
            rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
              rState.current = { name: "hidden" };
              setIsVisible(false);
            }, HIDE_VISIBILITY_TIMEOUT);
          }
          break;
        }
      }
    },
    [editor]
  );
  const show = reactExports.useCallback(() => {
    switch (rState.current.name) {
      case "hidden": {
        rState.current = { name: "showing" };
        rStableVisibilityTimeout.current = editor.timers.setTimeout(() => {
          const { x, y: y2 } = rNextPosition.current;
          rCurrPosition.current = new Vec(x, y2);
          setPosition({ x, y: y2 });
          rState.current = { name: "shown" };
          setIsVisible(true);
          setIsInteractive(true);
        }, SHOW_VISIBILITY_TIMEOUT);
        break;
      }
      case "hiding": {
        clearTimeout(rStableVisibilityTimeout.current);
        rState.current = { name: "shown" };
        setIsInteractive(true);
        move(rNextPosition.current.x, rNextPosition.current.y);
        break;
      }
    }
  }, [editor, move]);
  return { isVisible, isInteractive, show, hide: hide2, move, position };
}
function useIsMousingDownOnTextEditor(textEditor) {
  const [isMousingDown, setIsMousingDown] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!textEditor) return;
    const handlePointingStateChange = debounce(({ isPointing }) => {
      setIsMousingDown(isPointing);
    }, 16);
    const handlePointingDown = () => handlePointingStateChange({ isPointing: true });
    const handlePointingUp = () => handlePointingStateChange({ isPointing: false });
    const touchDownEvents = ["touchstart", "pointerdown", "mousedown"];
    const touchUpEvents = ["touchend", "pointerup", "mouseup"];
    touchDownEvents.forEach((eventName) => {
      textEditor.view.dom.addEventListener(eventName, handlePointingDown);
    });
    touchUpEvents.forEach((eventName) => {
      document.body.addEventListener(eventName, handlePointingUp);
    });
    return () => {
      touchDownEvents.forEach((eventName) => {
        textEditor.view.dom.removeEventListener(eventName, handlePointingDown);
      });
      touchUpEvents.forEach((eventName) => {
        document.body.removeEventListener(eventName, handlePointingUp);
      });
    };
  }, [textEditor]);
  return isMousingDown;
}
function MobileStylePanel() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const relevantStyles = useRelevantStyles();
  const color = relevantStyles?.get(DefaultColorStyle);
  const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() });
  const currentColor = (color?.type === "shared" ? theme[color.value] : theme.black).solid;
  const disableStylePanel = useValue(
    "disable style panel",
    () => editor.isInAny("hand", "zoom", "eraser", "laser"),
    [editor]
  );
  const handleStylesOpenChange = reactExports.useCallback(
    (isOpen) => {
      if (!isOpen) {
        editor.updateInstanceState({ isChangingStyle: false });
      }
    },
    [editor]
  );
  const { StylePanel } = useTldrawUiComponents();
  if (!StylePanel) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: "mobile style menu", onOpenChange: handleStylesOpenChange, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      TldrawUiButton,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: disableStylePanel ? "var(--color-muted-1)" : currentColor
        },
        title: msg2("style-panel.title"),
        disabled: disableStylePanel,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButtonIcon,
          {
            icon: disableStylePanel ? "blob" : color?.type === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "top", align: "end", children: StylePanel && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanel, { isMobile: true }) })
  ] });
}
function DefaultToolbarContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HandToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DrawToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EraserToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TextToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NoteToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AssetToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RectangleToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EllipseToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TriangleToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DiamondToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HexagonToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(OvalToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(RhombusToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StarToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CloudToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HeartToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(XBoxToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CheckBoxToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDownToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRightToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LineToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HighlightToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LaserToolbarItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FrameToolbarItem, {})
  ] });
}
function useIsToolSelected(tool) {
  const editor = useEditor();
  const geo = tool?.meta?.geo;
  return useValue(
    "is tool selected",
    () => {
      if (!tool) return false;
      const activeToolId = editor.getCurrentToolId();
      if (activeToolId === "geo") {
        return geo === editor.getSharedStyles().getAsKnownValue(GeoShapeGeoStyle);
      } else {
        return activeToolId === tool.id;
      }
    },
    [editor, tool?.id, geo]
  );
}
function ToolbarItem({ tool }) {
  const tools = useTools();
  const isSelected = useIsToolSelected(tools[tool]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: tool, isSelected });
}
function SelectToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "select" });
}
function HandToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "hand" });
}
function DrawToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "draw" });
}
function EraserToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "eraser" });
}
function ArrowToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow" });
}
function TextToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "text" });
}
function NoteToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "note" });
}
function AssetToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuToolItem, { toolId: "asset" });
}
function RectangleToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "rectangle" });
}
function EllipseToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "ellipse" });
}
function DiamondToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "diamond" });
}
function TriangleToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "triangle" });
}
function RhombusToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "rhombus" });
}
function HeartToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "heart" });
}
function HexagonToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "hexagon" });
}
function CloudToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "cloud" });
}
function StarToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "star" });
}
function OvalToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "oval" });
}
function XBoxToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "x-box" });
}
function CheckBoxToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "check-box" });
}
function ArrowLeftToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-left" });
}
function ArrowUpToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-up" });
}
function ArrowDownToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-down" });
}
function ArrowRightToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "arrow-right" });
}
function LineToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "line" });
}
function HighlightToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "highlight" });
}
function FrameToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "frame" });
}
function LaserToolbarItem() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarItem, { tool: "laser" });
}
const isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function addEvent(object2, event, method, useCapture) {
  if (object2.addEventListener) {
    object2.addEventListener(event, method, useCapture);
  } else if (object2.attachEvent) {
    object2.attachEvent("on".concat(event), method);
  }
}
function removeEvent(object2, event, method, useCapture) {
  if (object2.removeEventListener) {
    object2.removeEventListener(event, method, useCapture);
  } else if (object2.detachEvent) {
    object2.detachEvent("on".concat(event), method);
  }
}
function getMods(modifier, key) {
  const mods = key.slice(0, key.length - 1);
  for (let i = 0; i < mods.length; i++) mods[i] = modifier[mods[i].toLowerCase()];
  return mods;
}
function getKeys$1(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  const keys2 = key.split(",");
  let index2 = keys2.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys2[index2 - 1] += ",";
    keys2.splice(index2, 1);
    index2 = keys2.lastIndexOf("");
  }
  return keys2;
}
function compareArray(a1, a2) {
  const arr1 = a1.length >= a2.length ? a1 : a2;
  const arr2 = a1.length >= a2.length ? a2 : a1;
  let isIndex = true;
  for (let i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
  }
  return isIndex;
}
const _keyMap = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": isff ? 173 : 189,
  "=": isff ? 61 : 187,
  ";": isff ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
};
const _modifier = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
};
const modifierMap = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
const _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
const _handlers = {};
for (let k = 1; k < 20; k++) {
  _keyMap["f".concat(k)] = 111 + k;
}
let _downKeys = [];
let winListendFocus = null;
let _scope = "all";
const elementEventMap = /* @__PURE__ */ new Map();
const code = (x) => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
const getKey = (x) => Object.keys(_keyMap).find((k) => _keyMap[k] === x);
const getModifier = (x) => Object.keys(_modifier).find((k) => _modifier[k] === x);
function setScope(scope) {
  _scope = scope || "all";
}
function getScope() {
  return _scope || "all";
}
function getPressedKeyCodes() {
  return _downKeys.slice(0);
}
function getPressedKeyString() {
  return _downKeys.map((c2) => getKey(c2) || getModifier(c2) || String.fromCharCode(c2));
}
function getAllKeyCodes() {
  const result = [];
  Object.keys(_handlers).forEach((k) => {
    _handlers[k].forEach((_ref) => {
      let {
        key,
        scope,
        mods,
        shortcut
      } = _ref;
      result.push({
        scope,
        shortcut,
        mods,
        keys: key.split("+").map((v) => code(v))
      });
    });
  });
  return result;
}
function filter(event) {
  const target = event.target || event.srcElement;
  const {
    tagName
  } = target;
  let flag = true;
  const isInput = tagName === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(target.type);
  if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
    flag = false;
  }
  return flag;
}
function isPressed(keyCode) {
  if (typeof keyCode === "string") {
    keyCode = code(keyCode);
  }
  return _downKeys.indexOf(keyCode) !== -1;
}
function deleteScope(scope, newScope) {
  let handlers2;
  let i;
  if (!scope) scope = getScope();
  for (const key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers2 = _handlers[key];
      for (i = 0; i < handlers2.length; ) {
        if (handlers2[i].scope === scope) {
          const deleteItems = handlers2.splice(i, 1);
          deleteItems.forEach((_ref2) => {
            let {
              element
            } = _ref2;
            return removeKeyEvent(element);
          });
        } else {
          i++;
        }
      }
    }
  }
  if (getScope() === scope) setScope(newScope || "all");
}
function clearModifier(event) {
  let key = event.keyCode || event.which || event.charCode;
  const i = _downKeys.indexOf(key);
  if (i >= 0) {
    _downKeys.splice(i, 1);
  }
  if (event.key && event.key.toLowerCase() === "meta") {
    _downKeys.splice(0, _downKeys.length);
  }
  if (key === 93 || key === 224) key = 91;
  if (key in _mods) {
    _mods[key] = false;
    for (const k in _modifier) if (_modifier[k] === key) hotkeys[k] = false;
  }
}
function unbind(keysInfo) {
  if (typeof keysInfo === "undefined") {
    Object.keys(_handlers).forEach((key) => {
      Array.isArray(_handlers[key]) && _handlers[key].forEach((info) => eachUnbind(info));
      delete _handlers[key];
    });
    removeKeyEvent(null);
  } else if (Array.isArray(keysInfo)) {
    keysInfo.forEach((info) => {
      if (info.key) eachUnbind(info);
    });
  } else if (typeof keysInfo === "object") {
    if (keysInfo.key) eachUnbind(keysInfo);
  } else if (typeof keysInfo === "string") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let [scope, method] = args;
    if (typeof scope === "function") {
      method = scope;
      scope = "";
    }
    eachUnbind({
      key: keysInfo,
      scope,
      method,
      splitKey: "+"
    });
  }
}
const eachUnbind = (_ref3) => {
  let {
    key,
    scope,
    method,
    splitKey = "+"
  } = _ref3;
  const multipleKeys = getKeys$1(key);
  multipleKeys.forEach((originKey) => {
    const unbindKeys = originKey.split(splitKey);
    const len = unbindKeys.length;
    const lastKey = unbindKeys[len - 1];
    const keyCode = lastKey === "*" ? "*" : code(lastKey);
    if (!_handlers[keyCode]) return;
    if (!scope) scope = getScope();
    const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    const unbindElements = [];
    _handlers[keyCode] = _handlers[keyCode].filter((record) => {
      const isMatchingMethod = method ? record.method === method : true;
      const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
      if (isUnbind) unbindElements.push(record.element);
      return !isUnbind;
    });
    unbindElements.forEach((element) => removeKeyEvent(element));
  });
};
function eventHandler(event, handler, scope, element) {
  if (handler.element !== element) {
    return;
  }
  let modifiersMatch;
  if (handler.scope === scope || handler.scope === "all") {
    modifiersMatch = handler.mods.length > 0;
    for (const y2 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y2)) {
        if (!_mods[y2] && handler.mods.indexOf(+y2) > -1 || _mods[y2] && handler.mods.indexOf(+y2) === -1) {
          modifiersMatch = false;
        }
      }
    }
    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
      handler.keys = [];
      handler.keys = handler.keys.concat(_downKeys);
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault();
        else event.returnValue = false;
        if (event.stopPropagation) event.stopPropagation();
        if (event.cancelBubble) event.cancelBubble = true;
      }
    }
  }
}
function dispatch(event, element) {
  const asterisk = _handlers["*"];
  let key = event.keyCode || event.which || event.charCode;
  if (!hotkeys.filter.call(this, event)) return;
  if (key === 93 || key === 224) key = 91;
  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
  ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((keyName2) => {
    const keyNum = modifierMap[keyName2];
    if (event[keyName2] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName2] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    } else if (keyName2 === "metaKey" && event[keyName2]) {
      _downKeys = _downKeys.filter((k) => k in modifierMap || k === key);
    }
  });
  if (key in _mods) {
    _mods[key] = true;
    for (const k in _modifier) {
      if (Object.prototype.hasOwnProperty.call(_modifier, k)) {
        const eventKey = modifierMap[_modifier[k]];
        hotkeys[k] = event[eventKey];
      }
    }
    if (!asterisk) return;
  }
  for (const e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  }
  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
    if (_downKeys.indexOf(17) === -1) {
      _downKeys.push(17);
    }
    if (_downKeys.indexOf(18) === -1) {
      _downKeys.push(18);
    }
    _mods[17] = true;
    _mods[18] = true;
  }
  const scope = getScope();
  if (asterisk) {
    for (let i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === "keydown" && asterisk[i].keydown || event.type === "keyup" && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope, element);
      }
    }
  }
  if (!(key in _handlers)) return;
  const handlerKey = _handlers[key];
  const keyLen = handlerKey.length;
  for (let i = 0; i < keyLen; i++) {
    if (event.type === "keydown" && handlerKey[i].keydown || event.type === "keyup" && handlerKey[i].keyup) {
      if (handlerKey[i].key) {
        const record = handlerKey[i];
        const {
          splitKey
        } = record;
        const keyShortcut = record.key.split(splitKey);
        const _downKeysCurrent = [];
        for (let a2 = 0; a2 < keyShortcut.length; a2++) {
          _downKeysCurrent.push(code(keyShortcut[a2]));
        }
        if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
          eventHandler(event, record, scope, element);
        }
      }
    }
  }
}
function hotkeys(key, option, method) {
  _downKeys = [];
  const keys2 = getKeys$1(key);
  let mods = [];
  let scope = "all";
  let element = document;
  let i = 0;
  let keyup = false;
  let keydown = true;
  let splitKey = "+";
  let capture = false;
  let single = false;
  if (method === void 0 && typeof option === "function") {
    method = option;
  }
  if (Object.prototype.toString.call(option) === "[object Object]") {
    if (option.scope) scope = option.scope;
    if (option.element) element = option.element;
    if (option.keyup) keyup = option.keyup;
    if (option.keydown !== void 0) keydown = option.keydown;
    if (option.capture !== void 0) capture = option.capture;
    if (typeof option.splitKey === "string") splitKey = option.splitKey;
    if (option.single === true) single = true;
  }
  if (typeof option === "string") scope = option;
  if (single) unbind(key, scope);
  for (; i < keys2.length; i++) {
    key = keys2[i].split(splitKey);
    mods = [];
    if (key.length > 1) mods = getMods(_modifier, key);
    key = key[key.length - 1];
    key = key === "*" ? "*" : code(key);
    if (!(key in _handlers)) _handlers[key] = [];
    _handlers[key].push({
      keyup,
      keydown,
      scope,
      mods,
      shortcut: keys2[i],
      method,
      key: keys2[i],
      splitKey,
      element
    });
  }
  if (typeof element !== "undefined" && window) {
    if (!elementEventMap.has(element)) {
      const keydownListener = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return dispatch(event, element);
      };
      const keyupListenr = function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        dispatch(event, element);
        clearModifier(event);
      };
      elementEventMap.set(element, {
        keydownListener,
        keyupListenr,
        capture
      });
      addEvent(element, "keydown", keydownListener, capture);
      addEvent(element, "keyup", keyupListenr, capture);
    }
    if (!winListendFocus) {
      const listener = () => {
        _downKeys = [];
      };
      winListendFocus = {
        listener,
        capture
      };
      addEvent(window, "focus", listener, capture);
    }
  }
}
function trigger(shortcut) {
  let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(_handlers).forEach((key) => {
    const dataList = _handlers[key].filter((item) => item.scope === scope && item.shortcut === shortcut);
    dataList.forEach((data) => {
      if (data && data.method) {
        data.method();
      }
    });
  });
}
function removeKeyEvent(element) {
  const values = Object.values(_handlers).flat();
  const findindex = values.findIndex((_ref4) => {
    let {
      element: el
    } = _ref4;
    return el === element;
  });
  if (findindex < 0) {
    const {
      keydownListener,
      keyupListenr,
      capture
    } = elementEventMap.get(element) || {};
    if (keydownListener && keyupListenr) {
      removeEvent(element, "keyup", keyupListenr, capture);
      removeEvent(element, "keydown", keydownListener, capture);
      elementEventMap.delete(element);
    }
  }
  if (values.length <= 0 || elementEventMap.size <= 0) {
    const eventKeys = Object.keys(elementEventMap);
    eventKeys.forEach((el) => {
      const {
        keydownListener,
        keyupListenr,
        capture
      } = elementEventMap.get(el) || {};
      if (keydownListener && keyupListenr) {
        removeEvent(el, "keyup", keyupListenr, capture);
        removeEvent(el, "keydown", keydownListener, capture);
        elementEventMap.delete(el);
      }
    });
    elementEventMap.clear();
    Object.keys(_handlers).forEach((key) => delete _handlers[key]);
    if (winListendFocus) {
      const {
        listener,
        capture
      } = winListendFocus;
      removeEvent(window, "focus", listener, capture);
      winListendFocus = null;
    }
  }
}
const _api = {
  getPressedKeyString,
  setScope,
  getScope,
  deleteScope,
  getPressedKeyCodes,
  getAllKeyCodes,
  isPressed,
  filter,
  trigger,
  unbind,
  keyMap: _keyMap,
  modifier: _modifier,
  modifierMap
};
for (const a2 in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a2)) {
    hotkeys[a2] = _api[a2];
  }
}
if (typeof window !== "undefined") {
  const _hotkeys = window.hotkeys;
  hotkeys.noConflict = (deep) => {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }
    return hotkeys;
  };
  window.hotkeys = hotkeys;
}
const SKIP_KBDS = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function useKeyboardShortcuts() {
  const editor = useEditor();
  const isReadonlyMode = useReadonly();
  const actions = useActions();
  const tools = useTools();
  const isFocused = useValue("is focused", () => editor.getInstanceState().isFocused, [editor]);
  reactExports.useEffect(() => {
    if (!isFocused) return;
    const disposables = new Array();
    const hot = (keys2, callback) => {
      hotkeys(keys2, { element: document.body }, callback);
      disposables.push(() => {
        hotkeys.unbind(keys2, callback);
      });
    };
    const hotUp = (keys2, callback) => {
      hotkeys(keys2, { element: document.body, keyup: true, keydown: false }, callback);
      disposables.push(() => {
        hotkeys.unbind(keys2, callback);
      });
    };
    for (const action of Object.values(actions)) {
      if (!action.kbd) continue;
      if (isReadonlyMode && !action.readonlyOk) continue;
      if (SKIP_KBDS.includes(action.id)) continue;
      hot(getHotkeysStringFromKbd(action.kbd), (event) => {
        if (areShortcutsDisabled(editor)) return;
        preventDefault(event);
        action.onSelect("kbd");
      });
    }
    for (const tool of Object.values(tools)) {
      if (!tool.kbd || !tool.readonlyOk && editor.getIsReadonly()) {
        continue;
      }
      if (SKIP_KBDS.includes(tool.id)) continue;
      hot(getHotkeysStringFromKbd(tool.kbd), (event) => {
        if (areShortcutsDisabled(editor)) return;
        preventDefault(event);
        tool.onSelect("kbd");
      });
    }
    hot(",", (e) => {
      if (areShortcutsDisabled(editor)) return;
      if (editor.inputs.keys.has("Comma")) return;
      preventDefault(e);
      editor.focus();
      editor.inputs.keys.add("Comma");
      const { x, y: y2, z } = editor.inputs.currentPagePoint;
      const screenpoints = editor.pageToScreen({ x, y: y2 });
      const info = {
        type: "pointer",
        name: "pointer_down",
        point: { x: screenpoints.x, y: screenpoints.y, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    hotUp(",", (e) => {
      if (areShortcutsDisabled(editor)) return;
      if (!editor.inputs.keys.has("Comma")) return;
      editor.inputs.keys.delete("Comma");
      const { x, y: y2, z } = editor.inputs.currentScreenPoint;
      const info = {
        type: "pointer",
        name: "pointer_up",
        point: { x, y: y2, z },
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        ctrlKey: e.metaKey || e.ctrlKey,
        metaKey: e.metaKey,
        accelKey: isAccelKey(e),
        pointerId: 0,
        button: 0,
        isPen: editor.getInstanceState().isPenMode,
        target: "canvas"
      };
      editor.dispatch(info);
    });
    return () => {
      disposables.forEach((d) => d());
    };
  }, [actions, tools, isReadonlyMode, editor, isFocused]);
}
function areShortcutsDisabled(editor) {
  return editor.menus.hasAnyOpenMenus() || editor.getEditingShapeId() !== null || editor.getCrashingError();
}
function getHotkeysStringFromKbd(kbd2) {
  return getKeys(kbd2).map((kbd22) => {
    let str2 = "";
    const shift2 = kbd22.includes("!");
    const alt = kbd22.includes("?");
    const cmd = kbd22.includes("$");
    const k = kbd22.replace(/[!?$]/g, "");
    if (shift2 && alt && cmd) {
      str2 = `cmd+shift+alt+${k},ctrl+shift+alt+${k}`;
    } else if (shift2 && cmd) {
      str2 = `cmd+shift+${k},ctrl+shift+${k}`;
    } else if (alt && cmd) {
      str2 = `cmd+alt+${k},ctrl+alt+${k}`;
    } else if (alt && shift2) {
      str2 = `shift+alt+${k}`;
    } else if (shift2) {
      str2 = `shift+${k}`;
    } else if (alt) {
      str2 = `alt+${k}`;
    } else if (cmd) {
      str2 = `cmd+${k},ctrl+${k}`;
    } else {
      str2 = k;
    }
    return str2;
  }).join(",");
}
function getKeys(key) {
  if (typeof key !== "string") key = "";
  key = key.replace(/\s/g, "");
  const keys2 = key.split(",");
  let index2 = keys2.lastIndexOf("");
  for (; index2 >= 0; ) {
    keys2[index2 - 1] += ",";
    keys2.splice(index2, 1);
    index2 = keys2.lastIndexOf("");
  }
  return keys2;
}
const IsInOverflowContext = reactExports.createContext(false);
const NUMBERED_SHORTCUT_KEYS = {
  "1": 0,
  "2": 1,
  "3": 2,
  "4": 3,
  "5": 4,
  "6": 5,
  "7": 6,
  "8": 7,
  "9": 8,
  "0": 9
};
function OverflowingToolbar({ children }) {
  const editor = useEditor();
  const id = useUniqueSafeId();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const rButtons = reactExports.useRef([]);
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const overflowIndex = Math.min(8, 5 + breakpoint);
  const [totalItems, setTotalItems] = reactExports.useState(0);
  const mainToolsRef = reactExports.useRef(null);
  const [lastActiveOverflowItem, setLastActiveOverflowItem] = reactExports.useState(null);
  const css = reactExports.useMemo(() => {
    const activeCss = lastActiveOverflowItem ? `:not([data-value="${lastActiveOverflowItem}"])` : "";
    return `
			#${id}_main > *:nth-child(n + ${overflowIndex + (lastActiveOverflowItem ? 1 : 2)})${activeCss} {
				display: none;
			}
			#${id}_more > *:nth-child(-n + ${overflowIndex}) {
				display: none;
			}
			#${id}_more > *:nth-child(-n + ${overflowIndex + 4}) {
				margin-top: 0;
			}
        `;
  }, [lastActiveOverflowItem, id, overflowIndex]);
  const onDomUpdate = useEvent(() => {
    if (!mainToolsRef.current) return;
    const children2 = Array.from(mainToolsRef.current.children);
    setTotalItems(children2.length);
    const lastActiveElementIdx = children2.findIndex(
      (el) => el.getAttribute("data-value") === lastActiveOverflowItem
    );
    if (lastActiveElementIdx <= overflowIndex) {
      setLastActiveOverflowItem(null);
    }
    const activeElementIdx = Array.from(mainToolsRef.current.children).findIndex(
      (el) => el.getAttribute("aria-pressed") === "true"
    );
    if (activeElementIdx === -1) return;
    if (activeElementIdx >= overflowIndex) {
      setLastActiveOverflowItem(children2[activeElementIdx].getAttribute("data-value"));
    }
    rButtons.current = Array.from(mainToolsRef.current?.children ?? []).filter(
      (el) => {
        if (!(el instanceof HTMLElement)) return false;
        if (el.tagName.toLowerCase() !== "button") return false;
        return !!(el.offsetWidth || el.offsetHeight);
      }
    );
  });
  reactExports.useLayoutEffect(() => {
    onDomUpdate();
  });
  reactExports.useLayoutEffect(() => {
    if (!mainToolsRef.current) return;
    const mutationObserver = new MutationObserver(onDomUpdate);
    mutationObserver.observe(mainToolsRef.current, {
      childList: true,
      subtree: true,
      attributeFilter: ["data-value", "aria-pressed"]
    });
    return () => {
      mutationObserver.disconnect();
    };
  }, [onDomUpdate]);
  reactExports.useEffect(() => {
    if (!editor.options.enableToolbarKeyboardShortcuts) return;
    function handleKeyDown2(event) {
      if (areShortcutsDisabled(editor) || activeElementShouldCaptureKeys(
        true
        /* allow buttons */
      ))
        return;
      if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey) return;
      const index2 = NUMBERED_SHORTCUT_KEYS[event.key];
      if (typeof index2 === "number") {
        preventDefault(event);
        rButtons.current[index2]?.click();
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [editor]);
  const popoverId = "toolbar overflow";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { nonce: editor.options.nonce, children: css }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TldrawUiToolbar,
      {
        className: classNames("tlui-toolbar__tools", {
          "tlui-toolbar__tools__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
        }),
        label: msg2("tool-panel.title"),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: `${id}_main`, ref: mainToolsRef, className: "tlui-toolbar__tools__list", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "toolbar", sourceId: "toolbar", children }) }),
          totalItems > overflowIndex + 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(IsInOverflowContext.Provider, { value: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiPopover, { id: popoverId, open: isOpen, onOpenChange: setIsOpen, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiToolbarButton,
              {
                title: msg2("tool-panel.more"),
                type: "tool",
                className: "tlui-toolbar__overflow",
                "data-testid": "tools.more-button",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "chevron-up" })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiPopoverContent, { side: "top", align: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              TldrawUiToolbar,
              {
                className: "tlui-buttons__grid",
                "data-testid": "tools.more-content",
                label: msg2("tool-panel.more"),
                id: `${id}_more`,
                onClick: () => {
                  tlmenus.deleteOpenMenu(popoverId, editor.contextId);
                  setIsOpen(false);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "toolbar-overflow", sourceId: "toolbar", children })
              }
            ) })
          ] }) })
        ]
      }
    )
  ] });
}
function ToggleToolLockedButton({ activeToolId }) {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const msg2 = useTranslation();
  const isToolLocked = useValue("is tool locked", () => editor.getInstanceState().isToolLocked, [
    editor
  ]);
  const tool = useValue("current tool", () => editor.getCurrentTool(), [editor]);
  if (!activeToolId || !tool.isLockable) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiButton,
    {
      type: "normal",
      title: msg2("action.toggle-tool-lock"),
      "data-testid": "tool-lock",
      className: classNames("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      onClick: () => editor.updateInstanceState({ isToolLocked: !isToolLocked }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: isToolLocked ? "lock" : "unlock", small: true })
    }
  );
}
const DefaultToolbar = reactExports.memo(function DefaultToolbar2({ children }) {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const activeToolId = useValue("current tool id", () => editor.getCurrentToolId(), [editor]);
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const { ActionsMenu, QuickActions } = useTldrawUiComponents();
  const showQuickActions = editor.options.actionShortcutsLocation === "menu" ? false : editor.options.actionShortcutsLocation === "toolbar" ? true : breakpoint < PORTRAIT_BREAKPOINT.TABLET;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: "tlui-toolbar", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toolbar__inner", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toolbar__left", children: [
      !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-toolbar__extras", children: [
        showQuickActions && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TldrawUiToolbar,
          {
            className: "tlui-toolbar__extras__controls tlui-buttons__horizontal",
            label: msg2("actions-menu.title"),
            children: [
              QuickActions && /* @__PURE__ */ jsxRuntimeExports.jsx(QuickActions, {}),
              ActionsMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsMenu, {})
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleToolLockedButton, { activeToolId })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(OverflowingToolbar, { children: children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultToolbarContent, {}) })
    ] }),
    breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MobileStylePanel, {}) })
  ] }) });
});
function OfflineIndicator() {
  const msg2 = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classNames("tlui-offline-indicator"), children: [
    msg2("status.offline"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiIcon, { label: msg2("status.offline"), icon: "status-offline", small: true })
  ] });
}
function CenteredTopPanelContainer({
  maxWidth = 420,
  ignoreRightWidth = 0,
  stylePanelWidth = 148,
  marginBetweenZones = 12,
  squeezeAmount = 52,
  children
}) {
  const ref = reactExports.useRef(null);
  const breakpoint = useBreakpoint();
  const updateLayout = reactExports.useCallback(() => {
    const element = ref.current;
    if (!element) return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const totalWidth = layoutTop.offsetWidth;
    const leftWidth = leftPanel.offsetWidth;
    const rightWidth = rightPanel.offsetWidth;
    const selfWidth = element.offsetWidth - ignoreRightWidth;
    let xCoordIfCentered = (totalWidth - selfWidth) / 2;
    if (totalWidth % 2 !== 0) {
      xCoordIfCentered -= 0.5;
    }
    const xCoordIfLeftAligned = leftWidth + marginBetweenZones;
    const left = element.offsetLeft;
    const maxWidthProperty = Math.min(
      totalWidth - rightWidth - leftWidth - 2 * marginBetweenZones,
      maxWidth
    );
    const xCoord = Math.max(xCoordIfCentered, xCoordIfLeftAligned) - left;
    if (rightPanel.offsetWidth > stylePanelWidth && breakpoint <= 6) {
      element.style.setProperty("max-width", maxWidthProperty - squeezeAmount + "px");
    } else {
      element.style.setProperty("max-width", maxWidthProperty + "px");
    }
    element.style.setProperty("transform", `translate(${xCoord}px, 0px)`);
  }, [breakpoint, ignoreRightWidth, marginBetweenZones, maxWidth, squeezeAmount, stylePanelWidth]);
  reactExports.useLayoutEffect(() => {
    const element = ref.current;
    if (!element) return;
    const layoutTop = element.parentElement.parentElement;
    const leftPanel = layoutTop.querySelector(".tlui-layout__top__left");
    const rightPanel = layoutTop.querySelector(".tlui-layout__top__right");
    const observer = new ResizeObserver(updateLayout);
    observer.observe(leftPanel);
    observer.observe(rightPanel);
    observer.observe(layoutTop);
    observer.observe(element);
    updateLayout();
    return () => {
      observer.disconnect();
    };
  }, [updateLayout]);
  reactExports.useLayoutEffect(() => {
    updateLayout();
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: "tlui-top-panel__container", children });
}
function DefaultTopPanel() {
  const isOffline = useCollaborationStatus() === "offline";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CenteredTopPanelContainer, { children: isOffline && /* @__PURE__ */ jsxRuntimeExports.jsx(OfflineIndicator, {}) });
}
function DefaultZoomMenuContent() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-in", noClose: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuActionItem, { actionId: "zoom-out", noClose: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTo100MenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToFitMenuItem, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomToSelectionMenuItem, {})
  ] });
}
const DefaultZoomMenu = reactExports.memo(function DefaultZoomMenu2({ children }) {
  const container = useContainer();
  const [isOpen, onOpenChange] = useMenuIsOpen("zoom menu");
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultZoomMenuContent, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Root2$3, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ZoomTriggerButton, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2, { container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$1,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "zoom-menu", children: content })
      }
    ) })
  ] });
});
const ZoomTriggerButton = () => {
  const editor = useEditor();
  const breakpoint = useBreakpoint();
  const zoom = useValue("zoom", () => editor.getZoomLevel(), [editor]);
  const msg2 = useTranslation();
  const handleDoubleClick2 = reactExports.useCallback(() => {
    editor.resetZoom(editor.getViewportScreenCenter(), {
      animation: { duration: editor.options.animationMediumMs }
    });
  }, [editor]);
  const value = `${Math.floor(zoom * 100)}%`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiToolbarButton,
    {
      asChild: true,
      type: "icon",
      "aria-label": `${msg2("navigation-zone.zoom")} — ${value}`,
      title: `${msg2("navigation-zone.zoom")} — ${value}`,
      "data-testid": "minimap.zoom-menu-button",
      className: "tlui-zoom-menu__button",
      onDoubleClick: handleDoubleClick2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$1, { dir: "ltr", children: breakpoint < PORTRAIT_BREAKPOINT.MOBILE ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { flexGrow: 0, textAlign: "center" }, children: value }) })
    }
  );
};
const TldrawUiComponentsContext = reactExports.createContext(null);
function TldrawUiComponentsProvider({
  overrides = {},
  children
}) {
  const _overrides = useShallowObjectIdentity(overrides);
  const showCollaborationUi = useShowCollaborationUi();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiComponentsContext.Provider,
    {
      value: reactExports.useMemo(
        () => ({
          ContextMenu: DefaultContextMenu,
          ActionsMenu: DefaultActionsMenu,
          HelpMenu: null,
          ZoomMenu: DefaultZoomMenu,
          MainMenu: DefaultMainMenu,
          Minimap: DefaultMinimap,
          StylePanel: DefaultStylePanel,
          PageMenu: DefaultPageMenu,
          NavigationPanel: DefaultNavigationPanel,
          Toolbar: DefaultToolbar,
          RichTextToolbar: DefaultRichTextToolbar,
          KeyboardShortcutsDialog: DefaultKeyboardShortcutsDialog,
          QuickActions: DefaultQuickActions,
          HelperButtons: DefaultHelperButtons,
          DebugPanel: DefaultDebugPanel,
          DebugMenu: DefaultDebugMenu,
          MenuPanel: DefaultMenuPanel,
          SharePanel: showCollaborationUi ? DefaultSharePanel : null,
          CursorChatBubble: showCollaborationUi ? CursorChatBubble : null,
          TopPanel: showCollaborationUi ? DefaultTopPanel : null,
          Dialogs: DefaultDialogs,
          Toasts: DefaultToasts,
          A11y: DefaultA11yAnnouncer,
          ..._overrides
        }),
        [_overrides, showCollaborationUi]
      ),
      children
    }
  );
}
function useTldrawUiComponents() {
  const components = reactExports.useContext(TldrawUiComponentsContext);
  if (!components) {
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  }
  return components;
}
const TldrawUiContextProvider = track(function TldrawUiContextProvider2({
  overrides,
  components,
  assetUrls,
  onUiEvent,
  forceMobile,
  mediaMimeTypes,
  children
}) {
  const editor = useMaybeEditor();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MimeTypeContext.Provider, { value: mediaMimeTypes, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AssetUrlsProvider, { assetUrls: useDefaultUiAssetUrlsWithOverrides(assetUrls), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TldrawUiTranslationProvider,
    {
      overrides: useMergedTranslationOverrides(overrides),
      locale: editor?.user.getLocale() ?? defaultUserPreferences.locale,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiEventsProvider, { onEvent: onUiEvent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiToastsProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDialogsProvider, { context: "tla", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiA11yProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BreakPointProvider, { forceMobile, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiComponentsProvider, { overrides: components, children: /* @__PURE__ */ jsxRuntimeExports.jsx(InternalProviders, { overrides, children }) }) }) }) }) }) })
    }
  ) }) });
});
function InternalProviders({
  overrides,
  children
}) {
  const mergedOverrides = useMergedOverrides(overrides);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ActionsProvider, { overrides: mergedOverrides.actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToolsProvider, { overrides: mergedOverrides.tools, children }) });
}
function useEditorEvents() {
  const editor = useEditor();
  const { addToast } = useToasts();
  reactExports.useEffect(() => {
    function handleMaxShapes({ name, count: count2 }) {
      addToast({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${name} (${count2}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    editor.addListener("max-shapes", handleMaxShapes);
    return () => {
      editor.removeListener("max-shapes", handleMaxShapes);
    };
  }, [editor, addToast]);
}
React.memo(function TldrawUi2({
  renderDebugMenuItems,
  children,
  hideUi,
  components,
  ...rest
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiContextProvider, { ...rest, components, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiInner, { hideUi, renderDebugMenuItems, children }) });
});
const TldrawUiInner = React.memo(function TldrawUiInner2({
  children,
  hideUi,
  ...rest
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    children,
    hideUi ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiContent, { ...rest })
  ] });
});
const TldrawUiContent = React.memo(function TldrawUI() {
  const editor = useEditor();
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const isReadonlyMode = useReadonly();
  const isFocusMode = useValue("focus", () => editor.getInstanceState().isFocusMode, [editor]);
  const isDebugMode = useValue("debug", () => editor.getInstanceState().isDebugMode, [editor]);
  const {
    SharePanel,
    TopPanel,
    MenuPanel: MenuPanel2,
    StylePanel,
    Toolbar: Toolbar2,
    HelpMenu,
    NavigationPanel,
    HelperButtons,
    DebugPanel,
    CursorChatBubble: CursorChatBubble3,
    RichTextToolbar,
    Toasts,
    Dialogs,
    A11y
  } = useTldrawUiComponents();
  useKeyboardShortcuts();
  useNativeClipboardEvents();
  useEditorEvents();
  const rIsEditingAnything = reactExports.useRef(false);
  const rHidingTimeout = reactExports.useRef(-1);
  const [hideToolbarWhileEditing, setHideToolbarWhileEditing] = reactExports.useState(false);
  useReactor(
    "update hide toolbar while delayed",
    () => {
      const isMobileEnvironment = tlenv.isIos || tlenv.isAndroid;
      if (!isMobileEnvironment) return;
      const editingShape = editor.getEditingShapeId();
      if (editingShape === null) {
        if (rIsEditingAnything.current) {
          rIsEditingAnything.current = false;
          clearTimeout(rHidingTimeout.current);
          if (tlenv.isAndroid) {
            rHidingTimeout.current = editor.timers.setTimeout(() => {
              setHideToolbarWhileEditing(false);
            }, 150);
          } else {
            setHideToolbarWhileEditing(false);
          }
        }
        return;
      }
      if (!rIsEditingAnything.current) {
        rIsEditingAnything.current = true;
        clearTimeout(rHidingTimeout.current);
        setHideToolbarWhileEditing(true);
      }
    },
    []
  );
  const { "toggle-focus-mode": toggleFocus } = useActions();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classNames("tlui-layout", {
        "tlui-layout__mobile": breakpoint < PORTRAIT_BREAKPOINT.TABLET_SM
      }),
      "data-iseditinganything": hideToolbarWhileEditing,
      "data-breakpoint": breakpoint,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SkipToMainContent, {}),
        isFocusMode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          TldrawUiButton,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: msg2("focus-mode.toggle-focus-mode"),
            onClick: () => toggleFocus.onSelect("menu"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "dot" })
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__top", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__top__left", children: [
              MenuPanel2 && /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPanel2, {}),
              HelperButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(HelperButtons, {})
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tlui-layout__top__center", children: TopPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(TopPanel, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__top__right", children: [
              SharePanel && /* @__PURE__ */ jsxRuntimeExports.jsx(SharePanel, {}),
              StylePanel && breakpoint >= PORTRAIT_BREAKPOINT.TABLET_SM && !isReadonlyMode && /* @__PURE__ */ jsxRuntimeExports.jsx(StylePanel, {})
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__bottom", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tlui-layout__bottom__main", children: [
              NavigationPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(NavigationPanel, {}),
              Toolbar2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Toolbar2, {}),
              HelpMenu && /* @__PURE__ */ jsxRuntimeExports.jsx(HelpMenu, {})
            ] }),
            isDebugMode && DebugPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(DebugPanel, {}),
            A11y && /* @__PURE__ */ jsxRuntimeExports.jsx(A11y, {})
          ] })
        ] }),
        RichTextToolbar && /* @__PURE__ */ jsxRuntimeExports.jsx(RichTextToolbar, {}),
        Toasts && /* @__PURE__ */ jsxRuntimeExports.jsx(Toasts, {}),
        Dialogs && /* @__PURE__ */ jsxRuntimeExports.jsx(Dialogs, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FollowingIndicator, {}),
        CursorChatBubble3 && /* @__PURE__ */ jsxRuntimeExports.jsx(CursorChatBubble3, {})
      ]
    }
  );
});
const defaultTextOptions = {
  tipTapConfig: {
    extensions: tipTapDefaultExtensions
  },
  addFontsFromNode: defaultAddFontsFromNode
};
reactExports.memo(function TldrawImage2(props) {
  const [url, setUrl] = reactExports.useState(null);
  const [container, setContainer] = reactExports.useState(null);
  const _shapeUtils = useShallowArrayIdentity(props.shapeUtils ?? []);
  const shapeUtilsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("type", _shapeUtils, defaultShapeUtils),
    [_shapeUtils]
  );
  const _bindingUtils = useShallowArrayIdentity(props.bindingUtils ?? []);
  const bindingUtilsWithDefaults = reactExports.useMemo(
    () => mergeArraysAndReplaceDefaults("type", _bindingUtils, defaultBindingUtils),
    [_bindingUtils]
  );
  const store = useTLStore({ snapshot: props.snapshot, shapeUtils: shapeUtilsWithDefaults });
  const {
    pageId,
    bounds,
    scale,
    pixelRatio,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    format: format2 = "svg",
    licenseKey,
    assetUrls,
    textOptions = defaultTextOptions
  } = props;
  reactExports.useLayoutEffect(() => {
    if (!container) return;
    if (!store) return;
    let isCancelled = false;
    const tempElm = document.createElement("div");
    container.appendChild(tempElm);
    container.classList.add("tl-container", "tl-theme__light");
    const editor = new Editor$1({
      store,
      shapeUtils: shapeUtilsWithDefaults,
      bindingUtils: bindingUtilsWithDefaults,
      tools: [],
      getContainer: () => tempElm,
      licenseKey,
      fontAssetUrls: assetUrls?.fonts,
      textOptions
    });
    if (pageId) editor.setCurrentPage(pageId);
    const shapeIds = editor.getCurrentPageShapeIds();
    async function setSvg() {
      const imageResult = await editor.toImage([...shapeIds], {
        bounds,
        scale,
        background,
        padding,
        darkMode,
        preserveAspectRatio,
        format: format2
      });
      if (!imageResult || isCancelled) return;
      const url2 = URL.createObjectURL(imageResult.blob);
      setUrl(url2);
      editor.dispose();
    }
    setSvg();
    return () => {
      isCancelled = true;
    };
  }, [
    format2,
    container,
    store,
    shapeUtilsWithDefaults,
    bindingUtilsWithDefaults,
    pageId,
    bounds,
    scale,
    background,
    padding,
    darkMode,
    preserveAspectRatio,
    licenseKey,
    pixelRatio,
    assetUrls,
    textOptions
  ]);
  reactExports.useEffect(() => {
    return () => {
      if (url) URL.revokeObjectURL(url);
    };
  }, [url]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: setContainer, style: { position: "relative", width: "100%", height: "100%" }, children: url && /* @__PURE__ */ jsxRuntimeExports.jsx(
    "img",
    {
      src: url,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) });
});
reactExports.memo(function DefaultHelpMenu2({ children }) {
  const msg2 = useTranslation();
  const breakpoint = useBreakpoint();
  const ref = reactExports.useRef(null);
  usePassThroughWheelEvents(ref);
  const content = children ?? /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultHelpMenuContent, {});
  if (breakpoint < PORTRAIT_BREAKPOINT.MOBILE) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: "tlui-help-menu", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TldrawUiDropdownMenuRoot, { id: "help menu", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButton, { type: "help", title: msg2("help-menu.title"), "data-testid": "help-menu.button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiButtonIcon, { icon: "question-mark", small: true }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiDropdownMenuContent, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TldrawUiMenuContextProvider, { type: "menu", sourceId: "help-menu", children: content }) })
  ] }) });
});
const schemaV1 = object({
  schemaVersion: literal(1),
  storeVersion: positiveInteger,
  recordVersions: dict(
    string,
    object({
      version: positiveInteger,
      subTypeVersions: dict(string, positiveInteger).optional(),
      subTypeKey: string.optional()
    })
  )
});
const schemaV2 = object({
  schemaVersion: literal(2),
  sequences: dict(string, positiveInteger)
});
object({
  tldrawFileFormatVersion: nonZeroInteger,
  schema: numberUnion("schemaVersion", {
    1: schemaV1,
    2: schemaV2
  }),
  records: arrayOf(
    object({
      id: string,
      typeName: string
    }).allowUnknownProperties()
  )
});
registerTldrawLibraryVersion(
  "tldraw",
  "3.13.1",
  "esm"
);
function exhaustiveSwitchError(value, property) {
  const debugValue = value && typeof value === "object" && property in value ? value[property] : value;
  throw new Error(`Unknown switch case ${debugValue}`);
}
function asMessage(message) {
  if (Array.isArray(message)) return message;
  if (typeof message === "string") return [{ type: "text", text: message }];
  return [message];
}
function getSimpleContentFromCanvasContent(content) {
  return {
    shapes: compact(
      content.shapes.map((shape) => {
        if (shape.type === "text") {
          const s2 = shape;
          const textContent = JSON.stringify(s2.props.richText || "");
          return {
            shapeId: s2.id,
            type: "text",
            text: textContent,
            x: s2.x,
            y: s2.y,
            color: s2.props.color,
            textAlign: s2.props.textAlign,
            note: s2.meta?.description ?? ""
          };
        }
        return void 0;
      })
    )
  };
}
function compact(arr) {
  return arr.filter(Boolean);
}
const OPENAI_SYSTEM_PROMPT = `
## System Prompt:

You are an AI assistant that helps the user create text content on a digital canvas. You will be provided with a prompt that includes a description of the user's intent and the current state of the canvas, including the user's viewport (the part of the canvas that the user is viewing). Your goal is to generate a response that includes a description of your strategy and a list of structured events that represent the text elements you would create to satisfy the user's request.

You respond with structured JSON data based on a predefined schema.

### Schema Overview

You are interacting with a system that models text elements and tracks events (creating, moving, or deleting text). Your responses should include:

- **A long description of your strategy** (\`long_description_of_strategy\`): Explain your reasoning in plain text.
- **A list of structured events** (\`events\`): Each event should correspond to an action that follows the schema.

### Shape Schema

The only supported shape type is:

- **Text (\`text\`)**

Each text element has:

- \`x\`, \`y\` (numbers, coordinates, the TOP LEFT corner of the text)
- \`note\` (a description of the text's purpose or intent)
- \`text\` (the actual text content)
- \`color\` (optional, chosen from predefined colors)
- \`textAlign\` (optional, alignment: start, middle, end)

### Event Schema

Events include:
- **Think (\`think\`)**: The AI describes its intent or reasoning.
- **Create (\`create\`)**: The AI creates a new text element.
- **Update (\`update\`)**: The AI updates an existing text element.
- **Move (\`move\`)**: The AI moves a text element to a new position.
- **Delete (\`delete\`)**: The AI removes a text element.

Each event must include:
- A \`type\` (one of \`think\`, \`create\`, \`update\`, \`move\`, \`delete\`)
- A \`shapeId\` (if applicable)
- An \`intent\` (descriptive reason for the action)

### Rules

1. **Always return a valid JSON object conforming to the schema.**
2. **Do not generate extra fields or omit required fields.**
3. **Provide clear and logical reasoning in \`long_description_of_strategy\`.**
4. **Ensure each \`shapeId\` is unique and consistent across related events.**
5. **Use meaningful \`intent\` descriptions for all actions.**

## Useful notes

- Always begin with a clear strategy in \`long_description_of_strategy\`.
- Compare the information you have from the screenshot of the user's viewport with the description of the text elements on the viewport.
- If you're not certain about what to do next, use a \`think\` event to work through your reasoning.
- Make all of your changes inside of the user's current viewport.
- Use the \`note\` field to provide context for each text element. This will help you in the future to understand the purpose of each text element.
- The x and y define the top left corner of the text. The text's origin is in its top left corner.
- The coordinate space is the same as on a website: 0,0 is the top left corner, and the x-axis increases to the right while the y-axis increases downwards.
- Always make sure that any text elements you create or modify are within the user's viewport.
- Text elements are 32 points tall by default. Their width will auto adjust based on the text content.
- Consider appropriate text alignment (start, middle, end) based on the content and its purpose.
- If the canvas is empty, place your text elements in appropriate locations within the viewport.
- For multiple text elements, consider their relationship and positioning relative to each other.
- Only create text elements - do not attempt to create any other shape types.

# Examples

Developer: The user's viewport is { x: 0, y: 0, width: 1000, height: 500 }
User: Write "Welcome to our presentation" as a title, and add a subtitle "Introduction to AI"
Assistant: {
	long_description_of_strategy: "I will create two text elements: a main title at the top center of the viewport, and a subtitle positioned below it, also centered.",
	events: [
		{
			type: "create",
			shape: {
				type: "text",
				shapeId: "main-title",
				note: "Main presentation title",
				x: 200,
				y: 150,
				text: "Welcome to our presentation",
				color: "black",
				textAlign: "middle"
			},
			intent: "Create the main title text"
		},
		{
			type: "create",
			shape: {
				type: "text",
				shapeId: "subtitle",
				note: "Presentation subtitle",
				x: 300,
				y: 200,
				text: "Introduction to AI",
				color: "grey",
				textAlign: "middle"
			},
			intent: "Create the subtitle text"
		}
	]
}
`;
function buildPromptMessages(prompt) {
  const systemPrompt = buildSystemPrompt();
  const developerMessage = buildDeveloperMessage(prompt);
  const userMessage = buildUserMessages(prompt);
  return [systemPrompt, developerMessage, userMessage];
}
function buildSystemPrompt(_prompt) {
  return {
    role: "system",
    content: OPENAI_SYSTEM_PROMPT
  };
}
function buildDeveloperMessage(prompt) {
  const developerMessage = {
    role: "developer",
    content: []
  };
  developerMessage.content.push({
    type: "text",
    text: `The user's current viewport is: { x: ${prompt.promptBounds.x}, y: ${prompt.promptBounds.y}, width: ${prompt.promptBounds.w}, height: ${prompt.promptBounds.h} }`
  });
  if (prompt.canvasContent) {
    const simplifiedCanvasContent = getSimpleContentFromCanvasContent(prompt.canvasContent);
    developerMessage.content.push({
      type: "text",
      // todo: clean up all the newlines
      text: `Here are all of the shapes that are in the user's current viewport:

${JSON.stringify(simplifiedCanvasContent.shapes).replaceAll("\n", " ")}`
    });
  }
  return developerMessage;
}
function buildUserMessages(prompt) {
  const userMessage = {
    role: "user",
    content: []
  };
  if (prompt.image) {
    userMessage.content.push(
      {
        type: "image_url",
        image_url: {
          detail: "auto",
          url: prompt.image
        }
      },
      {
        type: "text",
        text: "Here is a screenshot of the my current viewport."
      }
    );
  }
  userMessage.content.push({
    type: "text",
    text: `Using the events provided in the response schema, here's what I want you to do:`
  });
  for (const message of asMessage(prompt.message)) {
    if (message.type === "image") {
      userMessage.content.push({
        type: "image_url",
        image_url: {
          url: message.src
        }
      });
    } else {
      userMessage.content.push({
        type: "text",
        text: message.text
      });
    }
  }
  return userMessage;
}
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  nullableStrategy: "from-target",
  removeAdditionalStrategy: "passthrough",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
const getDefaultOptions = (options) => {
  return typeof options === "string" ? {
    ...defaultOptions,
    basePath: ["#"],
    definitions: {},
    name: options
  } : {
    ...defaultOptions,
    basePath: ["#"],
    definitions: {},
    ...options
  };
};
const zodDef = (zodSchema) => {
  return "_def" in zodSchema ? zodSchema._def : zodSchema;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
const getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seenRefs: /* @__PURE__ */ new Set(),
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      zodDef(def),
      {
        def: zodDef(def),
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys2 = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$1;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex$1) {
          emojiRegex$1 = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex$1.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind2, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind2,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null;
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind2, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: kind2,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    this._cached = { shape, keys: keys2 };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return INVALID;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return INVALID;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b) {
    return new ZodPipeline({
      in: a2,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString.create;
const numberType = ZodNumber.create;
ZodNever.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const unionType = ZodUnion.create;
ZodIntersection.create;
ZodTuple.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
ZodPromise.create;
ZodOptional.create;
ZodNullable.create;
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
const parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
const integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef(_def, refs, forceResolution) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs, forceResolution) : {};
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: [...def.values]
  };
}
const isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}
let emojiRegex;
const zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  function processPattern(value) {
    return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
  }
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji, check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
const escapeNonAlphaNumeric = (value) => Array.from(value).map((c2) => /[a-zA-Z0-9]/.test(c2) ? c2 : `\\${c2}`).join("");
const addFormat = (schema, value, message, refs) => {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
};
const addPattern = (schema, regex, message, refs) => {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: processRegExp(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", processRegExp(regex, refs), message, refs);
  }
};
const processRegExp = (regexOrFunction, refs) => {
  const regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
  if (!refs.applyRegexFlags || !regex.flags)
    return regex.source;
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    const regexTest = new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
};
function parseRecordDef(def, refs) {
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? {}
      }), {}),
      additionalProperties: false
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : { ...acc, [key]: value }, {});
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys2 = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys2, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  const object2 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object2[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return {
    not: {}
  };
}
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
const primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a2) => a2.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter((x2) => !acc.includes(x2))], [])
    };
  }
  return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3" || refs.nullableStrategy === "property") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [primitiveMappings[def.innerType._def.typeName], "null"]
    };
  }
  if (refs.target === "openApi3") {
    const base3 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base3 && "$ref" in base3)
      return { allOf: [base3], nullable: true };
    return base3 && { ...base3, nullable: true };
  }
  const base2 = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base2 && { anyOf: [base2, { type: "null" }] };
}
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}
function decideAdditionalProperties(def, refs) {
  if (refs.removeAdditionalStrategy === "strict") {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  } else {
    return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? true;
  }
}
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
      if (propDef === void 0 || propDef._def === void 0)
        return acc;
      const propertyPath = [...refs.currentPath, "properties", propName];
      const parsedDef = parseDef(propDef._def, {
        ...refs,
        currentPath: propertyPath,
        propertyPath
      });
      if (parsedDef === void 0)
        return acc;
      if (refs.openaiStrictMode && propDef.isOptional() && !propDef.isNullable()) {
        console.warn(`Zod field at \`${propertyPath.join("/")}\` uses \`.optional()\` without \`.nullable()\` which is not supported by the API. See: https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#all-fields-must-be-required
This will become an error in a future version of the SDK.`);
      }
      return {
        properties: {
          ...acc.properties,
          [propName]: parsedDef
        },
        required: propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: decideAdditionalProperties(def, refs)
  };
  if (!result.required.length)
    delete result.required;
  return result;
}
const parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};
const parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a2 = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a2 ? "1" : "0"]
  });
  return {
    allOf: [a2, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
function parseUndefinedDef() {
  return {
    not: {}
  };
}
function parseUnknownDef() {
  return {};
}
const parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      if ("$ref" in seenSchema) {
        refs.seenRefs.add(seenSchema.$ref);
      }
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchema = selectParser(def, def.typeName, refs, forceResolution);
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
const get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.
    // the top-level schema *must* be `{"type": "object", "properties": {...}}` but if we ever
    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract
    // the schema to `#/definitions/` and reference that.
    //
    // e.g. if we need to reference a schema at
    // `["#","definitions","contactPerson","properties","person1","properties","name"]`
    // then we'll extract it out to `contactPerson_properties_person1_properties_name`
    case "extract-to-root":
      const name = item.path.slice(refs.basePath.length + 1).join("_");
      if (name !== refs.name && refs.nameStrategy === "duplicate-ref") {
        refs.definitions[name] = item.def;
      }
      return { $ref: [...refs.basePath, refs.definitionPath, name].join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index2) => refs.currentPath[index2] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
};
const getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
const selectParser = (def, typeName, refs, forceResolution) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return parseDef(def.getter()._def, refs);
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs, forceResolution);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};
const addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};
const zodToJsonSchema$1 = (schema, options) => {
  const refs = getRefs(options);
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? {};
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const definitions = (() => {
    if (isEmptyObj(refs.definitions)) {
      return void 0;
    }
    const definitions2 = {};
    const processedDefinitions = /* @__PURE__ */ new Set();
    for (let i = 0; i < 500; i++) {
      const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));
      if (newDefinitions.length === 0)
        break;
      for (const [key, schema2] of newDefinitions) {
        definitions2[key] = parseDef(zodDef(schema2), { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] }, true) ?? {};
        processedDefinitions.add(key);
      }
    }
    return definitions2;
  })();
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : refs.nameStrategy === "duplicate-ref" ? {
    ...main,
    ...definitions || refs.seenRefs.size ? {
      [refs.definitionPath]: {
        ...definitions,
        // only actually duplicate the schema definition if it was ever referenced
        // otherwise the duplication is completely pointless
        ...refs.seenRefs.size ? { [name]: main } : void 0
      }
    } : void 0
  } : {
    $ref: [...refs.$refStrategy === "relative" ? [] : refs.basePath, refs.definitionPath, name].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  return combined;
};
function zodToJsonSchema(schema, options) {
  return zodToJsonSchema$1(schema, {
    openaiStrictMode: true,
    name: options.name,
    nameStrategy: "duplicate-ref",
    $refStrategy: "extract-to-root",
    nullableStrategy: "property"
  });
}
function zodResponseFormat(zodObject, name, props) {
  return makeParseableResponseFormat({
    type: "json_schema",
    json_schema: {
      ...props,
      name,
      strict: true,
      schema: zodToJsonSchema(zodObject, { name })
    }
  }, (content) => zodObject.parse(JSON.parse(content)));
}
const SimpleColor = enumType([
  "red",
  "light-red",
  "green",
  "light-green",
  "blue",
  "light-blue",
  "orange",
  "yellow",
  "black",
  "violet",
  "light-violet",
  "grey",
  "white"
]);
enumType(["none", "tint", "semi", "solid", "pattern"]);
stringType();
const SimpleTextShape = objectType({
  type: literalType("text"),
  shapeId: stringType(),
  note: stringType(),
  // Grid-based positioning instead of coordinates
  contentType: enumType(["title", "heading", "subheading", "definition", "bullet", "numbered", "formula", "note", "example", "summary"]),
  targetRow: numberType().optional(),
  // AI can suggest specific row, otherwise auto-assigned
  columnSpan: arrayType(numberType()).length(2).optional(),
  // [start, end] columns, otherwise auto from content type
  // Keep text properties
  color: SimpleColor.optional(),
  text: stringType().optional(),
  textAlign: enumType(["start", "middle", "end"]).optional()
});
const SimpleShape = SimpleTextShape;
const SimpleCreateEvent = objectType({
  type: enumType(["create", "update"]),
  shape: SimpleShape,
  intent: stringType()
});
const SimpleMoveEvent = objectType({
  type: literalType("move"),
  shapeId: stringType(),
  x: numberType(),
  y: numberType(),
  intent: stringType()
});
const SimpleDeleteEvent = objectType({
  type: literalType("delete"),
  shapeId: stringType(),
  intent: stringType()
});
const SimpleThinkEvent = objectType({
  type: literalType("think"),
  text: stringType(),
  intent: stringType()
});
const SimpleEvent = unionType([
  SimpleThinkEvent,
  SimpleCreateEvent,
  // or update
  SimpleDeleteEvent,
  SimpleMoveEvent
]);
const ModelResponse = objectType({
  long_description_of_strategy: stringType(),
  events: arrayType(SimpleEvent)
});
const RESPONSE_FORMAT = zodResponseFormat(ModelResponse, "event");
const OPENAI_MODEL$1 = "gpt-4o-2024-08-06";
async function generateEvents(model2, prompt) {
  const response = await model2.chat.completions.create({
    model: OPENAI_MODEL$1,
    messages: buildPromptMessages(prompt),
    response_format: RESPONSE_FORMAT
  });
  const text = response.choices[0]?.message?.content ?? "";
  const json = JSON.parse(text);
  try {
    ModelResponse.parse(json);
  } catch (err) {
    throw new Error(`Invalid response from OpenAI: ${err}`);
  }
  return json.events;
}
function getTldrawAiChangesFromSimpleEvents(prompt, event) {
  switch (event.type) {
    case "update":
    case "create": {
      return getTldrawAiChangesFromSimpleCreateOrUpdateEvent(prompt, event);
    }
    case "delete": {
      return getTldrawAiChangesFromSimpleDeleteEvent(prompt, event);
    }
    case "move": {
      return getTldrawAiChangesFromSimpleMoveEvent(prompt, event);
    }
    case "think": {
      return [];
    }
    default: {
      throw exhaustiveSwitchError(event, "type");
    }
  }
}
function getTldrawAiChangesFromSimpleCreateOrUpdateEvent(prompt, event) {
  const { shape } = event;
  const changes = [];
  const shapeEventType = event.type === "create" ? "createShape" : "updateShape";
  if (shape.type === "text") {
    changes.push({
      type: shapeEventType,
      description: shape.note ?? "",
      shape: {
        id: shape.shapeId,
        type: "text",
        x: shape.x,
        y: shape.y,
        props: {
          richText: toRichText(shape.text ?? ""),
          color: shape.color ?? "black",
          textAlign: shape.textAlign ?? "middle"
        }
      }
    });
  }
  for (const change of changes) {
    if (change.type === "createShape") {
      prompt.canvasContent.shapes.push(change.shape);
    } else if (change.type === "createBinding") {
      prompt.canvasContent.bindings?.push(change.binding);
    }
  }
  return changes;
}
function getTldrawAiChangesFromSimpleDeleteEvent(prompt, event) {
  const { shapeId, intent } = event;
  return [
    {
      type: "deleteShape",
      description: intent ?? "",
      shapeId
    }
  ];
}
function getTldrawAiChangesFromSimpleMoveEvent(prompt, event) {
  const { shapeId, intent } = event;
  return [
    {
      type: "updateShape",
      description: intent ?? "",
      shape: {
        id: shapeId,
        x: event.x,
        y: event.y
      }
    }
  ];
}
var parse = {};
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    function parse2(s2) {
      if (s2 === void 0) {
        return void 0;
      }
      if (s2 === null) {
        return null;
      }
      if (s2 === "") {
        return "";
      }
      s2 = s2.replace(/\\+$/, (match) => match.length % 2 === 0 ? match : match.slice(0, -1));
      try {
        return JSON.parse(s2);
      } catch (e) {
        const [data, reminding] = s2.trimLeft()[0] === ":" ? parseAny(s2, e) : parseAny(s2, e, parseStringWithoutQuote);
        parse2.lastParseReminding = reminding;
        if (parse2.onExtraToken && reminding.length > 0) {
          const trimmedReminding = reminding.trimRight();
          parse2.lastParseReminding = trimmedReminding;
          if (trimmedReminding.length > 0) {
            parse2.onExtraToken(s2, data, trimmedReminding);
          }
        }
        return data;
      }
    }
    exports.parse = parse2;
    (function(parse3) {
      parse3.onExtraToken = (text, data, reminding) => {
        console.error("parsed json with extra tokens:", {
          text,
          data,
          reminding
        });
      };
    })(parse2 = exports.parse || (exports.parse = {}));
    function parseAny(s2, e, fallback) {
      const parser = parsers[s2[0]] || fallback;
      if (!parser) {
        console.error(`no parser registered for ${JSON.stringify(s2[0])}:`, { s: s2 });
        throw e;
      }
      return parser(s2, e);
    }
    function parseStringCasual(s2, e, delimiters) {
      if (s2[0] === '"') {
        return parseString(s2);
      }
      if (s2[0] === "'") {
        return parseSingleQuoteString(s2);
      }
      return parseStringWithoutQuote(s2, e, delimiters);
    }
    const parsers = {};
    function skipSpace(s2) {
      return s2.trimLeft();
    }
    parsers[" "] = parseSpace;
    parsers["\r"] = parseSpace;
    parsers["\n"] = parseSpace;
    parsers["	"] = parseSpace;
    function parseSpace(s2, e) {
      s2 = skipSpace(s2);
      return parseAny(s2, e);
    }
    parsers["["] = parseArray;
    function parseArray(s2, e) {
      s2 = s2.substr(1);
      const acc = [];
      s2 = skipSpace(s2);
      for (; s2.length > 0; ) {
        if (s2[0] === "]") {
          s2 = s2.substr(1);
          break;
        }
        const res = parseAny(s2, e, (s3, e2) => parseStringWithoutQuote(s3, e2, [",", "]"]));
        acc.push(res[0]);
        s2 = res[1];
        s2 = skipSpace(s2);
        if (s2[0] === ",") {
          s2 = s2.substring(1);
          s2 = skipSpace(s2);
        }
      }
      return [acc, s2];
    }
    for (const c2 of "0123456789.-".slice()) {
      parsers[c2] = parseNumber;
    }
    function parseNumber(s2) {
      for (let i = 0; i < s2.length; i++) {
        const c2 = s2[i];
        if (parsers[c2] === parseNumber) {
          continue;
        }
        const num = s2.substring(0, i);
        s2 = s2.substring(i);
        return [numToStr(num), s2];
      }
      return [numToStr(s2), ""];
    }
    function numToStr(s2) {
      if (s2 === "-") {
        return -0;
      }
      const num = +s2;
      if (Number.isNaN(num)) {
        return s2;
      }
      return num;
    }
    parsers['"'] = parseString;
    function parseString(s2) {
      for (let i = 1; i < s2.length; i++) {
        const c2 = s2[i];
        if (c2 === "\\") {
          i++;
          continue;
        }
        if (c2 === '"') {
          const str2 = fixEscapedCharacters(s2.substring(0, i + 1));
          s2 = s2.substring(i + 1);
          return [JSON.parse(str2), s2];
        }
      }
      return [JSON.parse(fixEscapedCharacters(s2) + '"'), ""];
    }
    function fixEscapedCharacters(s2) {
      return s2.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    }
    parsers["'"] = parseSingleQuoteString;
    function parseSingleQuoteString(s2) {
      for (let i = 1; i < s2.length; i++) {
        const c2 = s2[i];
        if (c2 === "\\") {
          i++;
          continue;
        }
        if (c2 === "'") {
          const str2 = fixEscapedCharacters(s2.substring(0, i + 1));
          s2 = s2.substring(i + 1);
          return [JSON.parse('"' + str2.slice(1, -1) + '"'), s2];
        }
      }
      return [JSON.parse('"' + fixEscapedCharacters(s2.slice(1)) + '"'), ""];
    }
    function parseStringWithoutQuote(s2, e, delimiters = [" "]) {
      const index2 = Math.min(...delimiters.map((delimiter) => {
        const index3 = s2.indexOf(delimiter);
        return index3 === -1 ? s2.length : index3;
      }));
      const value = s2.substring(0, index2).trim();
      const rest = s2.substring(index2);
      return [value, rest];
    }
    parsers["{"] = parseObject;
    function parseObject(s2, e) {
      s2 = s2.substr(1);
      const acc = {};
      s2 = skipSpace(s2);
      for (; s2.length > 0; ) {
        if (s2[0] === "}") {
          s2 = s2.substr(1);
          break;
        }
        const keyRes = parseStringCasual(s2, e, [":", "}"]);
        const key = keyRes[0];
        s2 = keyRes[1];
        s2 = skipSpace(s2);
        if (s2[0] !== ":") {
          acc[key] = void 0;
          break;
        }
        s2 = s2.substr(1);
        s2 = skipSpace(s2);
        if (s2.length === 0) {
          acc[key] = void 0;
          break;
        }
        const valueRes = parseAny(s2, e);
        acc[key] = valueRes[0];
        s2 = valueRes[1];
        s2 = skipSpace(s2);
        if (s2[0] === ",") {
          s2 = s2.substr(1);
          s2 = skipSpace(s2);
        }
      }
      return [acc, s2];
    }
    parsers["t"] = parseTrue;
    function parseTrue(s2, e) {
      return parseToken(s2, `true`, true, e);
    }
    parsers["f"] = parseFalse;
    function parseFalse(s2, e) {
      return parseToken(s2, `false`, false, e);
    }
    parsers["n"] = parseNull;
    function parseNull(s2, e) {
      return parseToken(s2, `null`, null, e);
    }
    function parseToken(s2, tokenStr, tokenVal, e) {
      for (let i = tokenStr.length; i >= 1; i--) {
        if (s2.startsWith(tokenStr.slice(0, i))) {
          return [tokenVal, s2.slice(i)];
        }
      }
      {
        const prefix = JSON.stringify(s2.slice(0, tokenStr.length));
        console.error(`unknown token starting with ${prefix}:`, { s: s2 });
        throw e;
      }
    }
  })(parse);
  return parse;
}
var parseExports = requireParse();
const OPENAI_MODEL = "gpt-4o-2024-08-06";
async function* streamEvents(model2, prompt) {
  const stream2 = model2.beta.chat.completions.stream({
    model: OPENAI_MODEL,
    messages: buildPromptMessages(prompt),
    response_format: RESPONSE_FORMAT
  });
  let accumulatedText = "";
  let cursor = 0;
  const events = [];
  let maybeUnfinishedEvent = null;
  for await (const chunk of stream2) {
    if (!chunk) continue;
    accumulatedText += chunk.choices[0]?.delta?.content ?? "";
    const json = parseExports.parse(accumulatedText);
    if (Array.isArray(json?.events)) {
      for (let i = cursor, len = json.events.length; i < len; i++) {
        const part = json.events[i];
        if (i === cursor) {
          try {
            SimpleEvent.parse(part);
            if (i < len) {
              events.push(part);
              yield part;
              maybeUnfinishedEvent = null;
              cursor++;
            } else {
              maybeUnfinishedEvent = part;
            }
          } catch {
          }
        }
      }
    }
  }
  if (maybeUnfinishedEvent) {
    events.push(maybeUnfinishedEvent);
    yield maybeUnfinishedEvent;
  }
  return events;
}
class OpenAiService extends TldrawAiBaseService {
  openai;
  constructor(env) {
    super(env);
    this.openai = new OpenAI({
      apiKey: env.OPENAI_API_KEY
    });
  }
  async generate(prompt) {
    const events = await generateEvents(this.openai, prompt);
    if (this.env.LOG_LEVEL === "debug") console.log(events);
    const changes = events.map((event) => getTldrawAiChangesFromSimpleEvents(prompt, event)).flat();
    console.log("######################## GENERATE ########################");
    console.log(changes);
    return { changes };
  }
  async *stream(prompt) {
    for await (const simpleEvent of streamEvents(this.openai, prompt)) {
      if (this.env.LOG_LEVEL === "debug") console.log(simpleEvent);
      for (const change of getTldrawAiChangesFromSimpleEvents(prompt, simpleEvent)) {
        console.log("######################## STREAM ########################");
        console.log(change);
        yield change;
      }
    }
  }
}
class TldrawAiDurableObject extends DurableObject {
  service;
  constructor(ctx, env) {
    super(ctx, env);
    this.service = new OpenAiService(this.env);
  }
  router = n({
    catch: (e) => {
      console.error(e);
      return s(e);
    }
  }).post("/generate", (request) => this.generate(request)).post("/stream", (request) => this.stream(request)).post("/cancel", (request) => this.cancel(request));
  // `fetch` is the entry point for all requests to the Durable Object
  fetch(request) {
    return this.router.fetch(request);
  }
  /**
   * Cancel the current stream.
   *
   * @param _request - The request object containing the prompt.
   * @returns A Promise that resolves to a Response object containing the cancelled response.
   */
  cancel(_request) {
    return new Response("Not implemented", {
      status: 501
    });
  }
  /**
   * Generate a set of changes from the model.
   *
   * @param request - The request object containing the prompt.
   * @returns A Promise that resolves to a Response object containing the generated changes.
   */
  async generate(request) {
    const prompt = await request.json();
    try {
      const response = await this.service.generate(prompt);
      return new Response(JSON.stringify(response), {
        headers: { "Content-Type": "application/json" }
      });
    } catch (error2) {
      console.error("AI response error:", error2);
      return new Response("An internal server error occurred.", {
        status: 500
      });
    }
  }
  /**
   * Stream changes from the model.
   *
   * @param request - The request object containing the prompt.
   * @returns A Promise that resolves to a Response object containing the streamed changes.
   */
  async stream(request) {
    const encoder = new TextEncoder();
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const response = {
      changes: []
    };
    (async () => {
      try {
        const prompt = await request.json();
        for await (const change of this.service.stream(prompt)) {
          response.changes.push(change);
          const data = `data: ${JSON.stringify(change)}

`;
          await writer.write(encoder.encode(data));
          await writer.ready;
        }
        await writer.close();
      } catch (error2) {
        console.error("Stream error:", error2);
        await writer.abort(error2);
      }
    })();
    return new Response(readable, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache, no-transform",
        Connection: "keep-alive",
        "X-Accel-Buffering": "no",
        "Transfer-Encoding": "chunked",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type"
      }
    });
  }
}
const { preflight, corsify } = y({ origin: "*" });
const router = n({
  before: [preflight],
  finally: [corsify],
  catch: (e) => {
    console.error(e);
    return s(e);
  }
}).post("/generate", generate).post("/stream", stream);
class worker extends WorkerEntrypoint {
  fetch(request) {
    return router.fetch(request, this.env, this.ctx);
  }
}
export {
  TldrawAiDurableObject,
  worker as default
};
